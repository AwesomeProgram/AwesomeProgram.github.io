<!DOCTYPE HTML>
<html lang="zh-CN" class="sidebar-visible no-js navy">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>量子状态与量子比特 - 信息技术 | AwesomeProgram</title>


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="所思即所见，所见即所得，所得皆所想，技术从未停歇，也未曾缺乏">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "navy";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('navy')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../PrefixChapter.html">前言</a></li><li class="chapter-item expanded "><a href="../rust/chapter_1.html"><strong aria-hidden="true">1.</strong> Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../rust/chapter_1_1.html"><strong aria-hidden="true">1.1.</strong> Rust 语法结构</a></li><li class="chapter-item expanded "><a href="../rust/chapter_1_4.html"><strong aria-hidden="true">1.2.</strong> Rust 标准库</a></li><li class="chapter-item expanded "><a href="../rust/chapter_1_5.html"><strong aria-hidden="true">1.3.</strong> Rust 工具链</a></li><li class="chapter-item expanded "><a href="../rust/chapter_1_6.html"><strong aria-hidden="true">1.4.</strong> Rust 类型操作</a></li><li class="chapter-item expanded "><a href="../rust/chapter_1_7.html"><strong aria-hidden="true">1.5.</strong> Rust 编码范式</a></li></ol></li><li class="chapter-item expanded "><a href="../go/chapter_1.html"><strong aria-hidden="true">2.</strong> Go</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../go/chapter_1_1.html"><strong aria-hidden="true">2.1.</strong> Go 语法结构</a></li><li class="chapter-item expanded "><a href="../go/chapter_1_2.html"><strong aria-hidden="true">2.2.</strong> Go 标准库</a></li></ol></li><li class="chapter-item expanded "><a href="../chapter_3.html"><strong aria-hidden="true">3.</strong> 各语言对比</a></li><li class="chapter-item expanded "><a href="../blockchain/chapter_1.html"><strong aria-hidden="true">4.</strong> 区块链</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../blockchain/chapter_1_1.html"><strong aria-hidden="true">4.1.</strong> 区块链简史</a></li><li class="chapter-item expanded "><a href="../blockchain/chapter_1_2.html"><strong aria-hidden="true">4.2.</strong> 区块链框架</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../blockchain/chapter_1_2_1.html"><strong aria-hidden="true">4.2.1.</strong> substrate</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../blockchain/chapter_1_2_1_1.html"><strong aria-hidden="true">4.2.1.1.</strong> 基本原理</a></li><li class="chapter-item expanded "><a href="../blockchain/chapter_1_2_1_2.html"><strong aria-hidden="true">4.2.1.2.</strong> 构建与编码</a></li><li class="chapter-item expanded "><a href="../blockchain/chapter_1_2_1_3.html"><strong aria-hidden="true">4.2.1.3.</strong> 启动区块链网络</a></li><li class="chapter-item expanded "><a href="../blockchain/chapter_1_2_1_4.html"><strong aria-hidden="true">4.2.1.4.</strong> 自定义pallet</a></li><li class="chapter-item expanded "><a href="../blockchain/chapter_1_2_1_5.html"><strong aria-hidden="true">4.2.1.5.</strong> 开发智能合约</a></li><li class="chapter-item expanded "><a href="../blockchain/chapter_1_2_1_6.html"><strong aria-hidden="true">4.2.1.6.</strong> 桥接其它链</a></li><li class="chapter-item expanded "><a href="../blockchain/chapter_1_2_1_7.html"><strong aria-hidden="true">4.2.1.7.</strong> 工具集成</a></li><li class="chapter-item expanded "><a href="../blockchain/chapter_1_2_1_8.html"><strong aria-hidden="true">4.2.1.8.</strong> 测试</a></li></ol></li><li class="chapter-item expanded "><a href="../blockchain/chapter_1_2_2.html"><strong aria-hidden="true">4.2.2.</strong> fabric</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../blockchain/chapter_1_2_2_1.html"><strong aria-hidden="true">4.2.2.1.</strong> 基本原理</a></li><li class="chapter-item expanded "><a href="../blockchain/chapter_1_2_2_2.html"><strong aria-hidden="true">4.2.2.2.</strong> 构建与开发</a></li></ol></li><li class="chapter-item expanded "><a href="../blockchain/chapter_1_2_3.html"><strong aria-hidden="true">4.2.3.</strong> EOSIO</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../blockchain/chapter_1_2_3_1.html"><strong aria-hidden="true">4.2.3.1.</strong> 基本原理</a></li><li class="chapter-item expanded "><a href="../blockchain/chapter_1_2_3_2.html"><strong aria-hidden="true">4.2.3.2.</strong> 构建与开发</a></li></ol></li><li class="chapter-item expanded "><a href="../blockchain/chapter_1_3.html"><strong aria-hidden="true">4.2.4.</strong> 智能合约与DApp</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../blockchain/chapter_1_3_1.html"><strong aria-hidden="true">4.2.4.1.</strong> Move</a></li><li class="chapter-item expanded "><a href="../blockchain/chapter_1_3_2.html"><strong aria-hidden="true">4.2.4.2.</strong> Solidity</a></li><li class="chapter-item expanded "><a href="../blockchain/chapter_1_3_3.html"><strong aria-hidden="true">4.2.4.3.</strong> Hardhat</a></li></ol></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../cloud/chapter_1.html"><strong aria-hidden="true">5.</strong> 云计算</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../cloud/chapter_1_1.html"><strong aria-hidden="true">5.1.</strong> 云计算简史</a></li><li class="chapter-item expanded "><a href="../cloud/chapter_1_2.html"><strong aria-hidden="true">5.2.</strong> 资源编排框架</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../cloud/chapter_1_2_1.html"><strong aria-hidden="true">5.2.1.</strong> kubernetes</a></li><li class="chapter-item expanded "><a href="../cloud/chapter_1_2_2.html"><strong aria-hidden="true">5.2.2.</strong> openstack</a></li></ol></li><li class="chapter-item expanded "><a href="../cloud/chapter_1_3.html"><strong aria-hidden="true">5.3.</strong> 虚拟化</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../cloud/chapter_1_3_1.html"><strong aria-hidden="true">5.3.1.</strong> 计算</a></li><li class="chapter-item expanded "><a href="../cloud/chapter_1_3_2.html"><strong aria-hidden="true">5.3.2.</strong> 网络</a></li><li class="chapter-item expanded "><a href="../cloud/chapter_1_3_3.html"><strong aria-hidden="true">5.3.3.</strong> 存储</a></li></ol></li><li class="chapter-item expanded "><a href="../cloud/chapter_1_4.html"><strong aria-hidden="true">5.4.</strong> 容器</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../cloud/chapter_1_4_1.html"><strong aria-hidden="true">5.4.1.</strong> docker</a></li><li class="chapter-item expanded "><a href="../cloud/chapter_1_4_2.html"><strong aria-hidden="true">5.4.2.</strong> containerd</a></li><li class="chapter-item expanded "><a href="../cloud/chapter_1_4_3.html"><strong aria-hidden="true">5.4.3.</strong> podman</a></li></ol></li><li class="chapter-item expanded "><a href="../cloud/chapter_1_5.html"><strong aria-hidden="true">5.5.</strong> 高级语言虚拟机</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../cloud/chapter_1_5_1.html"><strong aria-hidden="true">5.5.1.</strong> wasm</a></li><li class="chapter-item expanded "><a href="../cloud/chapter_1_5_2.html"><strong aria-hidden="true">5.5.2.</strong> jvm</a></li><li class="chapter-item expanded "><a href="../cloud/chapter_1_5_3.html"><strong aria-hidden="true">5.5.3.</strong> evm</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../privacy/chapter_1.html"><strong aria-hidden="true">6.</strong> 隐私计算</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../privacy/chapter_1_1.html"><strong aria-hidden="true">6.1.</strong> 密码学相关</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../privacy/chapter_1_1_1.html"><strong aria-hidden="true">6.1.1.</strong> 零知识证明</a></li><li class="chapter-item expanded "><a href="../privacy/chapter_1_1_2.html"><strong aria-hidden="true">6.1.2.</strong> MPC</a></li><li class="chapter-item expanded "><a href="../privacy/chapter_1_1_3.html"><strong aria-hidden="true">6.1.3.</strong> 差分隐私</a></li><li class="chapter-item expanded "><a href="../privacy/chapter_1_1_4.html"><strong aria-hidden="true">6.1.4.</strong> 秘密共享</a></li><li class="chapter-item expanded "><a href="../privacy/chapter_1_1_5.html"><strong aria-hidden="true">6.1.5.</strong> 同态加密</a></li></ol></li><li class="chapter-item expanded "><a href="../privacy/chapter_1_2.html"><strong aria-hidden="true">6.2.</strong> 可信执行环境</a></li><li class="chapter-item expanded "><a href="../privacy/chapter_1_3.html"><strong aria-hidden="true">6.3.</strong> 联邦学习</a></li></ol></li><li class="chapter-item expanded "><a href="../quantum/chapter_1.html"><strong aria-hidden="true">7.</strong> 量子计算</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../quantum/chapter_1_1.html" class="active"><strong aria-hidden="true">7.1.</strong> 量子状态与量子比特</a></li><li class="chapter-item expanded "><a href="../quantum/chapter_1_2.html"><strong aria-hidden="true">7.2.</strong> 多量子比特与量子纠缠</a></li><li class="chapter-item expanded "><a href="../quantum/chapter_1_3.html"><strong aria-hidden="true">7.3.</strong> 量子协议和量子算法</a></li><li class="chapter-item expanded "><a href="../quantum/chapter_1_4.html"><strong aria-hidden="true">7.4.</strong> 量子算法的应用</a></li><li class="chapter-item expanded "><a href="../quantum/chapter_1_5.html"><strong aria-hidden="true">7.5.</strong> 使用量子电路研究量子硬件</a></li><li class="chapter-item expanded "><a href="../quantum/chapter_1_6.html"><strong aria-hidden="true">7.6.</strong> 使用微波脉冲研究量子硬件</a></li><li class="chapter-item expanded "><a href="../quantum/chapter_1_7.html"><strong aria-hidden="true">7.7.</strong> 量子计算实验室</a></li><li class="chapter-item expanded "><a href="../quantum/chapter_1_8.html"><strong aria-hidden="true">7.8.</strong> 量子计算游戏和演示</a></li><li class="chapter-item expanded "><a href="../quantum/chapter_1_9.html"><strong aria-hidden="true">7.9.</strong> 量子计算应用开发</a></li></ol></li><li class="chapter-item expanded "><a href="../chapter_8.html"><strong aria-hidden="true">8.</strong> 软考记录</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">信息技术 | AwesomeProgram</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="量子状态与量子比特"><a class="header" href="#量子状态与量子比特">量子状态与量子比特</a></h1>
<h2 id="简介"><a class="header" href="#简介">简介</a></h2>
<p>如果您认为量子力学听起来很有挑战性，那么您并不孤单。我们所有的直觉都基于日常经验，因此比原子或电子更能理解球和香蕉的行为。尽管量子物体起初看起来随机且混乱，但它们只是遵循一套不同的规则。一旦我们知道这些规则是什么，我们就可以使用它们来创造新的强大技术。量子计算将是这方面最具革命性的例子。</p>
<p><img src="https://awesomeprogram.gitee.io/imgdata/tech_quan_atoms10.png" alt="" /></p>
<p>为了让您开始您的量子计算之旅，让我们测试一下您已经知道的内容。以下哪项是对 <em>bit</em> 的正确描述？</p>
<ul>
<li>木匠使用的刀片。</li>
<li>最小的信息单位：0或1。</li>
<li>你放在马嘴里的东西。</li>
</ul>
<p>实际上，它们都是正确的：这是一个非常多用途的词！但是，如果您选择了第二个，则表明您的思路已经正确。信息可以存储和处理为一系列 0 和 1 的想法是一个相当大的概念障碍，但这是今天大多数人甚至都没有考虑过的事情。以此为起点，我们可以开始想象遵守量子力学规则的比特。这些 quantum bits，或 qubits，将使我们能够以新的和不同的方式处理信息。</p>
<p>我们将开始更深入地研究量子比特的世界。为此，我们需要一些方法来跟踪我们应用门时他们在做什么。最有效的方法是使用向量和矩阵的数学语言。</p>
<p><img src="https://awesomeprogram.gitee.io/imgdata/tech_quan_bloch.png" alt="" /></p>
<p>本章对于已经熟悉向量和矩阵的读者来说最为有效。那些不熟悉的人也可能没问题，尽管不时查阅我们的<a href="https://qiskit.org/textbook/ch-appendix/linear_algebra.html">量子计算线性代数简介</a>可能会有用。</p>
<p>由于我们将使用基于 Python 的量子计算框架 Qiskit，因此了解 Python 的基础知识也很有用。需要入门的可以查阅<a href="https://qiskit.org/textbook/ch-prerequisites/python-and-jupyter-notebooks.html">Introduction to Python and Jupyter notebooks</a>。</p>
<h2 id="计算的原子"><a class="header" href="#计算的原子">计算的原子</a></h2>
<p>现在，任何人都可以在自己舒适的家中为量子计算机编程。</p>
<p>但是要创造什么？到底什么是量子程序？其实，什么是量子计算机？</p>
<p>这些问题可以通过与标准数字计算机进行比较来回答。不幸的是，大多数人实际上也不了解数字计算机的工作原理。在本文中，我们将了解这些设备背后的基本原理。为了帮助我们稍后过渡到量子计算，我们将使用与量子计算相同的工具来完成它。</p>
<p>如果我们想使用此页面中的代码，下面是我们需要运行的一些 Python 代码：</p>
<pre><code>from qiskit import QuantumCircuit, assemble, Aer
from qiskit.visualization import plot_histogram
</code></pre>
<h3 id="将信息拆分成比特"><a class="header" href="#将信息拆分成比特">将信息拆分成比特</a></h3>
<p>我们需要了解的第一件事是比特的概念。这些被设计成世界上最简单的字母表。只有两个字符，0 和 1，我们可以表示任何信息。</p>
<p>一个例子是数字。你可能习惯用0、1、2、3、4、5、6、7、8、9这十位数字的串来表示一个数，在这串数字中，每一位代表这个数的次数包含一定的十次方。例如，当我们写 9213 时，我们的意思是</p>
<p>$$
9000 + 200 + 10 + 3
$$</p>
<p>或者，以强调十的幂的方式表达</p>
<p>$$
(9\times10^3) + (2\times10^2) + (1\times10^1) + (3\times10^0)
$$</p>
<p>虽然我们通常使用基于数字 10 的系统，但我们也可以轻松地使用基于任何其他数字的系统。例如，二进制数字系统是基于数字二的。这意味着使用 0 和 1 这两个字符将数字表示为 2 的幂的倍数。例如，9213 变为 10001111111101，因为</p>
<p>$$
9213  = (1 \times 2^{13}) + (0 \times 2^{12}) + (0 \times 2^{11})+ (0 \times 2^{10}) +(1 \times 2^9) + (1 \times 2^8) + (1 \times 2^7) \\ ,,,   + (1 \times 2^6) + (1 \times 2^5) + (1 \times 2^4) + (1 \times 2^3) + (1 \times 2^2) + (0 \times 2^1) + (1 \times 2^0)
$$</p>
<p>在这里，我们将数字表示为 2、4、8、16、32 等的倍数，而不是 10、100、1000 等。</p>
<pre><code>from qiskit_textbook.widgets import binary_widget
binary_widget(nbits=5)
</code></pre>
<p>这些位串，称为二进制串，不仅可以用来表示数字。例如，有一种方法可以使用位来表示任何文本。对于您要使用的任何字母、数字或标点符号，您可以使用<a href="https://www.ibm.com/docs/en/aix/7.2?topic=adapters-ascii-decimal-hexadecimal-octal-binary-conversion-table">此表</a>找到对应的最多八位的字符串。尽管这些标准相当武断，但这是一个得到广泛认可的标准。事实上，它就是用来通过互联网向您传送这篇文章的。</p>
<p>这就是所有信息在计算机中的表示方式。无论是数字、字母、图像还是声音，都以二进制字符串的形式存在。</p>
<p>与我们的标准数字计算机一样，量子计算机也是基于同样的基本思想。主要区别在于它们使用 <em>qubits</em>，这是比特对量子力学的扩展。在本教科书的其余部分，我们将探讨什么是量子比特、它们能做什么以及它们是如何做到的。然而，在本节中，我们根本不讨论量子。所以，我们只是像使用比特一样使用量子比特。</p>
<p>快速练习 </p>
<ul>
<li>想一个数字并尝试用二进制写下来。</li>
<li>如果你有n个bit，它们可以处于多少种不同的状态？</li>
</ul>
<h3 id="以图表形式计算"><a class="header" href="#以图表形式计算">以图表形式计算</a></h3>
<p>无论我们使用的是量子比特还是经典比特，我们都需要操作它们，以便将我们拥有的输入转化为我们需要的输出。对于比特数很少的最简单程序，用称为电路图的图表来表示此过程很有用。这些在左边有输入，在右边有输出，中间有神秘符号表示的操作。这些操作被称为“门”，主要是出于历史原因。</p>
<p>下面是标准的基于位的计算机的电路示例。您不需要了解它的作用。它应该只是让您了解这些电路的外观。</p>
<p><img src="https://awesomeprogram.gitee.io/imgdata/tech_quan_classical_circuit.png" alt="" /></p>
<p>对于量子计算机，我们使用相同的基本思想，但对于如何表示输入、输出和用于运算的符号有不同的约定。这是代表与上述相同过程的量子电路。</p>
<p><img src="https://awesomeprogram.gitee.io/imgdata/tech_quan_quantum_circuit.png" alt="" /></p>
<p>在本节的其余部分，我们将解释如何构建电路。最后，您将了解如何创建上面的电路、它的作用以及它为什么有用。</p>
<h3 id="你的第一个量子电路"><a class="header" href="#你的第一个量子电路">你的第一个量子电路</a></h3>
<p>在电路中，我们通常需要做三项工作：首先，对输入进行编码，然后进行一些实际计算，最后提取输出。对于您的第一个量子电路，我们将专注于这些工作中的最后一个。我们首先创建一个具有八个量子位和八个输出的电路。</p>
<pre><code>qc_output = QuantumCircuit(8)
</code></pre>
<p>这个电路，我们称之为qc_output，是由 Qiskit 使用创建的QuantumCircuit。将QuantumCircuit量子电路中的量子比特数作为参数。</p>
<p>量子电路中输出的提取是使用称为 <code>measure_all()</code> 的操作完成的。每次测量都会告诉指定的量子位输出为指定的经典位。该命令 <code>qc_output.measure_all()</code> 向电路 <code>qc_output</code> 中的每个量子位添加一个测量值，还添加一些经典位以写入输出。</p>
<pre><code>qc_output.measure_all()
</code></pre>
<p>现在我们的电路已经有了一些东西，让我们来看看它。</p>
<pre><code>qc_output.draw(initial_state=True) 
</code></pre>
<p><img src="https://awesomeprogram.gitee.io/imgdata/tech_quan_qc1.png" alt="" /></p>
<p>量子位总是被初始化输出为0。由于我们没有对上面电路中的量子比特做任何事情，这正是我们测量它们时得到的结果。我们可以通过多次运行电路并在直方图中绘制结果来看到这一点。我们会发现每个量子比特的结果总是 00000000: a 0。</p>
<pre><code>sim = Aer.get_backend('aer_simulator') 
result = sim.run(qc_output).result()
counts = result.get_counts()
plot_histogram(counts)
</code></pre>
<p><img src="https://awesomeprogram.gitee.io/imgdata/tech_quan_qc1x.png" alt="" /></p>
<p>多次运行并将结果显示为直方图的原因是因为量子计算机的结果可能具有一些随机性。在这种情况下，由于我们没有做任何量子的事情，我们只能得到00000000的结果是确定的。</p>
<p>请注意，此结果来自量子模拟器，这是一台标准计算机，用于计算理想量子计算机的功能。模拟只能用于少量的量子位（~30 qubits），但在设计您的第一个量子电路时它们仍然是一个非常有用的工具。要在真实设备上运行，您只需替换 <code>Aer.get_backend('aer_simulator')</code> 为您要使用的设备的后端对象。</p>
<h3 id="示例创建加法器电路"><a class="header" href="#示例创建加法器电路">示例：创建加法器电路</a></h3>
<h4 id="编码一个输入"><a class="header" href="#编码一个输入">编码一个输入</a></h4>
<p>现在让我们看看如何将不同的二进制字符串编码为输入。为此，我们需要所谓的 <strong>NOT</strong> 门。这是您可以在计算机上执行的最基本的操作。它只是翻转位值：0成为1和1成为0。对于量子位，它是一个称为 X 的操作，可以完成 NOT 的作业。</p>
<p>下面我们创建一个专用于编码工作的新电路，并将其称为 qc_encode。现在，我们只指定量子位的数量。</p>
<pre><code>qc_encode = QuantumCircuit(8)
qc_encode.x(7)
qc_encode.draw()
</code></pre>
<p><img src="https://awesomeprogram.gitee.io/imgdata/tech_quan_qc2.png" alt="" /></p>
<p>可以使用我们之前的电路来提取结果：qc_output。</p>
<pre><code>qc_encode.measure_all()
qc_encode.draw()
</code></pre>
<p><img src="https://awesomeprogram.gitee.io/imgdata/tech_quan_qc3.png" alt="" /></p>
<p>现在我们可以运行组合电路并查看结果。</p>
<pre><code>sim = Aer.get_backend('aer_simulator') 
result = sim.run(qc_encode).result()
counts = result.get_counts()
plot_histogram(counts)
</code></pre>
<p><img src="https://awesomeprogram.gitee.io/imgdata/tech_quan_qc4.png" alt="" /></p>
<p>现在我们的计算机输出字符串10000000。</p>
<p>我们翻转的位来自量子位 7，位于字符串的最左侧。这是因为 Qiskit 从右到左对字符串中的位进行编号。有些人喜欢用相反的方式给他们的位编号，但是当我们使用位来表示数字时，Qiskit 的系统肯定有它的优势。具体来说，这意味着量子比特 7 告诉我们有多少个 2^7 有我们的数字。所以通过翻转这个位，我们现在已经在我们简单的 8 位计算机中写入了数字 128。</p>
<p>现在尝试为自己写另一个数字。例如，你可以做你的年龄。只需使用搜索引擎找出数字在二进制中的样子（如果它包含 <code>0b</code>，请忽略它），然后如果你的年龄小于 128，则在左侧添加一些 0。</p>
<pre><code>qc_encode = QuantumCircuit(8)
qc_encode.x(1)
qc_encode.x(5)

qc_encode.draw()
</code></pre>
<p><img src="https://awesomeprogram.gitee.io/imgdata/tech_quan_qc5.png" alt="" /></p>
<p>现在我们知道如何在计算机中对信息进行编码。下一步是处理它：获取我们已经编码的输入，并将其转换为我们需要的输出。</p>
<h4 id="记住如何做加法"><a class="header" href="#记住如何做加法">记住如何做加法</a></h4>
<p>要了解将输入转化为输出，我们需要解决一个问题。让我们做一些基本的数学运算。在小学，您会学习到如何处理大型数学问题并将它们分解成易于管理的部分。例如，您将如何解决以下问题？</p>
<pre><code>   9213
+  1854
=  ????
</code></pre>
<p>一种方法是从右到左逐位进行。所以我们从 3+4 开始</p>
<pre><code>   9213
+  1854
=  ???7
</code></pre>
<p>然后1+5</p>
<pre><code>   9213
+  1854
=  ??67
</code></pre>
<p>那么我们有 2+8=10。由于这是一个两位数的答案，我们需要将其转移到下一栏。</p>
<pre><code>   9213
+  1854
=  ?067
</code></pre>
<p>最后我们有9+1+1=11，得到我们的答案</p>
<pre><code>   9213
+  1854
= 11067
</code></pre>
<p>这可能只是简单的加法，但它演示了所有算法背后的原理。无论算法是设计用于解决数学问题还是处理文本或图像，我们总是将大任务分解为小而简单的步骤。</p>
<p>要在计算机上运行，​​需要将算法编译成尽可能最小和最简单的步骤。为了看看这些看起来像什么，让我们再次做上面的加法问题，但是用二进制。</p>
<pre><code>   10001111111101
+  00011100111110
=  ??????????????
</code></pre>
<p>请注意，第二个数字的左侧有一堆额外的 0。这只是为了使两个字符串的长度相同。</p>
<p>我们的第一个任务是对右侧的列执行 1+0。在二进制中，与在任何数字系统中一样，答案是 1。对于第二列的 0+1，我们得到相同的结果。</p>
<pre><code>   10001111111101
+  00011100111110
=  ????????????11
</code></pre>
<p>接下来，我们有 1+1。您一定会知道，1+1=2。在二进制中，数字 2 被写为10，因此需要两位。这意味着我们需要携带 1，就像我们携带十进制数 10 一样。</p>
<pre><code>   10001111111101
+  00011100111110
=  ???????????011 
</code></pre>
<p>下一列现在要求我们计算1+1+1。这意味着将三个数字相加，因此对于我们的计算机而言，事情变得越来越复杂。但是我们仍然可以将它编译成更简单的操作，并且只需要我们将两个位加在一起。为此，我们可以只从前两个 1 开始。</p>
<pre><code>   1
+  1
= 10
</code></pre>
<p>现在我们需要把这个 10 加到最后的 1，这可以使用我们通常的遍历列的方法来完成。</p>
<pre><code>  10
+ 01
= 11
</code></pre>
<p>最后的答案是11（也称为3）。</p>
<p>现在我们可以回到问题的其余部分了。有了 的答案 11，我们就有了另一个进位。</p>
<pre><code>   10001111111101
+  00011100111110
=  ??????????1011
</code></pre>
<p>所以现在我们还有另一个 1+1+1 要做。但我们已经知道如何做到这一点，所以这没什么大不了的。</p>
<p>事实上，到目前为止剩下的一切都是我们已经知道该怎么做的事情。这是因为，如果您将所有内容分解为仅添加两位，那么您将只需要计算四种可能的事情。这是四个基本求和（我们将用两位写出所有答案以保持一致）。</p>
<pre><code>0+0 = 00 (in decimal, this is 0+0=0)
0+1 = 01 (in decimal, this is 0+1=1)
1+0 = 01 (in decimal, this is 1+0=1)
1+1 = 10 (in decimal, this is 1+1=2)
</code></pre>
<p>这称为半加法器。如果我们的计算机可以实现这一点，并且可以将它们都连接在一起，那么它就可以进行任何加法操作。</p>
<h4 id="使用-qiskit-的加法器"><a class="header" href="#使用-qiskit-的加法器">使用 Qiskit 的加法器</a></h4>
<p>让我们使用 Qiskit 制作我们自己的半加法器。这将包括对输入进行编码的电路部分、执行算法的部分以及提取结果的部分。每当我们想要使用新输入时，都需要更改第一部分，但其余部分将始终保持不变。</p>
<p><img src="https://awesomeprogram.gitee.io/imgdata/tech_quan_half_adder.svg" alt="" /></p>
<p>我们要添加的两个比特编码在量子位0和1中。上面的例子在这两个量子位中都编码了1，因此它试图找到 <code>1+1</code> 的解。结果将是一个由两位组成的字符串，我们将从量子位 2 和 3 中读出，并分别存储在经典位 0 和 1 中。剩下的就是填写实际的程序，它位于中间的空白处。</p>
<p>图中的虚线只是为了区分电路的不同部分（尽管它们也可以有更有趣的用途）。它们是使用 <code>barrier</code> 命令制作的。</p>
<p>计算机的基本构建块称为逻辑门。我们已经使用了非门，但这还不足以构成我们的半加器。我们只能用它来手动写出答案。由于我们希望计算机为我们进行实际计算，因此我们需要一些更强大的门。</p>
<p>为了了解我们需要什么，让我们再看看我们的半加器需要做什么。</p>
<pre><code>0+0 = 00
0+1 = 01
1+0 = 01
1+1 = 10
</code></pre>
<p>所有这四个答案中最右边的位完全取决于我们添加的两位是相同还是不同。所以对于0+0和1+1，当两位相等时，答案的最右边的位就出来了0。对于0+1和1+0，我们在其中添加不同的位值，最右边的位是1。</p>
<p>为了使解的这一部分正确，我们需要一些东西来确定两个位是否不同。传统上，在数字计算的研究中，这被称为异或门。</p>
<table><thead><tr><th style="text-align: center">Input 1</th><th style="text-align: center">Input 2</th><th style="text-align: center">XOR Output</th></tr></thead><tbody>
<tr><td style="text-align: center">0</td><td style="text-align: center">0</td><td style="text-align: center">0</td></tr>
<tr><td style="text-align: center">0</td><td style="text-align: center">1</td><td style="text-align: center">1</td></tr>
<tr><td style="text-align: center">1</td><td style="text-align: center">0</td><td style="text-align: center">1</td></tr>
<tr><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">0</td></tr>
</tbody></table>
<p>在量子计算机中，异或门的工作由受控非门完成。由于这个名字很长，我们通常将其称为 CNOT。在 Qiskit 中它的名字是cx，更短。在电路图中，它如下图所示。</p>
<pre><code>qc_cnot = QuantumCircuit(2)
qc_cnot.cx(0,1)
qc_cnot.draw()
</code></pre>
<p><img src="https://awesomeprogram.gitee.io/imgdata/tech_quan_pair01.jpg" alt="" /></p>
<p>这适用于一对量子位。一个充当控制量子位（这是带有小点的那个）。另一个充当目标量子位（大圆圈里面有一个 +）。</p>
<p>有多种方法可以解释 CNOT 的影响。一种是说它查看它的两个输入位，看它们是否相同或不同。接下来，用结果覆盖目标量子位。如果它们相同，则目标位变为0，如果它们不同就变为1。</p>
<p><img src="https://awesomeprogram.gitee.io/imgdata/tech_quan_cnot_xor.svg" alt="" /></p>
<p>另一种解释 CNOT 的方法是说，如果控件是1，它对目标执行 NOT，否则不执行任何操作。这个解释与前一个解释一样有效（事实上，正是这个解释才有了门的名字）。</p>
<p>通过尝试每个可能的输入来亲自尝试 CNOT。例如，这是一个使用输入测试 CNOT 的电路01。</p>
<pre><code>qc = QuantumCircuit(2,2)
qc.x(0)
qc.cx(0,1)
qc.measure(0,0)
qc.measure(1,1)
qc.draw()
</code></pre>
<p><img src="https://awesomeprogram.gitee.io/imgdata/tech_quan_meas2b.jpg" alt="" /></p>
<p>如果你执行这个电路，你会发现输出是11。我们可以认为这种情况的发生是由于以下任一原因。</p>
<ul>
<li>
<p>CNOT计算输入值是否不同，发现不同，则表示要输出1。它通过覆盖 qubit 1 的状态（记住，它位于位串的左侧），01变成11.</p>
</li>
<li>
<p>CNOT 看到量子位 0 处于状态1，因此将 NOT 应用于量子位 1。这会将量子位 1 的 0 翻转为 1，因此 01 变为 11。</p>
</li>
</ul>
<p>下表显示了 CNOT 门的所有可能输入和相应输出：</p>
<table><thead><tr><th style="text-align: center">Input (q1 q0)</th><th style="text-align: center">Output (q1 q0)</th></tr></thead><tbody>
<tr><td style="text-align: center">00</td><td style="text-align: center">00</td></tr>
<tr><td style="text-align: center">01</td><td style="text-align: center">11</td></tr>
<tr><td style="text-align: center">10</td><td style="text-align: center">10</td></tr>
<tr><td style="text-align: center">11</td><td style="text-align: center">01</td></tr>
</tbody></table>
<p>对于我们的半加器，我们不想覆盖我们的输入之一。相反，我们想将结果写在一对不同的量子位上。为此，我们可以使用两个 CNOT。</p>
<pre><code>qc_ha = QuantumCircuit(4,2)
# encode inputs in qubits 0 and 1
qc_ha.x(0) # For a=0, remove this line. For a=1, leave it.
qc_ha.x(1) # For b=0, remove this line. For b=1, leave it.
qc_ha.barrier()
# use cnots to write the XOR of the inputs on qubit 2
qc_ha.cx(0,2)
qc_ha.cx(1,2)
qc_ha.barrier()
# extract outputs
qc_ha.measure(2,0) # extract XOR value
qc_ha.measure(3,1)

qc_ha.draw()
</code></pre>
<p><img src="https://awesomeprogram.gitee.io/imgdata/tech_quan_qc6.png" alt="" /></p>
<p>我们现在已经完成了半加法器的一半工作。我们只剩下输出的另一部分要做：就是存在于量子位 3 上的那个。</p>
<p>如果您再次查看四个可能的总和，您会注意到只有一种情况是 1 而不是 0：1+1=10。只有当我们添加的两个位都是1.</p>
<p>要计算这部分输出，我们可以让我们的计算机查看两个输入是否都是1。如果它们是——并且仅当它们是——我们需要在量子位 3 上做一个非门。这将把它翻转到1仅适用于这种情况的所需值，为我们提供我们需要的输出。</p>
<p>为此，我们需要一个新门：类似于 CNOT，但控制在两个量子位上，而不是一个。只有当两个控件都处于状态 1 时，这才会对目标量子位执行 NOT 1。这座新城门叫做 <em>Toffoli</em>。对于那些熟悉布尔逻辑门的人来说，它基本上是一个 AND 门。</p>
<p>在 Qiskit 中，<em>Toffoli</em> 用 ccx 命令表示。</p>
<pre><code>qc_ha = QuantumCircuit(4,2)
# encode inputs in qubits 0 and 1
qc_ha.x(0) # For a=0, remove the this line. For a=1, leave it.
qc_ha.x(1) # For b=0, remove the this line. For b=1, leave it.
qc_ha.barrier()
# use cnots to write the XOR of the inputs on qubit 2
qc_ha.cx(0,2)
qc_ha.cx(1,2)
# use ccx to write the AND of the inputs on qubit 3
qc_ha.ccx(0,1,3)
qc_ha.barrier()
# extract outputs
qc_ha.measure(2,0) # extract XOR value
qc_ha.measure(3,1) # extract AND value

qc_ha.draw()
</code></pre>
<p><img src="https://awesomeprogram.gitee.io/imgdata/tech_quan_qc7.jpg" alt="" /></p>
<p>在这个例子中，我们正在计算1+1，因为两个输入位都是1。让我们看看我们得到了什么。</p>
<pre><code>qobj = assemble(qc_ha)
counts = sim.run(qobj).result().get_counts()
plot_histogram(counts)

/home/divs/.local/lib/python3.8/site-packages/qiskit/utils/deprecation.py:62: DeprecationWarning: Using a qobj for run() is deprecated as of qiskit-aer 0.9.0 and will be removed no sooner than 3 months from that release date. Transpiled circuits should now be passed directly using `backend.run(circuits, **run_options).
  return func(*args, **kwargs)
</code></pre>
<p><img src="https://awesomeprogram.gitee.io/imgdata/tech_quan_qc8.png" alt="" /></p>
<p>结果是10，这是数字 2 的二进制表示。我们建造了一台可以解决著名数学问题 1+1 的计算机！</p>
<p>现在您可以尝试其他三个可能的输入，并证明我们的算法也能为这些输入提供正确的结果。</p>
<p>半加器包含加法所需的一切。使用 NOT、CNOT 和 Toffoli 门，我们可以创建程序来进行任意大小的任意数字集合的加法运算。</p>
<p>这三个门也足以完成计算中的所有其他事情。事实上，我们甚至可以不用 CNOT。此外，只有在创建具有值 1 的位时才真正需要非门。<em>Toffoli</em> 本质上是数学的原子。它是最简单的元素，其他任何解决问题的技巧都可以从它中编译出来。</p>
<p>正如我们所见，在量子计算中我们分裂了原子。</p>
<pre><code>import qiskit.tools.jupyter
%qiskit_version_table

/home/divs/.local/lib/python3.8/site-packages/qiskit/aqua/__init__.py:86: DeprecationWarning: The package qiskit.aqua is deprecated. It was moved/refactored to qiskit-terra For more information see &lt;https://github.com/Qiskit/qiskit-aqua/blob/main/README.md#migration-guide&gt;
  warn_package('aqua', 'qiskit-terra')
</code></pre>
<p><strong>Version Information</strong></p>
<table><tr><th>Qiskit Software</th><th>Version</th></tr><tr><td><code>qiskit-terra</code></td><td>0.18.2</td></tr><tr><td><code>qiskit-aer</code></td><td>0.9.0</td></tr><tr><td><code>qiskit-ignis</code></td><td>0.6.0</td></tr><tr><td><code>qiskit-ibmq-provider</code></td><td>0.16.0</td></tr><tr><td><code>qiskit-aqua</code></td><td>0.9.5</td></tr><tr><td><code>qiskit</code></td><td>0.30.0</td></tr><tr><td><code>qiskit-nature</code></td><td>0.2.1</td></tr><tr><td><code>qiskit-finance</code></td><td>0.2.1</td></tr><tr><td><code>qiskit-optimization</code></td><td>0.2.2</td></tr><tr><td><code>qiskit-machine-learning</code></td><td>0.2.1</td></tr><tr><th>System information</th></tr><tr><td>Python</td><td>3.8.10 (default, Jun  2 2021, 10:49:15) 
[GCC 9.4.0]</td></tr><tr><td>OS</td><td>Linux</td></tr><tr><td>CPUs</td><td>2</td></tr><tr><td>Memory (Gb)</td><td>7.521877288818359</td></tr><tr><td colspan='2'>Sun Oct 03 22:50:56 2021 IST</td></tr></table>
<h2 id="表示量子比特状态"><a class="header" href="#表示量子比特状态">表示量子比特状态</a></h2>
<p>您现在对位以及我们熟悉的数字计算机的工作原理有所了解。现代软件中使用的所有复杂变量、对象和数据结构基本上都是一大堆比特。我们这些从事量子计算工作的人称这些为经典变量。使用它们的计算机，就像您用来阅读本文的计算机，我们称为经典计算机。</p>
<p>在量子计算机中，我们的基本变量是量子位：位的量子变体。它们与普通位具有完全相同的限制：它们只能存储一条二进制信息，并且只能为我们提供0or的输出1。然而，它们也可以以只有量子力学才能描述的方式被操纵。这为我们提供了新的门，让我们能够找到设计算法的新方法。</p>
<p>要完全理解这些新门，我们首先需要了解如何记下量子比特状态。为此，我们将使用向量、矩阵和复数的数学。尽管我们会边走边介绍这些概念，但最好您已经熟悉它们。如果您需要更深入的解释或复习，可以在此处找到<a href="https://qiskit.org/textbook/ch-appendix/linear_algebra.html">指南</a>。</p>
<p>内容</p>
<p>1.经典比特与量子比特
1.1状态向量
1.2量子比特符号
1.3使用 Qiskit 探索量子比特
2.测量规则
2.1一个非常重要的规则
2.2这个规则的含义
3.布洛赫球体
3.1描述受限量子位状态
3.2视觉表示量子位状态</p>
<h3 id="经典比特与量子比特"><a class="header" href="#经典比特与量子比特">经典比特与量子比特</a></h3>
<h4 id="状态向量"><a class="header" href="#状态向量">状态向量</a></h4>
<p>在量子物理学中，我们使用状态向量来描述系统的状态。假设我们想描述汽车在赛道上的位置，这是一个经典系统，所以我们可以使用一个数字 x :</p>
<p><img src="https://learn.qiskit.org/content/ch-states/images/car_track_1.jpg" alt="" /></p>
<p>$$
x = 4
$$</p>
<p>或者，我们可以使用称为 状态向量的向量中的一组数字。statevector 中的每个元素都包含在某个地方找到汽车的概率：</p>
<p><img src="https://learn.qiskit.org/content/ch-states/images/car_track_2.jpg" alt="" /></p>
<p>$$
|x\rangle = \begin{bmatrix} 0\ \vdots \ 0 \ 1 \ 0 \ \vdots \ 0 \end{bmatrix} 
\begin{matrix} \  \  \ \leftarrow \  \  \  \ \end{matrix}
\begin{matrix} \  \ \text{Probability of} \ \text{car being at} \ \text{position 4} \  \  \ \end{matrix}
$$</p>
<p>这不仅限于位置，我们还可以保留汽车可能具有的所有可能速度以及汽车可能具有的所有可能颜色的状态向量。对于经典系统（如上面的汽车示例），这是一件愚蠢的事情，因为当我们真的只需要一个数字时，它需要保留巨大的向量。但正如我们将在本章中看到的那样，状态向量恰好是跟踪量子系统（包括量子计算机）的一种非常好的方法。</p>
<h4 id="量子比特符号"><a class="header" href="#量子比特符号">量子比特符号</a></h4>
<p>经典位总是有一个完全明确定义的状态：它们要么是0，要么1在计算过程中的每个点。没有比这更多的细节可以添加到 bit 的状态中了。所以要写下一个经典位 ( c) 的状态，我们可以只使用这两个二进制值。例如：</p>
<p>c = 0</p>
<p>对于量子位，此限制已解除。我们只需要在进行测量以提取输出时明确定义我们是从量子位得到 a0还是 a 。1届时，它必须承诺这两个选项之一。在所有其他时间，它的状态将比简单的二进制值所捕获的更复杂。</p>
<p>要了解如何描述这些，我们可以先关注两个最简单的情况。正如我们在上一节中看到的，可以在0测量时明确给出结果的状态下准备一个量子位。</p>
<p>我们需要这个状态的名称。让我们缺乏想象力并称它为 0。类似地，存在一个 qubit 状态，它一定会输出 a 1。我们称之为 1 个。这两种状态是完全互斥的。要么 qubit 肯定输出 a 0，要么它肯定输出 a 1。没有重叠。用数学表示这一点的一种方法是使用两个正交向量。</p>
<p>$$
|0\rangle = \begin{bmatrix} 1 \ 0 \end{bmatrix} , , , , |1\rangle =\begin{bmatrix} 0 \ 1 \end{bmatrix}.
$$</p>
<p>这是一次要全部接受的很多符号。首先，让我们打开奇怪的包装 | 和 ⟩。他们的工作本质上只是提醒我们，我们正在谈论代表标记的量子比特状态的向量 0 和 个。这有助于我们将它们与位值0和1/或数字 0 和 1 之类的东西区分开来。它是 Dirac 引入的 bra-ket 表示法的一部分。</p>
<p>如果您不熟悉向量，您基本上可以将它们视为我们使用特定规则操作的数字列表。如果您熟悉高中物理课上的向量，您就会知道这些规则使向量非常适合描述具有大小和方向的量。例如，物体的速度可以用矢量完美地描述。然而，我们对量子态使用向量的方式与此略有不同，所以不要太坚持你以前的直觉。是时候做点新的了！</p>
<p>使用向量，我们可以描述更复杂的状态，而不仅仅是 |0⟩ 和 |1。例如，考虑向量</p>
<p>$$
|q_0\rangle = \begin{bmatrix} \tfrac{1}{\sqrt{2}} \ \tfrac{i}{\sqrt{2}} \end{bmatrix} .
$$</p>
<p>要了解此状态的含义，我们需要使用数学规则来处理向量。具体来说，我们需要了解如何将向量相加以及如何将它们与标量相乘。</p>
<ul>
<li>提醒：标量的矩阵加法和乘法（单击此处展开）
要添加两个向量，我们将它们的元素加在一起：</li>
</ul>
<p>$$
|a\rangle = \begin{bmatrix}a_0 \ a_1 \ \vdots \ a_n \end{bmatrix}, \quad
|b\rangle = \begin{bmatrix}b_0 \ b_1 \ \vdots \ b_n \end{bmatrix}
|a\rangle + |b\rangle = \begin{bmatrix}a_0 + b_0 \ a_1 + b_1 \ \vdots \ a_n + b_n \end{bmatrix}
$$</p>
<p>要将向量乘以标量，我们将每个元素乘以标量：</p>
<p>$$
x|a\rangle = \begin{bmatrix}x \times a_0 \ x \times  a_1 \ \vdots \ x \times  a_n \end{bmatrix}
$$</p>
<p>这两个规则用于重写向量 |q0⟩（如上图）：</p>
<p>$$
\begin{aligned} 
|q_0\rangle &amp; = \tfrac{1}{\sqrt{2}}|0\rangle + \tfrac{i}{\sqrt{2}}|1\rangle \
&amp; = \tfrac{1}{\sqrt{2}}\begin{bmatrix}1\0\end{bmatrix} + \tfrac{i}{\sqrt{2}}\begin{bmatrix}0\1\end{bmatrix}\
&amp; = \begin{bmatrix}\tfrac{1}{\sqrt{2}}\0\end{bmatrix} + \begin{bmatrix}0\\tfrac{i}{\sqrt{2}}\end{bmatrix}\
&amp; = \begin{bmatrix}\tfrac{1}{\sqrt{2}} \ \tfrac{i}{\sqrt{2}} \end{bmatrix}\
\end{aligned}
$$</p>
<ul>
<li>提醒：正交基（单击此处展开）前面说过这两个向量 |0⟩ 和 |1 个 ⟩ 是正交的，这意味着它们既是正交的又是归一化的。正交意味着向量成直角：
<img src="https://qiskit.org/textbook/ch-states/images/basis.svg" alt="" /></li>
</ul>
<p>归一化意味着它们的大小（箭头的长度）等于 1。这两个向量 |0⟩ 和 |1 个 ⟩ 是线性独立的，这意味着我们无法描述 |0⟩ 按照 |1 个 ⟩，反之亦然。但是，使用这两个向量 |0⟩ 和 |1 个 ⟩，以及我们的标量加法和乘法规则，我们可以描述二维空间中所有可能的向量：
<img src="https://qiskit.org/textbook/ch-states/images/basis2.svg" alt="" /></p>
<p>因为载体 |0⟩ 和 |1 个 ⟩ 是线性无关的，并且可以使用向量加法和标量乘法来描述二维空间中的任何向量，我们称向量 |0⟩ 和 |1 个 ⟩ 形成基础。在这种情况下，由于它们既是正交的又是归一化的，我们称之为正交基。</p>
<p>由于各状态 |0⟩ 和 |1 个 ⟩ 形成正交基，我们可以用这两种状态的组合来表示任何二维向量。这允许我们以替代形式编写我们的量子比特的状态：</p>
<p>$$
|q_0\rangle = \tfrac{1}{\sqrt{2}}|0\rangle + \tfrac{i}{\sqrt{2}}|1\rangle
$$</p>
<p>这个向量，|q<sub>0</sub>⟩ 被称为量子比特的状态向量，它告诉我们关于这个量子比特我们可能知道的一切。目前，我们只能对状态向量的这个特定示例得出一些简单的结论：它并不完全 |0⟩ 并不完全 |1 个 ⟩。相反，它是由两者的线性组合来描述的。在量子力学中，我们通常使用“叠加”一词来描述此类线性组合。虽然我们的例子说明 |q<sub>0</sub>⟩ 可以表示为的叠加 |0⟩ 和 |1 个⟩，它与它们一样是一个确定且定义明确的量子位状态。为了解这一点，我们可以开始探索如何操纵量子位。</p>
<h4 id="用-qiskit-探索量子比特"><a class="header" href="#用-qiskit-探索量子比特">用 Qiskit 探索量子比特</a></h4>
<p>首先，我们需要导入所有需要的工具：</p>
<pre><code>from qiskit import QuantumCircuit, assemble, Aer
from qiskit.visualization import plot_histogram, plot_bloch_vector
from math import sqrt, pi
</code></pre>
<p>在 Qiskit 中，我们使用该QuantumCircuit对象来存储我们的电路，这本质上是我们电路上的量子操作列表以及它们所应用的量子位。</p>
<pre><code>qc = QuantumCircuit(1) # Create a quantum circuit with one qubit
</code></pre>
<p>在我们的量子电路中，我们的量子位总是从状态开始 |0⟩。我们可以使用该initialize()方法将其转换为任何状态。initialize()我们以列表的形式给出我们想要的向量，并告诉它我们想要在这个状态下初始化哪个量子位：</p>
<pre><code>qc = QuantumCircuit(1)  # Create a quantum circuit with one qubit
initial_state = [0,1]   # Define initial_state as |1&gt;
qc.initialize(initial_state, 0) # Apply initialisation operation to the 0th qubit
qc.draw()  # Let's view our circuit
</code></pre>
<p>然后我们可以使用 Qiskit 的模拟器之一来查看我们的量子比特的结果状态。</p>
<pre><code>sim = Aer.get_backend('aer_simulator')  # Tell Qiskit how to simulate our circuit
</code></pre>
<p>为了从我们的电路中获得结果，我们使用 run 来执行我们的电路，将电路和后端作为参数。然后我们用 .result() 它来得到这个结果：</p>
<pre><code>qc = QuantumCircuit(1)  # Create a quantum circuit with one qubit
initial_state = [0,1]   # Define initial_state as |1&gt;
qc.initialize(initial_state, 0) # Apply initialisation operation to the 0th qubit
qc.save_statevector()   # Tell simulator to save statevector
qobj = assemble(qc)     # Create a Qobj from the circuit for the simulator to run
result = sim.run(qobj).result() # Do the simulation and return the result
</code></pre>
<p>从 result，然后我们可以使用 获得最终的状态向量 .get_statevector()：</p>
<pre><code>out_state = result.get_statevector()
print(out_state) # Display the output state vector

Statevector([0.+0.j, 1.+0.j],
            dims=(2,))
</code></pre>
<p>注： Python 用来 j 表示 i 在复数中。我们看到一个包含两个复数元素的向量：0.+ 0.j = 0 和 1.+ 0.j = 1。</p>
<p>现在让我们像在真正的量子计算机中那样测量我们的量子位并查看结果：</p>
<pre><code>qc.measure_all()
qc.draw()
</code></pre>
<p>这一次，我们将使用以下方法获取 0 和结果的计数，而不是状态向量 .get_counts()</p>
<pre><code>qobj = assemble(qc)
result = sim.run(qobj).result()
counts = result.get_counts()
plot_histogram(counts)
</code></pre>
<p>我们可以看到我们（不出所料）有 100% 的机会测量 |1个 ⟩。这一次，让我们将我们的量子比特置于叠加态中，看看会发生什么。我们将使用状态 |q<sub>0</sub>⟩ 来自本节前面的内容：</p>
<p>$$
|q_0\rangle = \tfrac{1}{\sqrt{2}}|0\rangle + \tfrac{i}{\sqrt{2}}|1\rangle
$$</p>
<p>我们需要将这些振幅添加到 python 列表中。为了添加复振幅，Python 使用j虚数单位（我们通常称其为&quot; i &quot;数学上）：</p>
<pre><code>initial_state = [1/sqrt(2), 1j/sqrt(2)]  # Define state |q_0&gt;
</code></pre>
<p>然后我们像以前一样重复初始化量子位的步骤：</p>
<pre><code>qc = QuantumCircuit(1) # Must redefine qc
qc.initialize(initial_state, 0) # Initialize the 0th qubit in the state `initial_state`
qc.save_statevector() # Save statevector
qobj = assemble(qc)
state = sim.run(qobj).result().get_statevector() # Execute the circuit
print(state)           # Print the result

Statevector([0.70710678+0.j        , 0.        +0.70710678j],
            dims=(2,))
</code></pre>
<p>我们可以看到我们有相等的概率测量 |0⟩ 或者 |1 个 ⟩。为了解释这一点，我们需要谈谈测量。</p>
<h3 id="测量规则"><a class="header" href="#测量规则">测量规则</a></h3>
<h4 id="一个非常重要的规则"><a class="header" href="#一个非常重要的规则">一个非常重要的规则</a></h4>
<p>有一个简单的测量规则。找出测量状态的概率 |ψ⟩ 在该州 |x⟩ 我们的确是：</p>
<p>$$
p(|x\rangle) = | \langle x| \psi \rangle|^2
$$</p>
<p>符号 ⟨ 和 | 告诉我们 ⟨X| 是一个行向量和符号 | 和 ⟩ 告诉我们 |ψ⟩ 是列向量。在量子力学中，我们称列向量为kets，行向量为bra。它们一起构成了小括号表示法。任何凯特 |A⟩ 有对应的bra ⟨A|，我们使用共轭转置在它们之间进行转换。</p>
<ul>
<li>提醒：共轭转置（单击此处展开）
bra-ket 之间的转换使用共轭转置方法进行。我们知道一个ket（列向量）表示如下：</li>
</ul>
<p>$$
\quad|a\rangle = \begin{bmatrix}a_0 \ a_1 \ \vdots \ a_n \end{bmatrix}
$$</p>
<p>在共轭转置法中，矩阵被转置并且元素是复共轭的（由 &quot;∗&quot; 运算）其中复共轭（&quot;∗&quot;）的复数是实部和虚部大小相等但符号相反的数。这给出了对应的胸罩（行向量）如下：</p>
<p>$$
\langle a| = \begin{bmatrix}a_0^<em>, &amp; a_1^</em>, &amp; \dots &amp; a_n^* \end{bmatrix}
$$</p>
<ul>
<li>提醒：内积（点击此处展开）
向量相乘有不同的方法，这里我们使用内积。内积是您可能已经熟悉的点积的推广。在本指南中，我们使用 bra（行向量）和 ket（列向量）之间的内积，它遵循以下规则：</li>
</ul>
<p>$$
\langle a| = \begin{bmatrix}a_0^<em>, &amp; a_1^</em>, &amp; \dots &amp; a_n^* \end{bmatrix}, \quad
|b\rangle = \begin{bmatrix}b_0 \ b_1 \ \vdots \ b_n \end{bmatrix}
\langle a|b\rangle = a_0^* b_0 + a_1^* b_1 \dots a_n^* b_n
$$ </p>
<p>我们可以看到两个向量的内积总是给我们一个标量。要记住的一件有用的事情是两个正交向量的内积是 0，例如，如果我们有正交向量 |0⟩ 和 |1个 ⟩：</p>
<p>$$
\langle1|0\rangle = \begin{bmatrix} 0 &amp; 1\end{bmatrix}\begin{bmatrix}1 \ 0\end{bmatrix} = 0
$$</p>
<p>此外，请记住向量 |0⟩ 和 |1个 ⟩ 也归一化（量级等于 1）：</p>
<p>$$
\begin{aligned} 
\langle0|0\rangle &amp; = \begin{bmatrix} 1 &amp; 0\end{bmatrix}\begin{bmatrix}1 \ 0\end{bmatrix} = 1 \
\langle1|1\rangle &amp; = \begin{bmatrix} 0 &amp; 1\end{bmatrix}\begin{bmatrix}0 \ 1\end{bmatrix} = 1
\end{aligned}
$$</p>
<p>在上面的等式中，|X⟩ 可以是任何量子比特状态。找到测量的概率 |x⟩，我们取内积 |x⟩ 以及我们正在测量的状态（在这种情况下 |ψ⟩），然后平方幅度。这可能看起来有点令人费解，但很快就会成为第二天性。</p>
<p>如果我们看状态 |q<sub>0</sub>⟩ 从之前，我们可以看到测量的概率 |0⟩ 确实是 0.5：
$$
\begin{aligned}
|q_0\rangle &amp; = \tfrac{1}{\sqrt{2}}|0\rangle + \tfrac{i}{\sqrt{2}}|1\rangle \
\langle 0| q_0 \rangle  &amp; = \tfrac{1}{\sqrt{2}}\langle 0|0\rangle + \tfrac{i}{\sqrt{2}}\langle 0|1\rangle \
&amp; = \tfrac{1}{\sqrt{2}}\cdot 1 +  \tfrac{i}{\sqrt{2}} \cdot 0\
&amp; = \tfrac{1}{\sqrt{2}}\
|\langle 0| q_0 \rangle|^2 &amp; = \tfrac{1}{2}
\end{aligned}
$$</p>
<p>你应该验证测量的概率 |1个 ⟩ 作为练习。</p>
<p>这条规则支配着我们如何从量子态中获取信息。因此，它对我们在量子计算中所做的一切都非常重要。它还立即暗示了几个重要的事实。</p>
<h4 id="本规则的含义"><a class="header" href="#本规则的含义">本规则的含义</a></h4>
<h5 id="1-归一化"><a class="header" href="#1-归一化">#1 归一化</a></h5>
<p>该规则向我们表明振幅与概率有关。如果我们希望概率加起来为 1（它们应该！），我们需要确保状态向量被正确归一化。具体来说，我们需要状态向量的大小为 1。</p>
<p>$$
\langle\psi|\psi\rangle = 1 \
$$</p>
<p>因此，如果：</p>
<p>$$
|\psi\rangle = \alpha|0\rangle + \beta|1\rangle
$$</p>
<p>然后：</p>
<p>$$
|\alpha|^2 + |\beta|^2 = 1
$$</p>
<p>这解释了以下因素 <math xmlns="http://www.w3.org/1998/Math/MathML"><msqrt><mn>2</mn></msqrt></math> 个你已经在本章中看到了。事实上，如果我们试图给出initialize()一个未归一化的向量，它会给我们一个错误：</p>
<pre><code>vector = [1,1]
qc.initialize(vector, 0)


---------------------------------------------------------------------------
QiskitError                               Traceback (most recent call last)
Input In [12], in &lt;cell line: 2&gt;()
      1 vector = [1,1]
----&gt; 2 qc.initialize(vector, 0)

File /usr/local/lib/python3.8/site-packages/qiskit/extensions/quantum_initializer/initializer.py:191, in initialize(self, params, qubits)
    188     qubits = [qubits]
    189 num_qubits = len(qubits) if isinstance(params, int) else None
--&gt; 191 return self.append(Initialize(params, num_qubits), qubits)

File /usr/local/lib/python3.8/site-packages/qiskit/extensions/quantum_initializer/initializer.py:57, in Initialize.__init__(self, params, num_qubits)
     36 def __init__(self, params, num_qubits=None):
     37     r&quot;&quot;&quot;Create new initialize composite.
     38 
     39     Args:
   (...)
     55             and the remaining 3 qubits to be initialized to :math:`|0\rangle`.
     56     &quot;&quot;&quot;
---&gt; 57     self._stateprep = StatePreparation(params, num_qubits)
     59     super().__init__(&quot;initialize&quot;, self._stateprep.num_qubits, 0, self._stateprep.params)

File /usr/local/lib/python3.8/site-packages/qiskit/circuit/library/data_preparation/state_preparation.py:99, in StatePreparation.__init__(self, params, num_qubits, inverse, label)
     96 self._from_label = isinstance(params, str)
     97 self._from_int = isinstance(params, int)
---&gt; 99 num_qubits = self._get_num_qubits(num_qubits, params)
    101 params = [params] if isinstance(params, int) else params
    103 super().__init__(self._name, num_qubits, params, label=self._label)

File /usr/local/lib/python3.8/site-packages/qiskit/circuit/library/data_preparation/state_preparation.py:202, in StatePreparation._get_num_qubits(self, num_qubits, params)
    200     # Check if probabilities (amplitudes squared) sum to 1
    201     if not math.isclose(sum(np.absolute(params) ** 2), 1.0, abs_tol=_EPS):
--&gt; 202         raise QiskitError(&quot;Sum of amplitudes-squared does not equal one.&quot;)
    204     num_qubits = int(num_qubits)
    205 return num_qubits

QiskitError: 'Sum of amplitudes-squared does not equal one.'
</code></pre>
<p><b>快速练习</b> 
1.创建一个状态向量，它将给出 1个/3个测量概率 |0⟩。
2.创建将提供相同测量概率的不同状态向量。
3.验证测量的概率 |1个 ⟩ 对于这两个状态是 2个/3个。
您可以在下面的小部件中检查您的答案（接受答案 ±1% 的准确度，您可以在向量中使用 numpy 术语，例如在向量中的 'pi' 和 'sqrt()'）</p>
<pre><code># Run the code in this cell to interact with the widget
from qiskit_textbook.widgets import state_vector_exercise
state_vector_exercise(target=1/3)
</code></pre>
<h5 id="2-替代测量"><a class="header" href="#2-替代测量">#2 替代测量</a></h5>
<p>测量规则给了我们概率 p(|x⟩) 那个状态 |ψ⟩ 被测量为 |x⟩。它没有告诉我们 |x⟩ 只能是 |0⟩ 或者 |1个 ⟩。</p>
<p>到目前为止，我们考虑的测量实际上只是测量量子位的无数种可能方法中的一种。对于任何正交状态对，我们可以定义一个测量值，使量子位在两者之间进行选择。</p>
<p>下一节将进一步探讨这种可能性。现在，请记住 |x⟩ 不仅限于简单 |0⟩ 或者 |1个 ⟩。</p>
<h5 id="3-全球阶段"><a class="header" href="#3-全球阶段">#3 全球阶段</a></h5>
<p>我们知道测量状态 |1个 ⟩ 1会给我们确定的输出。但是我们也可以写下这样的状态
$$
\begin{bmatrix}0 \ i\end{bmatrix} = i|1\rangle.
$$</p>
<p>要查看其行为方式，我们应用测量规则。</p>
<p>$$
|\langle x| (i|1\rangle) |^2 = | i \langle x|1\rangle|^2 = |\langle x|1\rangle|^2
$$</p>
<p>在这里我们发现因素 i 一旦我们取复数的大小，它就会消失。这种影响完全独立于测量状态 |x⟩。我们正在考虑的衡量标准无关紧要，状态的概率 i|1个⟩ 与那些相同 |1个⟩。由于测量是我们从量子比特中提取任何信息的唯一方式，这意味着这两种状态在物理相关的所有方面都是等价的。</p>
<p>更一般地说，我们指的是任何整体因素 γ 在一个状态下 |γ| =1 个作为“全球阶段”。仅在全局阶段不同的状态在物理上是无法区分的。</p>
<p>$$
|\langle x| ( \gamma |a\rangle) |^2 = | \gamma \langle x|a\rangle|^2 = |\langle x|a\rangle|^2
$$</p>
<p>请注意，这与叠加中项之间的相位差不同，后者被称为“相对相位”。一旦我们考虑不同类型的测量和多个量子位，这就变得相关了。</p>
<h5 id="4-观察者效应"><a class="header" href="#4-观察者效应">#4 观察者效应</a></h5>
<p>我们知道振幅包含有关我们找到处于特定状态的量子位的概率的信息，但是一旦我们测量了量子位，我们就可以确定地知道量子位的状态。例如，如果我们测量状态下的量子比特：</p>
<p>$$
|q\rangle = \alpha|0\rangle + \beta|1\rangle
$$</p>
<p>并在状态内找到它 |0⟩，如果我们再次测量，有 100% 的机会找到状态中的量子比特 |0⟩。这意味着测量行为会改变我们量子比特的状态。</p>
<p>$$
|q\rangle = \begin{bmatrix} \alpha \ \beta \end{bmatrix} \xrightarrow{\text{Measure }|0\rangle} |q\rangle = |0\rangle = \begin{bmatrix} 1 \ 0 \end{bmatrix}
$$</p>
<p>我们有时将此称为折叠量子比特的状态。这是一种强大的效果，因此必须明智地使用它。例如，如果我们不断地测量我们的每个量子比特以跟踪它们在计算中每个点的值，它们将总是简单地处于一个明确定义的状态 |0⟩ 或者 |1个⟩。因此，它们与经典位没有什么不同，我们的计算可以很容易地被经典计​​算所取代。为了实现真正的量子计算，我们必须允许量子比特探索更复杂的状态。因此，仅当我们需要提取输出时才使用测量。这意味着我们经常将所有测量放在量子电路的末端。</p>
<p>我们可以使用 Qiskit 的状态向量模拟器来演示这一点。让我们在叠加中初始化一个量子位：</p>
<pre><code>qc = QuantumCircuit(1) # We are redefining qc
initial_state = [0.+1.j/sqrt(2),1/sqrt(2)+0.j]
qc.initialize(initial_state, 0)
qc.draw()
</code></pre>
<p>这应该在状态中初始化我们的量子位：</p>
<pre><code>|q\rangle = \tfrac{i}{\sqrt{2}}|0\rangle + \tfrac{1}{\sqrt{2}}|1\rangle
</code></pre>
<p>我们可以使用模拟器验证这一点：</p>
<pre><code>qc.save_statevector()
result = sim.run(assemble(qc)).result()
state = result.get_statevector()
print(&quot;Qubit State = &quot; + str(state))

Qubit State = Statevector([0.        +0.70710678j, 0.70710678+0.j        ],
            dims=(2,))
</code></pre>
<p>我们可以在这里看到 qubit 在 state 中初始化[0.+0.70710678j 0.70710678+0.j]，这是我们期望的状态。</p>
<p>现在让我们创建一个电路来测量这个量子位：</p>
<pre><code>qc = QuantumCircuit(1) # We are redefining qc
initial_state = [0.+1.j/sqrt(2),1/sqrt(2)+0.j]
qc.initialize(initial_state, 0)
qc.measure_all()
qc.save_statevector()
qc.draw()
</code></pre>
<p>当我们模拟整个电路时，我们可以看到其中一个振幅始终为0：</p>
<pre><code>qobj = assemble(qc)
state = sim.run(qobj).result().get_statevector()
print(&quot;State of Measured Qubit = &quot; + str(state))

State of Measured Qubit = Statevector([0.+1.j, 0.+0.j],
            dims=(2,))
</code></pre>
<p>您可以重新运行此单元几次以重新初始化量子位并再次测量它。你会注意到这两种结果的可能性是相等的，但是量子比特的状态永远不是 
|0⟩ 和 |1个⟩。有点有趣的是，国家的全球阶段 |0⟩ 幸存下来，但由于这是全球阶段，我们永远无法在真正的量子计算机上测量它。</p>
<h4 id="关于量子模拟器的注释"><a class="header" href="#关于量子模拟器的注释">关于量子模拟器的注释</a></h4>
<p>我们可以看到，写下一个量子位的状态需要跟踪两个复数，但在使用真正的量子计算机时，我们只会收到每个量子位的是或否（或）答案0。110 量子位量子计算机的输出将如下所示：</p>
<p>0110111110</p>
<p>仅 10 位，无叠加或复振幅。当使用真正的量子计算机时，我们无法看到我们的量子比特在计算过程中的状态，因为这会破坏它们！这种行为对于学习来说并不理想，因此 Qiskit 提供了不同的量子模拟器：默认情况下，模拟aer_simulator真实量子计算机的执行，但如果我们在电路中包含某些指令，也可以让您在测量前窥视量子状态。例如，这里我们包含了指令.save_statevector()，这意味着我们可以使用.get_statevector()模拟的结果。</p>
<h3 id="布洛赫球体"><a class="header" href="#布洛赫球体">布洛赫球体</a></h3>
<h4 id="描述受限量子比特态"><a class="header" href="#描述受限量子比特态">描述受限量子比特态</a></h4>
<p>我们在本章前面看到了量子位的一般状态（|q⟩）是：</p>
<p>$$
|q\rangle = \alpha|0\rangle + \beta|1\rangle
$$</p>
<p>（第二行告诉我们 α 和 β 是复数）。第 2 节中的前两个含义告诉我们，我们无法区分其中一些状态。这意味着我们可以更具体地描述量子位。</p>
<p>首先，由于我们无法测量全局相位，我们只能测量状态之间的相位差 |0⟩ 和 |1个⟩。而不是拥有 α 和 β 复杂，我们可以将它们限制为实数并添加一个项来告诉我们它们之间的相对相位：</p>
<p>$$
|q\rangle = \alpha|0\rangle + e^{i\phi}\beta|1\rangle
\alpha, \beta, \phi \in \mathbb{R}
$$</p>
<p>最后，由于量子位状态必须归一化，即</p>
<p>$$
\sqrt{\alpha^2 + \beta^2} = 1
$$</p>
<p>我们可以使用三角恒等式：</p>
<p>$$
\sqrt{\sin^2{x} + \cos^2{x}} = 1
$$</p>
<p>来描述真实的 α 和 β 就一个变量而言，θ：</p>
<p>$$
\alpha = \cos{\tfrac{\theta}{2}}, \quad \beta=\sin{\tfrac{\theta}{2}}
$$</p>
<p>由此我们可以使用两个变量来描述任何量子比特的状态 φ 和 θ：</p>
<p>$$
|q\rangle = \cos{\tfrac{\theta}{2}}|0\rangle + e^{i\phi}\sin{\tfrac{\theta}{2}}|1\rangle
\theta, \phi \in \mathbb{R}
$$</p>
<h4 id="32-可视化表示量子比特状态"><a class="header" href="#32-可视化表示量子比特状态">3.2 可视化表示量子比特状态</a></h4>
<p>我们想绘制我们的一般量子位状态：</p>
<p>$$
|q\rangle = \cos{\tfrac{\theta}{2}}|0\rangle + e^{i\phi}\sin{\tfrac{\theta}{2}}|1\rangle
$$</p>
<p>如果我们解释 θ 和 φ 作为球面坐标（r = 1个，因为量子比特状态的大小是 1个），我们可以在球体表面绘制任何单个量子比特状态，称为<em>Bloch</em>球体。</p>
<p>下面我们绘制了一个处于状态的量子比特 |+⟩。在这种情况下，θ=π/2 个和 φ = 0。</p>
<p>Qiskit 具有绘制 Bloch 球体的功能，plot_bloch_vector()。该函数默认接受笛卡尔坐标，但也可以通过传递参数接受球坐标coord_type='spherical'。</p>
<p>您也可以尝试这个<a href="https://javafxpert.github.io/grok-bloch/">交互式 Bloch 球体演示</a>。</p>
<pre><code>from qiskit.visualization import plot_bloch_vector
coords = [1,pi/2,0]  # [Radius, Theta, Phi]
plot_bloch_vector(coords, coord_type='spherical')
</code></pre>
<p><b>警告！</b> 
第一次了解量子位状态时，很容易混淆 qubits statevector和它的Bloch vector。请记住，<a href="https://qiskit.org/textbook/ch-states/representing-qubit-states.html#notation">状态向量是1.1</a>中讨论的向量，它保存我们的量子位可能处于的两个状态的振幅。布洛赫向量是一种可视化工具，可将 2D 复数状态向量映射到真实的 3D 空间。</p>
<p><b>快速练习</b> 
用于plot_bloch_vector()绘制状态中的量子位：</p>
<p>$$
1.|0\rangle
2.|1\rangle
3.\tfrac{1}{\sqrt{2}}(|0\rangle + |1\rangle)
4.\tfrac{1}{\sqrt{2}}(|0\rangle - i|1\rangle)
5.\tfrac{1}{\sqrt{2}}\begin{bmatrix}i\1\end{bmatrix}
$$</p>
<pre><code>import qiskit.tools.jupyter
%qiskit_version_table
</code></pre>
<ul>
<li>版本信息</li>
</ul>
<table><tr><th>Qiskit Software</th><th>Version</th></tr><tr><td><code>qiskit-terra</code></td><td>0.22.0</td></tr><tr><td><code>qiskit-aer</code></td><td>0.11.0</td></tr><tr><td><code>qiskit-ibmq-provider</code></td><td>0.19.2</td></tr><tr><td><code>qiskit</code></td><td>0.39.0</td></tr><tr><td><code>qiskit-nature</code></td><td>0.4.1</td></tr><tr><td><code>qiskit-finance</code></td><td>0.3.2</td></tr><tr><td><code>qiskit-optimization</code></td><td>0.4.0</td></tr><tr><td><code>qiskit-machine-learning</code></td><td>0.4.0</td></tr><tr><th>System information</th></tr><tr><td>Python version</td><td>3.8.13</td></tr><tr><td>Python compiler</td><td>Clang 13.1.6 (clang-1316.0.21.2.5)</td></tr><tr><td>Python build</td><td>default, Aug 29 2022 05:17:23</td></tr><tr><td>OS</td><td>Darwin</td></tr><tr><td>CPUs</td><td>8</td></tr><tr><td>Memory (Gb)</td><td>32.0</td></tr><tr><td colspan='2'>Mon Nov 28 09:32:47 2022 GMT</td></tr></table>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../quantum/chapter_1.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../quantum/chapter_1_2.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../quantum/chapter_1.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../quantum/chapter_1_2.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>


        <!-- Google Analytics Tag -->
        <script type="text/javascript">
            var localAddrs = ["localhost", "127.0.0.1", ""];

            // make sure we don't activate google analytics if the developer is
            // inspecting the book locally...
            if (localAddrs.indexOf(document.location.hostname) === -1) {
                (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
                m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
                })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

                ga('create', 'G-ZHWPPT6ESV', 'auto');
                ga('send', 'pageview');
            }
        </script>


        <script type="text/javascript">
            window.playground_copyable = true;
        </script>

        <script src="../ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="../editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="../theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="../theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>

        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
