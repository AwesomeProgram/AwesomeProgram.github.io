<!DOCTYPE HTML>
<html lang="zh-CN" class="sidebar-visible no-js navy">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>信息技术 | AwesomeProgram</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="所思即所见，所见即所得，所得皆所想，技术从未停歇，也未曾缺乏">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "navy";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('navy')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="PrefixChapter.html">前言</a></li><li class="chapter-item expanded "><a href="rust/chapter_1.html"><strong aria-hidden="true">1.</strong> Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="rust/chapter_1_1.html"><strong aria-hidden="true">1.1.</strong> Rust 语法结构</a></li><li class="chapter-item expanded "><a href="rust/chapter_1_4.html"><strong aria-hidden="true">1.2.</strong> Rust 标准库</a></li><li class="chapter-item expanded "><a href="rust/chapter_1_5.html"><strong aria-hidden="true">1.3.</strong> Rust 工具链</a></li><li class="chapter-item expanded "><a href="rust/chapter_1_6.html"><strong aria-hidden="true">1.4.</strong> Rust 类型操作</a></li><li class="chapter-item expanded "><a href="rust/chapter_1_7.html"><strong aria-hidden="true">1.5.</strong> Rust 编码范式</a></li></ol></li><li class="chapter-item expanded "><a href="go/chapter_1.html"><strong aria-hidden="true">2.</strong> Go</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="go/chapter_1_1.html"><strong aria-hidden="true">2.1.</strong> Go 语法结构</a></li><li class="chapter-item expanded "><a href="go/chapter_1_2.html"><strong aria-hidden="true">2.2.</strong> Go 标准库</a></li></ol></li><li class="chapter-item expanded "><a href="chapter_3.html"><strong aria-hidden="true">3.</strong> 各语言对比</a></li><li class="chapter-item expanded "><a href="blockchain/chapter_1.html"><strong aria-hidden="true">4.</strong> 区块链</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="blockchain/chapter_1_1.html"><strong aria-hidden="true">4.1.</strong> 区块链简史</a></li><li class="chapter-item expanded "><a href="blockchain/chapter_1_2.html"><strong aria-hidden="true">4.2.</strong> 区块链框架</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="blockchain/chapter_1_2_1.html"><strong aria-hidden="true">4.2.1.</strong> substrate</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="blockchain/chapter_1_2_1_1.html"><strong aria-hidden="true">4.2.1.1.</strong> 基本原理</a></li><li class="chapter-item expanded "><a href="blockchain/chapter_1_2_1_2.html"><strong aria-hidden="true">4.2.1.2.</strong> 构建与编码</a></li><li class="chapter-item expanded "><a href="blockchain/chapter_1_2_1_3.html"><strong aria-hidden="true">4.2.1.3.</strong> 启动区块链网络</a></li><li class="chapter-item expanded "><a href="blockchain/chapter_1_2_1_4.html"><strong aria-hidden="true">4.2.1.4.</strong> 自定义pallet</a></li><li class="chapter-item expanded "><a href="blockchain/chapter_1_2_1_5.html"><strong aria-hidden="true">4.2.1.5.</strong> 开发智能合约</a></li><li class="chapter-item expanded "><a href="blockchain/chapter_1_2_1_6.html"><strong aria-hidden="true">4.2.1.6.</strong> 桥接其它链</a></li><li class="chapter-item expanded "><a href="blockchain/chapter_1_2_1_7.html"><strong aria-hidden="true">4.2.1.7.</strong> 工具集成</a></li><li class="chapter-item expanded "><a href="blockchain/chapter_1_2_1_8.html"><strong aria-hidden="true">4.2.1.8.</strong> 测试</a></li></ol></li><li class="chapter-item expanded "><a href="blockchain/chapter_1_2_2.html"><strong aria-hidden="true">4.2.2.</strong> fabric</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="blockchain/chapter_1_2_2_1.html"><strong aria-hidden="true">4.2.2.1.</strong> 基本原理</a></li><li class="chapter-item expanded "><a href="blockchain/chapter_1_2_2_2.html"><strong aria-hidden="true">4.2.2.2.</strong> 构建与开发</a></li></ol></li><li class="chapter-item expanded "><a href="blockchain/chapter_1_2_3.html"><strong aria-hidden="true">4.2.3.</strong> EOSIO</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="blockchain/chapter_1_2_3_1.html"><strong aria-hidden="true">4.2.3.1.</strong> 基本原理</a></li><li class="chapter-item expanded "><a href="blockchain/chapter_1_2_3_2.html"><strong aria-hidden="true">4.2.3.2.</strong> 构建与开发</a></li></ol></li><li class="chapter-item expanded "><a href="blockchain/chapter_1_3.html"><strong aria-hidden="true">4.2.4.</strong> 智能合约与DApp</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="blockchain/chapter_1_3_1.html"><strong aria-hidden="true">4.2.4.1.</strong> Move</a></li><li class="chapter-item expanded "><a href="blockchain/chapter_1_3_2.html"><strong aria-hidden="true">4.2.4.2.</strong> Solidity</a></li><li class="chapter-item expanded "><a href="blockchain/chapter_1_3_3.html"><strong aria-hidden="true">4.2.4.3.</strong> Hardhat</a></li></ol></li></ol></li></ol></li><li class="chapter-item expanded "><a href="cloud/chapter_1.html"><strong aria-hidden="true">5.</strong> 云计算</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="cloud/chapter_1_1.html"><strong aria-hidden="true">5.1.</strong> 云计算简史</a></li><li class="chapter-item expanded "><a href="cloud/chapter_1_2.html"><strong aria-hidden="true">5.2.</strong> 资源编排框架</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="cloud/chapter_1_2_1.html"><strong aria-hidden="true">5.2.1.</strong> kubernetes</a></li><li class="chapter-item expanded "><a href="cloud/chapter_1_2_2.html"><strong aria-hidden="true">5.2.2.</strong> openstack</a></li></ol></li><li class="chapter-item expanded "><a href="cloud/chapter_1_3.html"><strong aria-hidden="true">5.3.</strong> 虚拟化</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="cloud/chapter_1_3_1.html"><strong aria-hidden="true">5.3.1.</strong> 计算</a></li><li class="chapter-item expanded "><a href="cloud/chapter_1_3_2.html"><strong aria-hidden="true">5.3.2.</strong> 网络</a></li><li class="chapter-item expanded "><a href="cloud/chapter_1_3_3.html"><strong aria-hidden="true">5.3.3.</strong> 存储</a></li></ol></li><li class="chapter-item expanded "><a href="cloud/chapter_1_4.html"><strong aria-hidden="true">5.4.</strong> 容器</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="cloud/chapter_1_4_1.html"><strong aria-hidden="true">5.4.1.</strong> docker</a></li><li class="chapter-item expanded "><a href="cloud/chapter_1_4_2.html"><strong aria-hidden="true">5.4.2.</strong> containerd</a></li><li class="chapter-item expanded "><a href="cloud/chapter_1_4_3.html"><strong aria-hidden="true">5.4.3.</strong> podman</a></li></ol></li><li class="chapter-item expanded "><a href="cloud/chapter_1_5.html"><strong aria-hidden="true">5.5.</strong> 高级语言虚拟机</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="cloud/chapter_1_5_1.html"><strong aria-hidden="true">5.5.1.</strong> wasm</a></li><li class="chapter-item expanded "><a href="cloud/chapter_1_5_2.html"><strong aria-hidden="true">5.5.2.</strong> jvm</a></li><li class="chapter-item expanded "><a href="cloud/chapter_1_5_3.html"><strong aria-hidden="true">5.5.3.</strong> evm</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="privacy/chapter_1.html"><strong aria-hidden="true">6.</strong> 隐私计算</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="privacy/chapter_1_1.html"><strong aria-hidden="true">6.1.</strong> 密码学相关</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="privacy/chapter_1_1_1.html"><strong aria-hidden="true">6.1.1.</strong> 零知识证明</a></li><li class="chapter-item expanded "><a href="privacy/chapter_1_1_2.html"><strong aria-hidden="true">6.1.2.</strong> MPC</a></li><li class="chapter-item expanded "><a href="privacy/chapter_1_1_3.html"><strong aria-hidden="true">6.1.3.</strong> 差分隐私</a></li><li class="chapter-item expanded "><a href="privacy/chapter_1_1_4.html"><strong aria-hidden="true">6.1.4.</strong> 秘密共享</a></li><li class="chapter-item expanded "><a href="privacy/chapter_1_1_5.html"><strong aria-hidden="true">6.1.5.</strong> 同态加密</a></li></ol></li><li class="chapter-item expanded "><a href="privacy/chapter_1_2.html"><strong aria-hidden="true">6.2.</strong> 可信执行环境</a></li><li class="chapter-item expanded "><a href="privacy/chapter_1_3.html"><strong aria-hidden="true">6.3.</strong> 联邦学习</a></li></ol></li><li class="chapter-item expanded "><a href="quantum/chapter_1.html"><strong aria-hidden="true">7.</strong> 量子计算</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="quantum/chapter_1_1.html"><strong aria-hidden="true">7.1.</strong> 量子状态与量子比特</a></li><li class="chapter-item expanded "><a href="quantum/chapter_1_2.html"><strong aria-hidden="true">7.2.</strong> 多量子比特与量子纠缠</a></li><li class="chapter-item expanded "><a href="quantum/chapter_1_3.html"><strong aria-hidden="true">7.3.</strong> 量子协议和量子算法</a></li><li class="chapter-item expanded "><a href="quantum/chapter_1_4.html"><strong aria-hidden="true">7.4.</strong> 量子算法的应用</a></li><li class="chapter-item expanded "><a href="quantum/chapter_1_5.html"><strong aria-hidden="true">7.5.</strong> 使用量子电路研究量子硬件</a></li><li class="chapter-item expanded "><a href="quantum/chapter_1_6.html"><strong aria-hidden="true">7.6.</strong> 使用微波脉冲研究量子硬件</a></li><li class="chapter-item expanded "><a href="quantum/chapter_1_7.html"><strong aria-hidden="true">7.7.</strong> 量子计算实验室</a></li><li class="chapter-item expanded "><a href="quantum/chapter_1_8.html"><strong aria-hidden="true">7.8.</strong> 量子计算游戏和演示</a></li><li class="chapter-item expanded "><a href="quantum/chapter_1_9.html"><strong aria-hidden="true">7.9.</strong> 量子计算应用开发</a></li></ol></li><li class="chapter-item expanded "><a href="chapter_8.html"><strong aria-hidden="true">8.</strong> 软考记录</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">信息技术 | AwesomeProgram</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="前言"><a class="header" href="#前言">前言</a></h1>
<h3 id="所思即所见所见即所得所得皆所想技术从未停歇也未曾缺乏"><a class="header" href="#所思即所见所见即所得所得皆所想技术从未停歇也未曾缺乏"><font face="华文行楷">所思即所见，所见即所得，所得皆所想，技术从未停歇，也未曾缺乏。</font></a></h3>
<h1 id="目录"><a class="header" href="#目录">目录</a></h1>
<h2 id="编程语言"><a class="header" href="#编程语言">编程语言</a></h2>
<ul>
<li><a href="./rust/chapter_1.html">Rust</a>
<ul>
<li><a href="./rust/chapter_1_1.html">Rust 语法结构</a></li>
</ul>
<!-- - [Rust 潜在设计](./rust/chapter_1_2.md)
- [Rust 内存布局](./rust/chapter_1_3.md) -->
<ul>
<li><a href="./rust/chapter_1_4.html">Rust 标准库</a></li>
<li><a href="./rust/chapter_1_5.html">Rust 工具链</a></li>
<li><a href="./rust/chapter_1_6.html">Rust 类型操作</a></li>
<li><a href="./rust/chapter_1_7.html">Rust 编码范式</a></li>
</ul>
</li>
<li><a href="./go/chapter_1.html">Go</a>
<ul>
<li><a href="./go/chapter_1_1.html">Go 语法结构</a></li>
<li><a href="./go/chapter_1_2.html">Go 标准库</a></li>
</ul>
</li>
<li><a href="./chapter_3.html">各语言对比</a></li>
</ul>
<h2 id="技术领域"><a class="header" href="#技术领域">技术领域</a></h2>
<ul>
<li><a href="./blockchain/chapter_1.html">区块链</a>
<ul>
<li><a href="./blockchain/chapter_1_1.html">区块链简史</a></li>
<li><a href="./blockchain/chapter_1_2.html">区块链框架</a>
<ul>
<li><a href="./blockchain/chapter_1_2_1.html">substrate</a>
<ul>
<li><a href="./blockchain/chapter_1_2_1_1.html">基本原理</a></li>
<li><a href="./blockchain/chapter_1_2_1_2.html">构建与编码</a></li>
<li><a href="./blockchain/chapter_1_2_1_3.html">启动区块链网络</a></li>
<li><a href="./blockchain/chapter_1_2_1_4.html">自定义pallet</a></li>
<li><a href="./blockchain/chapter_1_2_1_5.html">开发智能合约</a></li>
<li><a href="./blockchain/chapter_1_2_1_6.html">桥接其它链</a></li>
<li><a href="./blockchain/chapter_1_2_1_7.html">工具集成</a></li>
<li><a href="./blockchain/chapter_1_2_1_8.html">测试</a></li>
</ul>
</li>
<li><a href="./blockchain/chapter_1_2_2.html">fabric</a>
<ul>
<li><a href="./blockchain/chapter_1_2_2_1.html">基本原理</a></li>
<li><a href="./blockchain/chapter_1_2_2_2.html">构建与开发</a></li>
</ul>
</li>
<li><a href="./blockchain/chapter_1_2_3.html">EOSIO</a>
<ul>
<li><a href="./blockchain/chapter_1_2_3_1.html">基本原理</a></li>
<li><a href="./blockchain/chapter_1_2_3_2.html">构建与开发</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="./blockchain/chapter_1_3.html">智能合约与DApp</a>
<ul>
<li><a href="./blockchain/chapter_1_3_1.html">Move</a></li>
<li><a href="./blockchain/chapter_1_3_2.html">Solidity</a> </li>
<li><a href="./blockchain/chapter_1_3_3.html">Hardhat</a> </li>
</ul>
</li>
</ul>
</li>
<li><a href="./cloud/chapter_1.html">云计算</a>
<ul>
<li><a href="./cloud/chapter_1_1.html">云计算简史</a></li>
<li><a href="./cloud/chapter_1_2.html">资源编排框架</a>
<ul>
<li><a href="./cloud/chapter_1_2_1.html">kubernetes</a></li>
<li><a href="./cloud/chapter_1_2_2.html">openstack</a></li>
</ul>
</li>
<li><a href="./cloud/chapter_1_3.html">虚拟化</a>
<ul>
<li><a href="./cloud/chapter_1_3_1.html">计算</a></li>
<li><a href="./cloud/chapter_1_3_2.html">网络</a></li>
<li><a href="./cloud/chapter_1_3_3.html">存储</a></li>
</ul>
</li>
<li><a href="./cloud/chapter_1_4.html">容器</a> 
<ul>
<li><a href="./cloud/chapter_1_4_1.html">docker</a> </li>
<li><a href="./cloud/chapter_1_4_2.html">containerd</a> </li>
<li><a href="./cloud/chapter_1_4_3.html">podman</a> </li>
</ul>
</li>
<li><a href="./cloud/chapter_1_5.html">高级语言虚拟机</a> 
<ul>
<li><a href="./cloud/chapter_1_5_1.html">wasm</a> </li>
<li><a href="./cloud/chapter_1_5_2.html">jvm</a> </li>
<li><a href="./cloud/chapter_1_5_3.html">evm</a> </li>
</ul>
</li>
</ul>
</li>
<li><a href="./privacy/chapter_1.html">隐私计算</a>
<ul>
<li><a href="./privacy/chapter_1_1.html">密码学相关</a>
<ul>
<li><a href="./privacy/chapter_1_1_1.html">零知识证明</a></li>
<li><a href="./privacy/chapter_1_1_2.html">MPC</a></li>
<li><a href="./privacy/chapter_1_1_3.html">差分隐私</a></li>
<li><a href="./privacy/chapter_1_1_4.html">秘密共享</a></li>
<li><a href="./privacy/chapter_1_1_5.html">同态加密</a></li>
</ul>
</li>
<li><a href="./privacy/chapter_1_2.html">可信执行环境</a></li>
<li><a href="./privacy/chapter_1_3.html">联邦学习</a></li>
</ul>
</li>
<li><a href="./quantum/chapter_1.html">量子计算</a>
<ul>
<li><a href="./quantum/chapter_1_1.html">量子状态与量子比特</a></li>
<li><a href="./quantum/chapter_1_2.html">多量子比特与量子纠缠</a></li>
<li><a href="./quantum/chapter_1_3.html">量子协议和量子算法</a></li>
<li><a href="./quantum/chapter_1_4.html">量子算法的应用</a></li>
<li><a href="./quantum/chapter_1_5.html">使用量子电路研究量子硬件</a></li>
<li><a href="./quantum/chapter_1_6.html">使用微波脉冲研究量子硬件</a></li>
<li><a href="./quantum/chapter_1_7.html">量子计算实验室</a></li>
<li><a href="./quantum/chapter_1_8.html">量子计算游戏和演示</a></li>
<li><a href="./quantum/chapter_1_9.html">量子计算应用开发</a></li>
</ul>
</li>
</ul>
<h2 id="其它"><a class="header" href="#其它">其它</a></h2>
<ul>
<li><a href="./chapter_8.html">软考记录</a> </li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-翻译于官网描述"><a class="header" href="#rust-翻译于官网描述">Rust 翻译于官网描述</a></h1>
<h4 id="一门赋予每个人构建可靠且高效软件能力的语言"><a class="header" href="#一门赋予每个人构建可靠且高效软件能力的语言">一门赋予每个人构建可靠且高效软件能力的语言。</a></h4>
<h2 id="语言优势"><a class="header" href="#语言优势">语言优势</a></h2>
<ul>
<li>编译的代码具有与 C/C++ 相同的性能，并且具有出色的内存和能效。</li>
<li>可以避免 C/C++ 中70%的安全问题和大多数内存问题。</li>
<li>强大的类型系统可以防止数据竞争，带来“无畏的并发性”（等等）。</li>
<li>无缝与 C 进行互操作，以及数十种受支持的平台（基于 LLVM）。</li>
<li>连续四年被评为“最受欢迎的语言”。🤷‍♀️</li>
<li>现代工具：cargo（负责构建工作）、clippy（550+代码质量的lints）、Rustup（轻松的工具链管理）。</li>
</ul>
<h2 id="语言弱点"><a class="header" href="#语言弱点">语言弱点</a></h2>
<ul>
<li>陡峭的学习曲线，编译器强制执行（特别是内存）规则，这将是其他类似语言的“最佳实践”。</li>
<li>某些域、目标平台（尤其是嵌入式平台）和IDE功能中缺少Rust原生库。</li>
<li>编译时间比其他语言中“类似”的代码要长。</li>
<li>没有正式的语言规范，可能会阻止在某些领域（航空、医疗等）的合法使用。</li>
<li>一不留意的库（在自定义库中使用 unsafe）可能会很隐藏的破坏语言中的安全规范。</li>
</ul>
<h2 id="目录-1"><a class="header" href="#目录-1">目录</a></h2>
<ul>
<li><a href="rust/./chapter_1_1.html">Rust 语法结构</a>
<ul>
<li><a href="rust/./chapter_1_1.html#hello-rust">Hello, Rust!</a></li>
<li><a href="rust/./chapter_1_1.html#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">数据结构</a></li>
<li><a href="rust/./chapter_1_1.html#%E5%BC%95%E7%94%A8%E5%92%8C%E6%8C%87%E9%92%88">引用和指针</a></li>
<li><a href="rust/./chapter_1_1.html#%E5%87%BD%E6%95%B0%E4%B8%8E%E6%96%B9%E6%B3%95">函数与方法</a></li>
<li><a href="rust/./chapter_1_1.html#%E6%8E%A7%E5%88%B6%E6%B5%81%E7%A8%8B">控制流程</a></li>
<li><a href="rust/./chapter_1_1.html#%E4%BB%A3%E7%A0%81%E7%BB%84%E7%BB%87">代码组织</a></li>
<li><a href="rust/./chapter_1_1.html#%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D%E5%92%8C%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2">类型别名和强制转换</a></li>
<li><a href="rust/./chapter_1_1.html#%E5%AE%8F%E5%92%8C%E5%B1%9E%E6%80%A7">宏和属性</a></li>
<li><a href="rust/./chapter_1_1.html#%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D">模式匹配</a></li>
<li><a href="rust/./chapter_1_1.html#%E6%B3%9B%E5%9E%8B%E5%92%8C%E7%BA%A6%E6%9D%9F">泛型和约束</a></li>
<li><a href="rust/./chapter_1_1.html#higher-ranked-%E4%BE%8B%E5%AD%90">Higher-Ranked 例子</a></li>
<li><a href="rust/./chapter_1_1.html#%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D%E5%92%8C%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2">类型别名和强制转换</a></li>
<li><a href="rust/./chapter_1_1.html#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E5%AD%97%E7%AC%A6">字符串和字符</a></li>
<li><a href="rust/./chapter_1_1.html#%E6%96%87%E6%A1%A3%E6%B3%A8%E9%87%8A">文档注释</a></li>
<li><a href="rust/./chapter_1_1.html#%E5%85%B6%E5%AE%83%E6%9D%82%E9%A1%B9">其它杂项</a></li>
<li><a href="rust/./chapter_1_1.html#%E5%B8%B8%E7%94%A8%E8%BF%90%E7%AE%97%E7%AC%A6">常用运算符</a></li>
</ul>
</li>
<li><a href="rust/./chapter_1_4.html">Rust 标准库</a>
<ul>
<li><a href="rust/./chapter_1_4.html#%E5%8D%95%E7%BA%BF%E7%A8%8B">单线程</a> </li>
<li><a href="rust/./chapter_1_4.html#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8">线程安全</a> </li>
<li><a href="rust/./chapter_1_4.html#%E8%BF%AD%E4%BB%A3%E5%99%A8">迭代器</a> </li>
<li><a href="rust/./chapter_1_4.html#%E6%95%B0%E5%AD%97%E8%BD%AC%E6%8D%A2">数字转换</a> </li>
<li><a href="rust/./chapter_1_4.html#%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2">字符串转换</a> </li>
<li><a href="rust/./chapter_1_4.html#%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BE%93%E5%87%BA">字符串输出</a> </li>
</ul>
</li>
<li><a href="rust/./chapter_1_5.html">Rust 工具链</a>
<ul>
<li><a href="rust/./chapter_1_5.html#%E9%A1%B9%E7%9B%AE%E7%BB%84%E7%BB%87">项目组织</a> </li>
<li><a href="rust/./chapter_1_5.html#cargo">Cargo</a> </li>
<li><a href="rust/./chapter_1_5.html#%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91">交叉编译</a> </li>
<li><a href="rust/./chapter_1_5.html#%E5%B7%A5%E5%85%B7%E6%8C%87%E4%BB%A4">工具指令</a> </li>
</ul>
</li>
<li><a href="rust/./chapter_1_6.html">Rust 类型操作</a>
<ul>
<li><a href="rust/./chapter_1_6.html#%E7%B1%BB%E5%9E%8B-%E7%89%B9%E5%BE%81-%E6%B3%9B%E5%9E%8B">类型 特征 泛型</a></li>
<li><a href="rust/./chapter_1_6.html#%E7%89%B9%E5%BE%81%E4%B8%8E%E6%8E%A5%E5%8F%A3">特征与接口</a></li>
</ul>
</li>
<li><a href="rust/./chapter_1_7.html">Rust 编码范式</a></li>
</ul>
<p><img src="https://awesomeprogram.gitee.io/imgdata/tech_rustlang.png" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust语法结构"><a class="header" href="#rust语法结构">Rust语法结构</a></h1>
<h2 id="hello-rust"><a class="header" href="#hello-rust">Hello, Rust!</a></h2>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    println!(&quot;Hello, AwesomeProgram!&quot;);
}
</code></pre></pre>
<h2 id="数据结构"><a class="header" href="#数据结构">数据结构</a></h2>
<ul>
<li>通过关键字定义的数据类型和内存位置</li>
</ul>
<table><thead><tr><th>例子</th><th>解释</th></tr></thead><tbody>
<tr><td><code>struct S {}</code></td><td>使用命名字段定义一个 <strong>结构体</strong></td></tr>
<tr><td>  <code>struct S { x: T }</code></td><td><code>x</code> 使用类型 <code>T</code> 的命名字段定义结构体</td></tr>
<tr><td>  <code>struct S (T);</code></td><td>定义带有编号字段类型的&quot;元组&quot;结构体</td></tr>
<tr><td>  <code>struct S;</code></td><td>定义 <strong>零大小</strong> 的单元结构体，不占空间</td></tr>
<tr><td><code>enum E {}</code></td><td>定义一个 <strong>枚举</strong></td></tr>
<tr><td>  <code>enum E { A, B(), C {} }</code></td><td>定义枚举的变体，可以是 unit-<code>A</code>， tuple-<code>B()</code> 和struct-like <code>C{}</code></td></tr>
<tr><td>  <code>enum E { A = 1 }</code></td><td>如果变体只是与单元类似，则允许赋值，例如 FFI</td></tr>
<tr><td><code>union U {}</code></td><td>用于兼容 FFI 的，类似 C <strong>union</strong> 的 unsafe 代码</td></tr>
<tr><td><code>static X: T = T();</code></td><td>具有生命周期，单独内存位置的 <strong>全局变量</strong></td></tr>
<tr><td><code>const X: T = T();</code></td><td>定义 <strong>常量</strong>，使用时会复制到临时文件中</td></tr>
<tr><td><code>let x: T;</code></td><td>在绑定为 <code>x</code> 的堆栈上分配 <code>T</code> 类型的字节，可赋值一次，不可变</td></tr>
<tr><td><code>let mut x: T;</code></td><td>同上，但允许 <strong>可变</strong> 和可变借用</td></tr>
<tr><td>  <code>x = y;</code></td><td>移动 <code>y</code> 到 <code>x</code>，如果 <code>T</code> 没有实现 <strong>Copy</strong>，则 <code>y</code> 的所有权会失效，否则会保留所有权并把 <code>y</code> 复制一份</td></tr>
</tbody></table>
<ul>
<li>创建和访问数据结构，以及一些符号类型</li>
</ul>
<table><thead><tr><th>例子</th><th>解释</th></tr></thead><tbody>
<tr><td><code>S { x: y }</code></td><td>创建 <code>struct S {}</code> 或者 <code>use</code> 库 <code>enum E::S {}</code> ，将字段 <code>x</code> 设置为 <code>y</code></td></tr>
<tr><td><code>S { x }</code></td><td>同上，但使用本地变量 <code>x</code> 设置字段 <code>x</code></td></tr>
<tr><td><code>S { ..s }</code></td><td>填写剩余的字段 <code>s</code>，特别是与 <a href="https://doc.rust-lang.org/std/default/trait.Default.html">Default</a> 一起使用</td></tr>
<tr><td><code>S { 0: x }</code></td><td>像下一行 <code>S(x)</code> 一样，但设置字段 <code>.0</code> 使用结构体语法</td></tr>
<tr><td><code>S​ (x)</code></td><td>创建 <code>struct S (T)</code> 或者 <code>use</code> 库 <code>enum E::S ()</code> ，将字段 <code>.0</code> 设置为 <code>x</code></td></tr>
<tr><td><code>S</code></td><td>如果 <code>S</code> 是单元结构体 <code>S</code>，或者 <code>use</code> 库 <code>enum E::S</code>， 去创建 <code>S</code> 的值</td></tr>
<tr><td><code>E::C { x: y }</code></td><td>创建枚举变体 <code>C</code> ，上面其它的方法也可以</td></tr>
<tr><td><code>()</code></td><td>空元组，包括字面值和类型，又名单元 <strong>unit</strong></td></tr>
<tr><td><code>(x)</code></td><td>带括号的表达式</td></tr>
<tr><td><code>(x,)</code></td><td>单元素 <strong>元组</strong> 表达式</td></tr>
<tr><td><code>(S,)</code></td><td>单元素元组类型</td></tr>
<tr><td><code>[S]</code></td><td>未指定长度的 <strong>数组类型</strong>，即 <strong>slice</strong>，不能存储于栈中</td></tr>
<tr><td><code>[S; n]</code></td><td><strong>数组类型</strong>，固定长度是 <code>n</code> ，存储元素的类型是 <code>S</code></td></tr>
<tr><td><code>[x; n]</code></td><td>具有 <code>x</code> 的 <code>n</code> 个副本的数组实例</td></tr>
<tr><td><code>[x, y]</code></td><td>具有给定元素 <code>x</code> 和 <code>y</code> 的数组实例</td></tr>
<tr><td><code>x[0]</code></td><td>集合索引, 使用 <code>usize</code> 类型， 可以用 <strong>Index, IndexMut</strong> 来实现</td></tr>
<tr><td>  <code>x[..]</code></td><td>同上，全范围，还有 <code>x[a..b], x[a..=b], ...</code> 以及如下等等</td></tr>
<tr><td><code>a..b</code></td><td>左闭右开范围，如 <code>1..3</code> 意味着 <code>1, 2</code></td></tr>
<tr><td><code>..b</code></td><td>从起点开始的左闭右开范围</td></tr>
<tr><td><code>..=b</code></td><td>从起点开始的，包含最右边元素的范围</td></tr>
<tr><td><code>a..=b</code></td><td>包容最右边元素的范围，1..=3 意味着 1, 2, 3</td></tr>
<tr><td><code>a..</code></td><td>从 <code>a</code> 开始到结尾的范围</td></tr>
<tr><td><code>..</code></td><td>全范围，通常意味着整个集合</td></tr>
<tr><td><code>s.x</code></td><td>命名字段的访问，如果 <code>x</code> 不是类型 <code>S</code> 的一部分，则可能会尝试去调用 <a href="https://doc.rust-lang.org/std/ops/trait.Deref.html">Deref</a>（取消引用）</td></tr>
<tr><td><code>s.0</code></td><td>编号字段访问，用于元组类型 <code>S (T)</code></td></tr>
</tbody></table>
<h2 id="引用和指针"><a class="header" href="#引用和指针">引用和指针</a></h2>
<ul>
<li>授权未拥有内存的访问权限，另外可参阅泛型和约束部分</li>
</ul>
<table><thead><tr><th>例子</th><th>解释</th></tr></thead><tbody>
<tr><td><code>&amp;S</code></td><td>共享的引用（空间中可存放任何的 <code>&amp;s</code>）</td></tr>
<tr><td>  <code>&amp;[S]</code></td><td>包含地址和长度的指定切片引用</td></tr>
<tr><td>  <code>&amp;str</code></td><td>包含地址和长度的指定字符串切片引用</td></tr>
<tr><td>  <code>&amp;mut S</code></td><td>可变的独占引用（也包括 <code>&amp;mut [S]</code>，<code>&amp;mut dyn S</code>， …）</td></tr>
<tr><td>  <code>&amp;dyn T</code></td><td>包含地址和 vtable 的指定 <strong>trait object</strong> 引用</td></tr>
<tr><td><code>&amp;s</code></td><td>共享的借用（如 地址，长度，vtable，...以及像 <code>0x1234</code>）</td></tr>
<tr><td>  <code>&amp;mut s</code></td><td>可变的独占借用</td></tr>
<tr><td><code>*const S</code></td><td>不可变 <strong>原生指针类型</strong>，无内存安全保证</td></tr>
<tr><td>  <code>&amp;mut s</code></td><td>可变 <strong>原生指针类型</strong>，无内存安全保证</td></tr>
<tr><td>  <code>&amp;raw const s</code></td><td>创建不经过引用的原生指针，<code>ptr:addr_of!()</code></td></tr>
<tr><td>  <code>&amp;raw mut s</code></td><td>同上，是可变的，并且需要对未对齐的字段进行补齐</td></tr>
<tr><td><code>ref s</code></td><td>通过引用绑定，成为绑定引用类型</td></tr>
<tr><td>  <code>let ref r = s;</code></td><td>等价于 <code>let r = &amp;s</code></td></tr>
<tr><td>  <code>let S { ref mut x } = s;</code></td><td>可变引用绑定，等价于 <code>let x = &amp;mut s.x</code>；简洁的解构写法见<a href="rust/chapter_1_1.html#%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D"><strong>模式匹配</strong></a></td></tr>
<tr><td><code>*r</code></td><td>解除一个引用 <code>r</code> 去访问它所指向的内容</td></tr>
<tr><td>  <code>*r = s;</code></td><td>如果 <code>r</code> 是可变引用，则移动或复制 <code>s</code> 到目标内存</td></tr>
<tr><td>  <code>s = *r;</code></td><td>如果 <code>*r</code> 是 <strong>Copy</strong> 的话，使 <code>s</code> 等于任何 <code>r</code> 引用的副本</td></tr>
<tr><td>  <code>s = *r;</code></td><td>如果 <code>*r</code> 不是 <strong>Copy</strong> 的话，将不起作用，且会移动并留下空赋值</td></tr>
<tr><td>  <code>s = *my_box;</code></td><td><code>Box</code> 的特殊例子，如果 <code>*my_box</code> 不是 <strong>Copy</strong> 的话，将会移出 Box 里的内容</td></tr>
<tr><td><code>'a</code></td><td>生命周期的参数符号，表示在静态分析中的存活时间</td></tr>
<tr><td>  <code>&amp;'a S</code></td><td>只接受存有 <code>S</code> 类型的地址，存在 <code>'a</code> 或更长</td></tr>
<tr><td>  <code>&amp;'a mut S</code></td><td>同上，但是 <code>S</code> 类型地址的内容可变</td></tr>
<tr><td>  <code>struct S&lt;'a&gt; {}</code></td><td>表示 <code>S</code> 包含生命周期 <code>'a</code> 的地址， <code>S</code> 的创建者决定生命周期 <code>'a</code> 的长短</td></tr>
<tr><td>  <code>trait T&lt;'a&gt; {}</code></td><td>表示 <code>impl T for S</code> ， <code>S</code> 可能会包含地址</td></tr>
<tr><td>  <code>fn f&lt;'a&gt;(t: &amp;'a T)</code></td><td>同上，对于一个函数，调用者决定生命周期 <code>'a</code> 的长短</td></tr>
<tr><td><code>'static</code></td><td>持续整个程序执行期间的固定生命周期</td></tr>
</tbody></table>
<h2 id="函数与方法"><a class="header" href="#函数与方法">函数与方法</a></h2>
<ul>
<li>定义代码单元及其抽象表达</li>
</ul>
<table><thead><tr><th>例子</th><th>解释</th></tr></thead><tbody>
<tr><td><code>trait T {}</code></td><td>定义一个可以实现的通用行为，<strong>特征</strong></td></tr>
<tr><td><code>trait T : R {}</code></td><td><code>T</code> 是 <strong>supertrait</strong> <code>R</code> 的 <strong>subtrait</strong>，任何 <code>S</code> 必须在它 <code>impl T</code> 之前 <code>impl R</code></td></tr>
<tr><td><code>impl S {}</code></td><td>类型 <code>S</code> 的方法实现</td></tr>
<tr><td><code>impl T for S {}</code></td><td>为类型 <code>S</code> 实现特征 <code>T</code> 中的方法</td></tr>
<tr><td><code>impl !T for S {}</code></td><td>禁用自动派生 <strong>auto trait</strong></td></tr>
<tr><td><code>fn f() {}</code></td><td>定义一个 <strong>函数</strong>，或者一个 <strong>关联函数</strong>（在 <code>impl</code> 内）</td></tr>
<tr><td>  <code>fn f() -&gt; S {}</code></td><td>同上，返回类型 <code>S</code> 的值</td></tr>
<tr><td>  <code>fn f(&amp;self) {}</code></td><td>定义一个 <strong>方法</strong>，如在 <code>impl S {}</code> 内</td></tr>
<tr><td><code>struct S ​(T);</code></td><td>可以定义一个 <strong>构造函数</strong> <code>fn S(x: T) -&gt; S</code></td></tr>
<tr><td><code>const fn f() {}</code></td><td>在编译时可用的常量 <code>fn</code> ，如 <code>const X: u32 = f(Y)</code></td></tr>
<tr><td><code>async fn f() {}</code></td><td>异步函数转换，使 <code>f</code> 返回一个 <code>impl</code> <strong><code>Future</code></strong></td></tr>
<tr><td>  <code>async fn f() -&gt; S {}</code></td><td>同上，但使 <code>f</code> 返回一个 <code>impl Future&lt;Output=S&gt;</code></td></tr>
<tr><td>  <code>async { x }</code></td><td>在一个函数内使用，使 <code>{ x }</code> 为 <code>impl Future&lt;Output=X&gt;</code></td></tr>
<tr><td><code>fn() -&gt; S</code></td><td><strong>函数指针</strong>，内存持有可调用的地址</td></tr>
<tr><td><code>Fn() -&gt; S</code></td><td><strong>Callable Trait</strong> (也可以是 <code>FnMut</code>，<code>FnOnce</code>)，由闭包实现</td></tr>
<tr><td><code>|| {} </code></td><td>可借用其 <strong>捕获</strong> 的 <strong>闭包</strong> (如，局部变量)</td></tr>
<tr><td>  <code>|x| {}</code></td><td>闭包接受一个名为 <code>x</code> 的参数，主体是块表达式</td></tr>
<tr><td>  <code>|x| x + x</code></td><td>同上，没有块表达式，只有一单个表达式</td></tr>
<tr><td>  <code>move |x| x + y </code></td><td>闭包获取其捕获的所有权，即 <code>y</code> 转移到闭包中</td></tr>
<tr><td>  <code> return || true </code></td><td>闭包看起来像是 <strong>logical ORs</strong> (返回一个闭包)</td></tr>
<tr><td><code>unsafe</code></td><td>如果你喜欢放假前调试代码（代码的安全由你自己保证），<strong>unsafe code</strong></td></tr>
<tr><td>  <code>unsafe fn f() {}</code></td><td>会调用导致不安全的代码块，你必须检查必要条件</td></tr>
<tr><td>  <code>unsafe trait T {}</code></td><td>不仔细的 <code>T</code> 实现可能会造成不安全的代码块，实现者必须仔细检查</td></tr>
<tr><td>  <code>unsafe { f(); }</code></td><td>向编译器保证已经检查了必要条件</td></tr>
<tr><td>  <code>unsafe impl T for S {}</code></td><td>保证 <code>S</code> 是表现良好的，可以安全在 <code>S</code> 上使用 <code>T</code></td></tr>
</tbody></table>
<h2 id="控制流程"><a class="header" href="#控制流程">控制流程</a></h2>
<ul>
<li>在函数内执行控制</li>
</ul>
<table><thead><tr><th>例子</th><th>解释</th></tr></thead><tbody>
<tr><td><code>while x {}</code></td><td><strong>Loop</strong>，当表达式 <code>x</code> 是真时一直运行</td></tr>
<tr><td><code>loop {}</code></td><td><strong>Loop indefinitely</strong> 直到 <code>break</code>，可以主动创建 <code>break x</code></td></tr>
<tr><td><code>for x in iter {}</code></td><td>循环遍历 <strong>迭代器</strong> 的语法糖</td></tr>
<tr><td><code>if x {} else {}</code></td><td>如果表达式为真，则执行 <strong>条件分支</strong></td></tr>
<tr><td><code>'label: loop {}</code></td><td><strong>循环标签</strong>，用于嵌套循环中的流程控制</td></tr>
<tr><td><code>break</code></td><td><strong>Break expression</strong> 可退出循环</td></tr>
<tr><td>  <code>break x</code></td><td>同上，但使 <code>x</code> 为循环表达式的值（仅在实际的 <code>loop</code>）</td></tr>
<tr><td>  <code>break 'label</code></td><td>不仅要退出这个循环，还要退出标有 <code>'label</code> 的封闭循环</td></tr>
<tr><td>  <code>break 'label x</code></td><td>同上，但使 <code>x</code> 为标有 <code>'label</code> 的封闭循环的值</td></tr>
<tr><td><code>continue</code></td><td><strong>Continue expression</strong> 跳转到此循环后的下一个循环迭代</td></tr>
<tr><td><code>continue 'label</code></td><td>同上，但使标有 <code>'label</code> 的封闭循环替代本次循环</td></tr>
<tr><td><code>x?</code></td><td>如果 <code>x</code> 是 <code>Err</code> 或 <code>None</code> ，<strong>return and propagate</strong></td></tr>
<tr><td><code>x.await</code></td><td>只作用于 <code>async</code> 里，直到 <strong>Future</strong> 生成流或准备好 <code>x</code></td></tr>
<tr><td><code>return x</code></td><td>从函数中提前返回，更惯用的做法是在结尾使用表达式</td></tr>
<tr><td><code>f()</code></td><td>调用 <code>f</code>，(如一个函数，闭包，函数指针, <code>Fn</code> )</td></tr>
<tr><td><code>x.f()</code></td><td>调用成员函数，需要 <code>f</code> 把 <code>self</code>， <code>&amp;self</code>，...作为第一个参数</td></tr>
<tr><td>  <code>X::f(x)</code></td><td>同 <code>x.f()</code>，除非实现了 <code>impl Copy for X {}</code>，否则 <code>f</code> 仅可被调用一次</td></tr>
<tr><td>  <code>X::f(&amp;x)</code></td><td>同 <code>x.f()</code></td></tr>
<tr><td>  <code>X::f(&amp;mut x)</code></td><td>同 <code>x.f()</code></td></tr>
<tr><td>  <code>S::f(&amp;x)</code></td><td>如果 <code>x</code> <strong>derefs</strong> 到 <code>S</code> 同 <code>x.f()</code> 一样， 即 <code>x.f()</code> 发现了 <code>S</code> 的方法</td></tr>
<tr><td>  <code>T::f(&amp;x)</code></td><td>如果 <code>x</code> <strong>impl</strong> <code>T</code> 同 <code>x.f()</code> 一样， 即 <code>x.f()</code> 在范围内发现了 <code>T</code> 的方法</td></tr>
<tr><td><code>X::f()</code></td><td>调用关联函数，如 <code>X::new()</code></td></tr>
<tr><td>  <code>&lt;X as T&gt;::f()</code></td><td>为 <code>X</code> 调用特征方法 <code>T::f()</code> 的实现</td></tr>
</tbody></table>
<h2 id="代码组织"><a class="header" href="#代码组织">代码组织</a></h2>
<ul>
<li>拆分项目到更小的作用域内和最少的依赖</li>
</ul>
<table><thead><tr><th>例子</th><th>解释</th></tr></thead><tbody>
<tr><td><code>mod m {}</code></td><td>定义一个模块，从 <code>{}</code> 内部获取定义</td></tr>
<tr><td><code>mod m;</code></td><td>定义一个模块，从 <code>m.rs</code> 或 <code>m/mod.rs</code> 中获取定义</td></tr>
<tr><td><code>a::b</code></td><td>在 <code>a</code> (<code>mod</code>, <code>enum</code>, …) 的内部，名命空间的路径到元素 <code>b</code></td></tr>
<tr><td>  <code>::b</code></td><td>在 <strong>crate root</strong>、<strong>external prelude</strong>、<strong>global path</strong> 搜索 <code>b</code></td></tr>
<tr><td>  <code>crate::b</code></td><td>在 <strong>crate root</strong> 中搜索 <code>b</code></td></tr>
<tr><td>  <code>self::b</code></td><td>在当前的模块中搜索 <code>b</code></td></tr>
<tr><td>  <code>super::b</code></td><td>在上一级模块中搜索 <code>b</code></td></tr>
<tr><td><code>use a::b;</code></td><td>在范围内直接使用 <code>b</code> 而不需要 <code>a</code> 其余部分</td></tr>
<tr><td><code>use a::{b, c};</code></td><td>同上，但是会把 <code>b</code> 和 <code>c</code> 放到范围内</td></tr>
<tr><td><code>use a::b as x;</code></td><td>把 <code>b</code> 放到范围，使用别名 <code>x</code>，也像这样 <code>use std::error::Error as E</code></td></tr>
<tr><td><code>use a::b as _;</code></td><td>把 <code>b</code> 作为匿名放到范围中，通常适用于命名冲突的特征</td></tr>
<tr><td><code>use a::*;</code></td><td>把 <code>a</code> 内的所有接口放到范围中，仅推荐如果 <code>a</code> 是一些 <strong>prelude</strong></td></tr>
<tr><td><code>pub use a::b;</code></td><td>把 <code>a::b</code> 放到范围中，并且在这里重新导出</td></tr>
<tr><td><code>pub T</code></td><td>如果上一级路径是可见的则公开 <strong>visibility</strong></td></tr>
<tr><td>  <code>pub(crate) T</code></td><td>最多在当前 <strong>crate</strong> 中可见</td></tr>
<tr><td>  <code>pub(super) T</code></td><td>最多在上一级中可见</td></tr>
<tr><td>  <code>pub(self) T</code></td><td>最多在当前模块中可见(默认和没有 <code>pub</code> 一样).</td></tr>
<tr><td>  <code>pub(in a::b) T</code></td><td>最多在 <code>a::b</code> 中可见</td></tr>
<tr><td><code>extern crate a;</code></td><td>声明对外部的 <strong>crate</strong> 依赖，仅在 <code>use a::b</code> 内</td></tr>
<tr><td><code>extern &quot;C&quot; {}</code></td><td>从 <strong>FFI</strong> 声明外部依赖项和 ABI（如 &quot;C&quot;）</td></tr>
<tr><td><code>extern &quot;C&quot; fn f() {}</code></td><td>定义要使用 ABI（&quot;C&quot;）导出到 <strong>FFI</strong> 的函数</td></tr>
</tbody></table>
<ul>
<li>子模块中的项目始终可以访问任何项目，无论是否为 <code>pub</code></li>
</ul>
<h2 id="类型别名和强制转换"><a class="header" href="#类型别名和强制转换">类型别名和强制转换</a></h2>
<ul>
<li>类型的简写名称，以及将一种类型转换为另一种类型的方法</li>
</ul>
<table><thead><tr><th>例子</th><th>解释</th></tr></thead><tbody>
<tr><td><code>type T = S;</code></td><td>创建一个类型别名，即 <code>S</code> 的另一个名称</td></tr>
<tr><td><code>Self</code></td><td><strong>implementing type</strong>，如 <code>fn new() -&gt; Self</code></td></tr>
<tr><td><code>self</code></td><td>在 <code>fn f(self) {}</code> 里的方法，与 <code>fn f(self: Self) {}</code> 一样</td></tr>
<tr><td>  <code>&amp;self</code></td><td>同上，但将 self 改为借用，与 <code>f(self: &amp;Self)</code> 一样</td></tr>
<tr><td>  <code>&amp;mut self</code></td><td>同上，但将 self 改为可变借用，与 <code>f(self: &amp;mut Self)</code> 一样</td></tr>
<tr><td>  <code>self: Box&lt;Self&gt;</code></td><td><strong>任意self类型 Arbitrary self type</strong>，给智能指针添加方法（<code>my_box.f_of_self()</code>）</td></tr>
<tr><td><code>S as T</code></td><td>消除类型 <code>S</code> 改为特征 <code>T</code>， 如 <code>&lt;S as T&gt;::f()</code></td></tr>
<tr><td><code>S as R</code></td><td>在<strong>use</strong>符号中使用，导入 <code>S</code> 作为 <code>R</code>，如 <code>use a::S as R</code></td></tr>
<tr><td><code>x as u32</code></td><td>简单映射，可能会遭到意外的截断</td></tr>
</tbody></table>
<h2 id="宏和属性"><a class="header" href="#宏和属性">宏和属性</a></h2>
<ul>
<li>代码在实际编译之前进行展开生成</li>
</ul>
<table><thead><tr><th>例子</th><th>解释</th></tr></thead><tbody>
<tr><td><code>m!()</code></td><td>宏调用, 也可以 <code>m!{}</code>， <code>m![]</code> (依赖宏的实现)</td></tr>
<tr><td><code>#[attr]</code></td><td>外部属性，用于注释下面的条目</td></tr>
<tr><td><code>#![attr]</code></td><td>内部属性，用于注释上一级和周围的条目</td></tr>
</tbody></table>
<br>
<table><thead><tr><th>内部宏</th><th>解释</th></tr></thead><tbody>
<tr><td><code>$x:ty</code></td><td>宏捕获，<code>:...</code> 片段为 <code>$x</code> 声明了允许的内容</td></tr>
<tr><td><code>$x</code></td><td>宏替换，例如使用上面捕获的 <code>$x:ty</code></td></tr>
<tr><td><code>$(x),*</code></td><td>宏重复，例如在宏中重复零次或多次</td></tr>
<tr><td>  <code>$(x),?</code></td><td>同上，但重复零次或一次</td></tr>
<tr><td>  <code>$(x),+</code></td><td>同上，但重复一次或多次</td></tr>
<tr><td>  <code>$(x)&lt;&lt;+</code></td><td>实际上除了分隔符 <code>,</code> 也可以接受这样的 <code>&lt;&lt;</code></td></tr>
</tbody></table>
<h2 id="模式匹配"><a class="header" href="#模式匹配">模式匹配</a></h2>
<ul>
<li>在 match 或 let 表达式 以及函数参数中的模式构造</li>
</ul>
<table><thead><tr><th>例子</th><th>解释</th></tr></thead><tbody>
<tr><td><code>match m {}</code></td><td>初始化模式匹配，然后使用匹配分支</td></tr>
<tr><td><code>let S(x) = get();</code></td><td>明显地，<code>let</code> 还可以解构成类似下面的形式</td></tr>
<tr><td>  <code>let S { x } = s;</code></td><td>仅把 <code>x</code> 绑定到 <code>s.x</code> 的值</td></tr>
<tr><td>  <code>let (_, b, _) = abc;</code></td><td>仅把 <code>b</code> 绑定到 <code>abc.1</code> 的值</td></tr>
<tr><td>  <code>let (a, ..) = abc;</code></td><td>忽略 <strong>其余部分</strong> 也有作用</td></tr>
<tr><td>  <code>let (.., a, b) = (1, 2);</code></td><td>指定绑定优先于 <strong>其余部分</strong>，这里 <code>a</code> 是 <code>1</code> ，<code>b</code> 是 <code>2</code></td></tr>
<tr><td>  <code>let s @ S { x } = get();</code></td><td>当 <code>x</code> 绑定到 <code>s.x</code> 时，<code>s</code> 绑定到 <code>S</code>，<strong>pattern binding</strong></td></tr>
<tr><td>  <code>let w @ t @ f = get();</code></td><td>给每个 <code>w t f</code> 存储 <code>get()</code> 的三个副本结果</td></tr>
<tr><td>  <code>let Some(x) = get();</code></td><td>如果是可辩驳模式不会起到作用，应使 <code>if let</code> 来代替</td></tr>
<tr><td><code>if let Some(x) = get() {}</code></td><td>如果模式可被分配成分支(如，枚举变体)，语法糖</td></tr>
<tr><td><code>while let Some(x) = get() {}	</code></td><td>同上，<code>{}</code> 只要模式可被分配成分支，将继续调用 <code>get()</code></td></tr>
<tr><td><code>fn f(S { x }: S)</code></td><td>函数参数也像 <code>let</code> 一样使用，这里把 <code>x</code> 绑定到 <code>f(s)</code> 的 <code>s.x</code></td></tr>
</tbody></table>
<p><sup>*</sup>脱糖后如 <code>match get() { Some(x) =&gt; {}, _ =&gt; () }</code></p>
<ul>
<li>匹配表达式中的模式匹配分支，左侧这些分支也可以在 let 表达式中找到</li>
</ul>
<table><thead><tr><th>在匹配分支内</th><th>解释</th></tr></thead><tbody>
<tr><td><code>E::A =&gt; {}</code></td><td>匹配枚举变体 <code>A</code>，<strong>模式匹配</strong></td></tr>
<tr><td><code>E::B ( .. ) =&gt; {}</code></td><td>匹配枚举元组变体 <code>B</code>，任何索引的通配符</td></tr>
<tr><td><code>E::C { .. } =&gt; {}</code></td><td>匹配枚举结构体变体，任何字段的通配符</td></tr>
<tr><td><code>S { x: 0, y: 1 } =&gt; {}</code></td><td>匹配结构体与指定值（仅接受 <code>s</code> 与 <code>s.x 0</code> 和 <code>s.y 1</code>）</td></tr>
<tr><td><code>S { x: a, y: b } =&gt; {}</code></td><td>匹配结构体与 <code>any(!)</code>，并且绑定 <code>s.x</code> 到 <code>a</code> 和 <code>s.y</code> 到 <code>b</code></td></tr>
<tr><td>  <code>S { x, y } =&gt; {}</code></td><td>同上，但分别地把 <code>s.x</code> 和 <code>s.y</code> 的简写 <code>x</code> 和 <code>y</code> 作为绑定</td></tr>
<tr><td><code>S { .. } =&gt; {}</code></td><td>将 struct 与任何值匹配</td></tr>
<tr><td><code>D =&gt; {}</code></td><td>如果 <code>D</code> 在 <code>use</code> 中，匹配枚举变体到 <code>E::D</code></td></tr>
<tr><td><code>D =&gt; {}</code></td><td>如果 <code>D</code> 不在 <code>use</code> 中，匹配任何东西绑定到 <code>D</code>，也可能是 <code>E::D</code> 的一种错误形式</td></tr>
<tr><td><code>_ =&gt; {}</code></td><td>匹配任何内容（所有其余部分）的完全通配符。</td></tr>
<tr><td><code>0 | 1 =&gt; {}</code></td><td>模式选择，<strong>or-patterns</strong></td></tr>
<tr><td>  <code>E::A | E::Z =&gt; {}</code></td><td>同上，但是在枚举变体上</td></tr>
<tr><td>  <code>E::C {x} | E::D {x} =&gt; {}</code></td><td>同上，但如果所有变体都有它，则绑定 <code>x</code></td></tr>
<tr><td>  <code>Some(A | B) =&gt; {}</code></td><td>同上，可以匹配深度嵌套的 <strong>or-patterns</strong></td></tr>
<tr><td><code>(a, 0) =&gt; {}</code></td><td>为 <code>a</code> 和 <code>0</code> 匹配任何值的元组</td></tr>
<tr><td><code>[a, 0] =&gt; {}</code></td><td><strong>切片模式</strong>，为 <code>a</code> 和 <code>0</code> 匹配任何值的数组</td></tr>
<tr><td>  <code>[1, ..] =&gt; {}</code></td><td><strong>子切片模式</strong>，匹配数组从 <code>1</code> 开始，任何其余的值</td></tr>
<tr><td>  <code>[1, .., 5] =&gt; {}</code></td><td>匹配数组从 <code>1</code> 开始到 <code>5</code> 结束中的值</td></tr>
<tr><td>  <code>[1, x @ .., 5] =&gt; {}</code></td><td>同上，但还会绑定 <code>x</code> 到代表中间的切片</td></tr>
<tr><td>  <code>[a, x @ .., b] =&gt; {}</code></td><td>同上，但分别匹配任意的第一个和最后一个，绑定为 <code>a</code> 和 <code>b</code></td></tr>
<tr><td><code>1 .. 3 =&gt; {}</code></td><td><strong>范围模式</strong>，这里会匹配 <code>1</code> 和 <code>2</code>，部分不稳定</td></tr>
<tr><td>  <code>1 ..= 3 =&gt; {}</code></td><td>包含范围模式，匹配 <code>1</code>，<code>2</code> 和 <code>3</code></td></tr>
<tr><td>  <code>1 .. =&gt; {}</code></td><td>开放的范围模式，匹配 <code>1</code> 和任何更大的数</td></tr>
<tr><td><code>x @ 1..=5 =&gt; {}</code></td><td>绑定匹配到 <code>x</code>，<strong>模式绑定</strong>，此处的 <code>x</code> 将是 <code>1</code>，<code>2</code>，... 或 <code>5</code></td></tr>
<tr><td>  <code>Err(x @ Error {..}) =&gt; {}</code></td><td>也可以用于嵌套，这里 <code>x</code> 绑定到 <code>Error</code>，特别是下面有用的 <code>if</code> 形式</td></tr>
<tr><td><code>S { x } if x &gt; 10 =&gt; {}</code></td><td>模式 <strong>匹配保护</strong>，条件也必须为真才能匹配</td></tr>
</tbody></table>
<h2 id="泛型和约束"><a class="header" href="#泛型和约束">泛型和约束</a></h2>
<ul>
<li>泛型结合类型构造函数，特征和函数为你的代码提供更大的灵活性</li>
</ul>
<table><thead><tr><th>例子</th><th>解释</th></tr></thead><tbody>
<tr><td><code>S&lt;T&gt;</code></td><td>带有类型参数的 <strong>泛型</strong> 类型（<code>T</code> 表示占位符名称）</td></tr>
<tr><td><code>S&lt;T: R&gt;</code></td><td>打印简写的 <strong>trait bound</strong> 范式（<code>R</code> 必须是实际的特征）</td></tr>
<tr><td>  <code>T: R, P: S</code></td><td><strong>Independent trait bounds</strong>（这里一个给 <code>T</code>，一个给 <code>P</code>）</td></tr>
<tr><td>  <code>T: R, S</code></td><td>编译报错，你可能希望像使用下面的用法 <code>R + S</code></td></tr>
<tr><td>  <code>T: R + S</code></td><td><strong>Compound trait bound</strong>， <code>T</code> 必须满足 <code>R</code> 和 <code>S</code></td></tr>
<tr><td>  <code>T: R + 'a</code></td><td>同上，但是 <code>T</code> 必须满足 <code>R</code>，如果 <code>T</code> 有生命周期，必须比 <code>'a</code> 更久</td></tr>
<tr><td>  <code>T: ?Sized</code></td><td>选择离开预定义的 <strong>trait bound</strong>，这里是 <code>Sized</code></td></tr>
<tr><td>  <code>T: 'a</code></td><td>类型的 <strong>lifetime bound</strong>，如果 <code>T</code> 存在引用，则必须比 <code>'a</code> 更久</td></tr>
<tr><td>  <code>T: 'static</code></td><td>同上，特别是不意味着 <code>T</code> 将会 <code>'static</code>，仅可以会 <code>'static</code></td></tr>
<tr><td>  <code>'b: 'a</code></td><td><code>'b</code> 的生命周期必须存活至少为 <code>'a</code></td></tr>
<tr><td><code>S&lt;const N: usize&gt;</code></td><td><strong>Generic const bound</strong>，类型 <code>S</code> 的使用者可以提供常量值 <code>N</code></td></tr>
<tr><td>  <code>S&lt;10&gt;</code></td><td>在使用时，常量边界可以作为原始值提供</td></tr>
<tr><td>  <code>S&lt;{5+5}&gt;</code></td><td>表达式必须放在大括号中</td></tr>
<tr><td><code>S&lt;T&gt; where T: R</code></td><td>几乎和 <code>S&lt;T: R&gt;</code> 一样，但语法越长越易于阅读</td></tr>
<tr><td>  <code>S&lt;T&gt; where u8: R&lt;T&gt;</code></td><td>允许创建生成其它类型的条件语句</td></tr>
<tr><td><code>S&lt;T = R&gt;</code></td><td><strong>Default parameters</strong>，更容易使用，但也很灵活</td></tr>
<tr><td>  <code>S&lt;const N: u8 = 0&gt;</code></td><td>默认参数是常量，如 <code>f(x: S) {}</code> 中参数 <code>N</code> 是 <code>0</code></td></tr>
<tr><td>  <code>S&lt;T = u8&gt;</code></td><td>默认参数是类型，如 <code>f(x: S) {}</code> 中参数 <code>T</code> 是 <code>u8</code></td></tr>
<tr><td><code>S&lt;'_&gt;</code></td><td><strong>anonymous lifetime</strong>，如果可以明显的看出来，会要求编译器推断出来</td></tr>
<tr><td><code>S&lt;_&gt;</code></td><td><strong>anonymous type</strong>，如 <code>let x: Vec&lt;_&gt; = iter.collect()</code> 一样</td></tr>
<tr><td><code>S::&lt;T&gt;</code></td><td><strong>Turbofish</strong> 会调用类型消除歧义，如 <code>f::&lt;u32&gt;()</code> 一样</td></tr>
<tr><td><code>trait T&lt;X&gt; {}</code></td><td>基于 <code>X</code> 之上的一个特征泛型，可以有多个 <code>impl T for S</code>（一对 <code>X</code>）</td></tr>
<tr><td><code>trait T { type X; }</code></td><td>定义 <strong>关联类型</strong> <code>X</code>，仅 <code>impl T for S</code> 的一种可能</td></tr>
<tr><td>  <code>type X = R;</code></td><td>在 <code>impl T for S { type X = R; }</code> 中设置关联类型</td></tr>
<tr><td><code>impl&lt;T&gt; S&lt;T&gt; {}</code></td><td>为在 <code>S&lt;T&gt;</code> 中任意的 <code>T</code> 实现功能，<code>T</code> 是类型参数</td></tr>
<tr><td><code>impl S&lt;T&gt; {}</code></td><td>完全为 <code>S&lt;T&gt;</code> 实现功能，<code>T</code> 是指定类型（如 <code>S&lt;u32&gt;</code>）</td></tr>
<tr><td><code>fn f() -&gt; impl T</code></td><td><strong>Existential types</strong>，返回一个 <code>impl T</code> 的未知调用者 <code>S</code></td></tr>
<tr><td><code>fn f(x: &amp;impl T)</code></td><td>Trait bound <strong>impl traits</strong>， 类似于 <code>fn f&lt;S:T&gt;(x: &amp;S)</code></td></tr>
<tr><td><code>fn f(x: &amp;dyn T)</code></td><td><strong>dynamic dispatch</strong> 的标记，<code>f</code> 不会被单态化（<strong>monomorphized</strong>）</td></tr>
<tr><td><code>fn f() where Self: R;</code></td><td>在 <code>trait T {}</code> 中，使 <code>f</code> 仅可访问 <code>impl R</code> 的已知类型</td></tr>
<tr><td>  <code>fn f() where Self: Sized;</code></td><td>使用 <code>Sized</code> 可以从 <code>dyn T</code> trait object vtable 中选出 <code>f</code>，启用 trait object</td></tr>
<tr><td>  <code>fn f() where Self: R {}</code></td><td>其它 <code>R</code> 有用的 <code>w. dflt</code>，方法（<code>non dflt</code> 无论怎样都需要被实现）</td></tr>
</tbody></table>
<h2 id="higher-ranked-例子"><a class="header" href="#higher-ranked-例子">Higher-Ranked 例子</a></h2>
<ul>
<li>实际的类型和特征，抽象于一些东西，通常是生命周期</li>
</ul>
<table><thead><tr><th>例子</th><th>解释</th></tr></thead><tbody>
<tr><td><code>for&lt;'a&gt;</code></td><td><strong>higher-ranked bounds</strong> 的标记</td></tr>
<tr><td>  <code>trait T: for&lt;'a&gt; R&lt;'a&gt; {}</code></td><td>任何 <code>impl T</code> 的 <code>S</code> 都必须为了整个生命周期满足 <code>R</code></td></tr>
<tr><td><code>fn(&amp;'a u8)</code></td><td>函数指针类型持有 <code>fn</code> 可调用的指定的生命周期</td></tr>
<tr><td><code>for&lt;'a&gt; fn(&amp;'a u8)</code></td><td><strong>Higher-ranked type</strong> 持有 <code>fn</code> 可调用的任何上面的子类型</td></tr>
<tr><td>  <code>fn(&amp;'_ u8)</code></td><td>同上，自动展开到类型 <code>for&lt;'a&gt; fn(&amp;'a u8)</code></td></tr>
<tr><td>  <code>fn(&amp;u8)</code></td><td>同上，自动展开到类型 <code>for&lt;'a&gt; fn(&amp;'a u8)</code></td></tr>
<tr><td><code>dyn for&lt;'a&gt; Fn(&amp;'a u8)</code></td><td><strong>Higher-ranked</strong>（trait-object）类型，像上面的 <code>fn</code> 一样</td></tr>
<tr><td>  <code>dyn Fn(&amp;'_ u8)</code></td><td>同上，自动展开到类型 <code>dyn for&lt;'a&gt; Fn(&amp;'a u8)</code></td></tr>
<tr><td>  <code>dyn Fn(&amp;u8)</code></td><td>同上，自动展开到类型 <code>dyn for&lt;'a&gt; Fn(&amp;'a u8)</code></td></tr>
</tbody></table>
<p><sup>*</sup> <code>for&lt;&gt;</code> 是类型的一种，下面展示了 <code>impl T for for&lt;'a&gt; fn(&amp;'a u8)</code> 这样的写法</p>
<table><thead><tr><th>实现特征</th><th>解释</th></tr></thead><tbody>
<tr><td><code>impl&lt;'a&gt; T for fn(&amp;'a u8) {}</code></td><td>对于指针 <code>fn</code>，其中调用接受指定的 <code>'a</code>， imple trait <code>T</code></td></tr>
<tr><td><code>impl T for for&lt;'a&gt; fn(&amp;'a u8) {}	</code></td><td>对于指针 <code>fn</code>，其中调用接受任何的 imple trait <code>T</code></td></tr>
<tr><td>  <code>impl T for fn(&amp;u8) {}</code></td><td>同上，简写版</td></tr>
</tbody></table>
<h2 id="字符串和字符"><a class="header" href="#字符串和字符">字符串和字符</a></h2>
<ul>
<li>Rust 有几种创建文本值的方法</li>
</ul>
<table><thead><tr><th>例子</th><th>解释</th></tr></thead><tbody>
<tr><td><code>&quot;...&quot;</code></td><td>字符串文本，UTF-8 将解释 <code>\n</code> 为换行符</td></tr>
<tr><td><code>r&quot;...&quot;</code></td><td>原始字符串文本，UTF-8 不会解释 <code>\n</code></td></tr>
<tr><td><code>r#&quot;...&quot;#</code></td><td>原始字符串文本，UTF-8 也可以包含 <code>&quot;</code>，<code>#</code> 数量是可变的</td></tr>
<tr><td><code>b&quot;...&quot;</code></td><td>字节字符串文本，构造 ASCII <code>[u8]</code> ，不是字符串</td></tr>
<tr><td><code>br&quot;...&quot;, br#&quot;...&quot;#</code></td><td>原始字节字符串文本，ASCII <code>[u8]</code>，以上的组合</td></tr>
<tr><td><code>'🦀'</code></td><td>字符文本，固定 4 字节的 unicode <code>char</code></td></tr>
<tr><td><code>b'x'</code></td><td>ASCII 字节文本</td></tr>
</tbody></table>
<h2 id="文档注释"><a class="header" href="#文档注释">文档注释</a></h2>
<table><thead><tr><th>例子</th><th>解释</th></tr></thead><tbody>
<tr><td><code>///</code></td><td>外部文档注释，通常用于类型、特征、函数</td></tr>
<tr><td><code>//!</code></td><td>内行文档注释，主要用于文件到文档模块的开头</td></tr>
<tr><td><code>//</code></td><td>行注释，使用这些来记录代码流或内部结构</td></tr>
<tr><td><code>/*...*/</code></td><td>块注释</td></tr>
<tr><td><code>/**...*/</code></td><td>外部块文档注释</td></tr>
<tr><td><code>/*!...*/</code></td><td>内部块文档注释</td></tr>
</tbody></table>
<h2 id="其它杂项"><a class="header" href="#其它杂项">其它杂项</a></h2>
<ul>
<li>这些符号不属于任何其他类别，但知道了还是很好</li>
</ul>
<table><thead><tr><th>例子</th><th>解释</th></tr></thead><tbody>
<tr><td><code>!</code></td><td>始终为空</td></tr>
<tr><td><code>_</code></td><td>未命名的通配符变量绑定，例如 <code>|x, _| {}</code></td></tr>
<tr><td>  <code>let _ = x;</code></td><td>未命名的分配是不执行的，不会 <strong>move out x</strong> 或保留目标值</td></tr>
<tr><td><code>_x</code></td><td>变量绑定明确标记为未使用</td></tr>
<tr><td><code>1_234_567</code></td><td>用于可清晰分辨的数字分隔符</td></tr>
<tr><td><code>1_u8</code></td><td><strong>数字文本</strong> 的类型说明符（还可以是 <code>i8</code>，<code>u16</code> …）</td></tr>
<tr><td><code>0xBEEF, 0o777, 0b1001</code></td><td>十六进制（<code>0x</code>）、八进制（<code>0o</code>）和二进（<code>0b</code>）的整数文本</td></tr>
<tr><td><code>r#foo</code></td><td>用于版本兼容的原始标识符</td></tr>
<tr><td><code>x;</code></td><td>语句终止符或表达式</td></tr>
</tbody></table>
<h2 id="常用运算符"><a class="header" href="#常用运算符">常用运算符</a></h2>
<p>Rust 支持大多数运算符（<code>+</code>，<code>*</code>，<code>%</code>，<code>=</code>，<code>==</code>，...），包括重载。因为它们在 Rust 中的行为没有什么不同，所以就不在此处列出它们。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust标准库"><a class="header" href="#rust标准库">Rust标准库</a></h1>
<h2 id="单线程"><a class="header" href="#单线程">单线程</a></h2>
<ul>
<li>常见的需求但容易忘记的代码片段</li>
</ul>
<table><thead><tr><th><strong>字符串</strong> 需求</th><th>代码片段</th></tr></thead><tbody>
<tr><td>拼接字符串（任何实现了 <code>Display</code>）</td><td><code>format!(&quot;{x}{y}&quot;)</code></td></tr>
<tr><td>追加字符串（任何实现了 <code>Display</code> 到 任何实现了 <code>Write</code>）</td><td><code>write!(x, &quot;{y}&quot;)</code></td></tr>
<tr><td>按分隔符模式分割</td><td><code>s.split(pattern)</code></td></tr>
<tr><td>  ...with <code>&amp;str</code></td><td><code>s.split(&quot;abc&quot;)</code></td></tr>
<tr><td>  ...with <code>char</code></td><td><code>s.split('/')</code></td></tr>
<tr><td>  ...with <code>closure</code></td><td><code>s.split(char::is_numeric)</code></td></tr>
<tr><td>按空格切割</td><td><code>s.split_whitespace()</code></td></tr>
<tr><td>用换行符分割</td><td><code>s.lines()</code></td></tr>
<tr><td>按正则表达式分割</td><td><code>Regex::new(r&quot;\s&quot;)?.split(&quot;one two three&quot;)</code></td></tr>
</tbody></table>
<ol>
<li>如果 <code>x</code> 或 <code>y</code> 之后不打算用到，考虑使用 <code>write!</code> 或 <code>std::ops::Add</code></li>
<li>需要 <a href="https://crates.io/crates/regex">regex</a> crate </li>
</ol>
<br>
<table><thead><tr><th><strong>I/O</strong> 需求</th><th>代码片段</th></tr></thead><tbody>
<tr><td>创建一个新文件</td><td><code>File::create(PATH)?</code></td></tr>
<tr><td>通过<strong>OpenOptions</strong>创建</td><td><code>OpenOptions::new().create(true).write(true).truncate(true).open(PATH)?</code></td></tr>
</tbody></table>
<br>
<table><thead><tr><th><strong>宏</strong> 需求</th><th>代码片段</th></tr></thead><tbody>
<tr><td>宏 可变参数</td><td><code>macro_rules! var_args { ($($args:expr),*) =&gt; {{ }} }</code></td></tr>
<tr><td>  使用参数，如多次调用 <code>f</code></td><td><code>$( f($args); )*</code></td></tr>
</tbody></table>
<br>
<table><thead><tr><th><strong>Esoterics</strong> 需求</th><th>代码片段</th></tr></thead><tbody>
<tr><td>干净的闭包捕获</td><td><code>wants_closure({ let c = outer.clone(); move || use_clone(c) })</code></td></tr>
<tr><td>在 <code>try</code> 闭包中的修复推断</td><td><code>iter.try_for_each(|x| { Ok::&lt;(), Error&gt;(()) })?;</code></td></tr>
<tr><td>如果 <code>T</code> 实现了 Copy，则可迭代和编辑 <code>&amp;mut [T]</code></td><td><code>Cell::from_mut(mut_slice).as_slice_of_cells()</code></td></tr>
<tr><td>获取带有长度的子切片</td><td><code>&amp;original_slice[offset..][..length]</code></td></tr>
<tr><td>敏锐的确保特征 <code>T</code> 是对象安全的</td><td><code>const _: Option&lt;&amp;dyn T&gt; = None;</code></td></tr>
</tbody></table>
<h2 id="线程安全"><a class="header" href="#线程安全">线程安全</a></h2>
<table><thead><tr><th>例子</th><th><code>Send*</code></th><th><code>!Send</code></th></tr></thead><tbody>
<tr><td><code>Sync*</code></td><td>大多数类型是 ...<code>Arc&lt;T&gt;1,2</code>， <code>Mutex&lt;T&gt;</code></td><td><code>MutexGuard&lt;T&gt;</code>，<code>RwLockReadGuard&lt;T&gt;</code></td></tr>
<tr><td><code>!Sync</code></td><td><code>Cell&lt;T&gt;2</code>，<code>RefCell&lt;T&gt;</code></td><td><code>Rc&lt;T&gt;</code>，<code>&amp;dyn Trait</code>，<code>*const T</code>，<code>*mut T</code></td></tr>
</tbody></table>
<p><sup>*</sup>一个 <code>T: Send</code> 的实例可以被移动到另一个线程，而一个 <code>T: Sync</code> 意味着 <code>&amp;t</code> 可以被移动到移动到另一个线程</p>
<ol>
<li>如果 <code>T</code> 是 <code>Sync</code></li>
<li>如果 <code>T</code> 是 <code>Send</code></li>
<li>如果你需要去 send 一个裸指针，创建一个新类型 <code>struct Ptr(*const u8)</code> 和 <code>unsafe impl Send for Ptr {}</code>，仅需确保你可以 send 它</li>
</ol>
<h2 id="迭代器"><a class="header" href="#迭代器">迭代器</a></h2>
<table>
<tr>
<td align="center">获取迭代器</td>
</tr>
<tr>
<td><b>基本用法</b><br>
假设有一个类型 <code>C</code> 的集合<b>c</b>：
<li><code>c.into_iter()</code> — 将集合<b>c</b>转换为一个<b>Iterator</b><b>i</b>和<b>consumes</b><b>c</b>。需要实现了 <code>C</code> 的<b>IntoIterator</b>。条目的类型取决于 <code>C</code> 是什么。获取迭代器的"标准化"方法</li>
<li><code>c.iter()</code> — 一些集合提供的优雅方法，返回借用的迭代器，不会消耗 <code>c</code> </li>
<li><code>c.iter_mut()</code> — 同上，但是可变借用的迭代器允许更改集合</li>
</td>
</tr>
<tr>
<td><b>The Iterator</b><br>
一旦你有一个 <code>i</code>:
<li><code>i.next()</code> — 返回下一个元素c提供的 <code>Some(x)</code>，或者如果已经完成了则返回<code>None</code> </li>
</td>
</tr>
<tr>
<td><b>For 循环</b>
<li><code>for x in c {}</code> — 语法糖，调用<code>c.into_iter()</code>并且循环i直到为 <code>None</code> </li>
</td>
</tr>
</table>
<p><sup>*</sup>如果它看起来好像没有消耗 <code>c</code>，那是因为类型是 <code>Copy</code>，如 如果你调用 <code>(&amp;c).into_iter()</code>，它将在 <code>&amp;c</code> 上调用 <code>into_iter()</code> （这将消耗引用并将其转换为迭代器），但c仍保持不变。</p>
<br>
<table>
<tr>
<td align="center">实现迭代器</td>
</tr>
<tr>
<td><b>基本用法</b><br>
假设你有一个 `struct Collection<T> {}`
<li><code>struct IntoIter<T> {}</code> — 创建一个结构来保存你的迭代状态(如 索引)以进行值的迭代</li>
<li><code>impl Iterator for IntoIter {}</code> — 实现 <code>Iterator::next()</code>，这样它就可以生成元素</li>
<code>Collection&lt;T&gt;</code><br>
<code>IntoIter&lt;T&gt;</code> <code>⌾Iterator</code> <code>Item = T;</code>
</td>
</tr>
<tr>
<td><b>共享的和可变迭代器</b>
<li><code>struct Iter&lt;T&gt; {}</code> — 为共享迭代器去创建持有 <code>&Collection&lt;T&gt;</code> 的结构</li>
<li><code>struct IterMut&lt;T&gt; {}</code> — 同上，为了可变迭代器去创建持有 <code>&mut Collection&lt;T&gt;</code> 的结构</li>
<li><code>impl Iterator for Iter<T> {}</code> — 实现共享迭代器</li>
<li><code>impl Iterator for IterMut<T> {}</code> — 实现可变迭代器</li>
另外你可能会希望添加一些便捷的方法
<li><code>Collection::iter(&self) -> Iter</code></li>
<li><code>Collection::iter_mut(&mut self) -> IterMut</code></li>
<code>Iter&lt;T&gt;</code> <code>⌾Iterator</code> <code>Item = &T;</code><br>
<code>IterMut&lt;T&gt;</code> <code>⌾Iterator</code> <code>Item = &mut T;</code>
</td>
</tr>
<tr>
<td><b>使用循环的写法</b>
<li><code>impl IntoIterator for Collection {}</code> — 现在<code>for x in c {}</code>是有用的
<li><code>impl IntoIterator for &Collection {}</code> — 现在<code>for x in &c {}</code>是有用的
<li><code>impl IntoIterator for &mut Collection {}</code> — 现在<code>for x in &mut c {}</code>是有用的
<code>Collection&lt;T&gt;</code> <code>⌾IntoIterator</code> <code>Item = T;</code> <code>To = IntoIter&lt;T&gt;</code> Iterate over <code>T</code> <br>
<code>&Collection&lt;T&gt;</code> <code>⌾IntoIterator</code> <code>Item = &T;</code> <code>To = Iter&lt;T&gt;</code> Iterate over <code>&T</code> <br>
<code>&mut Collectn&lt;T&gt;</code> <code>⌾IntoIterator</code> <code>Item = &mut T;</code> <code>To = IterMut&lt;T&gt;</code> Iterate over <code>&mut T</code>
</tr>
</table>
<h2 id="数字转换"><a class="header" href="#数字转换">数字转换</a></h2>
<table><thead><tr><th>需要转换成的→</th><th><code>u8 … i128</code></th><th><code>f32 / f64</code></th><th><strong><code>String</code></strong></th></tr></thead><tbody>
<tr><td><code>u8 … i128</code></td><td><code>u8::try_from(x)?</code></td><td><code>x as f32</code></td><td><code>x.to_string()</code></td></tr>
<tr><td><code>f32 / f64</code></td><td><code>x as u8</code></td><td><code>x as f32</code></td><td><code>x.to_string()</code></td></tr>
<tr><td><code>String</code></td><td><code>x.parse::&lt;u8&gt;()?</code></td><td><code>x.parse::&lt;f32&gt;()?</code></td><td><code>x</code></td></tr>
</tbody></table>
<ol>
<li>如果打印是正确的话 <code>from()</code>会直接输出，如 <code>u32::from(my_u8)</code></li>
<li>截断(<code>11.9_f32 as u8 gives 11</code>)，充满(<code>1024_f32 as u8 gives 255</code>)</li>
<li>可能会有不合适的数字(<code>u64::MAX as f32</code>)或产生 <code>Inf</code> (<code>u128::MAX as f32</code>)</li>
</ol>
<h2 id="字符串转换"><a class="header" href="#字符串转换">字符串转换</a></h2>
<ul>
<li>如果你想要一个指定类型的字符串</li>
</ul>
<table><thead><tr><th>已经存在的类型 <code>x</code></th><th>要转换成 <strong>String</strong></th></tr></thead><tbody>
<tr><td><code>String</code></td><td><code>x</code></td></tr>
<tr><td><code>CString</code></td><td><code>x.into_string()?</code></td></tr>
<tr><td><code>OsString</code></td><td><code>x.to_str()?.to_string()</code></td></tr>
<tr><td><code>PathBuf</code></td><td><code>x.to_str()?.to_string()</code></td></tr>
<tr><td><code>Vec&lt;u8&gt;</code></td><td><code>String::from_utf8(x)?</code></td></tr>
<tr><td><code>&amp;str</code></td><td><code>x.to_string()</code></td></tr>
<tr><td><code>&amp;CStr</code></td><td><code>x.to_str()?.to_string()</code></td></tr>
<tr><td><code>&amp;OsStr</code></td><td><code>x.to_str()?.to_string()</code></td></tr>
<tr><td><code>&amp;Path</code></td><td><code>x.to_str()?.to_string()</code></td></tr>
<tr><td><code>&amp;[u8]</code></td><td><code>String::from_utf8_lossy(x).to_string()</code></td></tr>
</tbody></table>
<br>
<table><thead><tr><th>已存在的类型 <code>x</code></th><th>要转换成 <strong>CString</strong></th></tr></thead><tbody>
<tr><td><code>String</code></td><td><code>CString::new(x)?</code></td></tr>
<tr><td><code>CString</code></td><td><code>x</code></td></tr>
<tr><td><code>OsString</code></td><td><code>CString::new(x.to_str()?)?</code></td></tr>
<tr><td><code>PathBuf</code></td><td><code>CString::new(x.to_str()?)?</code></td></tr>
<tr><td><code>Vec&lt;u8&gt;</code></td><td><code>CString::new(x)?</code></td></tr>
<tr><td><code>&amp;str</code></td><td><code>CString::new(x)?</code></td></tr>
<tr><td><code>&amp;CStr</code></td><td><code>x.to_owned()</code></td></tr>
<tr><td><code>&amp;OsStr</code></td><td><code>CString::new(x.to_os_string().into_string()?)?</code></td></tr>
<tr><td><code>&amp;Path</code></td><td><code>CString::new(x.to_str()?)?</code></td></tr>
<tr><td><code>&amp;[u8]</code></td><td><code>CString::new(Vec::from(x))?</code></td></tr>
<tr><td><code>*mut c_char</code></td><td><code>unsafe { CString::from_raw(x) }</code></td></tr>
</tbody></table>
<br>
<table><thead><tr><th>已存在的类型 <code>x</code></th><th>要转换成 <strong>OsString</strong></th></tr></thead><tbody>
<tr><td><code>String</code></td><td><code>OsString::from(x)</code></td></tr>
<tr><td><code>CString</code></td><td><code>OsString::from(x.to_str()?)</code></td></tr>
<tr><td><code>OsString</code></td><td><code>x</code></td></tr>
<tr><td><code>PathBuf</code></td><td><code>x.into_os_string()</code></td></tr>
<tr><td><code>Vec&lt;u8&gt;</code></td><td><code>?</code></td></tr>
<tr><td><code>&amp;str</code></td><td><code>OsString::from(x)</code></td></tr>
<tr><td><code>&amp;CStr</code></td><td><code>OsString::from(x.to_str()?)</code></td></tr>
<tr><td><code>&amp;OsStr</code></td><td><code>OsString::from(x)</code></td></tr>
<tr><td><code>&amp;Path</code></td><td><code>x.as_os_str().to_owned()</code></td></tr>
<tr><td><code>&amp;[u8]</code></td><td><code>?</code></td></tr>
</tbody></table>
<br>
<table><thead><tr><th>已存在的类型 <code>x</code></th><th>要转换成 <strong>PathBuf</strong></th></tr></thead><tbody>
<tr><td><code>String</code></td><td><code>PathBuf::from(x)</code></td></tr>
<tr><td><code>CString</code></td><td><code>PathBuf::from(x.to_str()?)</code></td></tr>
<tr><td><code>OsString</code></td><td><code>PathBuf::from(x)</code></td></tr>
<tr><td><code>PathBuf</code></td><td><code>x</code></td></tr>
<tr><td><code>Vec&lt;u8&gt;</code></td><td><code>?</code></td></tr>
<tr><td><code>&amp;str</code></td><td><code>PathBuf::from(x)</code></td></tr>
<tr><td><code>&amp;CStr</code></td><td><code>PathBuf::from(x.to_str()?)</code></td></tr>
<tr><td><code>&amp;OsStr</code></td><td><code>PathBuf::from(x)</code></td></tr>
<tr><td><code>&amp;Path</code></td><td><code>PathBuf::from(x)</code></td></tr>
<tr><td><code>&amp;[u8]</code></td><td><code>?</code></td></tr>
</tbody></table>
<br>
<table><thead><tr><th>已存在的类型 <code>x</code></th><th>要转换成 <strong>PathBuf</strong></th></tr></thead><tbody>
<tr><td><code>String</code></td><td><code>PathBuf::from(x)</code></td></tr>
<tr><td><code>CString</code></td><td><code>PathBuf::from(x.to_str()?)</code></td></tr>
<tr><td><code>OsString</code></td><td><code>PathBuf::from(x)</code></td></tr>
<tr><td><code>PathBuf</code></td><td><code>x</code></td></tr>
<tr><td><code>Vec&lt;u8&gt;</code></td><td><code>?</code></td></tr>
<tr><td><code>&amp;str</code></td><td><code>PathBuf::from(x)</code></td></tr>
<tr><td><code>&amp;CStr</code></td><td><code>PathBuf::from(x.to_str()?)</code></td></tr>
<tr><td><code>&amp;OsStr</code></td><td><code>PathBuf::from(x)</code></td></tr>
<tr><td><code>&amp;Path</code></td><td><code>PathBuf::from(x)</code></td></tr>
<tr><td><code>&amp;[u8]</code></td><td><code>?</code></td></tr>
</tbody></table>
<br>
<table><thead><tr><th>已存在的类型 <code>x</code></th><th>要转换成 <strong>Vec<u8></strong></th></tr></thead><tbody>
<tr><td><code>String</code></td><td><code>x.into_bytes()</code></td></tr>
<tr><td><code>CString</code></td><td><code>x.into_bytes()</code></td></tr>
<tr><td><code>OsString</code></td><td><code>?</code></td></tr>
<tr><td><code>PathBuf</code></td><td><code>?</code></td></tr>
<tr><td><code>Vec&lt;u8&gt;</code></td><td><code>x</code></td></tr>
<tr><td><code>&amp;str</code></td><td><code>Vec::from(x.as_bytes())</code></td></tr>
<tr><td><code>&amp;CStr</code></td><td><code>Vec::from(x.to_bytes_with_nul())</code></td></tr>
<tr><td><code>&amp;OsStr</code></td><td><code>?</code></td></tr>
<tr><td><code>&amp;Path</code></td><td><code>?</code></td></tr>
<tr><td><code>&amp;[u8]</code></td><td><code>x.to_vec()</code></td></tr>
</tbody></table>
<br>
<table><thead><tr><th>已存在的类型 <code>x</code></th><th>要转换成 <strong>&amp;str</strong></th></tr></thead><tbody>
<tr><td><code>String</code></td><td><code>x.as_str()</code></td></tr>
<tr><td><code>CString</code></td><td><code>x.to_str()?</code></td></tr>
<tr><td><code>OsString</code></td><td><code>x.to_str()?</code></td></tr>
<tr><td><code>PathBuf</code></td><td><code>x.to_str()?</code></td></tr>
<tr><td><code>Vec&lt;u8&gt;</code></td><td><code>std::str::from_utf8(&amp;x)?</code></td></tr>
<tr><td><code>&amp;str</code></td><td><code>x</code></td></tr>
<tr><td><code>&amp;CStr</code></td><td><code>x.to_str()?</code></td></tr>
<tr><td><code>&amp;OsStr</code></td><td><code>x.to_str()?</code></td></tr>
<tr><td><code>&amp;Path</code></td><td><code>x.to_str()?</code></td></tr>
<tr><td><code>&amp;[u8]</code></td><td><code>std::str::from_utf8(x)?</code></td></tr>
</tbody></table>
<br>
<table><thead><tr><th>已存在的类型 <code>x</code></th><th>要转换成 <strong>&amp;CStr</strong></th></tr></thead><tbody>
<tr><td><code>String</code></td><td><code>CString::new(x)?.as_c_str()</code></td></tr>
<tr><td><code>CString</code></td><td><code>x.as_c_str()</code></td></tr>
<tr><td><code>OsString</code></td><td><code>x.to_str()?</code></td></tr>
<tr><td><code>PathBuf</code></td><td><code>?,4</code></td></tr>
<tr><td><code>Vec&lt;u8&gt;</code></td><td><code>CStr::from_bytes_with_nul(&amp;x)?</code></td></tr>
<tr><td><code>&amp;str</code></td><td><code>?,4</code></td></tr>
<tr><td><code>&amp;CStr</code></td><td><code>x</code></td></tr>
<tr><td><code>&amp;OsStr</code></td><td><code>?</code></td></tr>
<tr><td><code>&amp;Path</code></td><td><code>?</code></td></tr>
<tr><td><code>&amp;[u8]</code></td><td><code>?</code></td></tr>
</tbody></table>
<br>
<table><thead><tr><th>已存在的类型 <code>x</code></th><th>要转换成 <strong>PathBuf</strong></th></tr></thead><tbody>
<tr><td><code>String</code></td><td><code>PathBuf::from(x)</code></td></tr>
<tr><td><code>CString</code></td><td><code>PathBuf::from(x.to_str()?)</code></td></tr>
<tr><td><code>OsString</code></td><td><code>PathBuf::from(x)</code></td></tr>
<tr><td><code>PathBuf</code></td><td><code>x</code></td></tr>
<tr><td><code>Vec&lt;u8&gt;</code></td><td><code>?</code></td></tr>
<tr><td><code>&amp;str</code></td><td><code>PathBuf::from(x)</code></td></tr>
<tr><td><code>&amp;CStr</code></td><td><code>PathBuf::from(x.to_str()?)</code></td></tr>
<tr><td><code>&amp;OsStr</code></td><td><code>PathBuf::from(x)</code></td></tr>
<tr><td><code>&amp;Path</code></td><td><code>PathBuf::from(x)</code></td></tr>
<tr><td><code>&amp;[u8]</code></td><td><code>CStr::from_bytes_with_nul(x)?</code></td></tr>
<tr><td><code>*const c_char</code></td><td><code>unsafe { CStr::from_ptr(x) }</code></td></tr>
</tbody></table>
<br>
<table><thead><tr><th>已存在的类型 <code>x</code></th><th>要转换成 <strong>&amp;OsStr</strong></th></tr></thead><tbody>
<tr><td><code>String</code></td><td><code>OsStr::new(&amp;x)</code></td></tr>
<tr><td><code>CString</code></td><td><code>?</code></td></tr>
<tr><td><code>OsString</code></td><td><code>x.as_os_str()</code></td></tr>
<tr><td><code>PathBuf</code></td><td><code>x.as_os_str()</code></td></tr>
<tr><td><code>Vec&lt;u8&gt;</code></td><td><code>?</code></td></tr>
<tr><td><code>&amp;str</code></td><td><code>OsStr::new(x)</code></td></tr>
<tr><td><code>&amp;CStr</code></td><td><code>?</code></td></tr>
<tr><td><code>&amp;OsStr</code></td><td><code>x</code></td></tr>
<tr><td><code>&amp;Path</code></td><td><code>x.as_os_str()</code></td></tr>
<tr><td><code>&amp;[u8]</code></td><td><code>?</code></td></tr>
</tbody></table>
<br>
<table><thead><tr><th>已存在的类型 <code>x</code></th><th>要转换成 <strong>&amp;Path</strong></th></tr></thead><tbody>
<tr><td><code>String</code></td><td><code>Path::new(x)</code></td></tr>
<tr><td><code>CString</code></td><td><code>Path::new(x.to_str()?)</code></td></tr>
<tr><td><code>OsString</code></td><td><code>Path::new(x.to_str()?)</code></td></tr>
<tr><td><code>PathBuf</code></td><td><code>Path::new(x.to_str()?)</code></td></tr>
<tr><td><code>Vec&lt;u8&gt;</code></td><td><code>?</code></td></tr>
<tr><td><code>&amp;str</code></td><td><code>Path::new(x)</code></td></tr>
<tr><td><code>&amp;CStr</code></td><td><code>Path::new(x.to_str()?)</code></td></tr>
<tr><td><code>&amp;OsStr</code></td><td><code>Path::new(x)</code></td></tr>
<tr><td><code>&amp;Path</code></td><td><code>x</code></td></tr>
<tr><td><code>&amp;[u8]</code></td><td><code>?</code></td></tr>
</tbody></table>
<br>
<table><thead><tr><th>已存在的类型 <code>x</code></th><th>要转换成 <strong>&amp;[u8]</strong></th></tr></thead><tbody>
<tr><td><code>String</code></td><td><code>x.as_bytes()</code></td></tr>
<tr><td><code>CString</code></td><td><code>x.as_bytes()</code></td></tr>
<tr><td><code>OsString</code></td><td><code>?</code></td></tr>
<tr><td><code>PathBuf</code></td><td><code>?</code></td></tr>
<tr><td><code>Vec&lt;u8&gt;</code></td><td><code>&amp;x</code></td></tr>
<tr><td><code>&amp;str</code></td><td><code>x.as_bytes()</code></td></tr>
<tr><td><code>&amp;CStr</code></td><td><code>x.to_bytes_with_nul()</code></td></tr>
<tr><td><code>&amp;OsStr</code></td><td><code>x.as_bytes()</code></td></tr>
<tr><td><code>&amp;Path</code></td><td><code>?</code></td></tr>
<tr><td><code>&amp;[u8]</code></td><td><code>x</code></td></tr>
</tbody></table>
<br>
<table><thead><tr><th>已存在的类型 <code>x</code></th><th>要转换成 <strong>Other</strong>( <code>*const c_char</code> )</th></tr></thead><tbody>
<tr><td><code>CString</code></td><td><code>x.as_ptr()</code> ( <code>*const c_char</code> )</td></tr>
</tbody></table>
<p><sup>*</sup>如果类型能被推断出来则可使用简写 <code>x.into()</code></p>
<p><sup>*</sup>如果类型能被推断出来则可使用简写 <code>x.as_ref()</code></p>
<ol>
<li>如果调用了<strong>unsafe</strong>，你应该或必须确保原始数据带有字符串类型的有效表示(如 一个 <code>UTF-8</code> 的字符串)</li>
<li>仅在一些平台( <code>std::os::&lt;your_os&gt;::ffi::OsStrExt</code> )存在辅助方法去获取底层 <code>OsStr</code> 的原始表示。从那里使用表格的其它部分，如下</li>
</ol>
<pre><code class="language-rust editable noplayground">use std::os::unix::ffi::OsStrExt;
let bytes: &amp;[u8] = my_os_str.as_bytes();
CString::new(bytes)?
</code></pre>
<ol start="3">
<li><code>c_char</code> 必须来自之前的 <code>CString</code>，如果来自FFI，请参阅 <code>&amp;CStr</code></li>
<li><code>x</code> 因为缺少终止符 <code>0x0</code>，没有已知的简写，可能最好的方式是通过 <code>CString</code></li>
<li>必须确保向量实际上以 <code>0x0</code> 结尾</li>
</ol>
<h2 id="字符串输出"><a class="header" href="#字符串输出">字符串输出</a></h2>
<h3 id="apis"><a class="header" href="#apis">APIs</a></h3>
<ul>
<li>Rust使用这些APIs将类型转换为字符串化输出，统称为格式宏</li>
</ul>
<table><thead><tr><th>宏</th><th>输出</th><th>备注</th></tr></thead><tbody>
<tr><td><code>format!(fmt)</code></td><td><code>String</code></td><td>&quot;to String&quot; 的转换器</td></tr>
<tr><td><code>print!(fmt)</code></td><td>Console</td><td>写到标准输出</td></tr>
<tr><td><code>println!(fmt)</code></td><td>Console</td><td>写到标准输出，换行</td></tr>
<tr><td><code>eprint!(fmt)</code></td><td>Console</td><td>写到标准错误输出</td></tr>
<tr><td><code>eprintln!(fmt)</code></td><td>Console</td><td>写到标准错误输出，换行</td></tr>
<tr><td><code>write!(dst, fmt)</code></td><td>Buffer</td><td>还有 <code>use std::io::Write;</code></td></tr>
<tr><td><code>writeln!(dst, fmt)</code></td><td>Buffer</td><td>还有 <code>use std::io::Write;</code>，换行</td></tr>
</tbody></table>
<br>
<table><thead><tr><th>方法</th><th>备注</th></tr></thead><tbody>
<tr><td><code>x.to_string()</code></td><td>生成 <code>String</code>，实现任何的 <code>Display</code> 类型</td></tr>
</tbody></table>
<p><sup>*</sup>这 <code>fmt</code> 是字符串文字，例如 <code>&quot;hello {}&quot;</code>，指定输出和其他参数</p>
<h3 id="可打印的类型"><a class="header" href="#可打印的类型">可打印的类型</a></h3>
<p><sup>*</sup>在友好的 <code>format!</code> 中，类型通过 <code>trait Display &quot;{}&quot;</code> 或 <code>Debug &quot;{:?}&quot;</code> 转换，非详尽列表如下</p>
<table><thead><tr><th>类型</th><th>实现</th></tr></thead><tbody>
<tr><td><code>String</code></td><td><code>Debug, Display</code></td></tr>
<tr><td><code>CString</code></td><td><code>Debug</code></td></tr>
<tr><td><code>OsString</code></td><td><code>Debug</code></td></tr>
<tr><td><code>PathBuf</code></td><td><code>Debug</code></td></tr>
<tr><td><code>Vec&lt;u8&gt;</code></td><td><code>Debug</code></td></tr>
<tr><td><code>&amp;str</code></td><td><code>Debug, Display</code></td></tr>
<tr><td><code>&amp;CStr</code></td><td><code>Debug</code></td></tr>
<tr><td><code>&amp;OsStr</code></td><td><code>Debug</code></td></tr>
<tr><td><code>&amp;Path</code></td><td><code>Debug</code></td></tr>
<tr><td><code>&amp;[u8]</code></td><td><code>Debug</code></td></tr>
<tr><td><code>bool</code></td><td><code>Debug, Display</code></td></tr>
<tr><td><code>char</code></td><td><code>Debug, Display</code></td></tr>
<tr><td><code>u8 … i128</code></td><td><code>Debug, Display</code></td></tr>
<tr><td><code>f32, f64</code></td><td><code>Debug, Display</code></td></tr>
<tr><td><code>!</code></td><td><code>Debug, Display</code></td></tr>
<tr><td><code>()</code></td><td><code>Debug</code></td></tr>
</tbody></table>
<p><sup>*</sup>简而言之，几乎所有东西都是Debug，更多特殊类型可能需要特殊处理或转换到 <code>Display</code></p>
<h3 id="格式化"><a class="header" href="#格式化">格式化</a></h3>
<ul>
<li>格式宏中的每个参数指示符要么是空的 {}，{argument}，要么遵循基本语法</li>
</ul>
<pre><code class="language-rust editable noplayground">{ [argument] ':' [[fill] align] [sign] ['#'] [width [$]] ['.' precision [$]] [type] }
</code></pre>
<table><thead><tr><th>元素</th><th>含义</th></tr></thead><tbody>
<tr><td><code>argument</code></td><td>数字( <code>0, 1, ...</code> )，变量或名字，如 <code>print!(&quot;{x}&quot;)</code></td></tr>
<tr><td><code>fill</code></td><td>如果指定了宽度，用(如 <code>0</code> )来填充空白的字符</td></tr>
<tr><td><code>align</code></td><td>如果指定了宽度，则左(&lt;)、中(^)或右(&gt;)</td></tr>
<tr><td><code>sign	</code></td><td>可以是 <code>+</code>，标志总是被打印</td></tr>
<tr><td><code>#</code></td><td>代替格式化，如 美化的 <code>Debug</code> 格式器 <code>?</code> 或前缀十六进制使用 <code>0x</code></td></tr>
<tr><td><code>width</code></td><td>最小的宽度(≥0)，填充（默认为空格）如果以 <code>0</code> 开头，则补零</td></tr>
<tr><td><code>precision</code></td><td>数字的小数位(≥0)，或者形容非数字的最大宽度</td></tr>
<tr><td><code>$</code></td><td>解释宽度(width)或精度(precision)作为参数标识符，而不是允许动态格式化</td></tr>
<tr><td><strong><code>type</code></strong></td><td><code>Debug</code> 格式化、十六进制(x)、二进制(b)、八进制(o)、指针(p)、exp(e)</td></tr>
</tbody></table>
<br>
<table><thead><tr><th>格式化示例</th><th>解释</th></tr></thead><tbody>
<tr><td><code>{}</code></td><td>使用 <code>Display</code> 打印下一个参数</td></tr>
<tr><td><code>{x}</code></td><td>同上，但在范围内使用变量 <code>x</code></td></tr>
<tr><td><code>{:?}</code></td><td>使用 <code>Debug</code> 打印下一个参数</td></tr>
<tr><td><code>{2:#?}</code></td><td>使用 <code>Debug</code> 格式化，较好的打印第三个参数</td></tr>
<tr><td><code>{val:^2$}</code></td><td>将命名参数 <code>val</code> 居中，宽度由第三个参数指定</td></tr>
<tr><td><code>{:&lt;10.3}</code></td><td>左对齐宽度为 10，精度为 3</td></tr>
<tr><td><code>{val:#x}</code></td><td>将参数 <code>val</code> 格式化为十六进制，带前缀 <code>0x</code> (替代格式 <code>x</code> ）</td></tr>
</tbody></table>
<br>
<table><thead><tr><th>完整示例</th><th>解释</th></tr></thead><tbody>
<tr><td><code>println!(&quot;{}&quot;, x)</code></td><td>使用 <code>Display</code> 在标准输出打印并且追加一个新行</td></tr>
<tr><td><code>println!(&quot;{x}&quot;)</code></td><td>同上，但在范围内使用变量 <code>x</code></td></tr>
<tr><td><code>format!(&quot;{a:.3} {b:?}&quot;)</code></td><td>用三位数字转换 <code>PI</code>，增加空格，<code>b</code> 使用 <code>Debug</code>，返回 <code>String</code></td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-工具链"><a class="header" href="#rust-工具链">Rust 工具链</a></h1>
<h2 id="项目组织"><a class="header" href="#项目组织">项目组织</a></h2>
<ul>
<li>基本的项目结构布局，通用的文件和文件夹，一般可由 <code>cargo</code> 生成 </li>
</ul>
<table><thead><tr><th>入口</th><th>相关的 <code>code</code></th></tr></thead><tbody>
<tr><td>📁 <code>.cargo/</code></td><td>项目本地的 cargo 配置，通常会包含 <a href="https://doc.rust-lang.org/cargo/reference/config.html"><strong><code>config.toml</code></strong></a></td></tr>
<tr><td>📁 <code>benches/</code></td><td>通过运行 <strong>cargo bench</strong> 来为你的 crate 执行基准测试，一般需要设置默认为 nightly</td></tr>
<tr><td>📁 <code>examples/</code></td><td>通过示例展示如何使用你的 crate，他们会像外部用户一样看到你的 crate</td></tr>
<tr><td>  my_example.rs</td><td>运行个别的示例像 <strong>cargo run --example my_example</strong></td></tr>
<tr><td>📁 <code>src/</code></td><td>你项目的源代码</td></tr>
<tr><td>  <code>main.rs</code></td><td>程序的默认入口文件，被作用于 <strong>cargo run</strong></td></tr>
<tr><td>  <code>lib.rs</code></td><td>库的默认入口文件，如 对于搜索 <code>my_crate::f()</code> 开始的地方</td></tr>
<tr><td>📁 <code>src/bin/</code></td><td>存放额外的二进制文件的地方，即使是在库项目中</td></tr>
<tr><td>  <code>extra.rs</code></td><td>添加二进制文件，使用 <code>cargo run --bin extra</code> 去运行</td></tr>
<tr><td>📁 <code>tests/</code></td><td>通常用于存放集成测试，通过 <strong>cargo test</strong> 来调用，单元测试一般会保留在 <code>src/</code> 文件中</td></tr>
<tr><td><code>.rustfmt.toml</code></td><td>用作 <strong>cargo fmt</strong> 自定义的方式</td></tr>
<tr><td><code>.clippy.toml</code></td><td><strong>clippy lints</strong> 的指定配置，通过使用 <code>cargo clippy</code></td></tr>
<tr><td><code>build.rs</code></td><td><strong>Pre-build script</strong>，一般在构建 <code>C / FFI</code> 会用到</td></tr>
<tr><td><code>Cargo.toml</code></td><td>主项目的配置，一般用于定义依赖，组件等等</td></tr>
<tr><td><code>Cargo.lock</code></td><td>可用于查看依赖关系细节，为程序添加 <code>git</code>，而不是库</td></tr>
<tr><td><code>rust-toolchain.toml</code></td><td>为项目定义覆盖的工具链（channel、components、targets）</td></tr>
</tbody></table>
<h3 id="各种入口文件的小例子"><a class="header" href="#各种入口文件的小例子">各种入口文件的小例子</a></h3>
<pre><pre class="playground"><code class="language-rust editable">// src/main.rs (程序的默认入口文件)

fn main() {
    println!(&quot;Hello, AwesomeProgram!&quot;);
}
</code></pre></pre>
<pre><code class="language-rust editable noplayground">// src/lib.rs (库的默认入口文件)

pub fn f() {}      // 因为是根目录中的公开目录，所以可从外部访问

mod m {
    pub fn g() {}  // 不是根目录中的公开路径(模块 m 不是公开的), 因此 g 不能在 crate 之外被访问
}  
</code></pre>
<pre><code class="language-rust editable noplayground">// src/my_module.rs (单元测试可以在你项目中的任意文件)

fn f() -&gt; u32 { 0 }

#[cfg(test)]
mod test {
    use super::f;           // 需要从上级模块中导入目录，可以访问没有公开的成员

    #[test]
    fn ff() {
        assert_eq!(f(), 0);
    }
}
</code></pre>
<pre><code class="language-rust editable noplayground">// tests/sample.rs (集成测试的例子)

#[test]
fn my_sample() {
    assert_eq!(my_crate::f(), 123); // 集成测试和基准测试依赖第三方的 crate，因此，他们仅看到公开的目录
}
</code></pre>
<pre><code class="language-rust editable noplayground">// benches/sample.rs (基准测试的例子)

#![feature(test)]   // 基准测试仍处于试验阶段

extern crate test;  // 在 2018 版本中需要添加

use test::{black_box, Bencher};

#[bench]
fn my_algo(b: &amp;mut Bencher) {
    b.iter(|| black_box(my_crate::f())); // `black_box` 阻止 `f` 被优化掉
}
</code></pre>
<pre><code class="language-rust editable noplayground">// build.rs (预构建脚本的例子)

fn main() {
    // 你需要依赖目标 OS 的环境变量，对于当前的 OS 可以表示 `#[cfg(...)]`
    let target_os = env::var(&quot;CARGO_CFG_TARGET_OS&quot;);
}
</code></pre>
<pre><code class="language-rust editable noplayground">// src/lib.rs (过程宏的默认入口文件)

extern crate proc_macro;  // 显然需要像这样被导入

use proc_macro::TokenStream;

#[proc_macro_attribute]   // 可以作为 `#[my_attribute]` 被使用
pub fn my_attribute(_attr: TokenStream, item: TokenStream) -&gt; TokenStream {
    item
}

// Cargo.toml

[package]
name = &quot;my_crate&quot;
version = &quot;0.1.0&quot;

[lib]
proc-macro = true
</code></pre>
<h3 id="模块树和namespace导入的使用"><a class="header" href="#模块树和namespace导入的使用">模块树和NameSpace导入的使用</a></h3>
<table>
<tr>
<td align="center">模块树</td>
</tr>
<tr>
<td>模块和源文件的使用方式：</td>
</tr>
<tr>
<td>
<li><b>模块树</b>需要显式定义，它不是从<b>文件系统树</b>中隐式创建的</li>
<li><b>Module tree root</b>是库、应用程序等等的入口文件，如 lib.rs</li>
</td>
</tr>
<tr>
<td>实际模块的定义如下：</td>
</tr>
<tr>
<td>
<li>一个在文件中定义的 <b><code>mod m {}</code></b>，当使用 <b><code>mod m;</code></b> 时，将会先去读 <b><code>m.rs</code></b> 或者 <b><code>m/mod.rs</code></b> </li>
<li> <code>.rs</code> 的路径是基于嵌套的，如 <code>mod a { mod b { mod c; }}}</code>、<code>a/b/c.rs</code>、<code>a/b/c/mod.rs</code></li>
<li>通过一些<code> mod m; </code>来自 <b>Module tree root</b> 而没有路径的文件，是不会被编译器触及到的</li>
</td>
</tr>
</table>
<br>
<table><thead><tr><th style="text-align: left"></th><th style="text-align: left">Rust 有三种 NameSpaces</th><th style="text-align: left"></th></tr></thead><tbody>
<tr><td style="text-align: left">Namespace 类型</td><td style="text-align: left">Namespace 函数</td><td style="text-align: left">Namespace 宏</td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>mod X {}</code></td><td style="text-align: left"><code>fn X() {}</code></td><td style="text-align: left"><code>macro_rules! X { ... }</code></td></tr>
<tr><td style="text-align: left"><code>X (crate)</code></td><td style="text-align: left"><code>const X: u8 = 1;</code></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>trait X {}</code></td><td style="text-align: left"><code>static X: u8 = 1;</code></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>enum X {}</code></td><td style="text-align: left"></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>union X {}</code></td><td style="text-align: left"></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>struct X {}</code></td><td style="text-align: left"></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">  <code>struct X;</code><sup>1</sup></td><td style="text-align: left"></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">  <code>struct X();</code><sup>2</sup></td><td style="text-align: left"></td><td style="text-align: left"></td></tr>
</tbody></table>
<ol>
<li>在<em>类型</em>和<em>函数</em>中，定义类型 <code>X</code> 和常量 <code>X</code></li>
<li>在<em>类型</em>和<em>函数</em>中，定义类型 <code>X</code> 和函数 <code>X</code></li>
</ol>
<ul>
<li>在任何给定的作用域中，例如在一个模块中，每个名称空间只能存在一个项目
<ul>
<li><code>enum X {}</code> 和 <code>fn X() {}</code> 可以共存</li>
<li><code>struct X;</code> 和 <code>const X</code> 可以共存</li>
</ul>
</li>
<li>使用 <code>use my_mod::X;</code> 时，所有被 <code>X</code> 调用的目录都会被导入</li>
</ul>
<p><sup>*<sup>由于命名约定,如 按照约定 <code>fn</code> 和 <code>mod</code> 是小写，并且大多数开发者不会把所有东西都命名为 <code>X</code>， 在通常情况下你不必担心这些类型，它们可以成为设计宏时的一个因素</p>
<h2 id="cargo"><a class="header" href="#cargo">Cargo</a></h2>
<p><sup>*<sup>必须要被了解的命令和工具</p>
<table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody>
<tr><td><code>cargo init</code></td><td>在最近的版本创建一个新项目</td></tr>
<tr><td><code>cargo build</code></td><td>在调试模式中构建项目( <code>--release</code> 适用于所有可以优化的地方)</td></tr>
<tr><td><code>cargo check</code></td><td>检查项目是否可以编译成功(执行很快)</td></tr>
<tr><td><code>cargo test</code></td><td>为项目执行测试用例</td></tr>
<tr><td><code>cargo doc --open</code></td><td>在最近的版本创建一个新项目</td></tr>
<tr><td><code>cargo run</code></td><td>如果生成了一个二进制文件( <code>main.rs</code> )则执行你的项目</td></tr>
<tr><td>  <code>cargo run --bin b</code></td><td>运行二进制文件 <code>b</code>，将特性与其它依赖统一在一起，可能会造成混淆</td></tr>
<tr><td>  <code>cargo run -p w</code></td><td>运行子空间的 <code>w</code>，如你期望的可以更多的面对特性</td></tr>
<tr><td><code>cargo ... --timings</code></td><td>展示是什么 crate 导致你的构建花费了这么长时间，非常有用</td></tr>
<tr><td><code>cargo tree</code></td><td>显示依赖关系图</td></tr>
<tr><td><code>cargo +{nightly, stable} ...</code></td><td>在命令中使用给定的工具链，如 用于 'nightly only' 工具</td></tr>
<tr><td><code>cargo +nightly ...</code></td><td>一些 <code>nightly-only</code> 的命令，使用下面的命令替换 <code>...</code></td></tr>
<tr><td>  <code>rustc -- -Zunpretty=expanded</code></td><td>显示展开的宏</td></tr>
<tr><td><code>rustup doc</code></td><td>打开离线 Rust 文档，包括书籍，在没有网络环境下使用很好</td></tr>
</tbody></table>
<p><sup>*</sup>这里的 <code>cargo build</code> 你也可以打印 <code>cargo b</code>，并且 <code>--release</code> 意味着可以用 <code>-r</code> 代替</p>
<p>下面这些是可选的 rustup 组件，使用 <code>rustup component add [tool]</code> 安装它们</p>
<table><thead><tr><th>工具</th><th>描述</th></tr></thead><tbody>
<tr><td>cargo clippy</td><td>增加 lints 捕获一些常见的 <strong>滥用API</strong> 和 <strong>不符合语言习惯</strong> 的代码</td></tr>
<tr><td>cargo fmt</td><td>自动代码格式化 <code>rustup component add rustfmt</code></td></tr>
</tbody></table>
<p><sup>*</sup>有更多可添加的 cargo 插件 <a href="https://crates.io/categories/development-tools::cargo-plugins?sort=downloads"><strong>点我查看</strong></a></p>
<h2 id="交叉编译"><a class="header" href="#交叉编译">交叉编译</a></h2>
<p>🔘检查目标系统是支持的</p>
<p>🔘</sup>通过 <strong><code>rustup target install X</code></strong> 安装不同目标系统的需求</p>
<p>🔘安装原生的工具链</p>
<p>从目标主机供应商获取(谷歌、苹果 ...)，可能并非在所有的主机都可用(如 在 Windows 上没有 iOS 的工具连)</p>
<p>一些工具链需要额外的构建步骤(如 安卓系统需要 <code>make-standalone-toolchain.sh</code> )</p>
<p>🔘像下面这样更新 <strong><code>~/.cargo/config.toml</code></strong></p>
<pre><code class="language-rust editable noplayground">[target.aarch64-linux-android]
linker = &quot;[PATH_TO_TOOLCHAIN]/aarch64-linux-android/bin/aarch64-linux-android-clang&quot;
</code></pre>
<pre><code class="language-rust editable noplayground">[target.aarch64-linux-android]
linker = &quot;C:/[PATH_TO_TOOLCHAIN]/prebuilt/windows-x86_64/bin/aarch64-linux-android21-clang.cmd&quot;
</code></pre>
<p>🔘设置环境变量(可选的，等待编译器如果有报错提示后再进行设置)</p>
<pre><code class="language-rust editable noplayground">set CC=C:\[PATH_TO_TOOLCHAIN]\prebuilt\windows-x86_64\bin\aarch64-linux-android21-clang.cmd
set CXX=C:\[PATH_TO_TOOLCHAIN]\prebuilt\windows-x86_64\bin\aarch64-linux-android21-clang.cmd
set AR=C:\[PATH_TO_TOOLCHAIN]\prebuilt\windows-x86_64\bin\aarch64-linux-android-ar.exe
...
</code></pre>
<p>是否设置它们依赖于编译反馈的报错提示，不一定都是需要的</p>
<p>一些平台的配置可能会非常敏感，取决于如何指定路径(如 <code>\</code> 与 <code>/</code> )和引用路径</p>
<p>✔️使用 <code>cargo build --target=X</code> 去编译</p>
<h2 id="工具指令"><a class="header" href="#工具指令">工具指令</a></h2>
<p><sup>*<sup>嵌入在源码中的特殊标记通常用于工具或者预处理</p>
<table>
<tr>
<td colspan="2" align="center">宏</td>
</tr>
<tr>
<td colspan="2">在声明宏中，通过示例 <code>macro_rules!</code> 实现以下功能：</td>
</tr>
<tr>
<td><b>在宏内</b></td><td><b>解释</b></td>
</tr>
<tr>
<td><code>$x:ty</code></td>
<td>宏的捕获，这里是一种类型</td>
</tr>
<tr>
<td>&emsp; <code>$x:item</code></td>
<td>一个 <code>item</code> ，如 函数、结构、模块等等</td>
</tr>
<tr>
<td>&emsp; <code>$x:block</code></td>
<td>一组语句或表达式 <code>block {}</code>，如 <code>{ let x = 5; }</code> </td>
</tr>
<tr>
<td>&emsp; <code>$x:stmt</code></td>
<td>一个语句，如 <code>let x = 1 + 1;</code> 、<code>String::new();</code>、<code>vec![]</code> </td>
</tr>
<tr>
<td>&emsp; <code>$x:expr</code></td>
<td>一个表达式，如 <code>x</code> 、<code>1 + 1</code> 、<code>String::new()</code> 、<code>vec![]</code></td>
</tr>
<tr>
<td>&emsp; <code>$x:pat</code></td>
<td>一种分支模式，如 <code>Some(t)<code> 、<code>(17, 'a')<code> 、<code>_<code></td>
</tr>
<tr>
<td>&emsp; <code>$x:ty</code></td>
<td>一种类型，如 <code>String<code> 、<code>usize</code> 、<code>Vec&lt;u8&gt;</code></td>
</tr>
<tr>
<td>&emsp; <code>$x:ident</code></td>
<td>一个标识符，如 在 <code>let x = 0;</code> 中，标识符是 <code>x</code> </td>
</tr>
<tr>
<td>&emsp; <code>$x:path</code></td>
<td>一个路径，如 <code>foo</code> 、<code>std::mem::replace</code> 、<code>transmute::&lt;_, int&gt;</code> </td>
</tr>
<tr>
<td>&emsp; <code>$x:literal</code></td>
<td>一个字面值，如 <code>3</code> 、<code>"foo"</code> 、 <code>b"bar"</code> 等等</td>
</tr>
<tr>
<td>&emsp; <code>$x:lifetime</code></td>
<td>一个生命周期，如 <code>'a</code> 、<code>'static</code> 等等</td>
</tr>
<tr>
<td>&emsp; <code>$x:meta</code></td>
<td>一个<code>meta item</code>，在这些 <code>#[...]</code> 、<code>#![...]</code> 里面的属性 </td>
</tr>
<tr>
<td>&emsp; <code>$x:vis</code></td>
<td>一个可见的修饰符，如 <code>pub</code> 、<code>pub(crate)</code> 等</td>
</tr>
<tr>
<td>&emsp; <code>$x:tt</code></td>
<td>一个单独的 <code>token tree</code>，<a href="https://stackoverflow.com/a/40303308" >点击查看更多</a></td>
</tr>
<tr>
<td><code>$crate</code></td>
<td>一个卫生变量，定义宏的 <code>crate</code> </td>
</tr>
</table>
<br>
<table>
<tr>
<td colspan="2" align="center">文档</td>
</tr>
<tr>
<td colspan="2">在文档注释中的用法：</td>
</tr>
<tr>
<td><b>在文档注释内</b></td><td><b>解释</b></td>
</tr>
<tr>
<td><code>```...```</code></td>
<td>包含一个<b>文档测试</b>，可以使用 <code>cargo test</code>去运行 </td>
</tr>
<tr>
<td><code>```X,Y ...```</code></td>
<td>同上，并且包括可选配置 <code>X...Y</code></td>
</tr>
<tr>
<td>&emsp; <code>rust</code></td>
<td>明确使用 <code>Rust</code> 去编写测试，由 Rust 工具实现的</td>
</tr>
<tr>
<td>&emsp; <code>-</code></td>
<td>默认行为，编译测试，运行测试，如果发生恐慌则测试失败</td>
</tr>
<tr>
<td>&emsp; <code>should_panic</code></td>
<td>编译测试，运行测试，执行期望应该是恐慌，如果不是，则失败</td>
</tr>
<tr>
<td>&emsp; <code>no_run</code></td>
<td>编译测试，如果代码无法编译，则测试失败，不会运行测试</td>
</tr>
<tr>
<td>&emsp; <code>compile_fail</code></td>
<td>编译测试，如果代码可以编译，则测试失败</td>
</tr>
<tr>
<td>&emsp; <code>ignore</code></td>
<td>不会编译，不会运行，选择上面的选项</td>
</tr>
<tr>
<td>&emsp; <code>edition2018</code></td>
<td>执行代码为Rust 2018版，默认为 2015版</td>
</tr>
<tr>
<td><code>#</code></td>
<td>隐藏文档中的一行，如 <code># use x::hidden;</code> </td>
</tr>
<tr>
<td><code>[`S`]</code></td>
<td>创建指向<code>结构体、枚举、特征、函数……</code>的链接</td>
</tr>
<tr>
<td><code>[`S`](crate::S)</code></td>
<td>也可以使用路径，以 markdown 链接的形式</td>
</tr>
</table>
<br>
<table>
<tr>
<td colspan="3" align="center">#![globals]</td>
</tr>
<tr>
<td colspan="3">影响整个 crate 和程序的属性：</td>
</tr>
<tr>
<td><b>Opt-Out's</b></td><td><b>On</b></td><td><b>解释</b></td>
</tr>
<tr>
<td><code>#![no_std]</code></td>
<td><code>C</code></td>
<td>不会自动导入<b>std</b>，将使用<b>core</b>代替</td>
</tr>
<tr>
<td><code>#![no_implicit_prelude]</code></td>
<td><code>CM</code></td>
<td>不会添加<b>prelude</b>，需要手动导入<b>None</b> <b>Vec</b> ...</td>
</tr>
<tr>
<td><code>#![no_main]</code></td>
<td><code>C</code></td>
<td>如果是这种情况则不要在程序中写入 <code>main()</code> </td>
</tr>
<br>
<tr>
<td><b>Opt-In's</b></td><td><b>On</b></td><td><b>解释</b></td>
</tr>
<tr>
<td><code>#![feature(a, b, c)]</code></td>
<td><code>C</code></td>
<td>依赖可能永远不会稳定的特性，<a href="https://doc.rust-lang.org/unstable-book/the-unstable-book.html"><b>Unstable Book.</b></a></td>
</tr>
<br>
<tr>
<td><b>Builds</b></td><td><b>On</b></td><td><b>解释</b></td>
</tr>
<tr>
<td><code>#![windows_subsystem = "x"]	</code></td>
<td><code>C</code></td>
<td>在 Windows 上，做一个控制台或者应用程序</td>
</tr>
<tr>
<td><code>#![crate_name = "x"]</code></td>
<td><code>C</code></td>
<td>指定当前 crate 的名称，如 当在不使用 cargo 的时候</td>
</tr>
<tr>
<td><code>#![crate_type = "bin"]</code></td>
<td><code>C</code></td>
<td>指定当前 crate 的类型，如 bin lib dylib cdylib ...</td>
</tr>
<tr>
<td><code>#![recursion_limit = "123"]</code></td>
<td><code>C</code></td>
<td>为 deref 和 macros 设置编译期间的递归限制</td>
</tr>
<tr>
<td><code>#![type_length_limit = "456"]</code></td>
<td><code>C</code></td>
<td>限制类型替换的最大数量</td>
</tr>
<br>
<tr>
<td><b>Handlers</b></td><td><b>On</b></td><td><b>解释</b></td>
</tr>
<tr>
<td><code>#[panic_handler]</code></td>
<td><code>F</code></td>
<td>创建一些应用程序的<b>panic handler</b>，如 <code>fn f(&PanicInfo) -> !</code> </td>
</tr>
<tr>
<td><code>#[global_allocator]</code></td>
<td><code>S</code></td>
<td>创建一些静态项目的实现，<code>GlobalAlloc</code> 全局分配器</td>
</tr>
</table>
<br>
</table>
<table>
<tr>
<td colspan="3" align="center">#[code]</td>
</tr>
<tr>
<td colspan="3">主要控制写出代码的属性：</td>
</tr>
<tr>
<td><b>Developer UX</b></td><td><b>On</b></td><td><b>解释</b></td>
</tr>
<tr>
<td><code>#[non_exhaustive]</code></td>
<td><code>T</code></td>
<td> Future-proof <b>struct</b> 或 <b>enum</b>，暗示它以后数据将会扩大</td>
</tr>
<tr>
<td><code>#[path = "x.rs"]</code></td>
<td><code>M</code></td>
<td>从非标准库中获取模块</td>
</tr>
<tr>
<td><b>Codegen</b></td><td><b>On</b></td><td><b>解释</b></td>
</tr>
<tr>
<td><code>#[inline]</code></td>
<td><code>F</code></td>
<td>建议编译器应该在调用点时使用内联函数</td>
</tr>
<tr>
<td><code>#[inline(always)]</code></td>
<td><code>F</code></td>
<td>强烈要求编译器使用内联调用</td>
</tr>
<tr>
<td><code>#[inline(never)]</code></td>
<td><code>F</code></td>
<td>如果仍然内联函数，则指示编译器不起作用</td>
</tr>
<tr>
<td><code>#[cold]</code></td>
<td><code>F</code></td>
<td>提示该函数可能不会被调用</td>
</tr>
<tr>
<td><code>#[target_feature(enable="x")]</code></td>
<td><code>F</code></td>
<td>对于 <code>unsafe fn</code> 的代码强制 CPU 开启特性</td>
</tr>
<tr>
<td><code>#[track_caller]</code></td>
<td><code>F</code></td>
<td>对于更友好的 panic 输出信息，允许 <code>fn</code> 查找<b>caller</b></td>
</tr>
<tr>
<td><code>#[repr(X)]</code></td>
<td><code>T</code></td>
<td>使用另一种表示而不是默认的<b>rust</b></td>
</tr>
<tr>
<td>&emsp; <code>#[repr(C)]</code></td>
<td><code>T</code></td>
<td>使用 C-compatible (f. FFI)、可预测 (f. transmute) 的布局</td>
</tr>
<tr>
<td>&emsp; <code>#[repr(C, u8)]</code></td>
<td><code>enum</code></td>
<td>给<b>enum</b>判别器指定类型</td>
</tr>
<tr>
<td>&emsp; <code>#[repr(transparent)]</code></td>
<td><code>T</code></td>
<td>为单个元素类型提供与包含字段相同的布局</td>
</tr>
<tr>
<td>&emsp; <code>#[repr(packed(1))]</code></td>
<td><code>T</code></td>
<td>结构和包含字段的较低对齐，轻度的 UB 倾向</td>
</tr>
<tr>
<td>&emsp; <code>#[repr(align(8))]</code></td>
<td><code>T</code></td>
<td>将结构对齐提高到给定值，如 SIMD 类型</td>
</tr>
<tr>
<td colspan="3" align="left"><sup>*<sup>可以组合一些表示修饰符，如 <code>#[repr(C, packed(1))]</code></td>
</tr>
<tr>
<td><b>Linking</b></td><td><b>On</b></td><td><b>解释</b></td>
</tr>
<tr>
<td><code>#[no_mangle]</code></td>
<td><code>*</code></td>
<td>直接使用项目名称作为符号名称而不修改</td>
</tr>
<tr>
<td><code>#[no_link]</code></td>
<td><code>X</code></td>
<td>当想要使用宏时，不去链接<b>extern crate</b></td>
</tr>
<tr>
<td><code>#[link(name="x", kind="y")]</code></td>
<td><code>X</code></td>
<td>当查找符号时，要链接的本地库</td>
</tr>
<tr>
<td><code>#[link_name = "foo"]</code></td>
<td><code>F</code></td>
<td>要查找以解析 <code>extern fn</code> 的符号名称</td>
</tr>
<tr>
<td><code>#[link_section = ".sample"]</code></td>
<td><code>FS</code></td>
<td>应放置项目的目标文件的部分名称</td>
</tr>
<tr>
<td><code>#[export_name = "foo"]</code></td>
<td><code>FS</code></td>
<td>以不同的名称导出 <code>fn</code>或 <code>static</code></td>
</tr>
<tr>
<td><code>#[used]</code></td>
<td><code>S</code></td>
<td>不要优化掉 <code>static</code> 变量，尽管它看起来并未使用</td>
</tr>
</table>
<br>
<table>
<tr>
<td colspan="3" align="center">#[quality]</td>
</tr>
<tr>
<td colspan="3">Rust 工具用于提高代码质量的属性：</td>
</tr>
<tr>
<td><b>代码模式</b></td><td><b>On</b></td><td><b>解释</b></td>
</tr>
<tr>
<td><code>#[allow(X)]</code></td>
<td><code>*</code></td>
<td>指示 rustc 或 clippy 去忽略 class <code>X</code> 可能的问题</td>
</tr>
<tr>
<td><code>#[warn(X)]</code></td>
<td><code>*</code></td>
<td>发出警告，与 clippy lints 在一起使用</td>
</tr>
<tr>
<td><code>#[deny(X)]</code></td>
<td><code>*</code></td>
<td>编译失败</td>
</tr>
<tr>
<td><code>#[forbid(X)]</code></td>
<td><code>*</code></td>
<td>编译失败并且阻止后续的重写</td>
</tr>
<tr>
<td><code>#[deprecated = "msg"]</code></td>
<td><code>*</code></td>
<td>让你用户知道你制造了一个设计错误</td>
</tr>
<tr>
<td><code>#[must_use = "msg"]</code></td>
<td><code>FTX</code></td>
<td>使编译器检查由调用者处理的返回值</td>
</tr>
<tr>
<td colspan="3"><sup>*</sup>对于保证高质量 crates 的最佳选择，存在一些争论。积极维护的多个开发版本的 crates 可能会受益于更具侵略性<b>deny</b>或<b>forbid lints</b>；不经常更新的可能更多来自保守使用<b>warn</b>，因为未来的编译器或 clippy 更新可能会突然破坏其他工作代码并出现些小问题</td>
</tr>
<tr>
<td><b>测试</b></td><td><b>On</b></td><td><b>解释</b></td>
</tr>
<tr>
<td><code>#[test]</code></td>
<td><code>F</code></td>
<td>将函数标记为测试，使用 <code>cargo test</code> </td>
</tr>
<tr>
<td><code>#[ignore = "msg"]</code></td>
<td><code>F</code></td>
<td>编译但暂时不执行一些 <code>#[test]</code> </td>
</tr>
<tr>
<td><code>#[should_panic]</code></td>
<td><code>F</code></td>
<td>测试必须触发 <code>panic!()</code> 才能实际成功</td>
</tr>
<tr>
<td><code>#[bench]</code></td>
<td><code>F</code></td>
<td>标记函数在 <code>bench/</code> 作为基准测试，使用 <code>cargo bench</code> </td>
</tr>
<tr>
<td><b>格式化</b></td><td><b>On</b></td><td><b>解释</b></td>
</tr>
<tr>
<td><code>#[rustfmt::skip]</code></td>
<td><code>*</code></td>
<td>防止 <code>cargo fmt</code> 清理项目</td>
</tr>
<tr>
<td><code>#![rustfmt::skip::macros(x)]</code></td>
<td><code>CM</code></td>
<td>... 从清理宏 x 开始</td>
</tr>
<tr>
<td><code>#![rustfmt::skip::attributes(x)]</code></td>
<td><code>CM</code></td>
<td>... 从清理属性 x 开始</td>
</tr>
<tr>
<td><b>文档</b></td><td><b>On</b></td><td><b>解释</b></td>
</tr>
<tr>
<td><code>#[doc = "Explanation"]</code></td>
<td><code>*</code></td>
<td>与添加 <code>///</code> 文档注释相同</td>
</tr>
<tr>
<td><code>#[doc(alias = "other")]</code></td>
<td><code>*</code></td>
<td>提供用户可以在文档中搜索的另一个名称</td>
</tr>
<tr>
<td><code>#[doc(hidden)]</code></td>
<td><code>*</code></td>
<td>防止项目出现在文档中</td>
</tr>
<tr>
<td><code>#![doc(html_favicon_url = "")]</code></td>
<td><code>C</code></td>
<td>为文档设置 <b>favicon</b> </td>
</tr>
<tr>
<td><code>#![doc(html_logo_url = "")]</code></td>
<td><code>C</code></td>
<td>文档中使用的 <b>logo</b> </td>
</tr>
<tr>
<td><code>#![doc(html_playground_url = "")]</code></td>
<td><code>C</code></td>
<td>生成 Run 按钮并使用给定的服务</td>
</tr>
<tr>
<td><code>#![doc(html_root_url = "")]</code></td>
<td><code>C</code></td>
<td>指向外部 crate 的链接的基本 URL</td>
</tr>
<tr>
<td><code>#![doc(html_no_source)]</code></td>
<td><code>C</code></td>
<td>防止源包含在文档中</td>
</tr>
</table>
<br>
<table>
<tr>
<td colspan="3" align="center">#[macros]</td>
</tr>
<tr>
<td colspan="3">与宏的创建和使用相关的属性：</td>
</tr>
<tr>
<td><b>宏示例</b></td><td><b>On</b></td><td><b>解释</b></td>
</tr>
<tr>
<td><code>#[macro_export]</code></td>
<td><code>!</code></td>
<td>导出 <code>macro_rules!</code> 作为公开的在 <code>crate</code> 级别</td>
</tr>
<tr>
<td><code>#[macro_use]</code></td>
<td><code>MX</code></td>
<td>让宏持久化的模块，或者从 <code>extern crate</code> 导入</td>
</tr>
<tr>
<td><b>过程宏</b></td><td><b>On</b></td><td><b>解释</b></td>
</tr>
<tr>
<td><code>#[proc_macro]</code></td>
<td><code>F</code></td>
<td>将 <code>fn</code> 标记为<b>function-like</b>的过程宏，可作为 <code>m!()</code> 调用</td>
</tr>
<tr>
<td><code>#[proc_macro_derive(Foo)]</code></td>
<td><code>F</code></td>
<td>将可以 <code>#[derive(Foo)]</code> 的 <code>fn</code> 标记为<b>derive macro</b></td>
</tr>
<tr>
<td><code>#[proc_macro_attribute]</code></td>
<td><code>F</code></td>
<td>将可以理解成新的 <code>#[x]</code> 的 <code>fn</code> 标记为<b>attribute macro</b></td>
</tr>
<tr>
<td><b>Derives</b></td><td><b>On</b></td><td><b>解释</b></td>
</tr>
<tr>
<td><code>#[derive(X)]</code></td>
<td><code>T</code></td>
<td>让一些过程宏提供一些好的 <code>trait X</code> 的实现</td>
</tr>
</table>
<br>
<table>
<tr>
<td colspan="3" align="center">#[cfg]</td>
</tr>
<tr>
<td colspan="3">控制条件编译的属性：</td>
</tr>
<tr>
<td><b>配置属性</b></td><td><b>On</b></td><td><b>解释</b></td>
</tr>
<tr>
<td><code>#[cfg(X)]</code></td>
<td><code>*</code></td>
<td>如果配置 <code>X</code> 成立，则包含项目</td>
</tr>
<tr>
<td><code>#[cfg(all(X, Y, Z))]</code></td>
<td><code>*</code></td>
<td>如果所有的选项都成立，则包含项目</td>
</tr>
<tr>
<td><code>#[cfg(any(X, Y, Z))]</code></td>
<td><code>*</code></td>
<td>如果至少有一个选项成立，则包含项目</td>
</tr>
<tr>
<td><code>#[cfg(not(X))]</code></td>
<td><code>*</code></td>
<td>如果 <code>X</code> 不成立，则包含项目</td>
</tr>
<tr>
<td><code>#[cfg_attr(X, foo = "msg")]</code></td>
<td><code>*</code></td>
<td>如果配置 <code>X</code> 成立，则应用 <code>#[foo = "msg"]</code></td>
</tr>
<tr>
<td colspan="3"><sup>*</sup>注意，options 一般可以设置多次，即同一个 key 可以出现多个 value。可以同时期望 <code>#[cfg(target_feature = "avx")]</code> 和 <code>#[cfg(target_feature = "avx2")]</code> 为真。</td>
</tr>
<tr>
<td><b>已知选项</b></td><td><b>On</b></td><td><b>解释</b></td>
</tr>
<tr>
<td><code>#[cfg(target_arch = "x86_64")]</code></td>
<td><code>*</code></td>
<td>为了去编译 CPU 架构的 crate </td>
</tr>
<tr>
<td><code>#[cfg(target_feature = "avx")]</code></td>
<td><code>*</code></td>
<td>某一类特性类别的指令是否可用</td>
</tr>
<tr>
<td><code>#[cfg(target_os = "macos")]</code></td>
<td><code>*</code></td>
<td>你的代码将在其操作系统上运行</td>
</tr>
<tr>
<td><code>#[cfg(target_family = "unix")]</code></td>
<td><code>*</code></td>
<td>属于家族操作系统</td>
</tr>
<tr>
<td><code>#[cfg(target_env = "msvc")]</code></td>
<td><code>*</code></td>
<td>DLLs 和函数怎样与操作系统接口连接</td>
</tr>
<tr>
<td><code>#[cfg(target_endian = "little")]</code></td>
<td><code>*</code></td>
<td>你的 zero-cost 协议失败的主要原因</td>
</tr>
<tr>
<td><code>#[cfg(target_pointer_width = "64")]</code></td>
<td><code>*</code></td>
<td>有多少位指针、usize 和 CPU</td>
</tr>
<tr>
<td><code>#[cfg(target_vendor = "apple")]</code></td>
<td><code>*</code></td>
<td>目标生产商</td>
</tr>
<tr>
<td><code>#[cfg(debug_assertions)]</code></td>
<td><code>*</code></td>
<td><code>debug_assert!()</code>是否会发生 panic</td>
</tr>
<tr>
<td><code>#[cfg(panic = "unwind")]</code></td>
<td><code>*</code></td>
<td>是否 unwind 或 abort 将发生恐慌</td>
</tr>
<tr>
<td><code>#[cfg(proc_macro)]</code></td>
<td><code>*</code></td>
<td>是否将 crate 编译为过程宏</td>
</tr>
<tr>
<td><code>#[cfg(test)]</code></td>
<td><code>*</code></td>
<td>是否与 <code>cargo test</code>一起编译</td>
</tr>
<tr>
<td><code>#[cfg(feature = "serde")]</code></td>
<td><code>*</code></td>
<td>是否 feature serde 与你的 crate 被一起编译</td>
</tr>
</table>
<br>
<table>
<tr>
<td colspan="2" align="center">build.rs</td>
</tr>
<tr>
<td colspan="2">与预构建脚本关联的环境变量与输出</td>
</tr>
<tr>
<td><b>输入环境</b></td><td><b>解释</b></td>
</tr>
<tr>
<td><code>CARGO_FEATURE_X</code></td>
<td>为每一个激活的特性 X 设置环境变量</td>
</tr>
<tr>
<td>&emsp; <code>CARGO_FEATURE_SERDE</code></td>
<td>如果特性 serde 被强制启用</td>
</tr>
<tr>
<td>&emsp; <code>CARGO_FEATURE_SOME_FEATURE</code></td>
<td>如果有一些特性被强制启用，<code>-</code> 会转成 <code>_</code> </td>
</tr>
<tr>
<td><code>CARGO_CFG_X</code></td>
<td>暴露 cfg's，加入多个选项通过<b>,</b>并且会把<code>-</code> 转换成 <code>_</code> </td>
</tr>
<tr>
<td>&emsp; <code>CARGO_CFG_TARGET_OS=macos</code></td>
<td>如果 target_os 设置为了 macos </td>
</tr>
<tr>
<td>&emsp; <code>CARGO_CFG_TARGET_FEATURE=avx,avx2</code></td>
<td>如果 target_feature 设置为了 avx 和 avx2 </td>
</tr>
<tr>
<td><code>OUT_DIR</code></td>
<td>输出应该放到哪个目录</td>
</tr>
<tr>
<td><code>TARGET</code></td>
<td>正在编译的目标三重</td>
</tr>
<tr>
<td><code>HOST</code></td>
<td>主机三重(运行这个构建脚本)</td>
</tr>
<tr>
<td><code>PROFILE</code></td>
<td>可以是 debug 或 release </td>
</tr>
<tr>
<td colspan="2" align="left" >通过 <code>env::var()?</code> 从<b>build.rs</b>中是可用的，但并未详尽列出</td>
</tr>
<tr>
<td><b>输出字符串</b></td><td><b>On</b></td><td><b>解释</b></td>
</tr>
<tr>
<td><code>cargo:rerun-if-changed=PATH</code></td>
<td>仅在如果 PATH 变更了，再次运行这个 build.rs</td>
</tr>
<tr>
<td><code>cargo:rerun-if-env-changed=VAR</code></td>
<td>仅在如果环境变量 VAR 变更了，再次运行这个 build.rs</td>
</tr>
<tr>
<td><code>cargo:rustc-link-lib=[KIND=]NAME</code></td>
<td>就像通过<b>-l</b>选项链接本机库一样</td>
</tr>
<tr>
<td><code>cargo:rustc-link-search=[KIND=]PATH</code></td>
<td>就像通过<b>-l</b>选项，为本地库查找路径</td>
</tr>
<tr>
<td><code>cargo:rustc-flags=FLAGS</code></td>
<td>向编译器添加指定的 flags </td>
</tr>
<tr>
<td><code>cargo:rustc-cfg=KEY[="VALUE"]</code></td>
<td>发出给定的 cfg 选项以用于以后的编译</td>
</tr>
<tr>
<td><code>cargo:rustc-env=VAR=VALUE</code></td>
<td>在 crate 编译期间发出可通过<code>env!()</code>访问的变量</td>
</tr>
<tr>
<td><code>cargo:rustc-cdylib-link-arg=FLAG</code></td>
<td>当构建一个<b>cdylib</b>时，传递链接器标志</td>
</tr>
<tr>
<td><code>cargo:warning=MESSAGE</code></td>
<td>发出编译器警告</td>
</tr>
<tr>
<td colspan="2" align="left" >通过 <code>println!()</code> 从<b>build.rs</b>写出，但并未详尽列出</td>
</tr>
</table>
<p><sup>*</sup>对于属性中的On列：</p>
<ul>
<li><code>C</code> 表示在 crate 级别（通常 <code>#![my_attr]</code> 在顶级文件中给出）</li>
<li><code>M</code> 意味着在模块上</li>
<li><code>F</code> 指功能上</li>
<li><code>S</code> 意味着静态</li>
<li><code>T</code> 表示类型</li>
<li><code>X</code> 意味着一些特殊的东西</li>
<li><code>!</code> 意味着在宏上</li>
<li><code>*</code> 意味着几乎任何项目</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-类型操作"><a class="header" href="#rust-类型操作">Rust 类型操作</a></h1>
<h2 id="类型-特征-泛型"><a class="header" href="#类型-特征-泛型">类型 特征 泛型</a></h2>
<ul>
<li>允许用户自定义类型，以避免冗余代码</li>
</ul>
<h3 id="类型-与-特征"><a class="header" href="#类型-与-特征">类型 与 特征</a></h3>
<h4 id="类型"><a class="header" href="#类型">类型</a></h4>
<ul>
<li>一组具有给定语义、布局等等</li>
</ul>
<table><thead><tr><th style="text-align: left">类型</th><th style="text-align: left">值</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>u8</code></td><td style="text-align: left"><code>{ 0<sub>u8</sub>, 1<sub>u8</sub>, ..., 255<sub>u8</sub> }</code></td></tr>
<tr><td style="text-align: left"><code>char</code></td><td style="text-align: left"><code>{ 'a', 'b', ... '🦀' }</code></td></tr>
<tr><td style="text-align: left"><code>struct S(u8, char)</code></td><td style="text-align: left"><code>{ (0<sub>u8</sub>, 'a'), ... (255<sub>u8</sub>, '🦀') }</code></td></tr>
</tbody></table>
<h4 id="类型等价与转换"><a class="header" href="#类型等价与转换">类型等价与转换</a></h4>
<ul>
<li>这可能很明显，但 <code>u8</code>， <code>&amp;u8</code>， <code>&amp;mut u8</code>，彼此完全不同</li>
<li>任何 <code>t: T</code> 仅接受来自准确的 <code>T</code> 值，如
<ul>
<li><code>f(0_u8)</code> 不能被 <code>f(&amp;0_u8)</code> 调用</li>
<li><code>f(&amp;mut my_u8)</code> 不能被 <code>f(&amp;my_u8)</code> 调用</li>
<li><code>f(0_u8)</code> 不能被 <code>f(0_i8)</code> 调用</li>
</ul>
</li>
</ul>
<p><sup>*</sup>在数学意义上，从类型的角度来看 <code>0 != 0</code>，在语言意义上，<code>==(0u8, 0u16)</code> 仅为了阻止一些小意外而没有定义</p>
<table><thead><tr><th style="text-align: left">类型</th><th style="text-align: left">值</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>u8</code></td><td style="text-align: left"><code>{ 0<sub>u8</sub>, 1<sub>u8</sub>, ..., 255<sub>u8</sub> }</code></td></tr>
<tr><td style="text-align: left"><code>u16</code></td><td style="text-align: left"><code>{ 0<sub>u16</sub>, 1<sub>u16</sub>, ..., 65_535<sub>u16</sub> }</code></td></tr>
<tr><td style="text-align: left"><code>&amp;u8	</code></td><td style="text-align: left"><code>{ 0xffaa<sub>&amp;u8</sub>, 0xffbb<sub>&amp;u8</sub>, ... }</code></td></tr>
<tr><td style="text-align: left"><code>&amp;mut u8</code></td><td style="text-align: left"><code>{ 0xffaa<sub>&amp;mut u8</sub>, 0xffbb<sub>&amp;mut u8</sub>, ... }</code></td></tr>
</tbody></table>
<ul>
<li>然而，Rust 有时可能有助于在类型之间进行转换
<ul>
<li><strong>casts</strong>手动转换类型的值，<code>0_i8 as u8</code></li>
<li><strong>coercions</strong>安全时自动转换类型， <code>let x: &amp;u8 = &amp;mut 0_u8;</code></li>
</ul>
</li>
</ul>
<ol>
<li><strong>casts</strong>和<strong>coercions</strong>强制转换将一个集合（如 <code>u8</code>）的值转换到另一个集合（如 <code>u16</code>），可能会添加 CPU 指令来完成此操作；这与子类型不同，意味着类型和子类型是同一个集合的一部分（如 <code>u8</code> 是 <code>u16</code> 的子类型，跟 <code>0_u8</code> 和 <code>0_u16</code> 类似），而这种转换将纯粹是编译时检查。Rust并不对常规类型使用子类型（<code>0_u8</code> 与 <code>0_u16</code> 确实不同），而是对生命周期使用某种类型。</li>
<li>这里的安全不仅仅是物理概念（如 <code>&amp;u8</code> 不能被强制转换为 <code>&amp;u128</code>），还包括“历史表明这样的转换是否会导致编程错误”。</li>
</ol>
<h3 id="implementations--impl-s--"><a class="header" href="#implementations--impl-s--">Implementations — <code>impl S { }</code></a></h3>
<pre><code class="language-rust editable noplayground">impl Port {
    fn f() { ... }
}
</code></pre>
<ul>
<li>类型通常伴随着实现，如 <code>impl Port {}</code>，与类型相关的行为有：
<ul>
<li>相关函数 <code>Port::new(80)</code></li>
<li>方法 <code>port.close()</code></li>
</ul>
</li>
</ul>
<p><sup>*<sup>与之相关的更多的是哲学而不是技术，没有什么(除了好的品味)可以阻止 <code>u8::play_sound()</code> 的发生。</p>
<h3 id="特征--trait-t--"><a class="header" href="#特征--trait-t--">特征 — <code>trait T { }</code></a></h3>
<p><code>⌾ Copy</code> <code>⌾ Clone</code> <code>⌾ Sized</code> <code>⌾ ShowHex</code></p>
<ul>
<li>Traits ...
<ul>
<li>是“抽象”行为的方式</li>
<li>trait 作者在语义上声明这个 trait 意味着 X</li>
<li>其他人可以为他们的类型实现该行为</li>
</ul>
</li>
<li>将 trait 视为类型的“成员列表”：</li>
</ul>
<table><thead><tr><th style="text-align: center">Copy Trait</th><th></th><th style="text-align: center">Clone Trait</th><th></th><th style="text-align: center">Sized Trait</th></tr></thead><tbody>
<tr><td style="text-align: center"><strong><code>Self</code></strong></td><td></td><td style="text-align: center"><strong><code>Self</code></strong></td><td></td><td style="text-align: center"><strong><code>Self</code></strong></td></tr>
<tr><td style="text-align: center"><code>u8</code></td><td></td><td style="text-align: center"><code>u8</code></td><td></td><td style="text-align: center"><code>char</code></td></tr>
<tr><td style="text-align: center"><code>u16</code></td><td></td><td style="text-align: center"><code>String</code></td><td></td><td style="text-align: center"><code>Port</code></td></tr>
<tr><td style="text-align: center">...</td><td></td><td style="text-align: center">...</td><td></td><td style="text-align: center">...</td></tr>
<tr><td style="text-align: center">trait 作为成员表，<strong><code>Self</code></strong> 是指包含的类型</td><td></td><td style="text-align: center"></td><td></td><td style="text-align: center"></td></tr>
</tbody></table>
<ul>
<li>属于该成员名单的任何人都将遵守名单的行为</li>
<li>Traits 还可以包括相关的方法、函数、...</li>
</ul>
<pre><code class="language-rust editable noplayground">trait ShowHex {
    // Must be implemented according to documentation.
    fn as_hex() -&gt; String;

    // Provided by trait author.
    fn print_hex() {}
}
</code></pre>
<p><code>⌾ Copy</code></p>
<pre><code class="language-rust editable noplayground">trait Copy { }
</code></pre>
<ul>
<li>没有方法的特征通常被称为<strong>marker traits</strong></li>
<li><code>Copy</code> 是标记特征的例子，意味着内存可以按位复制</li>
</ul>
<p><code>⌾ Sized</code></p>
<ul>
<li>完全在明确控制外的一些 traits</li>
<li>Sized 由已知大小类型的编译器提供，要么是，要么不是</li>
</ul>
<h3 id="implementing-traits-for-types--impl-t-for-s--"><a class="header" href="#implementing-traits-for-types--impl-t-for-s--">Implementing Traits for Types — <code>impl T for S { }</code></a></h3>
<pre><code class="language-rust editable noplayground">impl ShowHex for Port { ... }
</code></pre>
<ul>
<li>特征是在'at some point'时为类型实现的</li>
<li><code>impl A for B</code> 添加类型 <code>B</code> 到 trait 成员列表：</li>
</ul>
<table><thead><tr><th style="text-align: center"><strong><code>ShowHex Trait</code></strong></th></tr></thead><tbody>
<tr><td style="text-align: center"><strong><code>Self</code></strong></td></tr>
<tr><td style="text-align: center"><code>Port</code></td></tr>
</tbody></table>
<ul>
<li>从表面上看，你可以认为该类型因其成员资格而获得“badge”</li>
</ul>
<table><thead><tr><th style="text-align: left"><code>u8</code></th><th></th><th style="text-align: left"><code>Device</code></th><th></th><th style="text-align: left"><code>Port</code></th></tr></thead><tbody>
<tr><td style="text-align: left"><code>impl { ... }</code></td><td></td><td style="text-align: left"><code>impl { ... }</code></td><td></td><td style="text-align: left"><code>impl { ... }</code></td></tr>
<tr><td style="text-align: left"><code>⌾Sized</code></td><td></td><td style="text-align: left"><code>⌾Transport</code></td><td></td><td style="text-align: left"><code>⌾Sized</code></td></tr>
<tr><td style="text-align: left"><code>⌾Clone</code></td><td></td><td style="text-align: left"></td><td></td><td style="text-align: left"><code>⌾Clone</code></td></tr>
<tr><td style="text-align: left"><code>⌾Copy</code></td><td></td><td style="text-align: left"></td><td></td><td style="text-align: left"><code>⌾ShowHex</code></td></tr>
</tbody></table>
<h3 id="特征与接口"><a class="header" href="#特征与接口">特征与接口</a></h3>
<h4 id="接口"><a class="header" href="#接口">接口</a></h4>
<ul>
<li>在 <strong>Java</strong> 中，用户Alice创建接口 <code>Eat</code></li>
<li>当用户Bob创建新类型 <code>Venison</code>，他必须决定是否让新类型实现 <code>Eat</code></li>
<li>换句话说，所有成员资格必须在类型定义期间详尽地说明</li>
<li>当使用新类型 <code>Venison</code> 时，用户Santa可以利用 <code>Eat</code> 提供的以下行为：</li>
</ul>
<pre><code class="language-rust editable noplayground">// Santa imports `Venison` to create it, can `eat()` if he wants.
import food.Venison;

new Venison(&quot;rudolph&quot;).eat();
</code></pre>
<h4 id="特征"><a class="header" href="#特征">特征</a></h4>
<ul>
<li>在 <strong>Rust</strong> 中，用户Alice创建特征 <code>Eat</code></li>
<li>用户Bob创建新类型 <code>Venison</code>，并且决定不去实现 <code>Eat</code>，他可能甚至都不知道 <code>Eat</code> 的存在</li>
<li>某用户后来决定添加 <code>Eat</code> 到 <code>Venison</code> 将是一个非常好的主意</li>
<li>当使用 <code>Venison</code> 时，用户Santa必须单独导入 <code>Eat</code>：</li>
</ul>
<pre><code class="language-rust editable noplayground">// Santa needs to import `Venison` to create it, and import `Eat` for trait method.
use food::Venison;
use tasks::Eat;

// Ho ho ho
Venison::new(&quot;rudolph&quot;).eat();
</code></pre>
<p><sup>*</sup>为了防止两个人实现不同的 <code>Eat</code>，Rust 编译器将限制选择为 Alice 或 Bob 其中的一个， 也就是说 <code>impl Eat for Venison</code> 可能只发生在 Venison crate 或 Eat crate 中。</p>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="go-翻译于官网描述"><a class="header" href="#go-翻译于官网描述">Go 翻译于官网描述</a></h1>
<h4 id="go-语言具有很强的表达能力它简洁清晰而高效得益于其并发机制-用它编写的程序能够非常有效地利用多核与联网的计算机其新颖的类型系统则使程序结构变得灵活而模块化-go-代码编译成机器码不仅非常迅速还具有方便的垃圾收集机制和强大的运行时反射机制-它是一个快速的静态类型的编译型语言感觉却像动态类型的解释型语言"><a class="header" href="#go-语言具有很强的表达能力它简洁清晰而高效得益于其并发机制-用它编写的程序能够非常有效地利用多核与联网的计算机其新颖的类型系统则使程序结构变得灵活而模块化-go-代码编译成机器码不仅非常迅速还具有方便的垃圾收集机制和强大的运行时反射机制-它是一个快速的静态类型的编译型语言感觉却像动态类型的解释型语言">Go 语言具有很强的表达能力，它简洁、清晰而高效。得益于其并发机制， 用它编写的程序能够非常有效地利用多核与联网的计算机，其新颖的类型系统则使程序结构变得灵活而模块化。 Go 代码编译成机器码不仅非常迅速，还具有方便的垃圾收集机制和强大的运行时反射机制。 它是一个快速的、静态类型的编译型语言，感觉却像动态类型的解释型语言。</a></h4>
<div style="break-before: page; page-break-before: always;"></div><h2 id="go语法"><a class="header" href="#go语法">Go语法</a></h2>
<h4 id="hello-go"><a class="header" href="#hello-go">Hello, Go!</a></h4>
<pre><code class="language-go editable">package main

import &quot;fmt&quot;

func main() {
	fmt.Println(&quot;Hello, AwesomeProgram&quot;)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><p><img src="https://awesomeprogram.gitee.io/imgdata/techs/202207061914193.png" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="区块链技术"><a class="header" href="#区块链技术">区块链技术</a></h1>
<h4 id="一个不断增长的记录列表被称为区块链中的块这些记录使用密码学安全地链接在一起整个区块链采用分布式且去中心的网络"><a class="header" href="#一个不断增长的记录列表被称为区块链中的块这些记录使用密码学安全地链接在一起整个区块链采用分布式且去中心的网络">一个不断增长的记录列表，被称为区块链中的块，这些记录使用密码学安全地链接在一起；整个区块链采用分布式且去中心的网络。</a></h4>
<h2 id="假想"><a class="header" href="#假想">假想</a></h2>
<ul>
<li>未来互联网采用的必要技术之一。</li>
<li>产业区块链将会创造额外的价值。</li>
<li>自治下的社会体系，将会是一个公共记录的网络。</li>
</ul>
<h2 id="目录-2"><a class="header" href="#目录-2">目录</a></h2>
<ul>
<li><a href="blockchain/./chapter_1_1.html">区块链简史</a></li>
<li><a href="blockchain/./chapter_1_2.html">区块链框架</a>
<ul>
<li><a href="blockchain/./chapter_1_2_1.html">substrate</a>
<ul>
<li><a href="blockchain/./chapter_1_2_1_1.html">基本原理</a></li>
<li><a href="blockchain/./chapter_1_2_1_2.html">构建与编码</a></li>
<li><a href="blockchain/./chapter_1_2_1_3.html">启动区块链网络</a></li>
<li><a href="blockchain/./chapter_1_2_1_4.html">自定义pallet</a></li>
<li><a href="blockchain/./chapter_1_2_1_5.html">开发智能合约</a></li>
<li><a href="blockchain/./chapter_1_2_1_6.html">桥接其它链</a></li>
<li><a href="blockchain/./chapter_1_2_1_7.html">工具集成</a></li>
<li><a href="blockchain/./chapter_1_2_1_8.html">测试</a></li>
</ul>
</li>
<li><a href="blockchain/./chapter_1_2_2.html">fabric</a>
<ul>
<li><a href="blockchain/./chapter_1_2_2_1.html">基本原理</a></li>
<li><a href="blockchain/./chapter_1_2_2_2.html">构建与开发</a></li>
</ul>
</li>
<li><a href="blockchain/./chapter_1_2_3.html">EOSIO</a>
<ul>
<li><a href="blockchain/./chapter_1_2_3_1.html">基本原理</a></li>
<li><a href="blockchain/./chapter_1_2_3_2.html">构建与开发</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="blockchain/./chapter_1_3.html">智能合约与DApp</a>
<ul>
<li><a href="blockchain/./chapter_1_3_1.html">Move</a></li>
<li><a href="blockchain/./chapter_1_3_2.html">Solidity</a></li>
<li><a href="blockchain/./chapter_1_3_3.html">Hardhat</a></li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="区块链简史"><a class="header" href="#区块链简史">区块链简史</a></h1>
<p><img src="https://awesomeprogram.gitee.io/imgdata/tech_bc_his.png" alt="" /></p>
<h3 id="公链"><a class="header" href="#公链">公链</a></h3>
<p>公共区块链绝对没有访问限制。任何有网络访问能力的人都可以向它发送事务，也可以成为验证者（即，参与共识协议的执行）。通常，这样的网络为那些使用某种类型的权益证明或工作量证明算法的人提供经济激励。一些最大、最知名的公共区块链，如，比特币区块链和以太坊区块链。</p>
<h3 id="私链"><a class="header" href="#私链">私链</a></h3>
<p>私有的区块链是有准入权限的，除非网络管理员邀请，否则不能加入。为了区分开放区块链和其他非开放专用计算集群的点对点去中心化数据库应用程序，分布式账本（DLT）通常用于私有区块链。任何人想要加入网络必须获得区块链集中管理员的授权，公众不能直接访问。</p>
<h3 id="联盟链"><a class="header" href="#联盟链">联盟链</a></h3>
<p>联盟链也是一种需要授权的区块链，但与私链不同的是，它由多个组织或机构管理，每个组织或机构管理一个或多个节点，其数据只允许系统中不同的机构读写和发送事务。联盟链的每个节点通常都有对应的实体组织，只有授权后才能加入或退出网络。各组织形成利益相关者联盟，共同维护区块链的健康运行。</p>
<h3 id="混合链"><a class="header" href="#混合链">混合链</a></h3>
<p>混合链是一种独特的区块链技术，它结合了公共链和私有链的特点，利用公共链和私人链各自的特点，结合成为最佳解决方案，换句话说，混合链有两种状态：公共链和私有链。</p>
<h3 id="侧链"><a class="header" href="#侧链">侧链</a></h3>
<p>侧链是与主区块链并行运行的区块链账本的名称。来自主区块链的条目(其中所说的条目通常代表数字资产)可以链接到侧链，也可以从侧链连接；这允许侧链以其他方式独立于主区块链运行（如，通过使用另一种保持记录的方法，另一种共识算法等）。</p>
<h3 id="比特币"><a class="header" href="#比特币">比特币</a></h3>
<p>比特币是一种去中心化的数字货币，可以在点对点比特币网络上进行传输，比特币交易由网络节点通过加密技术进行验证，并记录在一个名为区块链的公共分布式账本中。</p>
<h3 id="以太坊"><a class="header" href="#以太坊">以太坊</a></h3>
<p>以太坊是一个去中心化、开源的区块链，具有智能合约功能。以太币（ETH）是该平台的原生加密货币。在加密货币中，以太币的市值仅次于比特币。</p>
<h3 id="莱特币"><a class="header" href="#莱特币">莱特币</a></h3>
<p>莱特币是一个分布式点对点的加密货币和开源软件项目，根据 MIT/X11 开源协议发布。在技术细节方面，莱特币主链共享一个稍微修改的比特币代码库，这些代码差异的实际效果是为了更低的交易费用，更快的交易确认以及更快的挖矿难度目标重定。由于其与比特币的潜在相似性，莱特币历来被称为“比特币的黄金之银”。2022年，莱特币通过MWEB（MimbleWimble 扩展块）升级，通过软分叉的方式添加了可选的隐私功能。</p>
<h3 id="coin-与-token"><a class="header" href="#coin-与-token">Coin 与 Token</a></h3>
<p>Coin 和 Token 在基本层面上非常相似，它们都代表价值，可以处理支付，也可以用 Coin 交换 Token，反之亦然。大多数加密货币用户通常同时拥有 Coin 和 Token。如果加密货币交易由区块链处理，Coin 必须作用于区块链，而 Token 则依赖于智能合约。</p>
<h3 id="decentralized-application"><a class="header" href="#decentralized-application">Decentralized application</a></h3>
<p>一个去中心化的应用程序（DApp，dApp，Dapp，dapp）是一个可以自主操作的应用程序，通常通过使用智能合约，运行在去中心化计算，区块链或其他分布式账本系统上。与传统应用程序一样，DApps 为用户提供一些功能或实用程序。然而与传统应用程序不同的是，DApps 不需要人工干预就可以运行，也不属于任何一个实体，而是 DApps 分布式的 tokens 代表其所有权。</p>
<h3 id="decentralized-finance"><a class="header" href="#decentralized-finance">Decentralized finance</a></h3>
<p>通过在区块链上使用智能合约，由去中心化金融（DeFi）提供金融工具，而不依赖券商、交易所或银行等中介机构。DeFi 平台允许人们从他人那里借入资金，利用衍生品对资产的价格走势进行投机，交易加密货币，投保风险，并从类似储蓄的账户中赚取利息。DeFi 使用分层架构和高度可组合的模块构建，一些应用虽然促进了的高利率，但也存在较高的风险。</p>
<h3 id="decentralized-for-your-business"><a class="header" href="#decentralized-for-your-business">Decentralized for your business</a></h3>
<div style="break-before: page; page-break-before: always;"></div><h1 id="区块链框架"><a class="header" href="#区块链框架">区块链框架</a></h1>
<h2 id="substrate"><a class="header" href="#substrate">substrate</a></h2>
<p>一个面向多链未来的区块链框架。</p>
<p>使开发人员能够快速轻松地构建针对任何用例优化的未来证明区块链。</p>
<h2 id="fabric"><a class="header" href="#fabric">fabric</a></h2>
<h2 id="eosio"><a class="header" href="#eosio">EOSIO</a></h2>
<h2 id="智能合约与dapp"><a class="header" href="#智能合约与dapp">智能合约与DApp</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="substrate-1"><a class="header" href="#substrate-1">substrate</a></h1>
<h2 id="基本原理"><a class="header" href="#基本原理">基本原理</a></h2>
<ul>
<li><a href="blockchain/./chapter_1_2_1_1.html#substrate-%E6%A6%82%E5%BF%B5">区块链基础知识</a> 提供了有关与区块链开发相关的复杂性以及 Substrate 如何通过采用模块化，灵活和互操作方法来简化构建过程。</li>
<li><a href="blockchain/./chapter_1_2_1_1.html#substrate-%E4%BC%98%E7%82%B9">Substrate 优点</a> 讨论在传统智能合约平台上开发与使用底层开发的区别，以及为什么 Substrate 可能适合或可能不适合你的项目需求和目标。</li>
<li><a href="blockchain/./chapter_1_2_1_1.html#substrate-%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1">Substrate 架构设计</a> 描述了 Substrate 节点架构的关键组件，以及这些组件与定制区块链的设计和架构的关系。</li>
<li><a href="blockchain/./chapter_1_2_1_1.html#%E7%BD%91%E7%BB%9C%E5%92%8C%E5%8C%BA%E5%9D%97%E9%93%BE">网络和区块链</a> 定义了不同类型区块链部署场景的网络拓扑，以及它们如何基于 Substrate 构建区块链。</li>
<li><a href="blockchain/./chapter_1_2_1_1.html#runtime-%E5%BC%80%E5%8F%91">Runtime 开发</a> 强调了 Substrate 运行时的重要性，并介绍了核心应用接口，以及 Substrate 运行时开发所需的原语。</li>
<li><a href="blockchain/./chapter_1_2_1_1.html#%E5%85%B1%E8%AF%86">共识</a> 描述了最常见的共识模型，以及你可以为 Substrate 区块链实现的共识类型。</li>
<li><a href="blockchain/./chapter_1_2_1_1.html#%E4%BA%A4%E6%98%93%E5%92%8C%E5%8C%BA%E5%9D%97%E5%9F%BA%E7%A1%80">交易和区块基础</a> 介绍了交易类型和组区成块的组件。</li>
<li><a href="blockchain/./chapter_1_2_1_1.html#%E4%BA%A4%E6%98%93%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">交易生命周期</a> 解释了交易如何被接收、排队和执行，以及最终被包含在一个块中。</li>
<li><a href="blockchain/./chapter_1_2_1_1.html#%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E5%92%8C%E5%AD%98%E5%82%A8">状态转换和存储</a> 描述了如何使用 trie 数据结构和键值数据库存储和管理运行时中处理的状态更改。</li>
<li><a href="blockchain/./chapter_1_2_1_1.html#accounts-addresses-and-keys">Accounts、addresses和keys</a> 解释了 Accounts，addresses 和 keys 之间的关系以及它们的使用方式。</li>
<li><a href="blockchain/./chapter_1_2_1_1.html#rust-for-substrate">Rust for Substrate</a> 强调了 Rust 特性，包括 traits、泛型、关联类型和宏，在构建基于 Substrate 的区块链时，你应该非常熟悉。</li>
<li><a href="blockchain/./chapter_1_2_1_1.html#%E9%93%BE%E4%B8%8B%E6%93%8D%E4%BD%9C">链下操作</a> 探讨了处理一些链下操作的原因，以及执行这些链下操作的备选方案。</li>
</ul>
<h2 id="构建与编码"><a class="header" href="#构建与编码">构建与编码</a></h2>
<ul>
<li><a href="blockchain/./chapter_1_2_1_2.html#%E4%BB%A3%E7%A0%81%E5%BA%93%E7%9A%84%E4%BB%8B%E7%BB%8D">代码库的介绍</a> 重点强调了核心节点库和它们的结构，以提供构建 Substrate 节点的模块化框架。</li>
<li><a href="blockchain/./chapter_1_2_1_2.html#%E6%9E%84%E5%BB%BA%E8%BF%87%E7%A8%8B">构建过程</a> 深入研究了 Rust Code 如何编译为 Rust Binary 和 WebAssembly 目标，以及如何使用这两个目标来优化节点操作的细节。</li>
<li><a href="blockchain/./chapter_1_2_1_2.html#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%AD%98%E5%82%A8">运行时存储</a> 提供了更详细的存储结构分析，以及如何查找存储在运行时中的数据。</li>
<li><a href="blockchain/./chapter_1_2_1_2.html#%E4%BA%A4%E6%98%93%E6%9D%83%E9%87%8D%E5%92%8C%E8%B4%B9%E7%94%A8">交易、权重和费用</a> 解释了权重和费用在执行交易中的作用，以及如何计算和退还费用的机制。</li>
<li><a href="blockchain/./chapter_1_2_1_2.html#%E8%87%AA%E5%AE%9A%E4%B9%89-pallets">自定义 pallets</a> 公开了构成构建自定义 pallets 基础的宏和属性。</li>
<li><a href="blockchain/./chapter_1_2_1_2.html#pallet-%E8%80%A6%E5%90%88">Pallet 耦合</a> 描述了如何在运行时紧密或松散地耦合 Pallet。</li>
<li><a href="blockchain/./chapter_1_2_1_2.html#%E4%BA%8B%E4%BB%B6%E5%92%8C%E9%94%99%E8%AF%AF">事件和错误</a> 解释了如何从运行时发出事件和错误。</li>
<li><a href="blockchain/./chapter_1_2_1_2.html#randomness">Randomness</a> 建议了在基于 Substrate 的区块链上运行的应用程序中包含的随机性方法。</li>
<li><a href="blockchain/./chapter_1_2_1_2.html#chain-specification">Chain specification</a> 讨论 chain specifications 的使用，包括可以修改和不能修改的内容，以及如何发布定制的 chain specifications。</li>
<li><a href="blockchain/./chapter_1_2_1_2.html#privileged-calls-and-origins">Privileged calls and origins</a> 描述如何使用预定义或自定义源来标识函数调用的发起人。</li>
<li><a href="blockchain/./chapter_1_2_1_2.html#%E8%BF%9C%E7%A8%8B%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8">远程过程调用</a> 总结了如何使用远程过程调用和 RPC 方法与 Substrate 节点进行交互。</li>
<li><a href="blockchain/./chapter_1_2_1_2.html#%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91">应用程序开发</a> 介绍元数据和前端库作为运行在区块链之上，构建的应用程序的工具的作用。</li>
<li><a href="blockchain/./chapter_1_2_1_2.html#%E5%8D%87%E7%BA%A7%E8%BF%90%E8%A1%8C%E6%97%B6">升级运行时</a> 说明了如何对运行时进行版本控制，以及存储迁移支持运行时升级，使你的区块链能够随着时间的推移而发展。</li>
</ul>
<h2 id="启动区块链网络"><a class="header" href="#启动区块链网络">启动区块链网络</a></h2>
<ul>
<li><a href="blockchain/./chapter_1_2_1_3.html#%E6%9E%84%E5%BB%BA%E6%9C%AC%E5%9C%B0%E5%8C%BA%E5%9D%97%E9%93%BE">构建本地区块链</a> 向你展示了如何在开发环境中设置本地节点并与之交互。</li>
<li><a href="blockchain/./chapter_1_2_1_3.html#%E6%A8%A1%E6%8B%9F%E5%8C%BA%E5%9D%97%E9%93%BE%E7%A7%81%E6%9C%89%E7%BD%91%E7%BB%9C">模拟网络</a> 可以帮助你使用预定义帐户模拟两个节点的网络。</li>
<li><a href="blockchain/./chapter_1_2_1_3.html#%E6%B7%BB%E5%8A%A0%E5%8F%AF%E4%BF%A1%E4%BB%BB%E7%9A%84%E8%8A%82%E7%82%B9">添加可信任的节点</a> 演示如何生成密钥和派生一个 chain specification，以创建一个小型的可信验证器节点网络。</li>
<li><a href="blockchain/./chapter_1_2_1_3.html#%E7%9B%91%E8%A7%86%E8%8A%82%E7%82%B9%E6%8C%87%E6%A0%87">监视节点指标</a> 突出显示了如何利用 Substrate 公开的节点指标。</li>
<li><a href="blockchain/./chapter_1_2_1_3.html#%E5%8D%87%E7%BA%A7%E6%AD%A3%E5%9C%A8%E8%BF%90%E8%A1%8C%E7%9A%84%E8%8A%82%E7%82%B9">升级一个运行中的网络</a> 说明了通过修改正在运行的 Substrate 节点的运行时进行无分叉升级。</li>
</ul>
<h2 id="自定义pallet"><a class="header" href="#自定义pallet">自定义pallet</a></h2>
<ul>
<li><a href="blockchain/./chapter_1_2_1_4.html#%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%B8%AApallet%E5%88%B0%E8%BF%90%E8%A1%8C%E6%97%B6">添加一个pallet到运行时</a> 演示向 node template 运行时添加简单预定义 pallet 的常见步骤。</li>
<li><a href="blockchain/./chapter_1_2_1_4.html#%E9%85%8D%E7%BD%AE%E5%90%88%E7%BA%A6pallet">配置合约pallet</a> 演示了如何配置复杂托盘以使用智能合约。</li>
<li><a href="blockchain/./chapter_1_2_1_4.html#%E5%9C%A8%E8%87%AA%E5%AE%9A%E4%B9%89pallet%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%AE%8F">在自定义pallet中使用宏</a> 说明了如何使用宏创建自定义 pallet。</li>
<li><a href="blockchain/./chapter_1_2_1_4.html#%E6%8C%87%E5%AE%9A%E8%B0%83%E7%94%A8%E7%9A%84%E6%9D%A5%E6%BA%90">指定调用的来源</a> 演示了如何指定函数调用发起者的帐户。</li>
</ul>
<h2 id="开发智能合约"><a class="header" href="#开发智能合约">开发智能合约</a></h2>
<ul>
<li><a href="blockchain/./chapter_1_2_1_5.html#%E5%87%86%E5%A4%87%E7%AC%AC%E4%B8%80%E4%BB%BD%E5%90%88%E7%BA%A6">准备第一份合约</a> 描述了如何使用 ink! 编程语言来更新开发环境和创建智能合约项目。</li>
<li><a href="blockchain/./chapter_1_2_1_5.html#%E5%BC%80%E5%8F%91%E4%B8%80%E4%BB%BD%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6">开发一份智能合约</a> 演示如何使用智能合约存储、增加和检索一些简单的值。</li>
<li><a href="blockchain/./chapter_1_2_1_5.html#%E4%BD%BF%E7%94%A8maps%E5%AD%98%E5%82%A8%E5%80%BC">使用maps存储值</a> 通过演示如何在智能合约中使用 maps 存储和检索值，扩展了上一个教程。</li>
<li><a href="blockchain/./chapter_1_2_1_5.html#%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AAtoken%E5%90%88%E7%BA%A6">构建一个token合约</a> 说明了如何构建一个简单的智能合约来转移 ERC-20 代币。</li>
<li><a href="blockchain/./chapter_1_2_1_5.html#%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E7%9A%84%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5">智能合约的问题排查</a> 介绍编写和部署智能合约时可能遇到的一些常见问题。</li>
</ul>
<h2 id="桥接其它链"><a class="header" href="#桥接其它链">桥接其它链</a></h2>
<ul>
<li><a href="blockchain/./chapter_1_2_1_6.html#%E5%87%86%E5%A4%87%E4%B8%80%E4%B8%AA%E6%9C%AC%E5%9C%B0%E5%B9%B3%E8%A1%8C%E9%93%BE%E7%9A%84%E6%B5%8B%E8%AF%95%E7%BD%91%E5%87%86%E5%A4%87%E4%B8%80%E4%B8%AA%E6%9C%AC%E5%9C%B0%E4%B8%AD%E7%BB%A7%E9%93%BE">准备一个本地平行链的测试网</a> 帮助你准备一个本地的中继链作为第一步，为了将一个单链转化为一个平行链。</li>
<li><a href="blockchain/./chapter_1_2_1_6.html#%E8%BF%9E%E6%8E%A5%E6%9C%AC%E5%9C%B0%E5%B9%B3%E8%A1%8C%E9%93%BE">连接本地平行链</a> 展示了将本地平行链连接到中继链所需的步骤。</li>
<li><a href="blockchain/./chapter_1_2_1_6.html#%E8%BF%9E%E6%8E%A5rococo%E6%B5%8B%E8%AF%95%E7%BD%91%E8%8E%B7%E5%8F%96%E6%B5%8B%E8%AF%95%E7%BD%91%E6%8F%92%E6%A7%BD">连接Rococo测试网</a> 总结了将平行链连接到 Rococo 测试网的步骤。</li>
</ul>
<h2 id="工具集成"><a class="header" href="#工具集成">工具集成</a></h2>
<ul>
<li><a href="blockchain/./chapter_1_2_1_7.html#%E9%9B%86%E6%88%90%E4%B8%80%E4%B8%AA%E8%BD%BB%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%8A%82%E7%82%B9">集成一个轻客户端节点</a> 描述如何使用 Substrate Connect 轻客户端节点以达到同步，并从一个浏览器与 Substrate 链进行交互。</li>
<li><a href="blockchain/./chapter_1_2_1_7.html#%E8%AE%BF%E9%97%AEevm%E8%B4%A6%E6%88%B7">访问<strong>EVM</strong>帐户</a> 说明了如何使用自定义的 Substrate 节点访问基于以太坊的帐户和合约。</li>
<li><a href="blockchain/./chapter_1_2_1_7.html#%E4%BB%A5%E5%A4%AA%E5%9D%8A%E9%9B%86%E6%88%90">以太坊集成</a></li>
</ul>
<h2 id="测试"><a class="header" href="#测试">测试</a></h2>
<ul>
<li><a href="blockchain/./chapter_1_2_1_8.html#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95">单元测试</a> 解释如何使用Rust测试框架和模拟运行时环境来执行单元测试，以验证代码的单个函数或模块。</li>
<li><a href="blockchain/./chapter_1_2_1_8.html#%E8%B0%83%E8%AF%95">调试</a> 描述如何使用 Rust 日志功能调试运行时。</li>
<li><a href="blockchain/./chapter_1_2_1_8.html#%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95">基准测试</a> 解释了基准测试的作用，以及如何使用基准测试框架来评估代码中函数调用的性能，还有如何调整交易权重以准确反映执行时间。</li>
</ul>
<p><img src="https://awesomeprogram.gitee.io/imgdata/techs/tech_bc_subparachains.jpg" alt="" /></p>
<p><img src="https://awesomeprogram.gitee.io/imgdata/techs/tech_bc_subparachains2.jpg" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="基本原理-1"><a class="header" href="#基本原理-1">基本原理</a></h1>
<p>基本原理中的主题解释了 Substrate 开发环境的许多核心原则和独特功能，并重点介绍了作为区块链构建者你可以使用的一些设计决策。Substrate 提供了一个模块化和灵活的工具库，使你能够选择、组合、修改和复用组件，以满足你想要创建的区块链的需求目的，无论是私有网络还是发布一个可以通过 Polkadot 网络与其他区块链交互的区块链。</p>
<p>基本原理中旨在帮助你了解基于 Substrate 构建区块链时可能遇到的问题，以及 Substrate 如何帮助你构建最能满足你指定项目需求或商业模式的区块链。</p>
<h2 id="substrate-概念"><a class="header" href="#substrate-概念">substrate 概念</a></h2>
<h3 id="什么是区块链节点"><a class="header" href="#什么是区块链节点">什么是区块链节点</a></h3>
<p>在较高的级别上，所有区块链节点都需要以下核心组件：</p>
<ul>
<li>作为交易结果记录的状态变化的数据存储。</li>
<li>节点间分散通信的点对点网络。</li>
<li>共识的方法来防止恶意活动，并确保链的持续进展。</li>
<li>用于排序和处理传入交易的逻辑。</li>
<li>用于为块生成哈希摘要以及用于签名和验证与交易相关的签名的加密。</li>
</ul>
<p>由于构建区块链所需的核心组件所涉及的复杂性，大多数区块链项目都是从现有区块链代码库的完整副本开始的，这样开发人员就可以修改现有代码以添加新特性，而不是从头编写所有内容。例如，比特币仓库分叉，创建了莱特币、ZCash、Namecoin 和比特币现金。类似地，以太坊仓库被分叉以创建 Quorum、POA Network、KodakCoin 和 Musicoin。</p>
<p>但是，大多数区块链平台的设计不允许修改或定制。因此，通过fork构建新的区块链存在严重的限制，包括原始区块链代码中固有的可伸缩性等限制。在探索Substrate如何缓解与其他区块链项目相关的许多限制之前，重要的是要了解大多数区块链共享的一些常见属性。通过了解大多数区块链的运行方式，你将更好地了解Substrate如何为构建最适合你需求的区块链提供替代方案和功能。</p>
<h3 id="状态转换和分歧"><a class="header" href="#状态转换和分歧">状态转换和分歧</a></h3>
<p>区块链本质上是一个状态机。在任何时间点，区块链都有当前的内部状态。在执行入站交易时，它们会导致状态的更改，因此区块链必须从当前状态转换到新状态。但是，可能有多个有效的转换会导致不同的未来状态，区块链必须选择一个可以商定的状态转换。要对转换后的状态达成一致，区块链中的所有操作都必须是确定性的。为了使链成功地进行，大多数节点必须对所有的状态转换达成一致，包括：</p>
<ul>
<li>链的初始状态，称为创世纪或创世纪块。</li>
<li>由每个块中记录的执行交易产生的一系列状态转换。</li>
<li>将块包含在链条中的最终状态。</li>
</ul>
<p>在集中式网络中，中央机构可以在相互排斥的国家过渡之间进行选择。例如，配置为主要权限的服务器可能会以其看到的顺序记录对状态过渡的更改，或者在发生冲突时使用权重过程在竞争替代方案之间进行选择。在分散的网络中，节点在不同的订单中查看交易，因此他们必须使用更详细的方法来选择交易并在冲突状态过渡之间进行选择。</p>
<p>区块链用来将交易分解为块的方法并选择哪个节点可以向链条提交块，称为区块链的共识模型或共识算法。最常用的共识模型称为工作证明共识模型。通过工作证明共识模型，首先完成计算问题的节点有权向链条提交块。</p>
<p>为了使区块链具有容错性，并在某些节点被恶意行为者破坏或网络中断时提供一致的状态视图，一些共识模型要求至少三分之二的节点始终对状态达成一致。这三分之二的多数保证了网络是容错的，并且可以承受一些网络参与者的不良行为，无论这种行为是有意的还是偶然的。</p>
<h3 id="区块链经济"><a class="header" href="#区块链经济">区块链经济</a></h3>
<p>所有区块链都需要资源处理器、内存、存储和网络带宽来执行操作。参与网络的计算机(产生区块的节点)向区块链用户提供这些资源。这些节点创建了一个分布式的、去中心化的网络，以满足社区参与者的需求。</p>
<p>为了支持一个社区并使区块链可持续发展，大多数区块链要求用户以交易费用的形式为他们使用的网络资源付费。交易费用的支付要求用户身份与持有某种类型资产的账户相关联。区块链通常使用代币来代表账户中的资产价值，网络参与者通过交易所在链外购买代币。然后，网络参与者可以存入代币，使他们能够支付交易。</p>
<h3 id="区块链治理"><a class="header" href="#区块链治理">区块链治理</a></h3>
<p>一些区块链允许网络参与者提交并投票影响网络运营或区块链社区的提案。通过对提案的提交和投票，区块链社区可以决定区块链如何在基本的民主进程中发展。然而，链上治理相对少见，为了参与，区块链可能需要用户在帐户中维护大量代币，或被选为其他用户的代表。</p>
<h3 id="在区块链上运行应用程序"><a class="header" href="#在区块链上运行应用程序">在区块链上运行应用程序</a></h3>
<p>运行在区块链上的应用程序通常被称为去中心化应用程序或 dApps，它们通常是使用前端框架编写的web应用程序，但使用后端智能合约来更改区块链状态。</p>
<p>智能合约是在区块链上运行的程序，在特定条件下代表用户执行交易。开发人员可以编写智能合约，以确保通过编程执行的交易的结果被记录下来，不会被篡改。然而，仅使用智能合约，开发人员无法访问一些底层区块链功能，如共识、存储或交易层，相反，需要遵守链的固定规则和限制。智能合约开发者通常会接受这些限制，并将其作为一种权衡，即能够在更短的开发时间内做出更少的核心设计决策。</p>
<h2 id="substrate-优点"><a class="header" href="#substrate-优点">substrate 优点</a></h2>
<p>所有的区块链都有一些共同的特征。虽然 Substrate 本身不是区块链，但它是区块链构建器的工具包，带有模块化的组件框架，可以创建自定义区块链。使用 Substrate，你可以使用常见的区块链组件，如存储、共识和密码学，并将它们组合起来以按原样使用它们提供的功能，或者修改它们以适应项目的目的。</p>
<p>区块链开发是复杂的。它涉及到复杂的技术，包括高级密码学和分布式网络通信，你必须正确使用这些技术，以便为运行应用程序和用户信任提供安全的平台。在规模、治理、互操作性和可升级性方面存在一些难以解决的问题。复杂性为开发人员创造了很高的准入门槛。考虑到这一点，要回答的第一个问题是：你想要构建什么？</p>
<p>Substrate 并不完全适合每个用例、应用程序或项目。但是，如果你想构建一个区块链，那么 Substrate 可能是最佳选择：</p>
<ul>
<li>针对一个非常具体的用例进行定制</li>
<li>能够与其他可定制的区块链连接和通信</li>
<li>预定义的可组合模块化组件能够随着时间的升级而演变和变化</li>
</ul>
<p>Substrate是一个专门设计的软件开发工具包（SDK），旨在为你提供区块链所需的所有基本组件，以便你能够专注于打造使你的区块链独特和创新的逻辑。与其他分布式账本平台不同，Substrate 是：</p>
<ul>
<li>大多数区块链平台都有非常紧密耦合的、固执己见的子系统，很难解耦。基于另一个区块链分叉的链也存在风险，那些不明显的耦合可能从根本上破坏区块链系统本身。Substrate是一个完全模块化的区块链框架，通过选择适合你项目的网络堆栈、共识模型或治理方法或创建自己的组件，你可以使用显式解耦的组件组成链。使用 Substrate，你可以为你的规范设计部署和构建区块链，它也可以随你的需求变化而变化。</li>
<li>所有的 Substrate 架构和工具都可以在开源许可下使用。Substrate 框架的核心组件使用 <code>libp2p</code> 和 <code>jsonRPC</code> 等开放协议，同时允许你决定对区块链架构的自定义程度。Substrate 还拥有一个大型的、活跃的、有帮助的构建者社区，为生态系统做出贡献。来自社区的贡献增强了你在自身区块链发展过程中融入的能力。</li>
<li>大多数区块链平台提供的与其他区块链网络交互的能力有限。所有基于 Substrate 的区块链都可以通过跨共识消息传递（XCM）与其他区块链互操作。Substrate 可用于创建作为独立网络的链（单链），也可以中继链紧密耦合，以共享其作为平行链的安全性。</li>
<li>Substrate 是可升级、可组合和可适应的。Substrate 运行时的状态转换逻辑是一个自包含的 WebAssembly 对象。你的节点可以在特定条件下完全更改运行时本身，从而在网络范围内实现运行时升级。因此，可以进行“分叉”升级，因为在大多数情况下，节点在这个新运行时中都不需要任何操作。随着时间的推移，网络的运行时协议可以无缝地、甚至是彻底地随着用户的需求发展。</li>
</ul>
<h2 id="substrate-架构设计"><a class="header" href="#substrate-架构设计">substrate 架构设计</a></h2>
<p>由于节点是任何区块链的核心组件，因此了解 Substrate 节点的独特性非常重要，包括默认提供的核心服务和库，以及如何定制和扩展节点以适应不同的项目目标。</p>
<p>在去中心化网络中，所有节点既充当请求数据的客户机，又充当响应数据请求的服务器。在概念上和编程上，Substrate 体系结构按照类似的方式划分操作职责。下图以简化形式说明了这种职责分离，以帮助你可视化架构以及 Substrate 如何为构建区块链提供模块化框架。</p>
<p><img src="https://awesomeprogram.gitee.io/imgdata/tech_bc_subarch.jpg" alt="" /></p>
<p>在较高的层次上，Substrate 节点提供了具有两个主要元素的分层环境：</p>
<ul>
<li>一种处理网络活动的外部节点，如对等点发现、管理交易请求、与对等点达成共识以及响应 RPC 调用。</li>
<li>一个包含用于执行区块链状态转换函数的所有业务逻辑的运行时。</li>
</ul>
<h3 id="外部节点"><a class="header" href="#外部节点">外部节点</a></h3>
<p>外部节点负责运行时之外发生的活动。例如，外部节点负责处理对等点发现、管理交易池、与其他节点通信以达成共识，以及应答来自外部世界的 RPC 调用或浏览器请求。</p>
<p>外部节点处理的一些最重要的活动涉及以下组件：</p>
<ul>
<li>存储：外部节点使用简单而高效的键值存储层持久化 Substrate 区块链的演进状态。</li>
<li>点对点网络：外部节点使用 libp2p 网络栈的 Rust 实现与其他网络参与者通信。</li>
<li>共识：外部节点与其他网络参与者通信，以确保他们对区块链的状态达成一致。</li>
<li>远程过程调用（RPC）API：外部节点接受入站HTTP和WebSocket请求，以允许区块链用户与网络交互。</li>
<li>遥测：外部节点通过嵌入的 Prometheus 服务器收集并提供对节点指标的访问。</li>
<li>执行环境：外部节点负责为运行时选择要使用的执行环境 WebAssembly 或本地 Rust 程序，然后分发调用所选的运行时。</li>
</ul>
<p>执行这些任务通常需要外部节点向运行时查询信息或向运行时提供信息。这种通信通过调用专门的运行时 APIs 来处理。</p>
<h3 id="运行时"><a class="header" href="#运行时">运行时</a></h3>
<p>运行时确定交易是有效还是无效，并负责处理对区块链状态转换函数的更改。</p>
<p>因为运行时执行它接收到的函数，所以它控制如何将交易包含在块中，以及如何将块返回给外部节点以进行传播或导入到其他节点。本质上，运行时负责处理链上发生的所有事情。它也是构建 Substrate 区块链节点的核心组件。</p>
<p>Substrate 运行时被设计用来编译成 WebAssembly（Wasm）字节码。此设计决策会强制以下功能：</p>
<ul>
<li>支持无分叉升级。</li>
<li>多平台兼容性。</li>
<li>运行时有效性检查。</li>
<li>中继链共识机制的验证证明。</li>
</ul>
<p>与外部节点向运行时提供信息的方式类似，运行时使用专门的主机函数与外部节点或外部世界通信。</p>
<h3 id="轻客户端节点"><a class="header" href="#轻客户端节点">轻客户端节点</a></h3>
<p>轻客户端或轻节点是只提供运行时和当前状态的 Substrate 节点的简化版本。轻节点使用户能够直接使用浏览器、浏览器扩展、移动设备或台式电脑直接连接到 Substrate 运行时。使用轻客户端节点，你可以使用 Rust，JavaScript 或其他语言编写的 RPC 端点连接到 WebAssembly 执行环境，以读取块头，提交交易并查看交易结果。</p>
<h2 id="网络和区块链"><a class="header" href="#网络和区块链">网络和区块链</a></h2>
<p>在考虑构建区块链时，考虑到边界是定义网络的方法，这是有用的。例如，连接到单个路由器的一组计算机可以视为家庭网络。防火墙可能是定义企业网络的边界。较小的隔离网络可以通过公共通信协议连接到广域网。类似地，你可以将区块链网络视为由其边界与其他区块链的隔离或通信来定义的。</p>
<p>作为区块链的构建工具，Substrate 使你能够开发任何类型的区块链，并根据你的应用程序的特定需求定义其边界。考虑到这种灵活性，你需要做出的决定之一是要构建的网络类型以及不同节点在该网络中可能扮演的角色。</p>
<h3 id="网络类型"><a class="header" href="#网络类型">网络类型</a></h3>
<p>基于 Substrate 的区块链可用于不同类型的网络架构。例如，Substrate 区块链用于构建以下网络类型：</p>
<ul>
<li>私有网络：限制访问，受限节点集群的网络。</li>
<li>单独链：实现自己的安全协议，不与任何其他链连接或通信。比特币和以太坊是基于非 substrate 的单链的例子。</li>
<li>中继链：为连接到它们的其他链提供分散安全性和通信。Kusama 和 Polkadot 是中继链的例子。</li>
<li>平行链：连接到一个中继链，并有能力与使用同一中继链的其他链通信。因为平行链依赖于中继链来最终确定产生的区块，平行链必须实现与其目标中继链相同的共识协议。</li>
</ul>
<h3 id="节点类型"><a class="header" href="#节点类型">节点类型</a></h3>
<p>区块链需要对网络节点进行同步，以呈现区块链状态的一致和最新情况。每个同步节点存储一个区块链副本，并跟踪传入的交易。然而，保存整个区块链的完整副本需要大量的存储和计算资源，从创世区块到最近的区块，下载所有区块对于大多数用例来说并不实用。为了更容易地维护链的安全性和完整性，同时降低客户端希望访问区块链数据的资源需求，可以使用不同类型的节点与链进行交互。</p>
<ul>
<li>全节点</li>
<li>归档节点</li>
<li>轻客户端节点</li>
</ul>
<h4 id="全节点"><a class="header" href="#全节点">全节点</a></h4>
<p>全节点是区块链网络基础设施的关键部分，是最常见的节点类型。全节点存储区块链数据，通常参与常见的区块链操作，例如创建和验证块，接收和验证交易，以及响应用户请求提供数据服务。</p>
<p><img src="https://awesomeprogram.gitee.io/imgdata/tech_bc_subfullnode.jpg" alt="" /></p>
<p>默认情况下，全节点配置为仅存储最近的256个块，并丢弃比该块旧的状态（创世块除外），以防止全节点无限增长并消耗所有可用磁盘空间。可以配置完整节点保留的块数。</p>
<p>虽然旧的块被丢弃，但全节点保留了从创世块到最近块的所有块头，以验证状态是否正确。因为全节点可以访问所有的块头，所以可以通过执行从创世块开始的所有块来重建整个区块链的状态。因此，检索以前某个状态的信息需要更多的计算，通常应该使用归档。</p>
<p>全节点允许你读取链的当前状态，并直接在网络上提交和验证交易。通过丢弃旧块的状态，全节点所需的磁盘空间比归档节点少得多。然而，一个全节点需要更多的计算资源来查询和检索关于以前某个状态的信息。如果需要查询历史块，应该清除整个节点，然后以存档模式重新启动它。</p>
<h3 id="归档节点"><a class="header" href="#归档节点">归档节点</a></h3>
<p>归档节点类似于全节点，除了它们存储所有过去的块，每个块都有完整的状态可用。归档节点通常用于需要访问历史信息的实用程序，如区块链浏览器、钱包、论坛和类似应用程序。</p>
<p><img src="https://awesomeprogram.gitee.io/imgdata/tech_bc_subarchnode.jpg" alt="" /></p>
<p>由于存档节点保留历史状态，因此需要大量磁盘空间。由于运行归档节点需要大量的磁盘空间，因此归档节点不像全节点那样常见。然而，归档节点可以方便地在任何时间点查询链的过去状态。例如，你可以通过查询归档节点来查询某个区块中的帐户余额，或者查看导致特定状态更改的交易的详细信息。当你在归档节点中的数据上运行这些类型的查询时，它们会更快、更有效。</p>
<h3 id="轻客户端节点-1"><a class="header" href="#轻客户端节点-1">轻客户端节点</a></h3>
<p>轻客户端节点使你能够以最少的硬件资源连接到 Substrate 网络。</p>
<p><img src="https://awesomeprogram.gitee.io/imgdata/tech_bc_sublightnode.jpg" alt="" /></p>
<p>由于轻客户端节点需要最少的系统资源，所以它们可以嵌入到基于 web 的应用程序、浏览器扩展程序、移动设备应用程序或物联网设备（IoT）中。轻客户端节点通过 RPC 端点提供运行时和对当前状态的访问。轻客户端节点的 RPC 端点可以用 Rust、JavaScript 或其他语言编写，用于读取块头、提交交易和查看交易结果。</p>
<p>轻客户端节点不参与区块链或网络操作。例如，轻客户端节点不负责区块的创建或验证、传播交易或达成共识。轻客户端节点不存储任何过去的块，因此如果不从拥有历史数据的节点请求历史数据，它就无法读取历史数据。</p>
<h3 id="节点角色"><a class="header" href="#节点角色">节点角色</a></h3>
<p>根据启动节点时指定的命令行选项，节点可以在链的进程中扮演不同的角色，并可以提供对链上状态的不同级别的访问。例如，你可以限制被授权出新块的节点以及哪些节点可以与点对点节点通信。未被授权为出块的点对点节点可以导入新的区块，接收交易，并向其他节点发送和接收关于新交易的消息。还可以阻止节点连接到更广泛的网络，并限制节点与特定的节点通信。</p>
<h2 id="runtime-开发"><a class="header" href="#runtime-开发">Runtime 开发</a></h2>
<p>如架构中所述，Substrate 节点的运行时包含执行交易、保存状态转换以及与外部节点交互的所有业务逻辑。Substrate 提供了构建常见区块链组件所需的所有工具，因此你可以专注于开发定义区块链行为的运行时逻辑。</p>
<h3 id="状态转换和运行时"><a class="header" href="#状态转换和运行时">状态转换和运行时</a></h3>
<p>在最基本的层面上，每个区块链本质上都是在链上发生的每个变化的账本或记录。在基于 Substrate 的链中，这些对状态的变更被记录在运行时。由于运行时处理此操作，因此有时将运行时描述为提供状态转换的函数。</p>
<p>由于状态转换发生在运行时，因此运行时是你定义用于表示区块链状态的存储项，以及允许区块链用户更改此状态的交易。</p>
<p><img src="https://awesomeprogram.gitee.io/imgdata/tech_bc_substatetran.jpg" alt="" /></p>
<p>Substrate 运行时确定哪些交易有效和无效，以及如何响应交易，更改链状态。</p>
<h3 id="运行时接口"><a class="header" href="#运行时接口">运行时接口</a></h3>
<p>正如你在架构设计中所学到的，外部节点负责处理点对点网络的发现、交易池、区块与交易的传播、共识，以及响应来自外部世界的 RPC 调用。这些任务经常需要外部节点向运行时查询信息或向运行时提供信息。运行时API促进了外部节点和运行时之间的这种通信。</p>
<p>在Substrate中，<code>sp_api</code> crate 提供了实现运行时 API 的接口。它旨在让你能够灵活地使用 <strong>impl_runtime_apis</strong> 宏来自定义接口。然而，每个运行时都必须实现 <strong>Core</strong> 和 <strong>Metadata</strong> 接口。除了这些必需的接口之外，大多数 Substrate 节点（如 node template）都实现了以下运行时接口：</p>
<ul>
<li><a href="https://paritytech.github.io/substrate/master/sp_block_builder/trait.BlockBuilder.html">BlockBuilder</a>： 用于构建区块所需的功能。</li>
<li><a href="https://paritytech.github.io/substrate/master/sp_transaction_pool/runtime_api/trait.TaggedTransactionQueue.html">TaggedTransactionQueue</a>：用于验证交易。</li>
<li><a href="https://paritytech.github.io/substrate/master/sp_offchain/trait.OffchainWorkerApi.html">OffchainWorkerApi</a>：用于启用链下操作。</li>
<li><a href="https://paritytech.github.io/substrate/master/sp_consensus_aura/trait.AuraApi.html">AuraApi</a>：用于使用 round-robin 的共识方法进行区块的创建和验证。</li>
<li><a href="https://paritytech.github.io/substrate/master/sp_session/trait.SessionKeys.html">SessionKeys</a>：用于生成和解码 session 密钥。</li>
<li><a href="https://paritytech.github.io/substrate/master/sp_finality_grandpa/trait.GrandpaApi.html">GrandpaApi</a>：用于在运行时确认区块的终结。</li>
<li><a href="https://paritytech.github.io/substrate/master/frame_system_rpc_runtime_api/trait.AccountNonceApi.html">AccountNonceApi</a>：用于查询交易索引。</li>
<li><a href="https://paritytech.github.io/substrate/master/pallet_transaction_payment_rpc_runtime_api/trait.TransactionPaymentApi.html">TransactionPaymentApi</a>：用于查询有关交易的信息。</li>
<li><a href="https://paritytech.github.io/substrate/master/frame_benchmarking/trait.Benchmark.html">Benchmark</a>：用于估计和衡量完成交易所需的执行时间。</li>
</ul>
<h3 id="核心原语"><a class="header" href="#核心原语">核心原语</a></h3>
<p>Substrate 还定义了运行时必须实现的核心原语。Substrate 框架对运行时必须提供给其他 Substrate 层的内容做了最少的假设。然而，有一些数据类型必须被定义，并且必须满足特定的接口才能在 Substrate 框架中工作。
这些核心原语是：</p>
<ul>
<li><code>Hash</code>：一种对某些数据的密码摘要进行编码的类型。通常只有256位的数量。</li>
<li><code>DigestItem</code>：一种类型，必须能够编码，共识和 change-tracking 相关的多个“hard-wired”备选方案之一，以及与运行时内特定模块相关的任意多个“soft-coded”的变体。</li>
<li><code>Digest</code>：一系列 DigestItems。会编码与轻客户端在区块内相关的所有信息。</li>
<li><code>Extrinsic</code>：表示可以被区块链识别的外部的单个数据的类型。这通常涉及一个或多个签名，以及某些编码指令（例如，用于转移资金所有权或调用智能合约）</li>
<li><code>Header</code>：一种类型代表(以密码方式或其他方式)与一个块相关的所有信息。它包括 parent hash、the storage root 和 extrinsics trie root、the digest和区块号。</li>
<li><code>Block</code>：本质上只是 <code>Header</code> 和一系列 <code>Extrinsic</code> 元素的组合，以及要使用的哈希算法的规范。</li>
<li><code>BlockNumber</code>：一种对任何有效区块的历史总数进行编码的类型。通常是32位数量。</li>
</ul>
<h3 id="frame"><a class="header" href="#frame">FRAME</a></h3>
<p>作为运行时开发人员，<strong>FRAME</strong> 是可用的且最强大的工具之一。正如  Substrate 支持开发人员中提到的，<strong>FRAME</strong> 是模块化实体运行时聚合框架（Framework for Runtime Aggregation of Modularized Entities）的缩写，它包含了大量模块和支持库，也简化运行时开发。在 Substrate 中，这些被称为 <strong>pallets</strong> 的模块，可以为你提供希望在运行时中包含的不同用例和特性的自定义业务逻辑。例如，有一些 <strong>pallets</strong> 为 staking、共识、治理和其他常见活动提供了业务逻辑框架。</p>
<p>除了 <strong>pallets</strong> 之外，FRAME 还通过以下库和模块提供与运行时交互的服务：</p>
<ul>
<li><a href="https://paritytech.github.io/substrate/master/frame_system/index.html">FRAME system crate <code>frame_system</code></a>：为运行时提供底层的类型，存储和功能。</li>
<li><a href="https://paritytech.github.io/substrate/master/frame_support/index.html">FRAME support crate <code>frame_support</code></a>：是 Rust宏、类型、特性和模块的集合，可简化 Substrate pallets 的开发。</li>
<li><a href="https://paritytech.github.io/substrate/master/frame_executive/index.html">FRAME executive pallet <code>frame_executive</code></a>：在运行时编排各个 pallets 调用函数的执行。</li>
</ul>
<p>下图说明了 <strong>FRAME</strong> 及其 system、support 和 executives modules 如何为运行时环境提供服务。</p>
<p><img src="https://awesomeprogram.gitee.io/imgdata/tech_bc_subframe.jpg" alt="" /></p>
<h3 id="使用-pallets-构建运行时"><a class="header" href="#使用-pallets-构建运行时">使用 pallets 构建运行时</a></h3>
<p>你可以无需使用 FRAME，仅基于 Substrate 构建区块链。但是，FRAME pallets 可以让你使用预定义组件开始来构建你的自定义运行时逻辑。每个 pallet 定义特定 types、storage items 和 functions，为运行时实现一组特定的特性或功能。</p>
<p>下图说明了如何选择和组合 FRAME pallets 以组成运行时。</p>
<p><img src="https://awesomeprogram.gitee.io/imgdata/tech_bc_subruntime.jpg" alt="" /></p>
<h3 id="构建自定义-pallets"><a class="header" href="#构建自定义-pallets">构建自定义 pallets</a></h3>
<p>除了预构建 FRAME pallets 库之外，你还可以使用 FRAME 库和服务构建自己的自定义托盘。使用自定义托盘，你可以灵活地定义最适合你期望的运行时行为。由于每个 pallets 都有自己的独立逻辑，因此你可以将预构建和自定义 pallets 组合起来，以控制区块链提供的特性和功能，并实现你想要的结果。</p>
<p>例如，你可以在运行时包含 Balances pallet，以使用其加密货币相关的 storage items 和 functions 来管理 tokens；但在一个账余额改变时，也可以添加自定义逻辑调用你编写的 pallet。</p>
<p>大多数 pallet 由以下部分组成：</p>
<ul>
<li>Imports and dependencies</li>
<li>Pallet type 声明</li>
<li>Runtime configuration trait</li>
<li>Runtime storage</li>
<li>Runtime events</li>
<li>Hooks：用于应该在特定上下文中执行的钩子逻辑</li>
<li>Function：可用于执行交易的函数调用</li>
</ul>
<p>例如，如果要定义自定义 pallet，可以从 pallet 的代码结构开始，如下所示：</p>
<pre><code class="language-rust editable noplayground">// Add required imports and dependencies
pub use pallet::*;
#[frame_support::pallet]
pub mod pallet {
 use frame_support::pallet_prelude::*;
 use frame_system::pallet_prelude::*;

 // Declare the pallet type
 // This is a placeholder to implement traits and methods.
    #[pallet::pallet]
    #[pallet::generate_store(pub(super) trait Store)]
    pub struct Pallet&lt;T&gt;(_);

 // Add the runtime configuration trait
 // All types and constants go here.
 #[pallet::config]
 pub trait Config: frame_system::Config { ... }

 // Add runtime storage to declare storage items.
 #[pallet::storage]
 #[pallet::getter(fn something)]
 pub type MyStorage&lt;T: Config&gt; = StorageValue&lt;_, u32&gt;;

 // Add runtime events
 #[pallet::event]
 #[pallet::generate_deposit(pub(super) fn deposit_event)]
 pub enum Event&lt;T: Config&gt; { ... }

 //  Add hooks to define some logic that should be executed
 //  in a specific context, for example on_initialize.
 #[pallet::hooks]
 impl&lt;T: Config&gt; Hooks&lt;BlockNumberFor&lt;T&gt;&gt; for Pallet&lt;T&gt; { ... }

 // Add functions that are callable from outside the runtime.
 #[pallet::call]
 impl&lt;T:Config&gt; Pallet&lt;T&gt; { ... }

}
</code></pre>
<p>你可以根据需要使用部分或所有 pallets 去组合。在开始设计和构建自定义运行时时，你将了解更多关于 FRAME 库和用于定义 configuration traits、storage items、events和 errors 的运行时原语，以及如何编写分派给运行时执行的调用函数。</p>
<h2 id="共识"><a class="header" href="#共识">共识</a></h2>
<p>所有区块链都需要某种类型的共识机制来商定区块链状态。由于 Substrate 提供了构建区块链的模块化框架，因此它支持节点达成共识的几种不同模型。一般来说，不同的共识模型有不同的权衡，因此选择要用于链的共识类型是一个重要的考虑因素。Substrate 默认支持的共识模型只要最少的配置，但如果需要，也可以构建自定义的共识模型。</p>
<h3 id="两阶段的共识"><a class="header" href="#两阶段的共识">两阶段的共识</a></h3>
<p>与某些区块链不同，Substrate将达成共识的要求分为两个单独的阶段：</p>
<ul>
<li><strong>Block authoring</strong> 是节点用于创建新块的过程。</li>
<li><strong>Block finalization</strong> 是用于处理分叉和选择合法链的过程。</li>
</ul>
<h3 id="block-authoring"><a class="header" href="#block-authoring"><strong>Block authoring</strong></a></h3>
<p>在达成共识之前，区块链网络中的一些节点必须能够产生新的区块。区块链如何决定被授权的可以创建块的节点取决于你使用的是哪种共识模型。例如，在集中式网络中，单个节点可能创建所有块。在没有任何可信节点的完全去中心化网络中，算法必须在每个块高度选择区块创建者。</p>
<p>对于基于 Substrate 的区块链，你可以选择以下区块创建算法之一或你自己的创建区块的算法：</p>
<ul>
<li>基于授权的 round-robin 调度（Aura）。</li>
<li>基于插槽 Blind assignment of blockchain extension（BABE）调度。</li>
<li>基于算力的工作量证明（PoW）调度。</li>
</ul>
<p>Aura 和 BABE 共识模型要求你拥有一组已知的验证者节点，允许它们生成块。在这两种共识模型中，时间被划分为离散的插槽。在每个插槽中，只有一些验证者可以产生一个块。在 Aura 共识模型中，可以创建区块的验证者以 round-robin 方式不断轮询。在 BABE 共识模型中，验证者的选择是基于可验证的随机函数（VRF），而不是 round-robin 的选择方法。</p>
<p>在工作量证明的共识模型中，任何节点只要解决了一个计算密集型问题，就可以在任何时间产生一个块。解决这个问题需要花费 CPU 时间，因此节点只能产生的块与其计算资源成正比。Substrate 提供了一个工作量证明的区块生产引擎。</p>
<h3 id="finalization-and-forks"><a class="header" href="#finalization-and-forks"><strong>Finalization and forks</strong></a></h3>
<p>作为原始块，一个块包含块头和交易。每个块头都包含对其父块的引用，因此可以将链追溯到其创世块。当两个块引用同一个父块时，就会发生分叉。块终结是一种解决分叉的机制，使之只存在合法链。分叉选择规则是一种应该选择被扩展为最佳链的算法。Substrate 通过SelectChain trait 公开了这个分叉选择规则。你可以使用这个 trait 编写自定义的分叉选择规则，或者使用 GRANDPA，这个 Polkadot 和类似链中使用的终结机制。</p>
<p>在 GRANDPA 协议中，最长链规则简单地说，最佳的链就是最长的链。Substrate 用 <a href="https://paritytech.github.io/substrate/master/sc_consensus/struct.LongestChain.html">LongestChain</a> 结构体提供这个链选择规则。GRANDPA 在投票机制中使用最长链规则。
<img src="https://awesomeprogram.gitee.io/imgdata/tech_bc_sublongchain.jpg" alt="" /></p>
<p>“The Greedy Heaviest Observed SubTree”（GHOST）规则说，从创世块开始，每个分叉都是通过选择递归构建最多块的分支，然后确定最佳链。
<img src="https://awesomeprogram.gitee.io/imgdata/tech_bc_subghostchain.jpg" alt="" /></p>
<h3 id="确定性终结"><a class="header" href="#确定性终结">确定性终结</a></h3>
<p>用户很自然地想知道交易何时完成，以及何时发出被签名的某些事件（如收据交付或文件签名）。然而，根据目前所描述的区块创建和分叉选择规则，交易还没有完全终结。总是有可能出现较长或更重的链会还原之前的交易。然而，在特定的块上构建的块越多，其被还原的可能性就越小。通过这种方式，块的创建以及适当的分叉选择规则提供了概率终结性。</p>
<p>如果你的区块链需要确定性的终结，则可以为区块链逻辑添加最终机制。例如，你可以让拥有固定权限的一些成员进行最终投票。当对某一区块投下足够的票时，该区块被视为最终区块。在大多数区块链中，该投票比例为三分之二。如果没有外部协调（如硬分叉），则无法还原已完成的块。</p>
<p>在一些共识模型中，结合了块生产和块最终性，并且在块 <code>N</code> 最终确定之前，不能创建新的块 <code>N+1</code>。如你所见，在 Substrate 中，这两个过程是相互分开的。通过将块创建与块终结分离，Substrate 让你能够使用任何具有概率终结性的块创建算法，或将其与终结性机制结合以实现确定性终结性。</p>
<p>如果你的区块链使用终结性机制，则必须修改分叉选择规则以匹配终结性投票的结果。例如，一个节点不会使用只是最长链的原则，而是使用包含最近终结区块的最长链。</p>
<h3 id="默认共识模型"><a class="header" href="#默认共识模型">默认共识模型</a></h3>
<p>虽然你可以实现自己的共识机制，但默认情况下， <a href="https://github.com/substrate-developer-hub/substrate-node-template">Substrate node template</a> 包括用于区块创建的 Aura 和区块最终确定的 GRANDPA。Substrate 还提供了 BABE 和工作量证明共识模型的实现。</p>
<h4 id="aura"><a class="header" href="#aura">Aura</a></h4>
<p><a href="https://paritytech.github.io/substrate/master/sc_consensus_aura/index.html">Aura</a> 提供了一种基于插槽的区块创建机制。在 Aura 中是一组已知的授权轮询区块创建。</p>
<h4 id="babe"><a class="header" href="#babe">BABE</a></h4>
<p><a href="https://paritytech.github.io/substrate/master/sc_consensus_babe/index.html">BABE</a> 使用一组已知的验证者提供基于插槽的区块创建，通常用于权益证明区块链。与 Aura 不同，插槽分配基于对可验证的随机函数（VRF）的评估。每个验证者都会为一个 <em>epoch</em> 分配权重。这个 <em>epoch</em> 被分解成多个插槽，验证者在每个槽上计算它的 VRF。对于验证者的 VRF 输出低于其权重的每个槽，允许创建一个块。</p>
<p>因为多个验证者可以在同一个插槽中产生一个块，所以即使在良好的网络条件下，分叉在 BABE 中也比在 Aura 中更常见。</p>
<p>Substrate 的 BABE 实现还有一个回退机制，用于在给定的插槽内没有选择授权。这些次要插槽分配让 BABE 实现了恒定的出块时间。</p>
<h4 id="proof-of-work"><a class="header" href="#proof-of-work">Proof of work</a></h4>
<p><a href="https://paritytech.github.io/substrate/master/sc_consensus_pow/index.html">Proof-of-work</a> 创建区块不是基于插槽的，不需要已知的授权集。在工作量证明中，任何人都可以在任何时间生成一个块，只要他们能解决一个具有计算挑战性的问题（通常是哈希值逆向查找）。该问题的难度可以作为调整统计目标块的出块时间。</p>
<h4 id="grandpa"><a class="header" href="#grandpa">GRANDPA</a></h4>
<p>GRANDPA 提供区块确定性终结。它有一个已知的权重授权集，像 BABE。然而，GRANDPA 不会创建区块。它只是监听关于节点生成区块传播的消息。GRANDPA 验证者在链上投票，而不是块上。GRANDPA 验证者对他们认为最好的区块进行投票，并将其投票应用于所有以前的区块。在三分之二的 GRANDPA 授权者投票支持某一指定的区块后，该区块将被视为最终区块。</p>
<p>所有确定性终结算法，包括 GRANDPA 算法，都需要至少 <code>2f+1</code> 个非故障节点，其中 <code>f</code> 是故障或恶意节点的数量。了解更多关于这个阈值来自何处以及为什么它是理想中的值，请参阅具有开创性的论文<a href="https://lamport.azurewebsites.net/pubs/reaching.pdf">《Reaching Agreement in the Presence of Faults》</a>或《Byzantine Fault》。</p>
<p>并非所有共识协议都定义一个单一的，合法的区块链。当具有相同父块的两个块没有冲突的状态变化时，一些协议证实有向无环图（DAG）。</p>
<h2 id="交易和区块基础"><a class="header" href="#交易和区块基础">交易和区块基础</a></h2>
<p>在本文中，你将了解可以创建的不同类型的交易，以及如何在运行时使用它们。广义而言，交易决定了进入区块链中区块的数据。通过了解如何使用不同的交易类型，你可以更好地根据需求选择适当的类型。</p>
<h3 id="什么是交易"><a class="header" href="#什么是交易">什么是交易？</a></h3>
<p>一般来说，交易提供了一种可在区块中更改状态的机制。在 Substrate 中有三种不同的交易类型：</p>
<ul>
<li><strong>签名交易</strong></li>
<li><strong>未签名交易</strong></li>
<li><strong>内部交易</strong></li>
</ul>
<p>在 Substrate 中，这三种交易类型通常更广泛地称为 <strong>extrinsics</strong>。术语 extrinsics 通常用于表示源于运行时之外的任何信息。</p>
<p>然而，出于实际目的，独立考虑每种交易类型并确定每种类型最适用的场景更为有用。</p>
<h4 id="签名交易"><a class="header" href="#签名交易"><strong>签名交易</strong></a></h4>
<p>已签名的交易必须包括发送入站请求以执行一些运行时调用的帐户的签名。通常，使用提交请求的帐户的私钥对请求进行签名。在大多数情况下，提交请求的账户也会支付交易费。然而，交易费用和交易处理的其他元素取决于运行时逻辑如何被定义。</p>
<p>签名交易是最常见的交易类型。例如，假设你有一个带有一些代币的帐户。如果你想将代币转给 Alice，那么可以在 Balances pallet 中调用 <code>pallet_balances::Call::transfer</code> 函数。因为你的帐户被用作此功能的调用，所以你的帐户密钥用于对交易进行签名。作为请求者，你通常需要支付一定的费用来处理你的请求。或者，你也可以提示区块创建者给你的交易更高的优先级。</p>
<h4 id="未签名交易"><a class="header" href="#未签名交易"><strong>未签名交易</strong></a></h4>
<p>未签名的交易不需要签名，也不包含任何关于提交交易的人的信息。</p>
<p>对于未签名的交易，没有经济约束来防止垃圾邮件或重播攻击。你必须定义验证未签名交易的条件，以及保护网络免受误用和攻击所需的逻辑。由于未签名交易需要自定义验证，因此此交易类型会比已签名交易类型消耗更多的资源。</p>
<p>这个 <code>pallet_im_online::Call::heartbeat</code> 功能使用未签名交易来使验证者节点向网络发送一个信号，表明该节点在线。此函数只能由在网络中注册为验证者的节点调用。该函数包含用于验证节点是否为验证者的内部逻辑，允许节点使用未签名交易调用该函数，以避免支付任何费用。</p>
<h4 id="内部交易"><a class="header" href="#内部交易"><strong>内部交易</strong></a></h4>
<p>Inherent transactions（有时称为inherents）是一种特殊类型的未签名交易。通过这种类型的交易，块创建节点可以直接向块添加信息。内部交易只能由调用它们的块创建节点插入到块中。通常，这种类型的交易不会传播给其他节点或存储在交易队列中。假设使用内部交易插入的数据是有效的，无需特定验证。</p>
<p>例如，如果块创建节点将时间戳插入到块中，则无法证明时间戳是准确的。相反，验证者可以根据时间戳是否在其自身系统时钟的可接受范围内来接受或拒绝该块。</p>
<p>例如，<code>pallet_timestamp::Call::now</code> 函数允许一个块创建节点在生成每个块中插入当前时间戳。同样，<code>paras_inherent::Call::enter</code> 函数允许一个平行链 collator 节点能够向其中继链发送中继链期望的验证数据。。</p>
<h3 id="什么是块"><a class="header" href="#什么是块">什么是块</a></h3>
<p>在 Substrate 中，一个块由一个块头和一个交易数组组成。块头包含以下属性：</p>
<ul>
<li>Block height</li>
<li>Parent hash</li>
<li>Transaction root</li>
<li>State root</li>
<li>Digest</li>
</ul>
<p>所有交易都作为一个系列捆绑在一起，按照在运行时中定义的方式执行。你将在<strong>交易生命周</strong>期中了解有关交易排序的更多信息。Transaction root 是本系列的加密摘要。此加密摘要有两个用途：</p>
<ul>
<li>它防止在构建和分散标头后对一系列交易进行任何更改。</li>
<li>它使轻客户端能够简洁地验证任何给定的交易是否存在于仅给出区块头部信息的块中。</li>
</ul>
<h2 id="交易生命周期"><a class="header" href="#交易生命周期">交易生命周期</a></h2>
<p>在 Substrate 中，交易包含的数据被包含在块中。因为交易中的数据来源于运行时之外，所以交易有时更广泛地称为外部数据或<strong>extrinsics</strong>。然而，最常见的<strong>extrinsics</strong>是已签名的交易。因此，对交易生命周期的讨论是关注已签名交易的验证和执行方式。</p>
<p>你已经了解到，已签名的交易包括签名账户发送请求以执行某个运行时的调用。通常，使用提交请求帐户的私钥，对请求进行签名。在大多数情况下，提交请求的账户也会支付交易费。然而，交易费用和交易处理中的其他元素取决于如何定义运行时逻辑。</p>
<h3 id="定义交易的地方"><a class="header" href="#定义交易的地方">定义交易的地方</a></h3>
<p>如<strong>运行时开发</strong>中所述，Substrate node 运行时包含定义交易属性的业务逻辑，包括如下：</p>
<ul>
<li>什么构成有效交易。</li>
<li>交易是以签名还是未签名的方式发送。</li>
<li>交易如何改变链的状态。</li>
</ul>
<p>通常，你可以使用 pallets 来组建运行时的功能，并实现你希望区块链支持的交易。在编译运行时后，用户通过提交处理交易的请求与区块链进行交互。例如，用户可能会提交从一个帐户向另一个帐户转账的请求。该请求将成为一个已签名的交易，其中包含该用户帐户的签名，如果用户帐户中有足够的资金支付该交易，则该交易将成功执行，并进行转账。</p>
<h3 id="在区块创建的节点上如何处理交易"><a class="header" href="#在区块创建的节点上如何处理交易">在区块创建的节点上如何处理交易</a></h3>
<p>根据网络的配置，你可能会同时拥有授权创建块的节点和未授权创建块的节点。如果一个 Substrate 节点被授权生成块，它就可以处理接收到的已签名和未签名交易。下图说明了一个交易的生命周期，它由区块创建节点处理并提交到网络。</p>
<p><img src="https://awesomeprogram.gitee.io/imgdata/tech_bc_sublifecycle.jpg" alt="" /></p>
<p>发送到非区块创建节点的任何已签名或未签名的交易都将被传播至网络中的其他节点，并进入它们的交易池，直到被区块创建节点接收为止。</p>
<h3 id="验证和排队交易"><a class="header" href="#验证和排队交易">验证和排队交易</a></h3>
<p>如<strong>共识</strong>中所述，网络中的大多数节点必须就区块中的交易顺序达成一致，才能就区块链的状态达成一致，并继续安全地添加区块。为了达成共识，三分之二的节点必须就执行交易的顺序以及由此产生的状态变化达成一致。为了准备达成共识，首先对交易进行验证，并在本地节点上的交易池中排队。</p>
<h4 id="验证交易池中的交易"><a class="header" href="#验证交易池中的交易">验证交易池中的交易</a></h4>
<p>使用运行时中定义的规则，交易池检查每个交易的有效性。这些检查确保只有满足特定条件的有效交易才会排队包含到区块中。例如，交易池可能会执行以下检查以确定交易是否有效：</p>
<ul>
<li>交易索引也称为交易随机数，是否正确？</li>
<li>用于签名交易的账户是否有足够的资金支付相关费用？</li>
<li>用于签署交易的签名，是否有效？</li>
</ul>
<p>在初始有效性检查之后，交易池定期检查池中的现有交易是否仍然有效。如果发现交易无效或已过期，则把该交易从池中删除。</p>
<p>交易池仅处理交易的有效性以及对放置在交易队列中的有效交易进行排序。有关验证机制如何工作的具体细节，包括处理费用、帐户或签名，可以在 <a href="https://paritytech.github.io/substrate/master/sp_transaction_pool/runtime_api/trait.TaggedTransactionQueue.html#method.validate_transaction"><code>validate_transaction</code></a> 方法中找到。</p>
<h4 id="向交易队列中添加有效的交易"><a class="header" href="#向交易队列中添加有效的交易">向交易队列中添加有效的交易</a></h4>
<p>如果交易被标记为有效，则交易池将该交易移动到交易队列中。有效交易有两个交易队列：</p>
<ul>
<li><strong>ready queue</strong> 包含在新的待生成区块中的交易。如果运行时是用 FRAME 构建的，则交易必须符合它们在 <strong>ready queue</strong> 中的确切顺序。</li>
<li><strong>future queue</strong> 包含将来可能生效的交易。例如，如果交易的 <code>nonce</code> 对于其账户来说太高，它可以在 <strong>future queue</strong> 中等待，直到有一定数量交易的帐户已经被包含在链中。</li>
</ul>
<h4 id="无效交易的处理"><a class="header" href="#无效交易的处理">无效交易的处理</a></h4>
<p>如果交易是无效的，例如，因为它太大或不包含有效签名，它被拒绝添加到一个块中。交易可能因以下任何原因而被拒绝：</p>
<ul>
<li>交易已经包含在一个块中，所以它被从验证队列中删除。</li>
<li>交易的签名无效，因此它将立即被拒绝。</li>
<li>该交易太大，无法放入当前块中，因此需要将其放回队列以进行新一轮验证。</li>
</ul>
<h3 id="按优先级排序的交易"><a class="header" href="#按优先级排序的交易">按优先级排序的交易</a></h3>
<p>如果某个节点是下一个区块的创建者，则该节点使用优先级系统为下一个区块排序交易。交易从高优先级到低优先级排序，直到块达到最大权重或长度。</p>
<p>交易优先级是在运行时计算的，并作为交易的标签提供给外部节点。在 FRAME 运行时中，使用一个特殊的 pallet，它根据与交易相关的权重和费用计算优先级。此优先级计算适用于所有类型的交易，但内部交易除外。内部交易始终优先使用 <a href="https://paritytech.github.io/substrate/master/frame_support/traits/trait.EnsureInherentsAreFirst.html">EnsureInherentsAreFirst</a> trait。</p>
<h4 id="基于帐户的交易排序"><a class="header" href="#基于帐户的交易排序">基于帐户的交易排序</a></h4>
<p>如果你的运行时是使用 FRAME 构建的，那么每个已签名的交易都包含一个 nonce，该 nonce 在指定的帐户每次进行新交易时递增。例如，新账户的第一笔交易的 <code>nonce = 0</code>，同一账户的第二笔交易的 <code>nonce = 1</code>。块创建节点可以在对包含在块中的交易进行排序时使用 nonce。</p>
<p>对于具有依赖关系的交易，排序要考虑交易支付的费用以及它所包含的对其他交易的依赖。例如：</p>
<ul>
<li>如果存在 <code>TransactionPriority::max_value()</code> 的未签名交易和另一个已签名交易，未签名的交易则会被放在队列的第一位。</li>
<li>如果有来自不同发件人的两个交易，<code>priority</code> 决定了哪个交易更重要，应该首先被包含在块中。</li>
<li>如果来自同一发送者的两项交易具有相同的 <code>nonce</code>：在块中只能包含一个交易，因此，队列中只包含费用较高的交易。</li>
</ul>
<h3 id="执行交易和产生块"><a class="header" href="#执行交易和产生块">执行交易和产生块</a></h3>
<p>在将有效的交易放入交易队列后，一个单独的<strong>执行模块</strong>协调了如何执行交易以生成块。<strong>执行模块</strong>调用运行时模块中的函数，并按特定顺序执行这些函数。</p>
<p>作为运行时开发人员，了解执行模块如何与 system pallet 以及构成区块链业务逻辑的其他 pallet 交互非常重要，因为你可以插入<strong>执行模块</strong>的逻辑，以作为以下操作的一部分执行：</p>
<ul>
<li>初始化一个块</li>
<li>执行要包含在块中的交易</li>
<li>最终确定一个块的构建</li>
</ul>
<h4 id="初始化一个块"><a class="header" href="#初始化一个块">初始化一个块</a></h4>
<p>为了初始化一个块，<strong>执行模块</strong>首先在 system pallet 中调用 <code>on_initialize</code> 函数，然后在所有其他运行时 pallets 中。<code>on_initialize</code> 函数允许你定义应该在执行交易之前完成的业务逻辑。system pallet <code>on_initialize</code> 函数始终首先会被执行。其余的 pallets 将按照它们在 <code> construct_runtime!</code>宏 中定义的顺序被调用。</p>
<p>在执行所有 <code>on_initialize</code> 函数之后，<strong>执行模块</strong>会检查在块头和 trie root 中的父哈希，以验证信息是否正确。</p>
<h4 id="执行交易"><a class="header" href="#执行交易">执行交易</a></h4>
<p>块初始化后，将按照交易优先级的顺序执行每个有效交易。重要的是要记住，在执行之前不会缓存状态。相反，状态更改在执行期间直接写入存储。如果交易在执行过程中失败，则在失败之前发生的任何状态更改都不会恢复，使块处于不可恢复状态。在向存储提交任何状态更改之前，运行时逻辑应执行所有必要的检查，以确保 extrinsic 成功。</p>
<p>请注意，事件也写入存储。因此，运行时逻辑不应在执行补充操作之前发出事件。如果交易在事件发出后失败，则不会恢复该交易。</p>
<h4 id="最终确定一个块"><a class="header" href="#最终确定一个块">最终确定一个块</a></h4>
<p>在执行了所有已排序的交易之后，执行模块通过调用每个 pallet 的 <code>on_idle</code> 和 <code>on_finalize</code> 函数，来执行任何应该在块的末尾发生的最终业务逻辑。这个模块被再次按照它们在 <code>construct_runtime!</code>宏 中定义的顺序执行。但在这种情况下，<code>on_finalize</code> 函数在 system pallet 中是最后被执行。</p>
<p>在所有 <code>on_finalize</code> 函数都已被执行之后，<strong>执行模块</strong>会检查块头中的摘要和存储根是否与块初始化时计算的相匹配。</p>
<p><code>on_idle</code> 函数还通过块的剩余权重，以允许基于区块链继续使用执行。</p>
<h3 id="区块创建和区块导入"><a class="header" href="#区块创建和区块导入">区块创建和区块导入</a></h3>
<p>到目前为止，你已经看到了交易如何被包含在本地节点生成的块中。如果授权本地节点生成块，则<strong>交易生命周期</strong>遵循如下方式：</p>
<ol>
<li>本地节点监听网络上的交易。</li>
<li>每笔交易都要经过验证的。</li>
<li>有效的交易被放置在交易池中。</li>
<li>交易池在适当的交易队列中对有效交易进行排序，<strong>执行模块</strong>调用运行时以开始下一个块。</li>
<li>执行的交易与状态更改被存储在本地内存中。</li>
<li>将构造的区块发布到网络。</li>
</ol>
<p>将块发布到网络后，其他节点可以导入该块。块导入队列是每个 Substrate node 作为外部节点的一部分。通过监听传入的块和共识相关消息把块导入队列，并将它们添加到池中。在池中，检查传入信息的有效性，如果无效则丢弃。在验证块或信息有效后，块导入队列，将传入信息导入为本地节点的状态，并将其添加到节点知道的块数据库中。</p>
<p>在大多数情况下，你不需要知道有关如何传播交易或网络上其他节点如何导入块的详细信息。然而，如果你打算编写任何自定义共识逻辑或想了解更多关于区块导入队列的实现信息，则可以在 Rust API 文档中找到详细信息。</p>
<ul>
<li><a href="https://paritytech.github.io/substrate/master/sc_consensus/import_queue/trait.ImportQueue.html">ImportQueue</a></li>
<li><a href="https://paritytech.github.io/substrate/master/sc_consensus/import_queue/trait.Link.html">Link</a></li>
<li><a href="https://paritytech.github.io/substrate/master/sc_consensus/import_queue/struct.BasicQueue.html">BasicQueue</a></li>
<li><a href="https://paritytech.github.io/substrate/master/sc_consensus/import_queue/trait.Verifier.html">Verifier</a></li>
<li><a href="https://paritytech.github.io/substrate/master/sc_consensus/block_import/trait.BlockImport.html">BlockImport</a></li>
</ul>
<h2 id="状态转换和存储"><a class="header" href="#状态转换和存储">状态转换和存储</a></h2>
<p>Substrate 使用一个简单的键值数据存储，实现为支持可修改 Merkle 树的数据库。所有 Substrate 的 higher-level storage abstractions 都建立在这个简单的键值存储之上。</p>
<h3 id="key-value-数据库"><a class="header" href="#key-value-数据库">Key-Value 数据库</a></h3>
<p>Substrate 基于 RocksDB 实现其存储数据库，一种用于快速存储需求环境下的持久化键值存储。它还支持处于实验中的 <a href="https://github.com/paritytech/parity-db">Parity DB</a>。</p>
<p>这个数据库用于需要持久化存储的 Substrate 的所有组件，例如：</p>
<ul>
<li>Substrate clients</li>
<li>Substrate light-clients</li>
<li>Off-chain workers</li>
</ul>
<h3 id="trie-abstraction"><a class="header" href="#trie-abstraction">Trie abstraction</a></h3>
<p>使用简单键值存储的一个优点是，你可以轻松地在其上抽象存储结构。</p>
<p>Substrate 使用 <a href="https://github.com/paritytech/trie">'paritytech/trie'</a> 的 Base-16 修改的 Merkle-Patricia 树（trie）来提供 trie 结构，该结构的内容可以修改，并且其根哈希很有效地进行重新计算。</p>
<p>Tries 允许有效地存储并且共享历史块状态。trie root 代表 trie 中的数据，也就是说，使用不同数据的两次 tries 将始终具有不同的 roots。因此，两个区块链节点可以很容易地通过简单地比较它们的 trie roots 来验证它们具有相同的状态。</p>
<p>访问 trie 数据代价很高。每个读操作花费 O(log N) 时间，其中 N 是存储在 trie 中的元素数量。为了减轻这种情况，我们使用键值存储缓存。</p>
<p>所有 trie 节点都存储在数据库中，并且可以修改部分 trie 状态。例如，当键值对超出非存档节点的修改范围时，可以将其从存储中删除。</p>
<h4 id="state-trie"><a class="header" href="#state-trie">State trie</a></h4>
<p>基于 Substrate 的链有一个 main trie，称为状态 trie，其根哈希被放在每个块头中。可以很容易被用于验证区块链的状态，并为轻客户端需要的验证证据提供基础。</p>
<p>这个 trie 只存储合法链的内容，而不会分叉。有一个单独的 <a href="https://paritytech.github.io/substrate/master/sc_state_db/index.html"><code>state_db</code> layer</a> 维护 trie 状态，并在内存中计算出所有非法的引用内容。</p>
<h4 id="child-trie"><a class="header" href="#child-trie">Child trie</a></h4>
<p>Substrate 还提供了一个API，可以生成有自己根哈希的 child tries，并且它们可以在运行时被使用。</p>
<p>Child tries 与 main state trie 完全相同，只是 child trie 的根作为节点存储和更新在 main trie 中，而不是在区块头中。由于它们的头是 main state trie 的一部分，因此当包含 child tries 时，验证完整节点状态仍然很容易。</p>
<p>当你希望自己的独立 trie 具有单独的根哈希，你可以使用该哈希来验证这个 trie 中的特定内容时，Child tries 非常有用。trie 的子部分没有自动满足这些需求的 root-hash-like 表示，因此使用 child trie 代替。</p>
<h3 id="querying-storage"><a class="header" href="#querying-storage">Querying storage</a></h3>
<p>使用 Substrate 构建的区块链公开了可用于查询运行时存储的远程过程调用（RPC）服务器。当你使用 Substrate RPC访问存储项时，只需提供与该项关联的密钥。Substrate的运行时 <code>runtime storage APIs</code> API公开了多种存储项类型；继续阅读，了解如何计算不同类型存储项的存储键。</p>
<h4 id="storage-value-keys"><a class="header" href="#storage-value-keys">Storage value keys</a></h4>
<p>要计算简单 Storage Value 的密钥，获取包含存储值的 pallet 名称的 <a href="https://github.com/Cyan4973/xxHash">TwoX 128 hash</a> ，并将存储值本身的名称的 TwoX 128 hash 附加到它。例如，<a href="https://paritytech.github.io/substrate/master/pallet_sudo/index.html">Sudo</a> pallet 公开名为 <code>Key</code> 的存储值项：</p>
<pre><code class="language-rust editable noplayground">twox_128(&quot;Sudo&quot;)                   = &quot;0x5c0d1176a568c1f92944340dbfed9e9c&quot;
twox_128(&quot;Key&quot;)                    = &quot;0x530ebca703c85910e7164cb7d1c9e47b&quot;
twox_128(&quot;Sudo&quot;) + twox_128(&quot;Key&quot;) = &quot;0x5c0d1176a568c1f92944340dbfed9e9c530ebca703c85910e7164cb7d1c9e47b&quot;
</code></pre>
<p>如果熟悉的 <code>Alice</code> 帐户是 sudo 用户，读取 sudo pallet 的 <code>Key</code> 存储值的 RPC 请求和响应可以表示为：</p>
<pre><code class="language-rust editable noplayground">state_getStorage(&quot;0x5c0d1176a568c1f92944340dbfed9e9c530ebca703c85910e7164cb7d1c9e47b&quot;) = &quot;0xd43593c715fdd31c61141abd04a99fd6822c8558854ccde39a5684e7a56da27d&quot;
</code></pre>
<p>在这种情况下，返回的值 (<code>&quot;0xd43593c715fdd31c61141abd04a99fd6822c8558854ccde39a5684e7a56da27d&quot;</code>)  是 Alice's SCALE-encoded 账户的 ID (<code>5GrwvaEF5zXb26Fz9rcQpDWS57CtERHpNehXCPcNoHGKutQY</code>)。</p>
<p>你可能已经注意到，非加密的 TwoX 128 hash 算法用于生成 Storage Value 密钥。这是因为无需支付与加密哈希函数相关的执行成本，因为输入的哈希函数（pallet 和存储项目的名称）由运行时开发人员确定，而不是由区块链的潜在恶意用户确定。</p>
<h4 id="storage-map-keys"><a class="header" href="#storage-map-keys">Storage map keys</a></h4>
<p>与 Storage Values 一样，Storage Maps 的键等于包含 map 的 pallet 名称的 TwoX 128 hash 值，该 map 在 Storage Map 本身名称的 TwoX 128 hash 之前。要从 map 中检索元素，请将所需 map 密钥的哈希追加到 Storage Map 的存储密钥。对于具有两个键的 maps（Storage Double Maps），将第一个 map 键的哈希和第二个 map 键的哈希追加到 Storage Double Map 的存储键。</p>
<p>与 Storage Values 一样，Substrate 使用 TwoX 128 hash 算法处理 pallet 和 Storage Map 名称，当确定 map 中元素的哈希键时，但你需要保证使用正确的哈希算法（在 #[pallet::storage]宏 中声明的一个）。</p>
<p>下面是一个示例，说明了从名为 <code>Balances</code> 的 <code>pallet</code> 中查询名为 <code>FreeBalance</code> 的存储映射以获得 <code>Alice</code> 帐户的余额。在这个例子中，<code>FreeBalance</code> map 使用的是 the transparent Blake2 128 Concat hashing algorithm：</p>
<pre><code class="language-rust editable noplayground">twox_128(&quot;Balances&quot;)                                             = &quot;0xc2261276cc9d1f8598ea4b6a74b15c2f&quot;
twox_128(&quot;FreeBalance&quot;)                                          = &quot;0x6482b9ade7bc6657aaca787ba1add3b4&quot;
scale_encode(&quot;5GrwvaEF5zXb26Fz9rcQpDWS57CtERHpNehXCPcNoHGKutQY&quot;) = &quot;0xd43593c715fdd31c61141abd04a99fd6822c8558854ccde39a5684e7a56da27d&quot;

blake2_128_concat(&quot;0xd43593c715fdd31c61141abd04a99fd6822c8558854ccde39a5684e7a56da27d&quot;) = &quot;0xde1e86a9a8c739864cf3cc5ec2bea59fd43593c715fdd31c61141abd04a99fd6822c8558854ccde39a5684e7a56da27d&quot;

state_getStorage(&quot;0xc2261276cc9d1f8598ea4b6a74b15c2f6482b9ade7bc6657aaca787ba1add3b4de1e86a9a8c739864cf3cc5ec2bea59fd43593c715fdd31c61141abd04a99fd6822c8558854ccde39a5684e7a56da27d&quot;) = &quot;0x0000a0dec5adc9353600000000000000&quot;
</code></pre>
<p>存储查询返回的值（上例中为“0x0000a0dec5adc9353600000000000000”）是 Alice 账户余额的 SCALE 编码值(本例中为“1000000000000000000000”)。请注意，在对 Alice 的帐户 ID 进行哈希运算之前，必须对其进行 SCALE 编码。还要注意，<code>blake2_128_concat</code> 函数的输出由32个十六进制字符组成，然后是该函数的输入。这是因为 Blake2 128 Concat 是一种透明的哈希算法。</p>
<p>虽然上面的示例可能会使此特性看起来多余，但当目标是遍历 map 中的键时（而不是检索与单个键相关的值），它的实用性会变得更加明显了。为了让人们以一种看起来自然的方式使用 map（如 UIs），对 map 中的键进行遍历是一项常见的要求：首先用户会看到 map 中的元素列表，然后用户可以选择他们感兴趣的元素，并在 map 中查询关于该特定元素的更多细节。</p>
<p>下面是另一个使用相同示例 Storage Map 的示例（一个名为 <code>FreeBalances</code> 的 map，在名为 <code>Balances</code> 的 pallet 中使用 Blake2 128 Concat 哈希算法，该 pallet 演示了如何使用 Substrate RPC 通过 <code>state_getKeys</code> RPC endpoint 查询 Storage Map 的密钥列表）：</p>
<pre><code class="language-rust editable noplayground">twox_128(&quot;Balances&quot;)                                      = &quot;0xc2261276cc9d1f8598ea4b6a74b15c2f&quot;
twox_128(&quot;FreeBalance&quot;)                                   = &quot;0x6482b9ade7bc6657aaca787ba1add3b4&quot;

state_getKeys(&quot;0xc2261276cc9d1f8598ea4b6a74b15c2f6482b9ade7bc6657aaca787ba1add3b4&quot;) = [
 &quot;0xc2261276cc9d1f8598ea4b6a74b15c2f6482b9ade7bc6657aaca787ba1add3b4de1e86a9a8c739864cf3cc5ec2bea59fd43593c715fdd31c61141abd04a99fd6822c8558854ccde39a5684e7a56da27d&quot;,
 &quot;0xc2261276cc9d1f8598ea4b6a74b15c2f6482b9ade7bc6657aaca787ba1add3b432a5935f6edc617ae178fef9eb1e211fbe5ddb1579b72e84524fc29e78609e3caf42e85aa118ebfe0b0ad404b5bdd25f&quot;,
 ...
]
</code></pre>
<p>Substrate RPC 的 <code>state_getKeys</code> endpoint 返回的列表中的每个元素都可以直接用作 RPC 的 <code>state_getStorage</code> endpoint 的输入。实际上，上面示例列表中的第一个元素等于上一个示例中用于 <code>state_getStorage</code> 查询的输入（用作为 <code>Alice</code> 找到余额）。因为这些键所属的 map 使用一个透明哈希算法来生成的，所以可以确定与列表中的第二个元素关联的帐户。注意，列表中的每个元素都是以相同的64个字符开头的十六进制值，这是因为每个列表元素表示同一 map 中的键，并且该 map 通过连接两个 TwoX 128 hashes 来识别，每个都是 128-bits 或 32个十六进制字符。在解除列表中第二个元素的这一部分之后，你只剩下了 <code>0x32a5935f6edc617ae178fef9eb1e211fbe5ddb1579b72e84524fc29e78609e3caf42e85aa118ebfe0b0ad404b5bdd25f</code> 。</p>
<p>你在前面的示例中看到，这表示某个 SCALE 编码的帐户 ID 的 Blake2 128 Concat hash。Blake 128 Concat 哈希算法包括将哈希算法对其 Blake 128 哈希的输入的追加（或称为串联）。这意味着 Blake2 128 Concat 哈希的前 128 bits （或32个十六进制字符）代表 Blake2 128 哈希。剩下的数表示传递给Blake 2 128 哈希算法的值。在本例中，在删除表示 Blake 2 128 哈希 （如 0x32a5935f6edc617ae178fef9eb1e211f）的前32个十六进制字符后，剩下的是十六进制值 <code>0xbe5ddb1579b72e84524fc29e78609e3caf42e85aa118ebfe0b0ad404b5bdd25f</code>，这是一个 SCALE 编码的帐户 ID。解码该值的结果是 <code>5GNJqTPyNqANBkUVMN1LPPrxXnFouWXoe2wNSmmEoLctxiZY</code>，这是很熟悉的 <code>Alice_Stash</code> 帐户的帐户ID。</p>
<h3 id="运行时存储api"><a class="header" href="#运行时存储api">运行时存储API</a></h3>
<p>Substrate 的 <a href="https://paritytech.github.io/substrate/master/frame_support/index.html"><code>FRAME Support crate</code></a> 提供了为运行时存储项生成唯一确定性键的实用程序。这些存储项位于状态 trie 中，并且可以通过根据键查询 trie 来访问。</p>
<h2 id="accounts-addresses-and-keys"><a class="header" href="#accounts-addresses-and-keys">Accounts, addresses, and keys</a></h2>
<p>账户通常代表能够进行交易或持有资金的个人或组织的身份。虽然账户通常用于对应着一个人，但情况并非如此。帐户可用于代表用户或其他实体执行操作，或者自主地执行操作。此外，任何个人或实体都可以有多个账户用于不同目的。例如，Polkadot 是一个基于 Substrate 的区块链，拥有专门的账户，用于持有与交易的账户分开的资金。如何实现和使用帐户完全取决于你作为区块链或平行链的开发人员。</p>
<h3 id="公钥与私钥"><a class="header" href="#公钥与私钥">公钥与私钥</a></h3>
<p>通常，每个帐户都有一个所有者，该所有者拥有一个公共和私有密钥对。<strong>私钥</strong>是一个加密安全的随机生成的数字序列。为了便于阅读，私钥生成一个随机的单词序列，被称为 <strong>secret seed phrase</strong> 或 <strong>mnemonic</strong>。如果私钥丢失，帐户所有者可以使用此<strong>secret seed phrase</strong>恢复对帐户的访问。</p>
<p>对于大多数网络，与帐户相关联的<strong>公钥</strong>账户是如何在网络上被识别并将其用作交易的目标地址。然而，基于 Substrate 的链使用底层公钥来派生出一个或多个公共地址。Substrate 允许你为一个帐户生成多个地址和地址格式，而不是直接使用公钥。</p>
<h3 id="address-encoding-and-chain-specific-addresses"><a class="header" href="#address-encoding-and-chain-specific-addresses">Address encoding and chain-specific addresses</a></h3>
<p>Substrate 使你能够使用单个公钥派生出多个地址，因此你可以与多个链交互，而无需为每个网络创建单独的公钥和私钥对。默认情况下，与帐户公钥关联的地址使用 Substrate SS58 地址格式。该地址格式基于 base-58 编码。除了允许你从同一公钥派生出多个地址之外，base-58 编码具有以下优点：</p>
<ul>
<li>编码地址由58个字母数字字符组成。</li>
<li>字母数字字符串省略字符，如 <code>0</code>，<code>O</code>，<code>I</code> 和 <code>l</code>，在字符串中很难区分彼此。</li>
<li>网络信息，例如，可以在地址中编码指定的网络前缀。</li>
<li>可以使用 checksum 来检测输入错误，以确保正确输入的地址。</li>
</ul>
<p>因为单个公钥可用于派生不同 Substrate 链的地址，单个帐户可以有多个 chain-specific 的地址。例如，如果检查 <code>alice</code> 帐户的地址，公钥 <code>0xd43593c715fdd31c61141abd04a99fd6822c8558854ccde39a5684e7a56da27d</code> 取决于 chain-specific 的地址类型。
|Chain address type|Address|
|:-----:|:-----:|
|Polkadot (SS58)|15oF4uVJwmo4TdGW7VfQxNLavjCXviqxT9S1MgbjMNHr6Sp5|
|Kusama (SS58)|HNZata7iMYWmk5RvZRTiAsSDhV8366zq2YGb3tLH5Upf74F|
|Generic Substrate chain (SS58)|5GrwvaEF5zXb26Fz9rcQpDWS57CtERHpNehXCPcNoHGKutQY|</p>
<p>每个 Substrate 区块链可以注册自定义前缀，以创建 chain-specific 的地址类型。例如，所有 Polkadot 地址都以 <code>1</code> 开头，所有 Kusama 地址都以大写字母开头。所有未注册的 Substrate 链都从 <code>5</code> 开始。</p>
<p>你可以使用 <code>subkey inspect</code> 命令和 <code>--network</code> 选项或通过使用 <strong>Subscan</strong> 查找 chain-specific 地址的公钥。</p>
<p>有关生成公钥和私钥对以及检查地址的信息，可以参考 <strong>subkey</strong>。有关 chain-specific 地址的信息，可以参考 <a href="https://github.com/paritytech/ss58-registry"><strong>SS58 repository</strong></a> 的说明。</p>
<h3 id="在-frame-中的账户信息"><a class="header" href="#在-frame-中的账户信息">在 FRAME 中的账户信息</a></h3>
<p>从概念上讲，帐户代表具有一个或一个或多个公共地址的公共/私钥对的身份。然而，在使用 FRAME 构建的运行时中，帐户被定义为具有32字节地址标识符和相应帐户信息的 storage map，例如该账户已进行的交易数量、取决于该账户的模块数量以及账户余额。</p>
<p>帐户属性（如 <code>AccountId</code>）一般可以定义在 <code>frame_system</code> 模块中。然后在运行时实现中将泛型类型解析为特定类型，并最终指定一个特定值。然后在运行时实现中将泛型类型解析为特定类型，并最终指定一个特定值。例如，框架中的 <code>Account</code> 类型依赖于关联的 <code>AccountId</code> 类型。<code>AccountId</code> 类型保持为泛型类型，直到在运行时实现中为需要此信息的 pallet 分配了类型。</p>
<p>有关如何在 <code>frame_system</code> pallet 中定义帐户以及 <code>Account</code> storage map 中的帐户属性的更多信息，可参阅 <strong>Account data structures</strong>。有关使用泛型类型的详细信息，可参阅 <strong>Rust for Substrate</strong>。</p>
<h3 id="specialized-accounts"><a class="header" href="#specialized-accounts">Specialized accounts</a></h3>
<p>虽然大多数账户用于表示控制资金或执行交易的公钥/私钥对，但 Substrate 支持一些专用账户来控制特定密钥对的使用方式。例如，你的帐户可能需要自定义加密方案，只能用于执行特定功能，或者只能访问特定 pallets。</p>
<h4 id="staking-accounts-and-keys"><a class="header" href="#staking-accounts-and-keys">Staking accounts and keys</a></h4>
<p>在大多数情况下，在特定 FRAME pallet 的上下文中实现专用帐户。例如，指定权益证明（nominated proof-of-stake，NPoS）可能需要节点验证者和提名者持有大量 tokens。为了确保这些账户中的余额安全，Staking pallet 提供了一些账户抽象，用于分离执行特定操作所需的密钥对。
|账户类型|如何使用帐户|
|:-----:|:-----:|
|Stash account|<strong>stash account</strong> 表示定义验证器 staking 余额的公钥/私钥对。为了安全起见，你应该将账户密钥离线存放在冷存储中。你不应使用 <strong>stash account</strong> 进行频繁交易。因为此帐户的密钥保持离线状态，你可以指定一个 <strong>controller account</strong> 来做出 non-spending 决策，或者指定一个 <strong>keyless proxy account</strong> 来代表其在治理中投票。|
|Controller account|controller account 代表公钥/私钥对，该密钥对表示你可以有意图去成为验证者或提名者，设置首选项，如奖励、目的地和，对于验证者，设置会话密钥。controller account 只需支付交易费用，因此只需最少的资金。它永远不能用来花费它的 stash account 的资金。控制器采取的操作可能会导致削减，因此它仍然应该是安全的。|
|Session account|session account 表示验证者用于签名共识相关消息的公钥/私钥对。session account 不用于控制资金。这些键一般被定义在 <a href="https://paritytech.github.io/substrate/master/pallet_session/index.html">Session pallet</a> 中，并在运行时具体化。为了创建 session account 密钥对，你必须通过使用 controller 密钥签名交易并在链上发布 session 证书来证明该帐户代表你的 stash account 和提名者。你可以使用 <a href="https://paritytech.github.io/substrate/master/pallet_session/pallet/struct.Pallet.html#method.set_keys">session.setKeys</a> 交易在链上生成并注册新的会话密钥。你可以使用 <code>author_rotateKeys</code> RPC 调用更改 session 密钥。|</p>
<h4 id="keyless-proxy-accounts"><a class="header" href="#keyless-proxy-accounts">Keyless proxy accounts</a></h4>
<p>在某些情况下，你可能希望创建一个与任何所有者分离的帐户，以便它可以用于执行自主交易。例如，你可以创建一个帐户，然后将授权给该帐户，这样它就可以在没有你的干预和访问你密钥的情况下发送函数调用。在创建具有授权权限的新帐户之后，该账户可作为接收者用于销毁资金，或持有等待执行或转账的 tokens。</p>
<p>你可以使用 Proxy pallet 创建一个帐户，该帐户具有使用作为签名来源的委托帐户 来发送某些类型调用的权限。</p>
<h2 id="rust-for-substrate"><a class="header" href="#rust-for-substrate">Rust for Substrate</a></h2>
<p>使 Substrate 成为创建 mission-critical 软件的灵活和可扩展框架的主要原因是 Rust。作为 Substrate 的选择语言，Rust是一种首选的高性能编程语言，原因如下：</p>
<ul>
<li>Rust is fast：它在编译期是静态类型的，使得编译器可以针对速度优化代码，并且开发人员还可以针对指定的编译目标进行优化。</li>
<li>Rust is portable：它被设计为在支持任何类型操作系统的嵌入式设备上运行。</li>
<li>Rust is memory safe：它没有垃圾收集器，并且它检查你使用的每个变量和引用的每个内存地址，以避免任何内存泄漏。</li>
<li>Rust is Wasm first：它对编译到 WebAssembly 具有一流的支持。</li>
</ul>
<h3 id="rust-in-substrate"><a class="header" href="#rust-in-substrate">Rust in Substrate</a></h3>
<p>在架构部分中，你将了解到，Substrate 由两个不同的构建组件组成：外部节点和运行时。虽然在外部节点代码中使用了 Rust 中更复杂的特性，例如多线程和异步 Rust，但它们不会直接暴露给运行时工程师，这使得运行时工程师更容易关注其节点的业务逻辑。</p>
<p>通常，根据他们的关注点，开发人员应该知道：</p>
<ul>
<li>基本的 <a href="https://rust-unofficial.github.io/patterns/idioms/index.html">Rust习惯用法</a>，<a href="https://docs.rust-embedded.org/book/intro/no-std.html"> 使用 no_std 工作 </a> 和有哪些宏以及为什么使用这些宏（用于运行时工程）。</li>
<li>异步Rust（适用于使用外部节点（客户端）代码的更高级开发人员）。</li>
</ul>
<p>尽管在深入 Substrate 之前，一般对 Rust 的熟悉是必不可少的，并且有很多资源可以用来学习 Rust，包括 <a href="https://doc.rust-lang.org/book/">Rust Language Programming Book</a> 和 <a href="https://doc.rust-lang.org/rust-by-example/">Rust by Example</a>，本节剩余部分将重点介绍 Substrate 如何使用 Rust 的一些核心特性，以帮助开发人员开始运行时工程的开发。</p>
<h3 id="compilation-target"><a class="header" href="#compilation-target">Compilation target</a></h3>
<p>当构建 Substrate 节点时，我们使用 <code>wasm32-unknown-unknown</code> 编译目标，这意味着 Substrate 运行时工程师必须在约束范围内编写运行时，且必须编译为 Wasm 的运行时。这意味着你不能依赖于某些典型的标准库类型和函数，并且对于大多数运行时代码只能使用 <code>no_std</code> 兼容的 crates。Substrate 有许多自己的原始类型和相关特性，使其尽可能围绕 <code>no_std</code> 的要求工作。</p>
<h3 id="宏"><a class="header" href="#宏">宏</a></h3>
<p>当你学习编写 FRAME pallets 时，你将很快遇到各种不同类型的宏，它们被设计用来抽象和满足任何特定于运行时的需求。有了它们，你可以专注于编写惯用的 Rust，最大限度地减少编写额外代码的开销，否则你需要编写正确地与运行时交互的代码。</p>
<p>Rust 宏是一个强大的工具，有助于确保满足某些要求（无需编写重复的代码），例如以特定方式格式化的逻辑，进行具体的检查，或者某些逻辑由特定的数据结构组成。这对于帮助开发人员编写能够与复杂的 Substrate 运行时集成的代码特别有用。例如，所有 FRAME pallets 中都需要 <code>#[frame_system:：pallet]</code> 宏，以帮助你正确实现某些所需属性，诸如，存储项或外部可调用函数，并使其与 <code>construct_runtime</code> 中的构建过程兼容。</p>
<p>开发 Substrate 运行时需要大量使用 Rust 的属性宏，通常有两种风格：派生属性和自定义属性。当你开始使用 Substrate 时，准确地知道它们是如何工作的其实并不重要，而是要知道它们的存在，以便让你能够编写正确的运行时代码。</p>
<p>派生属性对于需要满足某些特性的自定义运行时类型非常有用，例如，在运行时执行期间，节点可以对类型进行解码。</p>
<p>其他的属性宏在整个 Substrate 的代码库中也很常见，用于：</p>
<ul>
<li>告诉编译器代码段是否打算编译为 <code>no_std</code> 或是否可以访问 <code>std</code> 库。</li>
<li>自定义 FRAME 支持用于编写 pallets 的宏。</li>
<li>指定运行时的内置方式。</li>
</ul>
<h3 id="泛型和配置-traits"><a class="header" href="#泛型和配置-traits">泛型和配置 traits</a></h3>
<p>通常与 Java 等语言中的接口相比，Rust 中的 traits 给类型提供了高级功能的方法。</p>
<p>如果你读过 pallets，你可能会注意到每个 pallet 都有一个 <code>Config</code> trait，允许你定义 pallet 依赖的类型和接口。</p>
<p>该 trait 本身从 <code>frame_system::pallet::Config</code> trait 继承了许多核心运行时类型，使编写运行时的逻辑时更容易访问常见类型。此外，在任何 FRAME pallet 中，<code>Config</code> trait 都是基于 <code>T</code> 上的泛型（下一节将介绍更多泛型）。这些核心运行时类型的一些常见示例如：<code>T::AccountId</code>，在运行时或 <code>T::BlockNumber</code> 中识别用户帐户的常见类型；<code>T::BlockNumber</code>，运行时使用的区块号类型。</p>
<p>有关 Rust 中的泛型类型和 traits 的更多信息，请参阅 Rust 手册中关于<a href="https://doc.rust-lang.org/book/ch10-01-syntax.html">泛型类型</a>、<a href="https://doc.rust-lang.org/book/ch10-02-traits.html">Traits</a> 和 <a href="https://doc.rust-lang.org/book/ch19-03-advanced-traits.html">Advanced traits</a> 的章节。</p>
<p>通过 Rust 泛型，Substrate 运行时开发人员可以编写与特定实现细节完全无关的 pallets，从而充分利用 Substrate 的灵活性、可扩展性和模块性。</p>
<p><code>Config</code> trait 中的所有类型都是使用 trait 边界通用定义的，并在运行时中具体实现。这不仅意味着你可以编写支持同一类型不同规格的 pallets （例如，Substrate链和以太坊链的地址），但你也可以通过最小的成本来自定义你需求的通用实现（例如，将块号更改为 <code>u32</code>）。</p>
<p>这使开发人员能够灵活地编写代码，而不必对你所做的核心区块链架构决策进行任何假设。</p>
<p>Substrate 最大限度地使用泛型类型，以提供最大的灵活性。你可以定义如何解析泛型类型以满足你的目的。</p>
<p>有关 Rust 中的泛型类型和 traits 的更多信息，可参阅 Rust 手册中有关<a href="https://doc.rust-lang.org/book/ch10-01-syntax.html">泛型类型</a>的章节。</p>
<h2 id="链下操作"><a class="header" href="#链下操作">链下操作</a></h2>
<p>在许多用例中，你可能希望在更新链上状态之前查询来自链外的源数据或正处理的数据，而不使用链上资源。合并链外数据的通常方式一般会连接到 oracles 以从一些传统的数据来源处提供数据。尽管使用 oracles 是处理链外数据源的一种方法，但 oracles 所能提供的安全性、可扩展性和基础设施效率都有一些限制。</p>
<p>为了使链外数据的集成更加安全和高效，Substrate 通过以下特性支持链下操作：</p>
<ul>
<li>Offchain workers（链外工作机）是一个子系统的组件，可以执行长时间运行且可能是不确定性的任务，例如：
<ul>
<li>网站服务请求</li>
<li>数据的加密、解密和签名</li>
<li>随机数生成</li>
<li>CPU 密集型计算</li>
<li>链上数据和链外工作机的枚举或聚合使你能够移动可能需要更多时间执行的任务，而不是允许出块处理管道中的任务。任何可能超过允许的最大块执行时间的任务都是合理的链外处理候选任务。</li>
</ul>
</li>
<li>Offchain storage（链下存储）是 Substrate 节点的本地存储，可以由链下工作机和链上逻辑访问
<ul>
<li>链下工作机对链下存储具有读写访问权限。</li>
<li>链上逻辑通过链下索引具有写访问权限，但没有读访问权限。链下存储允许不同的工作线程相互通信，并存储不需要在整个网络上达成共识的用户特定或节点特定数据。</li>
</ul>
</li>
<li>Offchain indexing（链下索引）是一项可选服务，允许运行时独立于链下工作机直接写入链下存储。链下索引为链上逻辑提供临时存储并补充了链上状态。</li>
</ul>
<h3 id="off-chain-workers"><a class="header" href="#off-chain-workers">Off-chain workers</a></h3>
<p>链下工作机在 Substrate 运行时之外的自己的 Wasm 执行环境中运行。这种运行方式分离的考虑确保了区块生产运行不会受到长期运行的链下任务的影响。然而，由于链下工作机与运行时在同一代码中声明，因此他们可以很容易地访问链上状态用于他们的计算。</p>
<p><img src="https://awesomeprogram.gitee.io/imgdata/tech_bc_subocw.jpg" alt="" /></p>
<p>链下工作机可以访问扩展的 API 与外部世界进行通信：</p>
<ul>
<li>有能力 <a href="https://paritytech.github.io/substrate/master/sp_runtime/offchain/trait.TransactionPool.html">submit transactions（提交交易）</a>，签名或未签名，发布计算结果到链上。</li>
<li>一个功能齐全的 HTTP 客户端，允许工作机从外部服务访问和获取数据。</li>
<li>访问本地密钥库以签名和验证状态或交易。</li>
<li>另外，所有链下工作机共享本地<a href="https://paritytech.github.io/substrate/master/sp_runtime/offchain/trait.OffchainStorage.html">键值数据库</a>。</li>
<li>一个安全的，本地熵源用于随机数的生成。</li>
<li>访问节点的<a href="https://paritytech.github.io/substrate/master/sp_runtime/offchain/struct.Timestamp.html">本地精确时间</a>。</li>
<li>有能力去挂起和恢复任务。</li>
</ul>
<p>请注意，链下工作机产生的结果不需要定期进行交易验证。因此，你应该保证链下操作，包括验证方法，以确定哪些信息进入链中。例如，你可以通过实现投票、权重均分或检查发送者签名的机制来验证链下交易。</p>
<p>在每次块导入过程中，都会生成链下工作机。然而，它们不会在初始区块链同步期间执行。</p>
<h3 id="offchain-storage"><a class="header" href="#offchain-storage">Offchain storage</a></h3>
<p>链下存储始终是 Substrate 节点的本地存储，不与任何其他区块链节点在链上共享，也不受共识机制的约束。你可以使用具有读写访问权限的链下工作线程访问在链下存储中的数据，或者通过使用链下索引的链上逻辑访问数据。</p>
<p>由于在每次块导入期间都会产生一个链下工作机线程，因此在任何指定时间内都可以有多个链下工作机线程运行。与任何多线程编程环境一样，当链下工作机线程访问链下存储时，有一些实用程序可以对其进行互斥锁定，以确保数据一致性。</p>
<p>链下存储作为链下工作机线程相互通信，以及充当链下和链上逻辑之间通信的桥梁。还可以使用远程过程调用（RPC）读取它，因此它适合存储无限增长的数据而不会过度消耗链上存储空间。</p>
<h3 id="offchain-indexing"><a class="header" href="#offchain-indexing">Offchain indexing</a></h3>
<p>在区块链的上下文中，存储通常与链上状态有关。然而，链上状态的是很昂贵的，因为它必须得到一致同意，并被转移到网络中的多个节点。因此，不应该使用链上存储去存储随着时间无限增长的历史数据或用户生成的数据。</p>
<p>为了满足访问历史数据或用户生成数据的需要，Substrate 提供通过使用链下索引可以对链下存储进行访问。链下索引允许运行时直接写入链下存储，而不需要使用链下工作机线程。你可以通过使用 <code>--enable-offchain-indexing</code> 命令行选项启动 Substrate 节点，以启用此功能来持久化数据。</p>
<p>与链下工作机不同，链下索引在每次处理区块时填充数据到链下存储。通过在每个块填充数据，链下索引可确保数据始终保持一致，并且对启用索引运行的每个节点，也都完全相同。</p>
<ul>
<li><a href="https://github.com/paritytech/substrate/tree/master/frame/examples/offchain-worker">Example: Offchain worker Pallet</a></li>
<li><a href="https://github.com/JoshOrndorff/recipes/blob/master/text/off-chain-workers/transactions.md">Example: Submit transactions</a></li>
<li><a href="https://github.com/JoshOrndorff/recipes/blob/master/text/off-chain-workers/http-json.md">Example: Use HTTP requests to fetch data</a></li>
<li><a href="https://github.com/JoshOrndorff/recipes/blob/master/text/off-chain-workers/storage.md">Example: Offchain storage</a></li>
<li><a href="https://github.com/JoshOrndorff/recipes/blob/master/text/off-chain-workers/indexing.md">Example: Offchain indexing</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="构建与编码-1"><a class="header" href="#构建与编码-1">构建与编码</a></h1>
<p>本节中的主题提供了对用于构造运行时逻辑的编写代码的更详细探索，包括可用于构建和与节点交互的库和工具，以及如何编译逻辑以构建 Substrate 节点的更近一步的观察。</p>
<h2 id="代码库的介绍"><a class="header" href="#代码库的介绍">代码库的介绍</a></h2>
<p>在使用 node template 时，你不需要知道任何有关正在使用的底层架构或库的信息，因为基本组件已经组装好并可以直接使用。</p>
<p>然而，如果你想要设计和构建自定义区块链，你可能需要熟悉可用的库，并了解这些不同库的功能。</p>
<p>在<strong>substrate 架构设计</strong>中，你了解了 Substrate 节点的核心组件以及节点的不同部分如何承担不同的责任。在技术层面上，节点不同层之间的职责分离反映在用于构建基于 Substrate 的区块链的核心库中。下图说明了库如何映射外节点和运行时职责，以及基本库如何提供两者之间的通信层。</p>
<p><img src="https://awesomeprogram.gitee.io/imgdata/tech_bc_sublibs.jpg" alt="" /></p>
<h3 id="核心节点库"><a class="header" href="#核心节点库">核心节点库</a></h3>
<p>使 Substrate 节点能够处理其网络职责的库，包括共识算法和块执行在内的是以使用 <code>sc_</code> 为前缀名的 Rust crates。例如，<a href="https://paritytech.github.io/substrate/master/sc_service/index.html"><code>sc_service</code></a>库负责为 Substrate 区块链构建网络层，管理网络参与者和交易池之间的通信。</p>
<p>在外部节点和运行时之间提供通信层的库是以使用 <code>sp_</code> 为前缀名的 Rust crates。这些库编排了需要外部节点和运行时之间交互活动。例如，<a href="https://paritytech.github.io/substrate/master/sp_std/index.html"><code>sp_std</code></a> 库从Rust 标准库中获取有用的基本逻辑，并使其可用于依赖于运行时的任何代码。</p>
<p>使你能够构建运行时逻辑并对传入和传出运行时的信息进行编码和解码的库是 Rust crates，在 crate 名称中使用 <code>frame_</code> 前缀。<code>frame_*</code> 库为运行时提供了基础代码结构。例如，<a href="https://paritytech.github.io/substrate/master/frame_system/index.html"><code>frame_system</code></a> 库提供了一系列与其他 Substrate 组件交互的基本功能，以及 <a href="https://paritytech.github.io/substrate/master/frame_support/index.html"><code>frame_support</code></a> 允许你声明运行时存储项、错误和事件。</p>
<p>除了 <code>frame_*</code> 库提供的基础代码结构外，运行时还可以包括一个或多个 <code>pallet_*</code> 库。每个使用 <code>pallet_</code> 为前缀的 Rust crate 都代表一个 FRAME 模块。在大多数情况下，你使用 <code>pallet_*</code> 库来组装你想要加入区块链的功能，以满足你的项目。</p>
<p>你可以使用 <code>sp_*</code> 核心库公开的基础代码构建 Substrate 运行时，而无需使用 <code>frame_*</code> 或 <code>pallet_*</code> 库。然而，<code>frame_*</code> 或 <code>pallet_*</code> 库为构建 Substrate 运行时提供了最有效方法。</p>
<h3 id="模块化架构"><a class="header" href="#模块化架构">模块化架构</a></h3>
<p>核心库的分离为编写区块链逻辑提供了灵活的模块化架构。基础代码库提供了一个外部节点和运行时都可以在此之上构建的方式，而无需彼此直接通信。基础类型和 traits 在它们各自独立的 crates 中公开，因此它们可用于外部节点和运行时组件，而不会引入循环依赖性问题。</p>
<h3 id="前端代码库"><a class="header" href="#前端代码库">前端代码库</a></h3>
<p>除了使你能够基于 Substrate 区块链的核心库构建区块链外，你还可以使用客户端库与 Substrate 节点进行交互。你可以使用客户端库来构建特定应用程序的前端。通常，客户端库公开的功能是在 Substrate 远程过程调用（RPC）APIs 的顶部实现的。有关使用元数据和前端库来构建应用程序的更多信息，可参见<strong>应用程序开发</strong>。</p>
<h2 id="构建过程"><a class="header" href="#构建过程">构建过程</a></h2>
<p>在架构设计中，你了解到 Substrate 节点由外部节点主机和运行时执行环境组成。这些节点组件通过调用运行时 API 和调用主机函数相互通信。在本节中，你将进一步了解如何将 Substrate 运行时编译为平台本机可执行文件和存储在区块链上的 WebAssembly（Wasm）二进制文件。在你了解了二进制文件如何编译的内部工作原理之后，你将进一步了解为什么有两个二进制文件，何时使用，以及如果需要，如何更改执行策略。</p>
<h3 id="编译一个优化的组件"><a class="header" href="#编译一个优化的组件">编译一个优化的组件</a></h3>
<p>你可能已经知道，可以通过在 Substrate node 项目的根目录中运行 <code>cargo build --release</code> 命令来编译 Substrate 节点。此命令为项目构建平台特定的可执行文件和 WebAssembly 二进制文件，并生成优化后的可执行文件。生成优化的可执行文件包括一些编译后处理。</p>
<p>作为优化过程的一部分，WebAssembly 运行时二进制会通过一系列内部步骤进行编译和压缩，然后再将其包含在链中的 genesis 状态中。为了让你更好地理解该过程，下图总结了这些步骤。</p>
<p><img src="https://awesomeprogram.gitee.io/imgdata/tech_bc_subnodeexec.jpg" alt="" /></p>
<p>以下各小节将更详细地描述构建过程。</p>
<h4 id="构建-webassembly-二进制文件"><a class="header" href="#构建-webassembly-二进制文件">构建 WebAssembly 二进制文件</a></h4>
<h5 id="webassembly中包含的功能"><a class="header" href="#webassembly中包含的功能">WebAssembly中包含的功能</a></h5>
<h5 id="用于自定义构建过程的环境变量"><a class="header" href="#用于自定义构建过程的环境变量">用于自定义构建过程的环境变量</a></h5>
<h5 id="用于自定义构建过程的环境变量-1"><a class="header" href="#用于自定义构建过程的环境变量-1">用于自定义构建过程的环境变量</a></h5>
<h5 id="压缩-webassembly-二进制文件"><a class="header" href="#压缩-webassembly-二进制文件">压缩 WebAssembly 二进制文件</a></h5>
<h3 id="执行策略"><a class="header" href="#执行策略">执行策略</a></h3>
<h3 id="构建没有-native-runtime-的-webassembly"><a class="header" href="#构建没有-native-runtime-的-webassembly">构建没有 native runtime 的 WebAssembly</a></h3>
<h3 id="不使用-webassembly-编译-rust"><a class="header" href="#不使用-webassembly-编译-rust">不使用 WebAssembly 编译 Rust</a></h3>
<h2 id="运行时存储"><a class="header" href="#运行时存储">运行时存储</a></h2>
<h3 id="存储项目"><a class="header" href="#存储项目">存储项目</a></h3>
<h3 id="声明存储项目"><a class="header" href="#声明存储项目">声明存储项目</a></h3>
<h3 id="访问存储项目"><a class="header" href="#访问存储项目">访问存储项目</a></h3>
<h3 id="哈希算法"><a class="header" href="#哈希算法">哈希算法</a></h3>
<h3 id="初始化配置"><a class="header" href="#初始化配置">初始化配置</a></h3>
<h3 id="最佳实践"><a class="header" href="#最佳实践">最佳实践</a></h3>
<h2 id="交易权重和费用"><a class="header" href="#交易权重和费用">交易、权重和费用</a></h2>
<h3 id="如何计算费用"><a class="header" href="#如何计算费用">如何计算费用</a></h3>
<h3 id="使用-transaction-payment-pallet"><a class="header" href="#使用-transaction-payment-pallet">使用 transaction payment pallet</a></h3>
<h3 id="有特殊要求的交易"><a class="header" href="#有特殊要求的交易">有特殊要求的交易</a></h3>
<h3 id="默认权重注释"><a class="header" href="#默认权重注释">默认权重注释</a></h3>
<h3 id="提交派发权重校准"><a class="header" href="#提交派发权重校准">提交派发权重校准</a></h3>
<h3 id="自定义费用"><a class="header" href="#自定义费用">自定义费用</a></h3>
<h2 id="自定义-pallets"><a class="header" href="#自定义-pallets">自定义 pallets</a></h2>
<h3 id="pallet-宏和属性"><a class="header" href="#pallet-宏和属性">Pallet 宏和属性</a></h3>
<h3 id="有用的-frame-traits"><a class="header" href="#有用的-frame-traits">有用的 FRAME traits</a></h3>
<h3 id="运行时实现"><a class="header" href="#运行时实现">运行时实现</a></h3>
<h2 id="pallet-耦合"><a class="header" href="#pallet-耦合">Pallet 耦合</a></h2>
<h3 id="紧密的耦合-pallet"><a class="header" href="#紧密的耦合-pallet">紧密的耦合 Pallet</a></h3>
<h3 id="松散的耦合-pallet"><a class="header" href="#松散的耦合-pallet">松散的耦合 Pallet</a></h3>
<h3 id="选择-pallet-耦合策略"><a class="header" href="#选择-pallet-耦合策略">选择 Pallet 耦合策略</a></h3>
<h2 id="事件和错误"><a class="header" href="#事件和错误">事件和错误</a></h2>
<h3 id="声明一个事件"><a class="header" href="#声明一个事件">声明一个事件</a></h3>
<h3 id="向运行时公开事件"><a class="header" href="#向运行时公开事件">向运行时公开事件</a></h3>
<h3 id="存下一个事件"><a class="header" href="#存下一个事件">存下一个事件</a></h3>
<h3 id="支持的类型"><a class="header" href="#支持的类型">支持的类型</a></h3>
<h3 id="监听一个事件"><a class="header" href="#监听一个事件">监听一个事件</a></h3>
<h3 id="错误"><a class="header" href="#错误">错误</a></h3>
<h2 id="randomness"><a class="header" href="#randomness">Randomness</a></h2>
<h3 id="确定随机性"><a class="header" href="#确定随机性">确定随机性</a></h3>
<h3 id="substrates-randomness-trait"><a class="header" href="#substrates-randomness-trait">Substrate's randomness trait</a></h3>
<h3 id="安全属性"><a class="header" href="#安全属性">安全属性</a></h3>
<h2 id="chain-specification"><a class="header" href="#chain-specification">Chain specification</a></h2>
<h3 id="自定义外部节点配置"><a class="header" href="#自定义外部节点配置">自定义外部节点配置</a></h3>
<h3 id="自定义初始配置"><a class="header" href="#自定义初始配置">自定义初始配置</a></h3>
<h3 id="存储-chain-specification-信息"><a class="header" href="#存储-chain-specification-信息">存储 chain specification 信息</a></h3>
<h3 id="通过一个-chain-specification-启动节点"><a class="header" href="#通过一个-chain-specification-启动节点">通过一个 chain specification 启动节点</a></h3>
<h3 id="为运行时声明存储项"><a class="header" href="#为运行时声明存储项">为运行时声明存储项</a></h3>
<h3 id="raw-chain-specifications"><a class="header" href="#raw-chain-specifications">Raw chain specifications</a></h3>
<h2 id="privileged-calls-and-origins"><a class="header" href="#privileged-calls-and-origins">Privileged calls and origins</a></h2>
<h3 id="raw-origins"><a class="header" href="#raw-origins">Raw origins</a></h3>
<h3 id="origin-call"><a class="header" href="#origin-call">Origin call</a></h3>
<h3 id="custom-origins"><a class="header" href="#custom-origins">Custom origins</a></h3>
<h3 id="next-steps"><a class="header" href="#next-steps">Next steps</a></h3>
<h2 id="远程过程调用"><a class="header" href="#远程过程调用">远程过程调用</a></h2>
<p>远程过程调用，或叫RPCs，是外部编程的一种方式，例如，一个浏览器或前端应用程序，与一个 Substrate 节点通信。他们通常被用作检查存储值、提交交易、并查询当前共识授权。Substrate 附带了几个<a href="https://polkadot.js.org/docs/substrate/rpc/">默认的RPCs</a>。在许多案例中，添加自定义 RPCs 到你的节点中是很有用的。</p>
<h3 id="rpc扩展构建器"><a class="header" href="#rpc扩展构建器">RPC扩展构建器</a></h3>
<p>要将自定义 RPC 客户端连接到 Substrate 节点时，你必须提供一个被称为 RPC 扩展构建器的函数。此函数会采用一个参数，为节点应该接受还是拒绝不安全的 RPC 调用，并返回一个节点需要创建 JSON RPC 的 <a href="https://paritytech.github.io/substrate/master/node_rpc/type.IoHandler.html"><code>IoHandler</code></a>。关于更多上下文的内容，可通过查看 <a href="https://paritytech.github.io/substrate/master/sc_service/trait.RpcExtensionBuilder.html"><code>RpcExtensionBuilder</code> trait API</a> 文档。</p>
<h3 id="rpc类型"><a class="header" href="#rpc类型">RPC类型</a></h3>
<p>RPCs 可以是节点共识机制的接口，也可以是任何外部用户向区块链提交交易的接口。在所有情况下，重要的是要考虑 RPCs 公开哪些 endpoints。启动一个节点，并运行此命令以查看节点的 RPC API 的全部列表：</p>
<pre><code class="language-bash editable noplayground">curl -H &quot;Content-Type: application/json&quot; -d '{&quot;id&quot;:1, &quot;jsonrpc&quot;:&quot;2.0&quot;, &quot;method&quot;: &quot;rpc_methods&quot;}' http://localhost:9933/
</code></pre>
<h3 id="公开的rpcs"><a class="header" href="#公开的rpcs">公开的RPCs</a></h3>
<p>Substrate 节点提供以下命令行选项，允许你公开 RPC 接口：</p>
<pre><code class="language-bash editable noplayground">--ws-external
--rpc-external
--unsafe-ws-external
--unsafe-rpc-external
</code></pre>
<p>默认情况下，如果你尝试暴露 RPC 接口并同时运行验证者节点，则该节点会拒绝启动；<code>--unsafe-*</code> 标签允许你取消此安全限制。暴露 RPC 接口会对外暴露一个巨大的攻击可能性，必须要仔细的审查。</p>
<p>有很多 RPC 方法可以用来控制节点的行为，但是你应该避免暴露它。例如，你不应该暴露下面的 RPC 方法：</p>
<ul>
<li><code>author_submitExtrinsic</code> — 允许向本地交易池提交交易。</li>
<li><code>author_insertKey</code> — 允许向本地密钥存储库插入私钥。</li>
<li><code>author_rotateKeys</code> — session 密钥轮换。</li>
<li><code>author_removeExtrinsic</code> — 从池中移除并禁用 extrinsic。</li>
<li><code>system_addReservedPeer</code> — 添加保留节点。</li>
<li><code>system_removeReservedPeer</code> — 移除保留节点。</li>
</ul>
<p>你还应该避免暴露可能需要很长时间执行的 RPC 方法，这可能会组织客户端的状态同步。例如，你应该避免使用下面的 RPC 方法：</p>
<ul>
<li><code>storage_keys_paged</code> — 获取状态中具有指定前缀和分页支持的所有 key。</li>
<li><code>state_getPairs</code> — 获取状态中具有指定前缀的所有 key 及其值。</li>
</ul>
<p>这些 RPCs 是使用 <code>#[rpc(name = &quot;rpc_method&quot;)]</code> 宏声明的，其中 <code>rpc_method</code> 是函数的名称， 例如，<code>author_submitExtrinsic</code> 对应于 <a href="https://paritytech.github.io/substrate/master/sc_rpc/author/trait.AuthorApi.html#tymethod.submit_extrinsic"><code>submit_extrinsic</code></a>。</p>
<p>如果请求来自不受信任的用户，过滤掉此类调用则至关重要。实现这一点的方法是通过 <a href="https://docs.substrate.io/reference/glossary/#json-rpc">JSON-RPC</a> 代理，该代理能够过滤检查调用并仅传递允许的 APIs。</p>
<h3 id="rpcs-for-remote_externalities"><a class="header" href="#rpcs-for-remote_externalities">RPCs for remote_externalities</a></h3>
<p>在 <code>remote_externalities</code> 上下文中存在一种特殊类型的 RPCs 使用方法。<a href="https://paritytech.github.io/substrate/master/remote_externalities/rpc_api/index.html"><code>rpc_api</code></a> 允许你对 Substrate 节点进行一次性的调用，例如，对于使用 <code>try_runtime</code> 等工具进行测试非常有用。</p>
<h3 id="endpoints"><a class="header" href="#endpoints">Endpoints</a></h3>
<p>当启用任何 Substrate 节点时，你可以使用下面两个 endpoints：</p>
<ul>
<li>HTTP endpoint：<code>http://localhost:9933</code></li>
<li>WebSocket endpoint：<code>ws://localhost:9944</code></li>
</ul>
<p>大多数 Substrate 前端库和工具都使用更强大的 Websocket endpoint 与区块链进行交互。通过 WebSockets，你可以订阅链的状态，诸如事件，以及你的区块链发生在无论任何条件下的所有改变，都会接收推送通知。</p>
<p>要调用 <code>Metadata</code> 端点，需要与运行节点一起运行下面这行命令：</p>
<pre><code class="language-bash editable noplayground">curl -H &quot;Content-Type: application/json&quot; -d '{&quot;id&quot;:1, &quot;jsonrpc&quot;:&quot;2.0&quot;, &quot;method&quot;: &quot;state_getMetadata&quot;}' http://localhost:9933/
</code></pre>
<p>该命令的返回值不是 human-readable 的格式，基于此，它需要使用<a href="https://docs.substrate.io/reference/scale-codec/">类型编码（SCALE）</a>。</p>
<p>每个存储项都有一个相关联的存储 key，用于查询存储，这就是 RPC endpoints 知道怎么去查看。</p>
<h3 id="示例"><a class="header" href="#示例">示例</a></h3>
<p><strong><code>state_getMetadata</code></strong> 
RPC 请求：</p>
<pre><code class="language-javascript editable noplayground">function get_metadata_request(endpoint) {
  let request = new Request(endpoint, {
    method: &quot;POST&quot;,
    body: JSON.stringify({
      id: 1,
      jsonrpc: &quot;2.0&quot;,
      method: &quot;state_getMetadata&quot;,
    }),
    headers: { &quot;Content-Type&quot;: &quot;application/json&quot; },
  });
  return request;
}
</code></pre>
<p>原文本解码：</p>
<pre><code class="language-javascript editable noplayground">function decode_metadata(metadata) {
  return new TextDecoder().decode(util.hexToU8a(metadata));
}
</code></pre>
<p><strong><code>state_getStorage</code></strong>
RPC request：</p>
<pre><code class="language-json editable noplayground">Request:   {&quot;id&quot;:1,&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;method&quot;:&quot;state_getStorage&quot;,[&quot;{storage_key}&quot;]}
</code></pre>
<p>其中 <code>storage_key</code> 是由对应名称的pallet，函数和 key（可选的）生成的参数。</p>
<pre><code class="language-javascript editable noplayground">function get_runtime_storage_parameter_with_key(module_name, function_name, key) {
  // We use xxhash 128 for strings the runtime developer can control
  let module_hash = util_crypto.xxhashAsU8a(module_name, 128);
  let function_hash = util_crypto.xxhashAsU8a(function_name, 128);

  // We use blake2 256 for strings the end user can control
  let key_hash = util_crypto.blake2AsU8a(keyToBytes(key));

  // Special syntax to concatenate Uint8Array
  let final_key = new Uint8Array([...module_hash, ...function_hash, ...key_hash]);

  // Return a hex string
  return util.u8aToHex(final_key);
}
</code></pre>
<h2 id="应用程序开发"><a class="header" href="#应用程序开发">应用程序开发</a></h2>
<h3 id="元数据系统"><a class="header" href="#元数据系统">元数据系统</a></h3>
<h3 id="元数据格式"><a class="header" href="#元数据格式">元数据格式</a></h3>
<h3 id="rpc-apis"><a class="header" href="#rpc-apis">RPC APIs</a></h3>
<h3 id="连接到一个节点"><a class="header" href="#连接到一个节点">连接到一个节点</a></h3>
<h3 id="开始构建"><a class="header" href="#开始构建">开始构建</a></h3>
<h3 id="前端用例"><a class="header" href="#前端用例">前端用例</a></h3>
<h2 id="升级运行时"><a class="header" href="#升级运行时">升级运行时</a></h2>
<p>无分叉运行时升级是用于 Substrate 框架区块链开发的的一个定义特性。无需分叉代码库就可以更新运行时逻辑，这使你的区块链能够随着时间的推移而发展和改进。通过包含为区块链定义运行时执行环境（运行时 WebAssembly blob）状态中的一个元素，可以实现此功能。</p>
<p>因为运行时是区块链状态的一部分，所以网络维护人员可以利用区块链的无信任、去中心化共识功能来安全地增强运行时。</p>
<p>在用于运行时开发的 FRAME 系统中，系统库定义了用于更新运行时定义的 <a href="https://paritytech.github.io/substrate/master/frame_system/pallet/enum.Call.html#variant.set_code">the <code>set_code</code> call</a>。<a href="blockchain/./chapter_1_2_1_3.html#%E5%8D%87%E7%BA%A7%E4%B8%80%E4%B8%AA%E8%BF%90%E8%A1%8C%E4%B8%AD%E7%9A%84%E7%BD%91%E7%BB%9C">升级一个运行中的网络</a>教程演示了在不关闭节点或中断操作的情况下升级运行时的两种方法。但是，本节教程中的两个升级都演示了向运行时添加功能，而不是更新现有的运行时状态。如果运行时升级需要更改现有状态，则可能需要进行存储迁移。</p>
<h3 id="运行时版本控制"><a class="header" href="#运行时版本控制">运行时版本控制</a></h3>
<p>在<a href="blockchain/chapter_1_2_1_2.html#%E6%9E%84%E5%BB%BA%E8%BF%87%E7%A8%8B">构建过程</a>中，你了解了编译节点会同时生成平台的原生二进制文件和 WebAssembly 二进制文件，并且可以通过执行策略命令行选项来控制在区块生产过程的不同地方选择使用哪一个二进制文件。选择要与之通信的运行时执行环境的组件称为执行程序。尽管你可以覆盖自定义场景的默认执行策略，但在大多数情况下，或者执行程序通过评估原生二进制和 WebAssembly 二进制的以下信息选择适当的二进制文件来使用：</p>
<ul>
<li><code>spec_name</code></li>
<li><code>spec_version</code></li>
<li><code>authoring_version</code></li>
</ul>
<p>为了向执行程序进程提供此信息，运行时包含类似于以下的<a href="https://paritytech.github.io/substrate/master/sp_version/struct.RuntimeVersion.html">运行时版本结构</a>：</p>
<pre><code class="language-rust editable noplayground">pub const VERSION: RuntimeVersion = RuntimeVersion {
  spec_name: create_runtime_str!(&quot;node-template&quot;),
  impl_name: create_runtime_str!(&quot;node-template&quot;),
  authoring_version: 1,
  spec_version: 1,
  impl_version: 1,
  apis: RUNTIME_API_VERSIONS,
  transaction_version: 1,
};
</code></pre>
<p>结构中的参数提供了以下信息:
|<strong>This parameter</strong>|<strong>Provides this</strong>|
|:-----|:-----|
|<code>spec_name</code>|不同 Substrate 运行时的标识符。|
|<code>impl_name</code>|spec 实现的名称。这对节点影响不大，只用于区分不同团队实现的代码。|
|<code>authoring_version</code>|authorship 接口的版本。除非是它的原生运行时，否则生产节点不会尝试生成块。|
|<code>spec_version</code>|运行时 specification 的版本。完整节点不会尝试使用它的原生运行时来替代链上的 Wasm 运行时，除非 Wasm 和原生二进制文件之间的所有 <code>spec_name</code>、<code>spec_version</code> 和 <code>authoring_version</code> 都是相同的。<code>spec_version</code> 的更新可以作为一个 CI 过程自动化，就像 <a href="https://gitlab.parity.io/parity/polkadot/-/blob/master/scripts/gitlab/check_extrinsics_ordering.sh">Polkadot 网络</a>一样。当 <code>transaction_version</code> 有更新时，通常会递增此参数。|
|<code>impl_version</code>|specification 的实现版本，节点可以忽略这一点，它只用于表明代码是不同的。只要 <code>authoring_version</code> 和 <code>spec_version</code> 是相同的，代码本身就可能会发生变化，但是原生二进制文件和 Wasm 二进制文件做的是相同的事情。通常只有逻辑之外的破坏性优化才会导致 <code>impl_version</code> 的更改。|
|<code>transaction_version</code>|处理交易的接口版本。此参数可以用于同步硬件钱包或其他签名设备的固件更新，以验证运行时交易是否有效。该参数允许硬件钱包知道哪些交易可以安全签名。如果在 <code>construct_runtime!</code> 宏中的 pallet 索引发生变化，或者如果对可调用的函数有任何更改，这个数字就会碰撞，比如参数的数量或参数类型。如果更新了这个编号，那么 <code>spec_version</code> 也必须更新。|
|<code>apis</code>|支持的<a href="https://paritytech.github.io/substrate/master/sp_api/macro.impl_runtime_apis.html">运行时 APIs</a> 及其版本列表。|</p>
<p>编排引擎，有时被称为执行程序，验证原生运行时是否具有相同的一致性，在 WebAssembly 选择执行之前，将驱动逻辑作为 WebAssembry。但是由于运行时版本是手动设置的，因此如果运行时版本被错误表示，编排引擎仍然可能做出不适当的决策。</p>
<h3 id="访问运行时版本"><a class="header" href="#访问运行时版本">访问运行时版本</a></h3>
<p>FRAME 系统通过 <code>state.getRuntimeVersion</code> RPC endpoint 公开运行时版本信息。endpoint 接受一个可选的块标识符。然而，在大多数情况下，你使用运行时<a href="https://docs.substrate.io/main-docs/build/application-development/#metadata-system">元数据</a>来理解运行时公开的 APIs 以及如何与这些 APIs 交互。只有当链的<a href="https://paritytech.github.io/substrate/master/sp_version/struct.RuntimeVersion.html#structfield.spec_version">运行时 spec_version</a> 更改时，运行时元数据才应该更改。</p>
<h3 id="无分叉的运行时升级"><a class="header" href="#无分叉的运行时升级">无分叉的运行时升级</a></h3>
<p>传统区块链在升级其链的状态转换功能时，需要进行硬分叉。硬分叉要求所有节点操作员停止其节点并手动升级到最新的可执行文件。对于分布式生产网络，协调硬分叉升级可能是一个复杂的过程。</p>
<p>运行时版本属性使基于 Substrate 的区块链能够实时升级运行时逻辑，而不会造成网络分叉。</p>
<p>要执行无分叉运行时升级，Substrate 使用现有运行时逻辑将存储在区块链上的 Wasm 运行时更新为具有新逻辑的新共识迭代版本。作为共识过程的一部分，这种升级被推送到网络上的所有全节点。在 Wasm 运行时升级之后，编排引擎会发现本机运行时 <code>spec_name</code>、<code>spec_version</code> 或 <code>authoring_version</code> 不再与新的 Wasm 运行时匹配。因此，编配引擎会执行规范的 Wasm 运行时，而不是在任何执行流程中使用原生本地运行时。</p>
<h3 id="存储迁移"><a class="header" href="#存储迁移">存储迁移</a></h3>
<p>存储迁移是自定义的一次性函数，允许你更新存储以适应运行时中的更改。例如，如果运行时升级将用于表示用户余额的数据类型从无符号整数更改为有符号整数，存储迁移将读取现有值为无符号整数，并回写已转换为有符号整数的更新值。如果你没有在需要时对数据的存储方式进行此类更改，运行时就无法正确地解释存储值以包含在运行时状态中，并可能导致没有定义的行为。</p>
<h4 id="使用frame进行存储迁移"><a class="header" href="#使用frame进行存储迁移">使用FRAME进行存储迁移</a></h4>
<p>使用 <a href="https://paritytech.github.io/substrate/master/frame_support/traits/trait.OnRuntimeUpgrade.html"><code>OnRuntimeUpgrade</code></a> trait 实现 FRAME 存储迁移。<code>OnRuntimeUpgrade</code> trait 指定一个单独的函数，<code>on_runtime_upgrade</code>，它允许你指定在运行时升级之后立即运行的逻辑，但要在任何 <a href="https://docs.substrate.io/main-docs/fundamentals/transaction-lifecycle/#initialize-a-block"><code>on_initialize</code></a> 函数或交易被执行之前。</p>
<h4 id="准备存储迁移"><a class="header" href="#准备存储迁移">准备存储迁移</a></h4>
<p>准备存储迁移意味着理解运行时升级所定义的更改。Substrate 存储库使用 <a href="https://github.com/paritytech/substrate/pulls?q=is%3Apr+label%3AE1-runtimemigration"><code>E1-runtimemigration</code></a> 标签来指定此类更改。</p>
<h4 id="写一个迁移"><a class="header" href="#写一个迁移">写一个迁移</a></h4>
<p>每次存储迁移都是不同的，具有不同的需求和不同的复杂性级别。但是当你需要进行存储迁移时，可以参考以下推荐实践进行操作：</p>
<ul>
<li>将迁移提取到可复用的函数中，并为它们编写测试。</li>
<li>包括在迁移中的登录以协助调试。</li>
<li>请记住迁移是在升级的运行时上下文中执行的。迁移代码可能需要包含已弃用的类型，如<a href="https://github.com/hicommonwealth/substrate/blob/5f3933f5735a75d2d438341ec6842f269b886aaa/frame/indices/src/migration.rs#L5-L22">本例</a>所示。</li>
<li>使用存储版本使迁移更具有声明性，从而使迁移更安全，如<a href="https://github.com/paritytech/substrate/blob/c79b522a11bbc7b3cf2f4a9c0a6627797993cb79/frame/elections-phragmen/src/lib.rs#L119-L157">本例</a>所示。</li>
</ul>
<h4 id="迁移的排序"><a class="header" href="#迁移的排序">迁移的排序</a></h4>
<p>默认情况下，FRAME 命令执行 <code>on_runtime_upgrade</code> 函数，根据 pallet 在 <code>construct_runtime!</code> 宏中出现的顺序。对于升级，函数以相反的顺序运行，从最先执行的最后一个 pallet 开始。如果需要你也可以强制执行自定义顺序（请参阅此处的<a href="https://github.com/hicommonwealth/edgeware-node/blob/7b66f4f0a9ec184fdebcccd41533acc728ebe9dc/node/runtime/src/lib.rs#L845-L866">示例</a>）。
FRAME 存储迁移按照这个顺序运行：</p>
<ol>
<li>如果使用自定义顺序，则需要自定义 <code>on_runtime_upgrade</code>。</li>
<li>系统 <code>frame_system::on_runtime_upgrade</code> 函数。</li>
<li>所有的 <code>on_runtime_upgrade</code> 函数都是在运行时中定义的，从 <code>construct_runtime!</code> 宏中的最后一个 pallet 开始。</li>
</ol>
<h4 id="测试迁移"><a class="header" href="#测试迁移">测试迁移</a></h4>
<p>测试存储迁移非常重要，以下是一些可用来测试存储迁移的工具：</p>
<ul>
<li><a href="https://github.com/paritytech/substrate-debug-kit">Substrate debug kit</a> 包括一个 <a href="https://github.com/paritytech/substrate-debug-kit/tree/master/remote-externalities">remote externalities</a> 工具，该工具允许对实时的链数据安全地执行存储迁移单元测试。</li>
<li><a href="https://github.com/maxsam4/fork-off-substrate">fork-off-substrate</a> 脚本可以很容易地创建一个 chain specification，引导一个本地测试链来测试运行时升级和存储迁移。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="启动区块链网络-1"><a class="header" href="#启动区块链网络-1">启动区块链网络</a></h1>
<p>本节教程演示了使用基于 Substrate 的区块链节点的基础知识，包括如何使节点在对等网络中相互通信，以及如何收集关于节点操作的指标。通常，你应该按照列出的顺序完成教程，因为它们为尝试后面的教程或执行更复杂的任务奠定了基础。后面的教程加强或扩展了在本教程中学习的基本主题。</p>
<h2 id="构建本地区块链"><a class="header" href="#构建本地区块链">构建本地区块链</a></h2>
<h3 id="编译substrate节点"><a class="header" href="#编译substrate节点">编译Substrate节点</a></h3>
<pre><code class="language-bash editable noplayground">git clone https://github.com/substrate-developer-hub/substrate-node-template

cd substrate-node-template &amp;&amp; git checkout polkadot-v0.9.26

rustup update
rustup update nightly
rustup target add wasm32-unknown-unknown --toolchain nightly

cargo build --release
</code></pre>
<h3 id="启动节点"><a class="header" href="#启动节点">启动节点</a></h3>
<pre><code class="language-bash editable noplayground">./target/release/node-template --dev   
</code></pre>
<p><img src="https://awesomeprogram.gitee.io/imgdata/tech_bc_subnos.jpg" alt="" /></p>
<h3 id="安装front-end-template"><a class="header" href="#安装front-end-template">安装front-end template</a></h3>
<pre><code class="language-bash editable noplayground">node --version
yarn --version
npm install -g yarn
git clone https://github.com/substrate-developer-hub/substrate-front-end-template
cd substrate-front-end-template
yarn install
</code></pre>
<h3 id="启动front-end-template"><a class="header" href="#启动front-end-template">启动front-end template</a></h3>
<pre><code class="language-bash editable noplayground">yarn start
</code></pre>
<p>访问 http://localhost:8000/</p>
<p><img src="https://awesomeprogram.gitee.io/imgdata/tech_bc_subfronts.jpg" alt="" /></p>
<h3 id="停止本地节点"><a class="header" href="#停止本地节点">停止本地节点</a></h3>
<ol>
<li>返回显示节点输出的终端。</li>
<li>按 Control-c 终止正在运行的进程。</li>
<li>验证终端是否返回到 substrate-node-template 目录中的终端提示。</li>
</ol>
<h2 id="模拟区块链私有网络"><a class="header" href="#模拟区块链私有网络">模拟区块链私有网络</a></h2>
<p>在本节教程中，你将看到权威共识模型在实践中是如何工作的，它使用两个预定义的权威帐户使节点能够生成块。在这个模拟网络中，两个节点使用不同的帐户和密钥启动，但在一台计算机上运行。</p>
<h3 id="启动第一个区块链节点"><a class="header" href="#启动第一个区块链节点">启动第一个区块链节点</a></h3>
<p>本教程通过使用名为 alice 和 bob 的预定义帐户在单个本地计算机上运行两个 Substrate 节点来模拟私有网络。</p>
<h4 id="清除之前旧链的数据"><a class="header" href="#清除之前旧链的数据">清除之前旧链的数据</a></h4>
<pre><code class="language-bash editable noplayground">./target/release/node-template purge-chain --base-path /tmp/alice --chain local

# Are you sure to remove &quot;/tmp/alice/chains/local_testnet/db&quot;? [y/N]:
y
</code></pre>
<h4 id="使用-alice-账户启动本地区块链节点"><a class="header" href="#使用-alice-账户启动本地区块链节点">使用 alice 账户启动本地区块链节点</a></h4>
<pre><code class="language-bash editable noplayground">./target/release/node-template \
--base-path /tmp/alice \
--chain local \
--alice \
--port 30333 \
--ws-port 9945 \
--rpc-port 9933 \
--node-key 0000000000000000000000000000000000000000000000000000000000000001 \
--telemetry-url &quot;wss://telemetry.polkadot.io/submit/ 0&quot; \
--validator
</code></pre>
<h3 id="回顾命令行选项"><a class="header" href="#回顾命令行选项">回顾命令行选项</a></h3>
<table><thead><tr><th style="text-align: left">选项</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>--base-path</code></td><td style="text-align: left">指定用于存储与此链相关的所有数据的目录。</td></tr>
<tr><td style="text-align: left"><code>--chain local</code></td><td style="text-align: left">指定要使用的 chain specification，有效的预定义 chain specifications 包括 <code>local</code>、<code>development</code> 和 <code>staging</code>。</td></tr>
<tr><td style="text-align: left"><code>--alice</code></td><td style="text-align: left">将 <code>alice</code> 帐户的预定义密钥添加到节点的密钥库中。通过此设置，alice 帐户用于区块生成和最终确认。</td></tr>
<tr><td style="text-align: left"><code>--port 30333</code></td><td style="text-align: left">指定要监听 peer-to-peer（<code>p2p</code>）通信的端口。由于本教程使用在同一物理计算机上运行的两个节点来模拟网络，所以你必须为至少一个帐户显式指定不同的端口。</td></tr>
<tr><td style="text-align: left"><code>--ws-port 9945</code></td><td style="text-align: left">指定要监听传入 WebSocket 流量的端口，默认端口为 <code>9944</code>，本教程使用自定义 web socket 端口号（9945）。</td></tr>
<tr><td style="text-align: left"><code>--rpc-port 9933</code></td><td style="text-align: left">指定要监听传入 RPC 通信的端口，默认端口是 <code>9933</code>。</td></tr>
<tr><td style="text-align: left"><code>--node-key &lt;key&gt;</code></td><td style="text-align: left">指定用于 <code>libp2p</code> 网络的 Ed25519 密钥，你应该在开发和测试时使用此选项。</td></tr>
<tr><td style="text-align: left"><code>--telemetry-url</code></td><td style="text-align: left">指定发送遥测数据的位置。对于本教程，你可以将遥测数据发送到由 Parity 托管的服务器，该服务器可供任何人使用。</td></tr>
<tr><td style="text-align: left"><code>--validator</code></td><td style="text-align: left">指定此节点参与网络的区块生成和最终确认。</td></tr>
</tbody></table>
<p>有关 node template 可用的命令行选项的详细信息，请通过运行以下命令查看用法帮助：
<code>./target/release/node-template --help</code></p>
<h3 id="查看显示的节点消息"><a class="header" href="#查看显示的节点消息">查看显示的节点消息</a></h3>
<p>如果节点成功启动，终端将显示描述网络操作的消息。例如，你应该看到类似的输出：</p>
<pre><code class="language-bash editable noplayground">2022-08-16 15:29:55 Substrate Node    
2022-08-16 15:29:55 ✌️  version 4.0.0-dev-de262935ede    
2022-08-16 15:29:55 ❤️  by Substrate DevHub &lt;https://github.com/substrate-developer-hub&gt;, 2017-2022    
2022-08-16 15:29:55 📋 Chain specification: Local Testnet    
2022-08-16 15:29:55 🏷  Node name: Alice    
2022-08-16 15:29:55 👤 Role: AUTHORITY    
2022-08-16 15:29:55 💾 Database: RocksDb at /tmp/alice/chains/local_testnet/db/full    
2022-08-16 15:29:55 ⛓  Native runtime: node-template-100 (node-template-1.tx1.au1)    
2022-08-16 15:29:55 🔨 Initializing Genesis block/state (state: 0x6894…033d, header-hash: 0x2cdc…a07f)    
2022-08-16 15:29:55 👴 Loading GRANDPA authority set from genesis on what appears to be first startup.    
2022-08-16 15:29:56 Using default protocol ID &quot;sup&quot; because none is configured in the chain specs    
2022-08-16 15:29:56 🏷  Local node identity is: 12D3KooWEyoppNCUx8Yx66oV9fJnriXwCcXwDDUA2kj6vnc6iDEp    
2022-08-16 15:29:56 💻 Operating system: macos    
2022-08-16 15:29:56 💻 CPU architecture: x86_64    
2022-08-16 15:29:56 📦 Highest known block at #0    
2022-08-16 15:29:56 〽️ Prometheus exporter started at 127.0.0.1:9615    
2022-08-16 15:29:56 Running JSON-RPC HTTP server: addr=127.0.0.1:9933, allowed origins=Some([&quot;http://localhost:*&quot;, &quot;http://127.0.0.1:*&quot;, &quot;https://localhost:*&quot;, &quot;https://127.0.0.1:*&quot;, &quot;https://polkadot.js.org&quot;])    
2022-08-16 15:29:56 Running JSON-RPC WS server: addr=127.0.0.1:9945, allowed origins=Some([&quot;http://localhost:*&quot;, &quot;http://127.0.0.1:*&quot;, &quot;https://localhost:*&quot;, &quot;https://127.0.0.1:*&quot;, &quot;https://polkadot.js.org&quot;])    
2022-08-16 15:29:56 creating instance on iface 192.168.1.125    
2022-08-16 15:30:01 💤 Idle (0 peers), best: #0 (0x2cdc…a07f), finalized #0 (0x2cdc…a07f), ⬇ 0 ⬆ 0
...
</code></pre>
<p><img src="https://awesomeprogram.gitee.io/imgdata/tech_bc_subpeersingle.jpg" alt="" /></p>
<p>特别是，你应该注意输出中的以下消息：</p>
<ul>
<li><code>🔨 Initializing Genesis block/state (state: 0xea47…9ba8, header-hash: 0x9d07…7cce)</code> 标识节点正在开始初始化或生成创世块，当你启动下一个节点时，请验证这些值是否相同。</li>
<li><code>🏷 Local node identity is: 12D3KooWEyoppNCUx8Yx66oV9fJnriXwCcXwDDUA2kj6vnc6iDEp</code> 指定唯一标识此节点的字符串。该字符串由 <code>--node-key</code> 确定，该键使用 <code>alice</code> 帐户启动节点。你使用此字符串来识别启动第二个节点连接到该节点的网络。</li>
<li><code>2021-03-10 17:34:37 💤 Idle (0 peers), best: #0 (0x9d07…7cce), finalized #0 (0x9d07…7cce), ⬇ 0 ⬆ 0</code> 表明网络中没有其他节点，也没有生成区块。在开始生成块之前，另一个节点必须加入网络。</li>
</ul>
<h3 id="添加第二个节点到区块链网络"><a class="header" href="#添加第二个节点到区块链网络">添加第二个节点到区块链网络</a></h3>
<p>你使用 <code>alice</code> 帐户密钥启动的节点已经运行，现在你可以使用 <code>bob</code> 帐户将另一个节点添加到该网络中。因为你正在加入一个已经运行的网络，所以可以使用正在运行节点的标识将新节点加入的网络。这些命令与你之前使用的命令类似，但有一些重要区别。</p>
<pre><code class="language-bash editable noplayground">./target/release/node-template purge-chain --base-path /tmp/bob --chain local -y
# 通过在命令中添加-y，您可以删除链数据，而无需提示您确认操作。

./target/release/node-template \
--base-path /tmp/bob \
--chain local \
--bob \
--port 30334 \
--ws-port 9946 \
--rpc-port 9934 \
--telemetry-url &quot;wss://telemetry.polkadot.io/submit/ 0&quot; \
--validator \
--bootnodes /ip4/127.0.0.1/tcp/30333/p2p/12D3KooWEyoppNCUx8Yx66oV9fJnriXwCcXwDDUA2kj6vnc6iDEp
</code></pre>
<p>注意此命令与上一个命令之间的以下差异：</p>
<ul>
<li>因为两个节点运行在同一台物理计算机上，所以你必须指定不同的值给这些选项，<code>--base-path</code>、<code>--port</code>、<code>--ws-port</code>、<code>--rpc-port</code></li>
<li>此命令包含 <code>--bootnodes</code> 选项，并且指定一个引导节点，该节点由 <code>alice</code> 启动。</li>
</ul>
<p><code>--bootnodes</code> 选项由以下信息组成：</p>
<ul>
<li><code>ip4</code> 表示节点的IP地址使用IPv4格式。</li>
<li><code>127.0.0.1</code> 为运行的节点指定 IP 地址，在本案例中，表示 <code>localhost</code> 的地址。</li>
<li><code>tcp</code> 表示将 <code>TCP</code> 指定为用于 peer-to-peer 通信的协议。</li>
<li><code>30333</code> 表示指定用于 peer-to-peer 通信的端口号，在本案例中，表示 TCP 流量的端口号。</li>
<li><code>12D3KooWEyoppNCUx8Yx66oV9fJnriXwCcXwDDUA2kj6vnc6iDEp</code> 标识要与此网路通信的运行节点，在本案例中，表示为使用 <code>alice</code> 账户启动节点的标识符。</li>
</ul>
<h3 id="验证区块是否已生成和已最终确认"><a class="header" href="#验证区块是否已生成和已最终确认">验证区块是否已生成和已最终确认</a></h3>
<p>启动第二个节点后，节点应作为对等节点相互连接，并开始生成块。</p>
<ol>
<li>确认你在启动第一个节点的终端中看到与以下类似的行：</li>
</ol>
<pre><code class="language-bash editable noplayground">2022-08-16 15:32:33 discovered: 12D3KooWBCbmQovz78Hq7MzPxdx9d1gZzXMsn6HtWj29bW51YUKB /ip4/127.0.0.1/tcp/30334
2022-08-16 15:32:33 discovered: 12D3KooWBCbmQovz78Hq7MzPxdx9d1gZzXMsn6HtWj29bW51YUKB /ip6/::1/tcp/30334
2022-08-16 15:32:36 🙌 Starting consensus session on top of parent 0x2cdce15d31548063e89e10bd201faa63c623023bbc320346b9580ed3c40fa07f
2022-08-16 15:32:36 🎁 Prepared block for proposing at 1 (5 ms) [hash: 0x9ab34110e4617454da33a3616efc394eb1ce95ee4bf0daab69aa4cb392d4104b; parent_hash: 0x2cdc…a07f; extrinsics (1): [0x4634…cebf]] 
2022-08-16 15:32:36 🔖 Pre-sealed block for proposal at 1. Hash now 0xf0869a5cb8ebd0fcc5f2bc194ced84ca782d9749604e888c8b9b515517179847, previously 0x9ab34110e4617454da33a3616efc394eb1ce95ee4bf0daab69aa4cb392d4104b.
2022-08-16 15:32:36 ✨ Imported #1 (0xf086…9847)
2022-08-16 15:32:36 💤 Idle (1 peers), best: #1 (0xf086…9847), finalized #0 (0x2cdc…a07f), ⬇ 1.0kiB/s ⬆ 1.0kiB/s
2022-08-16 15:32:41 💤 Idle (1 peers), best: #1 (0xf086…9847), finalized #0 (0x2cdc…a07f), ⬇ 0.6kiB/s ⬆ 0.6kiB/s
2022-08-16 15:32:42 ✨ Imported #2 (0x0d5e…2a7f)
2022-08-16 15:32:46 💤 Idle (1 peers), best: #2 (0x0d5e…2a7f), finalized #0 (0x2cdc…a07f), ⬇ 0.6kiB/s ⬆ 0.6kiB/s
2022-08-16 15:32:48 🙌 Starting consensus session on top of parent 0x0d5ef31979c2aa17fb88497018206d3057151119337293fe85d9526ebd1e2a7f
2022-08-16 15:32:48 🎁 Prepared block for proposing at 3 (0 ms) [hash: 0xa307c0112bce39e0dc689132452154da2079a27375b44c4d94790b46a601346a; parent_hash: 0x0d5e…2a7f; extrinsics (1): [0x63cc…39a6]]    
2022-08-16 15:32:48 🔖 Pre-sealed block for proposal at 3. Hash now 0x0c55670e745dd12892c9e7d5205085a78ccea98df393a822fa9b3865cfb3d51b, previously 0xa307c0112bce39e0dc689132452154da2079a27375b44c4d94790b46a601346a.
2022-08-16 15:32:48 ✨ Imported #3 (0x0c55…d51b)
2022-08-16 15:32:51 💤 Idle (1 peers), best: #3 (0x0c55…d51b), finalized #1 (0xf086…9847), ⬇ 0.7kiB/s ⬆ 0.9kiB/s    
...
</code></pre>
<p><img src="https://awesomeprogram.gitee.io/imgdata/tech_bc_subpeersone.jpg" alt="" /></p>
<p><img src="https://awesomeprogram.gitee.io/imgdata/tech_bc_subpeerstwo.jpg" alt="" /></p>
<p>在这些行中，你可以看到有关你的区块链的以下信息：</p>
<ul>
<li>在这个网络中发现第二个节点的标识（<code>12D3KooWBCbmQovz78Hq7MzPxdx9d1gZzXMsn6HtWj29bW51YUKB</code>）。</li>
<li>该节点有一个peer（<code>1 peers</code>）。</li>
<li>节点产生了一些块（<code>best: #3 (0x0c55…d51b)</code>）。</li>
<li>这些块被最终确认（<code>finalized #1 (0xf086…9847)</code>）。</li>
</ul>
<ol start="2">
<li>验证你在启动第二个节点的终端中看到类似的输出。</li>
<li>在终端中按下的 Control-c，关闭其中一个节点。关闭节点后，你将看到剩余节点现在没有对等节点，并且已停止生成块。例如：</li>
</ol>
<pre><code class="language-bash editable noplayground">2022-08-16 15:53:45 💤 Idle (1 peers), best: #143 (0x8f11…1684), finalized #141 (0x5fe3…5a25), ⬇ 0.8kiB/s ⬆ 0.7kiB/s
2022-08-16 15:53:50 💤 Idle (0 peers), best: #143 (0x8f11…1684), finalized #141 (0x5fe3…5a25), ⬇ 83 B/s ⬆ 83 B/s
</code></pre>
<p><img src="https://awesomeprogram.gitee.io/imgdata/tech_bc_subpeershut.jpg" alt="" /></p>
<ol start="4">
<li>通过在终端中按下 Control-c 关闭第二个节点。如果你使用 <code>--dev</code> 命令行选项在开发模式下启动节点的，则节点的所有状态都被清除。</li>
</ol>
<h2 id="添加可信任的节点"><a class="header" href="#添加可信任的节点">添加可信任的节点</a></h2>
<p>在本节教程中，你将为网络中的验证器节点生成自己的密钥。重要的是要记住，区块链网络中的每个参与者都负责生成唯一密钥。有几种方法可以生成密钥，例如，可以使用 <code>node-template</code> 子命令、独立的 <strong>subkey</strong> 命令行程序、Polkadot-JS 应用程序或者第三方密钥生成程序来生成密钥对。</p>
<p>虽然你可以使用预定义的密钥对来完成本教程，但你应该永远不会在生产环境中使用这些 key。本教程不使用预定义的密钥或更安全的 <code>subkey</code> 程序，而是演示如何使用 Substrate node template 和 <code>key</code> 子命令生成密钥。</p>
<h3 id="使用-node-template-生成本地密钥"><a class="header" href="#使用-node-template-生成本地密钥">使用 node template 生成本地密钥</a></h3>
<pre><code class="language-bash editable noplayground">./target/release/node-template key generate --scheme Sr25519 --password-interactive

</code></pre>
<p>该命令生成密钥并显示类似如下的输出：</p>
<pre><code class="language-bash editable noplayground">Secret phrase:  pig giraffe ceiling enter weird liar orange decline behind total despair fly
Secret seed:       0x0087016ebbdcf03d1b7b2ad9a958e14a43f2351cd42f2f0a973771b90fb0112f
Public key (hex):  0x1a4cc824f6585859851f818e71ac63cf6fdc81018189809814677b2a4699cf45
Account ID:        0x1a4cc824f6585859851f818e71ac63cf6fdc81018189809814677b2a4699cf45
Public key (SS58): 5CfBuoHDvZ4fd8jkLQicNL8tgjnK8pVG9AiuJrsNrRAx6CNW
SS58 Address:      5CfBuoHDvZ4fd8jkLQicNL8tgjnK8pVG9AiuJrsNrRAx6CNW
</code></pre>
<p>现在你有了 Sr25519 key，对于一个节点使用 <code>aura</code> 生成块。在本例中，帐户的 Sr25519 公钥为 <code>5CfBuoHDvZ4fd8jkLQicNL8tgjnK8pVG9AiuJrsNrRAx6CNW</code>。</p>
<p>使用刚刚生成的帐户的 <strong>secret phrase</strong>，使用 Ed25519 签名方案派生密钥。</p>
<pre><code class="language-bash editable noplayground">./target/release/node-template key inspect --password-interactive --scheme Ed25519 &quot;pig giraffe ceiling enter weird liar orange decline behind total despair fly&quot;
</code></pre>
<p>该命令显示类似于以下内容的输出：</p>
<pre><code class="language-bash editable noplayground">Secret phrase `pig giraffe ceiling enter weird liar orange decline behind total despair fly` is account:
Secret seed:       0x0087016ebbdcf03d1b7b2ad9a958e14a43f2351cd42f2f0a973771b90fb0112f
Public key (hex):  0x2577ba03f47cdbea161851d737e41200e471cd7a31a5c88242a527837efc1e7b
Public key (SS58): 5CuqCGfwqhjGzSqz5mnq36tMe651mU9Ji8xQ4JRuUTvPcjVN
Account ID:        0x2577ba03f47cdbea161851d737e41200e471cd7a31a5c88242a527837efc1e7b
SS58 Address:      5CuqCGfwqhjGzSqz5mnq36tMe651mU9Ji8xQ4JRuUTvPcjVN
</code></pre>
<p>现在你有了 Ed25519 key，对于一个节点使用 <code>grandpa</code> 最终确认块。在本例中，帐户的 Ed25519 公钥为 <code>5CuqCGfwqhjGzSqz5mnq36tMe651mU9Ji8xQ4JRuUTvPcjVN</code>。</p>
<h3 id="生成第二组密钥"><a class="header" href="#生成第二组密钥">生成第二组密钥</a></h3>
<p>对于本教程，专用网络仅包含两个节点，因此你需要两组 key。
为了便于说明，本教程中使用的第二组关键点是：</p>
<ul>
<li>Sr25519: 5EJPj83tJuJtTVE2v7B9ehfM7jNT44CBFaPWicvBwYyUKBS6 （<code>aura</code>）</li>
<li>Ed25519: 5FeJQsfmbbJLTH1pvehBxrZrT5kHvJFj84ZaY5LK7NU87gZS （<code>grandpa</code>）</li>
</ul>
<h3 id="创建自定义-chain-specification"><a class="header" href="#创建自定义-chain-specification">创建自定义 chain specification</a></h3>
<p>为了简单起见，你在本节教程中创建的自定义 chain specification 是本地 chain specification 的修改版本，说明了如何创建双节点网络。如果你有所需的密钥，可以按照相同的步骤向网络添加更多节点。</p>
<h4 id="修改本地-chain-specification"><a class="header" href="#修改本地-chain-specification">修改本地 chain specification</a></h4>
<p>你可以修改预定义的本地 chain specification，而不是编写全新的 chain specification。</p>
<p>在本地 chain specification 的基础上创建一个新的 chain specification：</p>
<pre><code class="language-bash editable noplayground">./target/release/node-template build-spec --disable-default-bootnode --chain local &gt; customSpec.json
</code></pre>
<p>如果你在文本编辑器中打开 <code>customSpec.json</code> 文件，则会看到它包含多个字段。其中一个字段是使用 <code>cargo build --release</code> 命令构建的运行时的 WebAssembly（Wasm）二进制文件。由于 WebAssembly（WASM）二进制是一个二进制大型对象（blob），因此你可以预览第一行和最后几行，以查看需要更改的字段。预览 <code>customSpec.json</code> 中的前几个字段，通过运行以下命令：
<code>head customSpec.json</code></p>
<p>该命令显示文件中的前几个字段。例如：</p>
<pre><code class="language-bash editable noplayground">{
 &quot;name&quot;: &quot;Local Testnet&quot;,
 &quot;id&quot;: &quot;local_testnet&quot;,
 &quot;chainType&quot;: &quot;Local&quot;,
 &quot;bootNodes&quot;: [],
 &quot;telemetryEndpoints&quot;: null,
 &quot;protocolId&quot;: null,
 &quot;properties&quot;: null,
 &quot;consensusEngine&quot;: null,
 &quot;codeSubstitutes&quot;: {},
</code></pre>
<p>预览 <code>customSpec.json</code> 中的最后几个字段，通过运行下面的命令
<code>tail -n 80 customSpec.json</code></p>
<p>此命令显示 Wasm 二进制字段后面的最后部分，包括运行时使用的几个 pallets（如 <code>sudo</code> 和 <code>balances</code>）的详细信息。</p>
<p>在文本编辑器中打开 <code>customSpec.json</code> 文件，修改 <code>name</code> 字段以将此  chain specification 标识为自定义  chain specification。
<code>&quot;name&quot;: &quot;My Custom Testnet&quot;,</code></p>
<p>修改 <code>aura</code> 字段，通过为每个网络参与者添加 Sr25519 SS58 地址 keys，指定有权创建块的节点。</p>
<pre><code class="language-bash editable noplayground">&quot;aura&quot;: { &quot;authorities&quot;: [
 &quot;5CfBuoHDvZ4fd8jkLQicNL8tgjnK8pVG9AiuJrsNrRAx6CNW&quot;, &quot;5CXGP4oPXC1Je3zf5wEDkYeAqGcGXyKWSRX2Jm14GdME5Xc5&quot;
 ]
},
</code></pre>
<p>修改 <code>grandpa</code> 字段，以指定节点，并通过为每个网络参与者添加 Ed25519 SS58 地址 keys 来最终确定块。</p>
<pre><code class="language-bash editable noplayground">&quot;grandpa&quot;: {
   &quot;authorities&quot;: [
     [
       &quot;5CuqCGfwqhjGzSqz5mnq36tMe651mU9Ji8xQ4JRuUTvPcjVN&quot;,
       1
     ],
     [
       &quot;5DpdMN4bVTMy67TfMMtinQTcUmLhZBWoWarHvEYPM4jYziqm&quot;,
       1
     ]
   ]
 },
</code></pre>
<p>请注意，在 <code>grandpa</code> 部分中有两个 <code>authorities</code> 字段的数据值。第一个值是地址键。第二个值用于支持 <strong>weighted votes</strong>。在本例中，每个验证者的权重为 1 票。</p>
<h4 id="添加验证者"><a class="header" href="#添加验证者">添加验证者</a></h4>
<p>如刚才看到的，你可以通过修改 <code>aura</code> 和 <code>grandpa</code> 部分在 chain specification 中添加和更改授权地址。你可以使用此技术添加任意数量的验证者。
添加验证：</p>
<ul>
<li>修改 <code>aura</code> 部分，使其包含 <strong>Sr25519</strong> 地址。</li>
<li>修改 <code>grandpa</code> 部分，使其包含 <strong>Ed25519</strong> 地址和一个投票权重。</li>
</ul>
<p>确保为每个验证者使用唯一的键，如果两个验证器有相同的键，它们就会产生冲突的块。</p>
<h3 id="转换-chain-specification-为原始格式"><a class="header" href="#转换-chain-specification-为原始格式">转换 chain specification 为原始格式</a></h3>
<p>在使用验证者信息准备 chain specification 之后，必须将其转换为 raw specification 格式，然后才能使用。raw chain specification 包含与未转换 specification 相同的信息。然而，raw chain specification 还包含编码的存储密钥，节点使用这些密钥来引用其本地存储中的数据。分配 raw chain specification 可确保每个节点使用适当的存储密钥存储数据。
将 chain specification 转换为使用原始格式：</p>
<pre><code class="language-bash editable noplayground">./target/release/node-template build-spec --chain=customSpec.json --raw --disable-default-bootnode &gt; customSpecRaw.json
</code></pre>
<h3 id="与其他人共享-chain-specification"><a class="header" href="#与其他人共享-chain-specification">与其他人共享 chain specification</a></h3>
<p>如果你正在创建私人区块链网络以与其他参与者共享，请确保只有一个人创建 chain specification 并共享该 specification 的最终原始版本，例如 <code>customSpecRaw.json</code> 文件和网络中的所有其他验证器。</p>
<p>由于 Rust 编译器生成的优化的 WebAssembly 二进制文件在确定性上不可复制，因此生成 Wasm 运行时的人都会生成一个略微不同的 Wasm blob。为了确保确定性，区块链网络中的所有参与者必须使用完全相同的 raw chain specification 文件。</p>
<h3 id="准备启动私有网络"><a class="header" href="#准备启动私有网络">准备启动私有网络</a></h3>
<p>要继续，请验证以下内容：</p>
<ul>
<li>你已为至少两个授权帐户生成或收集了帐户密钥。</li>
<li>你已经更新了自定义 chain specification，以包括块生成的 key（<code>aura</code>）和块最终确认的 key（<code>grandpa</code>）。</li>
<li>你已经将自定义 chain specification 转换为原始格式，并将原始 chain specification 分发给参与私有网络的节点。</li>
</ul>
<p>如果你完成了这些步骤，就可以启动私有区块链中的第一个节点了。</p>
<h3 id="开始第一个节点"><a class="header" href="#开始第一个节点">开始第一个节点</a></h3>
<p>作为私有区块链网络的第一个参与者，你负责启动第一个节点，被称为 <strong>bootnode</strong>。
通过运行与以下类似的命令，使用自定义 chain specification 启动第一个节点：</p>
<pre><code class="language-bash editable noplayground">./target/release/node-template \
  --base-path /tmp/node01 \
  --chain ./customSpecRaw.json \
  --port 30333 \
  --ws-port 9945 \
  --rpc-port 9933 \
  --telemetry-url &quot;wss://telemetry.polkadot.io/submit/ 0&quot; \
  --validator \
  --rpc-methods Unsafe \
  --name MyNode01 \
  --password-interactive
</code></pre>
<p>注意以下命令行选项启动节点：</p>
<ul>
<li><code>--base path</code> 命令行选项指定与第一个节点关联链的自定义位置。</li>
<li><code>--chain</code> 命令行选项指定自定义 chain specification。</li>
<li><code>--validator</code> 命令行选项指示此节点已经被链授权。</li>
<li><code>--rpc-methods Unsafe</code> 命令行选项允许你使用不安全的通信模式，在本教程继续这样用，因为你的区块链未在生产设置中使用。</li>
<li><code>--name</code> 命令行选项使你能够在遥测 UI 中为节点提供一个方便阅读的名称。</li>
</ul>
<p>此命令还使用自己的 keys 而不是预定义的帐户启动节点。由于你没有使用已知 keys 的预定义帐户，因此你需要在单独的步骤中将 keys 添加到密钥库中。</p>
<h3 id="查看有关节点操作的信息"><a class="header" href="#查看有关节点操作的信息">查看有关节点操作的信息</a></h3>
<p>启动本地节点后，有关所执行操作的信息将显示在终端外壳中。在该终端中，验证看到的输出与以下类似：</p>
<pre><code class="language-bash editable noplayground">2021-11-03 15:32:14 Substrate Node
2021-11-03 15:32:14 ✌️  version 3.0.0-monthly-2021-09+1-bf52814-x86_64-macos
2021-11-03 15:32:14 ❤️  by Substrate DevHub &lt;https://github.com/substrate-developer-hub&gt;, 2017-2021
2021-11-03 15:32:14 📋 Chain specification: My Custom Testnet
2021-11-03 15:32:14 🏷 Node name: MyNode01
2021-11-03 15:32:14 👤 Role: AUTHORITY
2021-11-03 15:32:14 💾 Database: RocksDb at /tmp/node01/chains/local_testnet/db
2021-11-03 15:32:14 ⛓  Native runtime: node-template-100 (node-template-1.tx1.au1)
2021-11-03 15:32:15 🔨 Initializing Genesis block/state (state: 0x2bde…8f66, header-hash: 0x6c78…37de)
2021-11-03 15:32:15 👴 Loading GRANDPA authority set from genesis on what appears to be first startup.
2021-11-03 15:32:15 ⏱  Loaded block-time = 6s from block 0x6c78abc724f83285d1487ddcb1f948a2773cb38219c4674f84c727833be737de
2021-11-03 15:32:15 Using default protocol ID &quot;sup&quot; because none is configured in the chain specs
2021-11-03 15:32:15 🏷 Local node identity is: 12D3KooWLmrYDLoNTyTYtRdDyZLWDe1paxzxTw5RgjmHLfzW96SX
2021-11-03 15:32:15 📦 Highest known block at #0
2021-11-03 15:32:15 〽️ Prometheus exporter started at 127.0.0.1:9615
2021-11-03 15:32:15 Listening for new connections on 127.0.0.1:9945.
2021-11-03 15:32:20 💤 Idle (0 peers), best: #0 (0x6c78…37de), finalized #0 (0x6c78…37de), ⬇ 0 ⬆ 0
</code></pre>
<p>注意以下信息：</p>
<ul>
<li>输出表明所使用的 chain specification 是你使用 <code>--chain</code> 命令行选项创建和指定的自定义 chain specification。</li>
<li>输出表明该节点是有授权的，因为你使用 <code>--validator</code> 命令行选项启动了该节点。</li>
<li>输出显示了使用块哈希初始化的 <strong>创世块</strong><code>(state: 0x2bde…8f66, header-hash: 0x6c78…37de)</code>。</li>
<li>输出指定了节点的 <strong>本地节点标识</strong>，在本例中，节点标识为 <code>12D3KooWLmrYDLoNTyTYtRdDyZLWDe1paxzxTw5RgjmHLfzW96SX</code>。</li>
<li>输出指定用于节点的 IP 地址是本地主机 <code>127.0.0.1</code>。</li>
</ul>
<p>这些值用于本节教程示例中你的节点，你必须将节点的值提供给其他网络参与者以连接到 bootnode。现在你已经使用自己的密钥成功启动了一个验证器节点，并看到了节点标识，你可以继续下一步。但是，在将密钥添加到密钥库之前，请按 Control-c 停止该节点。</p>
<h3 id="将-key-添加到密钥库"><a class="header" href="#将-key-添加到密钥库">将 key 添加到密钥库</a></h3>
<p>启动第一个节点后，尚未生成任何块。下一步是为网络中的每个节点向密钥库添加两种类型的 key。
对于每个节点：</p>
<ul>
<li>添加 <code>aura</code> 授权 keys 以启用区块的生成。</li>
<li>添加 <code>grandpa</code> 授权 keys 以启用区块的最终确认。</li>
</ul>
<p>有几种方法可以将 key 插入密钥库。对于本节教程，你可以使用 <code>key</code> 子命令插入本地生成的 key。</p>
<p>通过运行与以下类似的命令，插入从 <code>key</code> 子命令生成的 <code>aura</code> 密钥（key）：</p>
<pre><code class="language-bash editable noplayground">./target/release/node-template key insert --base-path /tmp/node01 \
  --chain customSpecRaw.json \
  --scheme Sr25519 \
  --suri &lt;your-secret-seed&gt; \
  --password-interactive \
  --key-type aura
</code></pre>
<p>使用 secret phrase 或者 secret seed 替换 <code>&lt;your-secret-seed&gt;</code> ，在之前 <a href="blockchain/chapter_1_2_1_3.html#%E4%BD%BF%E7%94%A8-node-template-%E7%94%9F%E6%88%90%E6%9C%AC%E5%9C%B0%E5%AF%86%E9%92%A5"><strong>使用 node template 生成本地密钥</strong></a> 的部分查找相关的第一个密钥对。</p>
<p>在本节教程中，secret phrase 是 <code>pig giraffe ceiling enter weird liar orange decline behind total despair fly</code>，因此 <code>--suri</code> 命令行选项使用这段字符串将 key 插入密钥库。
<code>--suri &quot;pig giraffe ceiling enter weird liar orange decline behind total despair fly&quot;</code></p>
<p>你也可以从指定的文件位置插入 key，有关可用命令行选项的信息，请运行以下命令：
<code>./target/release/node-template key insert --help</code></p>
<p>输入生成密钥的密码。</p>
<p>通过运行与以下类似的命令，插入从 key 子命令生成的 <code>grandpa</code> 密钥（key）：</p>
<pre><code class="language-bash editable noplayground">./target/release/node-template key insert \
  --base-path /tmp/node01 \
  --chain customSpecRaw.json \
  --scheme Ed25519 \
  --suri &lt;your-secret-key&gt; \
  --password-interactive \
  --key-type gran
</code></pre>
<p>使用 secret phrase 或者 secret seed 替换 <code>&lt;your-secret-seed&gt;</code> ，在之前 <a href="blockchain/chapter_1_2_1_3.html#%E4%BD%BF%E7%94%A8-node-template-%E7%94%9F%E6%88%90%E6%9C%AC%E5%9C%B0%E5%AF%86%E9%92%A5"><strong>使用 node template 生成本地密钥</strong></a> 的部分查找相关的第一个密钥对。</p>
<p>在本节教程中，secret phrase 是 <code>pig giraffe ceiling enter weird liar orange decline behind total despair fly</code>，因此 <code>--suri</code> 命令行选项使用这段字符串将 key 插入密钥库。
<code>--suri &quot;pig giraffe ceiling enter weird liar orange decline behind total despair fly&quot;</code></p>
<p>输入生成密钥的密码。</p>
<p>通过运行以下命令验证你的密钥（key）是否位于 <code>node01</code> 的密钥库中：</p>
<pre><code class="language-bash editable noplayground">ls /tmp/node01/chains/local_testnet/keystore
</code></pre>
<p>该命令显示类似于以下的输出：</p>
<pre><code class="language-bash editable noplayground">617572611441ddcb22724420b87ee295c6d47c5adff0ce598c87d3c749b776ba9a647f04
6772616e1441ddcb22724420b87ee295c6d47c5adff0ce598c87d3c749b776ba9a647f04
</code></pre>
<p>在 /tmp/node01 下的第一个节点的密钥库中添加了 keys 后，你可以使用先前在 <a href="blockchain/chapter_1_2_1_3.html#%E5%BC%80%E5%A7%8B%E7%AC%AC%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9">开始第一个节点</a> 中使用的命令重新启动节点。</p>
<h3 id="开启允许其他参与者加入"><a class="header" href="#开启允许其他参与者加入">开启允许其他参与者加入</a></h3>
<p>现在可以使用 <code>--bootnodes</code> 和 <code>--validator</code> 命令行选项允许其他验证者加入网络。</p>
<p>向私有网络添加第二个验证者区块链节点：</p>
<pre><code class="language-bash editable noplayground">./target/release/node-template \
  --base-path /tmp/node02 \
  --chain ./customSpecRaw.json \
  --port 30334 \
  --ws-port 9946 \
  --rpc-port 9934 \
  --telemetry-url &quot;wss://telemetry.polkadot.io/submit/ 0&quot; \
  --validator \
  --rpc-methods Unsafe \
  --name MyNode02 \
  --bootnodes /ip4/127.0.0.1/tcp/30333/p2p/12D3KooWLmrYDLoNTyTYtRdDyZLWDe1paxzxTw5RgjmHLfzW96SX \
  --password-interactive
</code></pre>
<p>此命令使用 <code>base-path</code>、<code>name</code> 和 <code>validator</code> 命令行选项将此节点标识为专用网络的第二个验证者。<code>--chain</code> 命令行选项指定要使用的 chain specification 文件，对于网络中的所有验证者，此文件必须完全相同。确保为 <code>--bootnodes</code> 命令行选项设置了正确的信息。特别是，请确保已从网络中的第一个节点指定了本地节点标识符。如果未设置正确的 <code>bootnode</code> 标识符，则会看到如下错误：
<code>The bootnode you want to connect to at ... provided a different peer ID than the one you expect: ... </code></p>
<p>通过运行与以下类似的命令，插入从 key 子命令生成的 <code>aura</code> 密钥（key）：</p>
<pre><code class="language-bash editable noplayground">./target/release/node-template key insert --base-path /tmp/node02 \
  --chain customSpecRaw.json \
  --scheme Sr25519 \
  --suri &lt;second-participant-secret-seed&gt; \
  --password-interactive \
  --key-type aura
</code></pre>
<p>使用 secret phrase 或者 secret seed 替换 <code>&lt;second-participant-secret-seed&gt;</code> ，在之前 <a href="blockchain/chapter_1_2_1_3.html#%E7%94%9F%E6%88%90%E7%AC%AC%E4%BA%8C%E7%BB%84%E5%AF%86%E9%92%A5"><strong>生成第二组密钥</strong></a> 的部分查找相关的第二个密钥对。只有 <code>--key-type</code> 的值是 <code>aura</code> 才能开启区块生成功能。</p>
<p>输入生成密钥的密码。</p>
<p>通过运行与以下类似的命令，插入从 key 子命令生成的 <code>grandpa</code> 密钥（key）：</p>
<pre><code class="language-bash editable noplayground">./target/release/node-template key insert --base-path /tmp/node02 \
  --chain customSpecRaw.json \
  --scheme Ed25519 --suri &lt;second-participant-secret-seed&gt; \
  --password-interactive \
  --key-type gran
</code></pre>
<p>使用 secret phrase 或者 secret seed 替换 <code>&lt;second-participant-secret-seed&gt;</code> ，在之前 <a href="blockchain/chapter_1_2_1_3.html#%E7%94%9F%E6%88%90%E7%AC%AC%E4%BA%8C%E7%BB%84%E5%AF%86%E9%92%A5"><strong>生成第二组密钥</strong></a> 的部分查找相关的第二个密钥对。只有 <code>--key-type</code> 的值是 <code>gran</code> 才能开启区块最终确认功能。</p>
<p>块终结需要至少三分之二的验证者将其密钥添加到各自的密钥库中。由于此网络在 chain specification 中配置了两个验证器，因此只有在第二个节点添加了其密钥后，才能开启块最终确认。</p>
<p>输入生成密钥的密码。</p>
<p>通过运行以下命令验证你的密钥（key）是否位于 <code>node02</code> 的密钥库中：
<code>ls /tmp/node02/chains/local_testnet/keystore</code></p>
<p>该命令显示类似于以下的输出：</p>
<pre><code class="language-bash editable noplayground">617572611a4cc824f6585859851f818e71ac63cf6fdc81018189809814677b2a4699cf45
6772616e1a4cc824f6585859851f818e71ac63cf6fdc81018189809814677b2a4699cf45
</code></pre>
<p>Substrate nodes 在插入 <code>grandpa</code> 密钥之后需要重新启动，因此，你必须关闭并重新启动节点，然后才能看到正在完成的块。按 Control-c 关闭节点。</p>
<p>通过运行以下命令重新启动第二个区块链节点：</p>
<pre><code class="language-bash editable noplayground">./target/release/node-template \
  --base-path /tmp/node02 \
  --chain ./customSpecRaw.json \
  --port 30334 \
  --ws-port 9946 \
  --rpc-port 9934 \
  --telemetry-url 'wss://telemetry.polkadot.io/submit/ 0' \
  --validator \
  --rpc-methods Unsafe \
  --name MyNode02 \
  --bootnodes /ip4/127.0.0.1/tcp/30333/p2p/12D3KooWLmrYDLoNTyTYtRdDyZLWDe1paxzxTw5RgjmHLfzW96SX \
  --password-interactive
</code></pre>
<p>在两个节点将其密钥 key 添加到位于 /tmp/node01 和 /tmp/node02 下的各自密钥库并重新启动后，你应该看到相同的 genesis 块和状态根哈希。你还应该看到，每个节点都有一个 peer（<code>1 peers</code>），并且它们生成了一个块 proposal （<code>best: #2 (0xe111…c084)</code>）。几秒钟后，你将看到两个节点上的新块都已最终确认。</p>
<p><img src="https://awesomeprogram.gitee.io/imgdata/tech_bc_subtrust1.jpg" alt="" /></p>
<p><img src="https://awesomeprogram.gitee.io/imgdata/tech_bc_subtrust2.jpg" alt="" /></p>
<h2 id="授权特定节点"><a class="header" href="#授权特定节点">授权特定节点</a></h2>
<p>本节教程演示了许可网络的简化版本。在许可网络中，仅允许授权节点执行特定的网络活动。例如，你可以授予某些节点验证块的权限，而授予其他节点传播交易的权限。具有被授予特定权限的节点的区块链不同于公共或无许可的区块链。在无许可的区块链中，任何人都可以通过在合适的硬件上运行节点软件来加入网络。一般而言，无许可区块链提供了更大的网络去中心化。然而，在某些用例中，创建许可的区块链可能是合适的。例如，许可区块链适用于以下类型的项目：</p>
<ul>
<li>用于私人或联盟网络，例如私人企业或非营利组织。</li>
<li>在高度监管的数据环境中，如医疗保健、金融或企业对企业之间的联盟。</li>
<li>用于大规模测试预公开区块链网络。</li>
</ul>
<p>本节教程说明如何通过 <a href="https://paritytech.github.io/substrate/master/pallet_node_authorization/index.html">node authorization pallet</a> 使用 Substrate 构建一个许可网络。</p>
<h3 id="节点授权和所有权"><a class="header" href="#节点授权和所有权">节点授权和所有权</a></h3>
<p><code>node-authorization</code> pallet 是一个预先构建的 FRAME pallet，使你能够管理网络的一组可配置节点。每个节点由一个 <code>PeerId</code> 标识，每个 <code>PeerId</code> 由一个且仅一个声明节点的 <code>AccountId</code> 拥有。有两种方式可以授权节点加入网络：</p>
<ul>
<li>通过将 <code>PeerId</code> 添加到预定义节点的列表中，你必须获得网络中的 governance pallet 或 sudo pallet 的核准才能执行此操作。</li>
<li>通过请求来自特定节点 paired peer 连接，该节点可以是预定义的节点 <code>PeerId</code>，也可以是普通节点。</li>
</ul>
<p>请注意，任何用户都可以声称是 <code>PeerId</code> 的所有者，为了防止错误声明，应在启动节点之前声明节点。在你启动节点后，它的 <code>PeerID</code> 对网络是可见的，任何人随后都可以声明它。</p>
<p>作为节点的所有者，你可以添加和删除节点的连接。例如，你可以操纵预定义节点与你的节点之间的连接，或者操纵你的节点与其他非预定义节点之间的关系。你不能更改预定义节点的连接，因为他们总是被允许互相连接。</p>
<p><code>node-authorization</code> pallet 使用一个链下工作机配置其节点连接。请确保在启动节点时已经启用了链外工作机，因为对于非授权节点，它在默认情况下是禁用的。</p>
<h3 id="构建节点模板"><a class="header" href="#构建节点模板">构建节点模板</a></h3>
<pre><code class="language-bash editable noplayground">cd substrate-node-template
git checkout polkadot-v0.9.26
cargo build --release
</code></pre>
<h3 id="添加节点授权pallet"><a class="header" href="#添加节点授权pallet">添加节点授权pallet</a></h3>
<p>由于 Substrate 运行时编译为包含标准库函数的原生 Rust 二进制文件和不包含标准库的 WebAssembly（Wasm）二进制文件，因此Cargo.toml 文件控制两条重要信息：</p>
<ul>
<li>将 pallets 作为运行时的依赖项导入，包括要导入的 pallets 的位置和版本。</li>
<li>编译原生 Rust 二进制文件时应启用每个 pallet 中的功能。通过从每个 pallet 启用标准库（<code>std</code>）的特性，你可以编译运行时以包含函数、类型和原语，否则在构建 WebAssembly 二进制文件时会丢失这些函数、类型和原语。</li>
</ul>
<p>有关在 <code>Cargo.toml</code> 文件中添加依赖项的一些信息，可参见 Cargo 文档中的<a href="https://doc.rust-lang.org/cargo/guide/dependencies.html"><strong>依赖</strong></a>。有关启用和管理依赖包的功能的信息，可参见 Cargo 文档中的<a href="https://doc.rust-lang.org/cargo/reference/features.html"><strong>特性</strong></a>。</p>
<h4 id="添加节点授权的依赖"><a class="header" href="#添加节点授权的依赖">添加节点授权的依赖</a></h4>
<p>在 <code>[dependencies]</code> 部分添加 <code>pallet-node-authorization</code> crate，使其用于 node template 运行时：</p>
<pre><code class="language-bash editable noplayground">[dependencies]
pallet-node-authorization = { default-features = false, version = &quot;4.0.0-dev&quot;, git = &quot;https://github.com/paritytech/substrate.git&quot;, branch = &quot;polkadot-v0.9.26&quot; }
</code></pre>
<p>该行 <code>pallet-node-authorization</code> crate 作为依赖导入，并且为该 crate 指定以下配置细节：</p>
<ul>
<li>当编译运行时，默认情况下不启用 pallet 特性。</li>
<li>检索 <code>pallet-node-authorization</code> crate 的存储库位置。</li>
<li>用于检索 crate 的 commit tag。</li>
<li>crate 的版本标识符。</li>
</ul>
<p>将 <code>pallet-node-authorization/std</code> 特性添加到 <code>features</code> 列表中，以便在编译运行时启用。</p>
<pre><code class="language-bash editable noplayground">[features]
default = ['std']
std = [
 ...
 &quot;pallet-node-authorization/std&quot;,    # add this line
 ...
]
</code></pre>
<p>如果你忘记更新 <code>Cargo.toml</code> 文件中的 <code>features</code> 部分，在编译运行时二进制文件时，你可能会看到 <code>cannot find function</code> 错误。</p>
<p>通过运行以下命令，检查新依赖项是否正确解析：</p>
<pre><code class="language-bash editable noplayground">cargo check -p node-template-runtime
</code></pre>
<h4 id="添加管理规则"><a class="header" href="#添加管理规则">添加管理规则</a></h4>
<p>为了在本节教程中模拟治理，你可以配置 pallet 使用 <code>EnsureRoot</code> 特权函数，然后就能被 Sudo pallet 调用 。默认情况下，Sudo pallet 包含在节点模板中，使你能够通过 root-level 管理帐户进行调用。在生产环境中，你将使用更接近现实的基于治理的方式去检查。</p>
<p>要在运行时启用 <code>EnsureRoot </code> 规则，需要在 <code>runtime/src/lib.rs</code> 文件中添加下面这一行：</p>
<pre><code class="language-bash editable noplayground">use frame_system::EnsureRoot;
</code></pre>
<h3 id="为pallet实现config-trait"><a class="header" href="#为pallet实现config-trait">为pallet实现Config trait</a></h3>
<p>每个 pallet 都有一个称为 <code>Config</code> 的 <strong>Rust trait</strong>，<code>Config</code> trait 用于识别 pallet 所需的参数和类型。添加一个 pallet 所需的大多数 pallet-specific 代码都是使用 <code>Config</code> trait 实现的。例如，查看你需要在 node-authorization pallet 中实现 <code>Config</code> trait，你可以参考 <a href="https://paritytech.github.io/substrate/master/pallet_node_authorization/pallet/trait.Config.html"><code>pallet_node_authorization::Config</code></a> 的 Rust 文档。</p>
<p>要在你的运行时实现 <code>node-authorization</code> pallet ，打开 <code>runtime/src/lib.rs</code> 文件：</p>
<ul>
<li>为 pallet 在 <code>parameter_types</code> 部分添加以下代码：</li>
</ul>
<pre><code class="language-rust editable noplayground">parameter_types! {
 pub const MaxWellKnownNodes: u32 = 8;
 pub const MaxPeerIdLength: u32 = 128;
}
</code></pre>
<ul>
<li>使用以下代码为 pallet 的 <code>Config</code> trait 添加 <code>impl</code> 部分</li>
</ul>
<pre><code class="language-rust editable noplayground">impl pallet_node_authorization::Config for Runtime {
 type Event = Event;
 type MaxWellKnownNodes = MaxWellKnownNodes;
 type MaxPeerIdLength = MaxPeerIdLength;
 type AddOrigin = EnsureRoot&lt;AccountId&gt;;
 type RemoveOrigin = EnsureRoot&lt;AccountId&gt;;
 type SwapOrigin = EnsureRoot&lt;AccountId&gt;;
 type ResetOrigin = EnsureRoot&lt;AccountId&gt;;
 type WeightInfo = ();
}
</code></pre>
<ul>
<li>使用以下代码行将 pallet 添加到 <code>construct_runtime</code> 宏：</li>
</ul>
<pre><code class="language-bash editable noplayground">construct_runtime!(
pub enum Runtime where
   Block = Block,
   NodeBlock = opaque::Block,
   UncheckedExtrinsic = UncheckedExtrinsic
 {
   /*** Add This Line ***/
   NodeAuthorization: pallet_node_authorization::{Pallet, Call, Storage, Event&lt;T&gt;, Config&lt;T&gt;},
 }
);
</code></pre>
<ul>
<li>
<p>保存代码并关闭文件。</p>
</li>
<li>
<p>通过运行以下命令检查配置是否可以编译：</p>
</li>
</ul>
<pre><code class="language-bash editable noplayground">cargo check -p node-template-runtime
</code></pre>
<h4 id="为授权节点添加创世纪存储"><a class="header" href="#为授权节点添加创世纪存储">为授权节点添加创世纪存储</a></h4>
<p>在启动网络以使用节点授权之前，需要一些额外的配置来处理 peer 标识符和 account 标识符。例如，<code>PeerId</code> 以 bs58 的格式编码，因此你需要在 <code>node/Cargo.toml</code> 中为 bs58 库添加一个新的依赖项对 <code>PeerId</code> 进行解码以获取它的字节。为了简化操作，授权节点与预定义帐户相关联。</p>
<p>要为授权节点配置 genesis 存储，打开 <code>node/Cargo.toml</code> 文件，在 [dependencies] 部分为 node template 添加 <code>bs58</code> 库：</p>
<pre><code class="language-bash editable noplayground">[dependencies]
bs58 = &quot;0.4.0&quot;
</code></pre>
<p>保存代码并关闭文件。</p>
<p>在编辑器中打开 <code>node/src/chain_spec.rs</code> 文件，使用以下代码为授权加入网络的节点添加 genesis 存储：</p>
<pre><code class="language-bash editable noplayground">use sp_core::OpaquePeerId; // A struct wraps Vec&lt;u8&gt;, represents as our `PeerId`.
use node_template_runtime::NodeAuthorizationConfig; // The genesis config that serves for our pallet.
</code></pre>
<p>为 FRAME 模块配置初始存储状态的 <code>testnet_genesis</code> 函数：</p>
<pre><code class="language-bash editable noplayground">/// Configure initial storage state for FRAME modules.
fn testnet_genesis(
 wasm_binary: &amp;[u8],
 initial_authorities: Vec&lt;(AuraId, GrandpaId)&gt;,
 root_key: AccountId,
 endowed_accounts: Vec&lt;AccountId&gt;,
 _enable_println: bool,
 ) -&gt; GenesisConfig {
</code></pre>
<p>在 <code>GenesisConfig</code> 声明中，添加以下代码块：</p>
<pre><code class="language-rust editable noplayground"> node_authorization: NodeAuthorizationConfig {
   nodes: vec![
     (
       OpaquePeerId(bs58::decode(&quot;12D3KooWBmAwcd4PJNJvfV89HwE48nwkRmAgo8Vy3uQEyNNHBox2&quot;).into_vec().unwrap()),
       endowed_accounts[0].clone()
     ),
     (
       OpaquePeerId(bs58::decode(&quot;12D3KooWQYV9dGMFoRzNStwpXztXaBUjtPqi6aU76ZgUriHhKust&quot;).into_vec().unwrap()),
       endowed_accounts[1].clone()
     ),
   ],
 },
</code></pre>
<p>在这部分代码中，<code>NodeAuthorizationConfig</code> 包含一个 <code>nodes</code> 属性，代表一个拥有两个元素 tuple 的 vector。元组中第一个元素是 <code>OpaquePeerId</code>，<code>bs58::decode</code> 操作转化为方便 human-readable <code>PeerId</code>，如，<code>12D3KooWBmAwcd4PJNJvfV89HwE48nwkRmAgo8Vy3uQEyNNHBox2</code> 到字节。元组中第二个元素是 <code>AccountId</code>，代表此节点的所有者，该示例使用预定义的 Alice 和 Bob，此处标识为 endowed 的帐户 [0] 和 [1]。</p>
<p>保存代码并关闭文件。</p>
<h4 id="验证节点是否可编译"><a class="header" href="#验证节点是否可编译">验证节点是否可编译</a></h4>
<p>现在已经完成了代码更改，可以验证节点是否可编译。</p>
<pre><code class="language-bash editable noplayground">cargo build --release
</code></pre>
<p>如果没有语法错误，则可以继续。如果存在错误，请按照编译输出中的说明进行修复，然后重新运行 <code>cargo build</code> 命令。</p>
<h3 id="启动许可网络"><a class="header" href="#启动许可网络">启动许可网络</a></h3>
<p>你现在可以使用预定义帐户的节点密钥和对等标识符来启动许可网络并授权其他节点加入。在本节教程，你将启动四个节点。其中三个节点与预定义的帐户相关联，所有三个节点都允许生成和验证块。第四节点是一个子节点，仅有权在指定节点所有者的批准下从该节点读取数据。</p>
<h4 id="获取节点-keys-和-peerids"><a class="header" href="#获取节点-keys-和-peerids">获取节点 keys 和 peerIDs</a></h4>
<p>你已经在 genesis 存储中配置了与 Alice 和 Bob 帐户关联的节点。你可以使用 subkey 程序检查与预定义帐户关联的密钥，并生成和检查你自己的密钥。然而，如果你运行 <code>subkey generate-node-key</code> 命令，那么你的节点 key 和 peer 标识符是随机生成的，与本节教程中使用的 key 并不匹配。由于本节教程使用预定义的帐户和 well-known node keys，下表总结了每个帐户的 key。
|账户|与账户关联的 Keys|
|:-----|:-----|
|Alice|Node key: c12b6d18942f5ee8528c8e2baf4e147b5c5c18710926ea492d09cbd9f6c9f82a|
||PeerID (generated from the node key): 12D3KooWBmAwcd4PJNJvfV89HwE48nwkRmAgo8Vy3uQEyNNHBox2|
||Decoded PeerID in hex: 0024080112201ce5f00ef6e89374afb625f1ae4c1546d31234e87e3c3f51a62b91dd6bfa57df|
|Bob|Node key: 6ce3be907dbcabf20a9a5a60a712b4256a54196000a8ed4050d352bc113f8c58
|
||PeerID (generated from the node key): 12D3KooWQYV9dGMFoRzNStwpXztXaBUjtPqi6aU76ZgUriHhKust|
||Decoded PeerID in hex: 002408011220dacde7714d8551f674b8bb4b54239383c76a2b286fa436e93b2b7eb226bf4de7|</p>
<p>另外两个开发帐户 Charlie 和 Dave 没有 well-known node keys 或 peer 标识符。出于演示目的，我们将使用以下的 keys：
|账户|与账户关联的 Keys|
|:-----|:-----|
|Charlie|Node key: 3a9d5b35b9fb4c42aafadeca046f6bf56107bd2579687f069b42646684b94d9e|
||PeerID (generated from the node key): 12D3KooWJvyP3VJYymTqG7eH4PM5rN4T2agk5cdNCfNymAqwqcvZ|
||Decoded PeerID in hex: 002408011220876a7b4984f98006dc8d666e28b60de307309835d775e7755cc770328cdacf2e|
|Dave|Node key: a99331ff4f0e0a0434a6263da0a5823ea3afcfffe590c9f3014e6cf620f2b19a|
||PeerID (generated from the node key): 12D3KooWPHWFrfaJzxPnqnAYAoRUyAHHKqACmEycGTVmeVhQYuZN|
||Decoded PeerID in hex: 002408011220c81bc1d7057a1511eb9496f056f6f53cdfe0e14c8bd5ffca47c70a8d76c1326d|</p>
<h4 id="启动第一个节点"><a class="header" href="#启动第一个节点">启动第一个节点</a></h4>
<pre><code class="language-bash editable noplayground">./target/release/node-template \
--chain=local \
--base-path /tmp/validator1 \
--alice \
--node-key=c12b6d18942f5ee8528c8e2baf4e147b5c5c18710926ea492d09cbd9f6c9f82a \
--port 30333 \
--ws-port 9944
</code></pre>
<p>在这个命令中，使用 <code>--node-key</code> 选项指定用于安全连接到网络的 key。该 key 还用于内部生成 human-readable PeerId，如上部分所示。<code>--alice</code> 将节点命名为 alice，并使节点成为可以生成块和完成块的验证者，是 <code>--name alice --validator</code> 的简写。</p>
<h4 id="启动第二个节点"><a class="header" href="#启动第二个节点">启动第二个节点</a></h4>
<pre><code class="language-bash editable noplayground">./target/release/node-template \
--chain=local \
--base-path /tmp/validator2 \
--bob \
--node-key=6ce3be907dbcabf20a9a5a60a712b4256a54196000a8ed4050d352bc113f8c58 \
--port 30334 \
--ws-port 9945
</code></pre>
<p>两个节点启动后，你应该能够在两个终端日志中看到生成和完成的新块。</p>
<h4 id="添加第三个节点到已知节点列表中"><a class="header" href="#添加第三个节点到已知节点列表中">添加第三个节点到已知节点列表中</a></h4>
<p><code>node-authorization</code> pallet 使用链下工作机来配置节点连接。因为第三个节点不是一个 well-known 节点并且它将网络中的第四个节点配置为 read-only sub-node，因此你必须以命令行选项以启动链下工作机。</p>
<pre><code class="language-bash editable noplayground">./target/release/node-template \
--chain=local \
--base-path /tmp/validator3 \
--name charlie  \
--node-key=3a9d5b35b9fb4c42aafadeca046f6bf56107bd2579687f069b42646684b94d9e \
--port 30335 \
--ws-port=9946 \
--offchain-worker always
</code></pre>
<p>启动此节点后，你应该会看到该节点没有连接的 peers。由于这是一个许可网络，因此必须明确授权节点进行连接。Alice 和 Bob 节点被配置在创世纪 <code>chain_spec.rs</code> 的文件中。所有其它节点都必须通过 Sudo pallet 的调用来手动添加。 </p>
<h4 id="授权对第三节点的访问"><a class="header" href="#授权对第三节点的访问">授权对第三节点的访问</a></h4>
<p>本节教程使用 sudo pallet 进行治理。因此，你可以使用 <code>sudo</code> pallet 调用 <code>node-authorization</code> pallet 提供的 <code>add_well_known_node</code> 函数来添加第三个节点。
切换到 <strong>Developer</strong> 页面，<strong>Sudo</strong> 标签，在应用程序中，提交 <code>nodeAuthorization</code> - <code>add_well_known_node</code> 调用，peer id为 Charlie 节点的十六进制，所有者为 Charlie。</p>
<p><img src="https://awesomeprogram.gitee.io/imgdata/tech_bc_subaddwekno.jpg" alt="" /></p>
<p>在事务被包括在块中之后，你应该可以看到 charlie 节点被连接到 alice 和 bob 节点，并开始同步块。这三个节点可以使用本地网络中默认启用的 <a href="https://paritytech.github.io/substrate/master/sc_network/index.html">mDNS</a> 发现机制找到彼此。</p>
<p>如果你的节点不在同一个本地网络上，你应该使用命令行选项 <code>--no-mdns</code> 来禁用它。</p>
<h4 id="添加一个子节点"><a class="header" href="#添加一个子节点">添加一个子节点</a></h4>
<p>该网络中的第四节点不是 well-known 的节点。这个节点的所有者是用户 <code>dave</code>，但它是 <code>charlie</code> 的 sub-node。子节点只能通过连接到 <code>charlie</code> 拥有的节点来访问网络。父节点负责任何子节点的授权连接，并在需要删除或审计该子节点时控制访问。</p>
<pre><code class="language-bash editable noplayground">./target/release/node-template \
--chain=local \
--base-path /tmp/validator4 \
--name dave \
--node-key=a99331ff4f0e0a0434a6263da0a5823ea3afcfffe590c9f3014e6cf620f2b19a \
--port 30336 \
--ws-port 9947 \
--offchain-worker always
</code></pre>
<p>启动后，没有可用的连接。这是一个许可网络，因此首先，Charlie 需要配置他的节点以允许从 Dave 的节点进行连接。
切换到 <strong>Developer Extrinsics</strong> 页面，让 Charlie 去提交一个 <code>addConnections</code> extrinsic。第一个 PeerId 是 Charlie 所在节点的十六进制 peer id。连接是 Charlie 节点允许的 peer ids 列表，这里我们只添加 Dave 的。</p>
<p><img src="https://awesomeprogram.gitee.io/imgdata/tech_bc_subchaddconn.jpg" alt="" /></p>
<p>然后，Dave 需要配置他的节点以允许从 Charlie 的节点进行连接。但在他添加这一点之前，Dave 需要声明他的节点，证明这个节点的所有权。</p>
<p><img src="https://awesomeprogram.gitee.io/imgdata/tech_bc_subdavclano.jpg" alt="" /></p>
<p>类似地，Dave 可以从 Charlie 的节点添加连接。</p>
<p><img src="https://awesomeprogram.gitee.io/imgdata/tech_bc_subdavaddconn.jpg" alt="" /></p>
<p>你现在应该看到 Dave 正在捕获 blocks，且只有一个属于 Charlie 的同伴！重新启动 Dave 的节点，以防它无法立即与 Charlie 连接。</p>
<p>任何节点都可以发布影响其他节点行为的 extrinsics，只要它是用作引用链上的数据，并且你在密钥存储库中拥有可用于所需来源的相关帐户的 singing key。本演示中的所有节点都可以访问开发人员的 singing key，因此我们能够代表 charlie 从网络上的任何连接节点发出影响 charlie 子节点的命令。在实际应用中，节点操作员只能访问其节点 keys，并且是唯一能够正确签名和提交 extrinsics 的人，很可能来自他们自己的节点，在那里他们可以控制 key 的安全性。</p>
<p>现在，您已经学习了如何构建一个网络，其中某些节点具有有限的权限和对网络资源的访问权限。</p>
<h2 id="监视节点指标"><a class="header" href="#监视节点指标">监视节点指标</a></h2>
<h2 id="升级一个运行中的网络"><a class="header" href="#升级一个运行中的网络">升级一个运行中的网络</a></h2>
<p>与许多区块链不同，Substrate 开发框架支持对作为区块链核心的运行时进行<strong>无分叉升级</strong>。大多数区块链项目需要一个<a href="https://docs.substrate.io/reference/glossary/#fork">硬分叉</a>的代码库，以支持新功能的持续开发或现有功能的增强。使用Substrate，你可以部署增强的运行时功能，在不使用硬分叉的情况下进行中断迭代。因为运行时的定义本身是 Substrate 链状态中的一个元素，网络参与者可以通过调用交易中的 <a href="https://paritytech.github.io/substrate/master/frame_system/pallet/enum.Call.html#variant.set_code"><code>set_code</code> 函数</a>来更新此值。由于运行时状态的更新是对区块链的共识机制和加密保证进行验证，网络参与者可以使用区块链本身分发更新或扩展的运行时逻辑，而无需分叉链或发布新的区块链客户端。</p>
<p>本节教程演示如何通过将以下更改部署到现有的 Substrate 运行时来执行无分叉升级：</p>
<ul>
<li>将 Scheduler pallet 添加到运行时。</li>
<li>使用 Scheduler pallet 增加网络帐户的最低余额。</li>
</ul>
<h3 id="使用sudo托盘授权升级"><a class="header" href="#使用sudo托盘授权升级">使用Sudo托盘授权升级</a></h3>
<p>在 FRAME 中，<code>Root</code> 源标识着运行时管理员。只有此管理员才能通过调用 <code>set_code</code> 函数来更新运行时。要使用 <code>Root</code> 源调用此函数，可以使用 Sudo pallet 中的 <code>sudo</code> 函数来指定具有超级用户管理权限的帐户。</p>
<p>默认情况下，node template 的 chain specification 文件指定 <code>alice</code> 开发帐户是 Sudo 管理帐户的所有者。因此，本节教程使用 <code>alice</code> 帐户执行运行时升级。</p>
<h4 id="运行时升级的资源核算"><a class="header" href="#运行时升级的资源核算">运行时升级的资源核算</a></h4>
<p>分发到 Substrate 运行时的函数调用总是与<a href="https://docs.substrate.io/reference/glossary/#weight">权重</a>相关联，以反映资源使用情况。FRAME System 模块设置边界，可以使用这些交易的块长度和块权重。然而，<code>set_code</code> 函数被有意设计为消耗一个块所能容纳的最大权重。强制运行时升级以消耗整个块，可以防止同一块中的交易在运行时的不同版本上执行。</p>
<p><code>set_code</code> 函数的权重注释还指定该函数位于 <code>Operational</code> 类中，因为它提供网络功能。标识为可操作的函数调用：</p>
<ul>
<li>可以消耗一个块的全部权重限制。</li>
<li>优先级最高。</li>
<li>免除支付交易费用。</li>
</ul>
<h4 id="管理资源核算"><a class="header" href="#管理资源核算">管理资源核算</a></h4>
<p>在本节教程中，<a href="https://paritytech.github.io/substrate/master/pallet_sudo/pallet/enum.Call.html#variant.sudo_unchecked_weight"><code>sudo_unchecked_weight</code></a> 函数用于为运行时升级调用 <code>set_code</code> 函数。<code>sudo_unchecked_weight</code> 函数与 <code>sudo</code> 函数相同，只是它支持一个附加参数来指定用于调用的权重。此参数使你能够绕过资源核算保护措施，为分发 <code>set_code</code> 函数的调用指定零权重。此设置允许一个块花费无限时间进行计算，以确保运行时升级不会失败，无论操作多么复杂。它可能需要所有时间才能显示成功或失败。</p>
<h3 id="升级运行时以添加调度程序pallet"><a class="header" href="#升级运行时以添加调度程序pallet">升级运行时以添加调度程序pallet</a></h3>
<p>node template 在其运行时中不包含 <a href="https://paritytech.github.io/substrate/master/pallet_scheduler/index.html">Scheduler pallet</a>。为了演示运行时升级，让我们将 Scheduler pallet 添加到运行节点。</p>
<p>要升级运行时，通过运行下面的命令在开发模式下启动本地节点：</p>
<pre><code class="language-bash editable noplayground">cargo run --release -- --dev
</code></pre>
<p>保持节点运行。你可以编辑并重新编译以升级运行时，而无需停止或重新启动正在运行的节点。</p>
<p>在第二个终端中，在编辑器中打开 <code>substrate-node-template/runtime/Cargo.toml</code> 文件，添加 Scheduler pallet 作为依赖项。</p>
<pre><code class="language-toml editable noplayground">[dependencies]
...
pallet-scheduler = { version = &quot;4.0.0-dev&quot;, default-features = false, git = &quot;https://github.com/paritytech/substrate.git&quot;, branch = &quot;polkadot-v0.9.28&quot; }
...
</code></pre>
<p>添加 Scheduler pallet 到 <code>features</code> 列表中。</p>
<pre><code class="language-toml editable noplayground">[features]
default = [&quot;std&quot;]
std = [
 ...
 &quot;pallet-scheduler/std&quot;,
 ...
</code></pre>
<p>在编辑器中打开 <code>substrate-node-template/runtime/src/lib.rs</code> 文件，添加 Scheduler pallet 所需的类型。</p>
<pre><code class="language-rust editable noplayground">parameter_types! {
 pub MaximumSchedulerWeight: Weight = 10_000_000;
 pub const MaxScheduledPerBlock: u32 = 50;
}
</code></pre>
<p>为 Scheduler pallet 的 Config trait 添加实现。</p>
<pre><code class="language-rust editable noplayground">impl pallet_scheduler::Config for Runtime {
 type Event = Event;
 type Origin = Origin;
 type PalletsOrigin = OriginCaller;
 type Call = Call;
 type MaximumWeight = MaximumSchedulerWeight;
 type ScheduleOrigin = frame_system::EnsureRoot&lt;AccountId&gt;;
 type MaxScheduledPerBlock = MaxScheduledPerBlock;
 type WeightInfo = ();
 type OriginPrivilegeCmp = EqualPrivilegeOnly;
 type PreimageProvider = ();
 type NoPreimagePostponement = ();
}
</code></pre>
<p>在 <code>construct_runtime!</code> 宏里添加 Scheduler pallet。</p>
<pre><code class="language-rust editable noplayground">construct_runtime!(
 pub enum Runtime where
 Block = Block,
 NodeBlock = opaque::Block,
 UncheckedExtrinsic = UncheckedExtrinsic
 {
   /*** snip ***/
   Scheduler: pallet_scheduler,
 }
);
</code></pre>
<p>在文件的顶部添加以下 trait 依赖：</p>
<pre><code class="language-rust editable noplayground">pub use frame_support::traits::EqualPrivilegeOnly;
</code></pre>
<p>增加 <a href="https://paritytech.github.io/substrate/master/sp_version/struct.RuntimeVersion.html"><code>RuntimeVersion</code> 结构</a>中的 <a href="https://paritytech.github.io/substrate/master/sp_version/struct.RuntimeVersion.html#structfield.spec_version">spec_version</a> 以升级运行时版本。</p>
<pre><code class="language-rust editable noplayground">pub const VERSION: RuntimeVersion = RuntimeVersion {
 spec_name: create_runtime_str!(&quot;node-template&quot;),
 impl_name: create_runtime_str!(&quot;node-template&quot;),
 authoring_version: 1,
 spec_version: 101,  // *Increment* this value, the template uses 100 as a base
 impl_version: 1,
 apis: RUNTIME_API_VERSIONS,
 transaction_version: 1,
};
</code></pre>
<p>检查 <code>RuntimeVersion</code> 结构体的组件：</p>
<ul>
<li><code>spec_name</code> 指定运行时的名称。</li>
<li><code>impl_name</code> 指定客户端的名称。</li>
<li><code>authoring_version</code> 指定 <a href="https://docs.substrate.io/reference/glossary/#author">block authors</a> 的版本。</li>
<li><code>spec_version</code> 指定运行时的版本。</li>
<li><code>impl_version</code> 指定客户端的版本。</li>
<li><code>apis</code> 指定支持的 APIs 列表。</li>
<li><code>transaction_version</code> 指定 <a href="https://docs.substrate.io/reference/glossary/#dispatch">dispatchable function</a> 接口的版本。</li>
</ul>
<p>要升级运行时，你必须递增 <code>spec_version</code> 的值。更多信息请参见 <a href="https://github.com/paritytech/substrate/blob/v3.0.0/frame/system/src/lib.rs">FRAME System</a> 模块和 <code>can_set_code</code> 函数。</p>
<p>保存代码并关闭 <code>substrate-node-template/runtime/src/lib.rs</code> 文件。</p>
<p>在第二个终端窗口或选项卡中构建更新的运行时，而不停止正在运行的节点。</p>
<pre><code class="language-bash editable noplayground">cargo build --release -p node-template-runtime
</code></pre>
<p><code>--release</code> 命令行选项需要较长的编译时间。然而它生成了一个更小的构建工件，更适合提交到区块链网络。存储优化对于任何区块链都至关重要。使用此命令，构建工件将输出到 <code>target/release</code> 目录。</p>
<p>连接到本地节点使用新的构建构件升级运行时。
你可以使用 <a href="https://polkadot.js.org/apps/#/extrinsics?rpc=ws://127.0.0.1:9944">Polkadot-JS application</a> 连接到本地节点。</p>
<p>选择 Alice 帐户提交对 <code>sudoUncheckedWeight</code> 函数的调用，并且从 <code>system</code> pallet 调用 <code>setCode</code> 函数作为其参数。</p>
<p><img src="https://awesomeprogram.gitee.io/imgdata/tech_bc_subselaca.jpg" alt="" /></p>
<p>选择 <code>file upload</code>，然后选择或拖放运行时生成的 WebAssembly 文件。例如，点击选择 <code>target/release/wbuild/node-template-runtime/node_template_runtime.compact.compressed.wasm</code> 文件。保留 <code>_weight</code> 参数的默认值为 <code>0</code>。</p>
<p><img src="https://awesomeprogram.gitee.io/imgdata/tech_bc_sudupg.jpg" alt="" /></p>
<p>点击 <strong>Submit Transaction</strong>。</p>
<p>查看授权，然后点击 <strong>Sign and Submit</strong>。</p>
<p>在交易包含在一个块中之后，Polkadot-JS 应用程序中显示的版本号表明运行时版本现在是 <code>101</code>。</p>
<p><img src="https://awesomeprogram.gitee.io/imgdata/tech_bc_subver101.jpg" alt="" /></p>
<p>如果你的本地节点在终端中生成的块与浏览器中显示的匹配，那么你已经成功完成了运行时升级。</p>
<p>下一步，我们将：</p>
<ol>
<li>升级你的运行时版本</li>
<li>使用 Scheduler pallet 来调度正在链上运行的运行时升级</li>
</ol>
<h3 id="调度一个升级"><a class="header" href="#调度一个升级">调度一个升级</a></h3>
<p>既然 node template 已经升级到包含 Scheduler pallet，那么 <a href="https://paritytech.github.io/substrate/master/pallet_scheduler/pallet/enum.Call.html#variant.schedule"><code>schedule</code> 函数</a> 就可以用于执行下一次运行时升级。在之前的部分，我们使用 <code>sudo_unchecked_weight</code> 函数覆盖 <code>set_code</code> 函数的关联权重；在本节中，将安排运行时升级，以便它可以作为块中的唯一<a href="https://docs.substrate.io/fundamentals/transaction-types/">外部</a>因素处理。</p>
<h4 id="准备一个可升级的运行时"><a class="header" href="#准备一个可升级的运行时">准备一个可升级的运行时</a></h4>
<p>此升级比之前的升级更简单，只需要更新 <code>runtime/src/lib.rs</code> 中的单个值，除了运行时的 <code>spec_version</code> 之外。</p>
<pre><code class="language-rust editable noplayground">pub const VERSION: RuntimeVersion = RuntimeVersion {
 spec_name: create_runtime_str!(&quot;node-template&quot;),
 impl_name: create_runtime_str!(&quot;node-template&quot;),
 authoring_version: 1,
 spec_version: 102,  // *Increment* this value.
 impl_version: 1,
 apis: RUNTIME_API_VERSIONS,
 transaction_version: 1,
};

/*** snip ***/

parameter_types! {
 pub const ExistentialDeposit: u128 = 1000;  // Update this value.
 pub const MaxLocks: u32 = 50;
}

/*** snip ***/
</code></pre>
<p>这一变化增加了 Balances pallet 的 <a href="https://docs.substrate.io/reference/glossary/#existential-deposit"><code>ExistentialDeposit</code></a>，从 Balances pallet 的角度来看，需要保持帐户存活的最低余额。</p>
<p>请记住，此更改不会导致所有在500到1000之间的余额都被获取，这将需要进行存储迁移，不在本节教程的范围。</p>
<h4 id="构建一个可升级的运行时"><a class="header" href="#构建一个可升级的运行时">构建一个可升级的运行时</a></h4>
<pre><code class="language-bash editable noplayground">cargo build --release -p node-template-runtime
</code></pre>
<p>这将覆盖任何以前的构建工件。因此如果你希望有最后一个运行时 Wasm 构建文件的副本，请确保已经将它们复制到其他地方。</p>
<h4 id="升级运行时-1"><a class="header" href="#升级运行时-1">升级运行时</a></h4>
<p>在上一节中，<code>Scheduler pallet</code> 配置了 <code>Root</code> 源作为其 <a href="https://paritytech.github.io/substrate/master/pallet_scheduler/pallet/trait.Config.html#associatedtype.ScheduleOrigin"><code>ScheduleOrigin</code></a>，这意味着可以使用 <code>sudo</code> 函数（而不是 <code>sudo_unchecked_weight</code>）来调用 <code>schedule</code> 函数。使用此链接打开 Polkadot JS 应用程序 UI 的 <code>Sudo</code> 标签：<a href="https://polkadot.js.org/apps/#/sudo?rpc=ws://127.0.0.1:9944">https://polkadot.js.org/apps/#/sudo?rpc=ws://127.0.0.1:9944</a>。</p>
<p>在提供 <code>when</code> 参数之前，等待所有其他字段都被填充。保留 <code>maybe_periodic</code> 参数为空，<code>priority</code> 参数的默认值为 <code>0</code>。选择 System pallet 的 <code>set_code</code> 函数作为 <code>call</code> 参数，并像之前一样提供 Wasm 二进制文件。保留 <strong>with weight override</strong> 选项不激活。一旦填充了所有其他字段，以后使用大约10个区块（1分钟）的区块号来填充 <code>when</code> 参数并快速提交交易。</p>
<p><img src="https://awesomeprogram.gitee.io/imgdata/tech_bc_subschupg.jpg" alt="" /></p>
<p>你可以使用模板节点的命令行输出或 <a href="https://polkadot.js.org/apps/#/explorer?rpc=ws://127.0.0.1:9944">Polkadot JS Apps UI block explorer</a> 来监视这个预定调用的发生。</p>
<p><img src="https://awesomeprogram.gitee.io/imgdata/tech_bc_subscupsu.jpg" alt="" /></p>
<p>在目标区块被包含在链中之后，Polkadot JS 应用程序界面左上角的版本号应该反映出运行时的版本现在是 <code>102</code>。</p>
<p>然后，你可以通过使用 <a href="https://polkadot.js.org/apps/#/chainstate/constants?rpc=ws://127.0.0.1:9944">Polkadot JS app UI Chain State</a> 应用程序来观察升级中所做的具体变化，以从 Balances pallet 中查询 <code>existentialDeposit</code> 常量值。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="自定义pallet-1"><a class="header" href="#自定义pallet-1">自定义pallet</a></h1>
<p>本教程的重点是如何使用 pallets 自定义运行时，包括如何将简单和复杂的 pallets 添加到运行时，以及如何将 pallets 与智能合约结合使用。</p>
<h2 id="添加一个pallet到运行时"><a class="header" href="#添加一个pallet到运行时">添加一个pallet到运行时</a></h2>
<p>Nicks pallet 允许区块链用户支付押金，为他们控制的帐户保留昵称。它实现了以下功能：</p>
<ul>
<li><code>set_name</code> 函数用于收集押金，并为帐户设置名称，如果该名称尚未被使用。</li>
<li><code>clear_name </code> 函数用于删除与帐户关联的名称并退还押金。</li>
<li><code>kill_name</code> 函数用于强制删除帐户名称，但不会退还押金。</li>
</ul>
<h3 id="添加nicks-pallet的依赖"><a class="header" href="#添加nicks-pallet的依赖">添加Nicks pallet的依赖</a></h3>
<p>将 Nicks pallet 的依赖项添加到运行时，打开 <code>runtime/Cargo.toml</code> 文件，复制一个存在的 pallet 依赖项描述，然后把名字替换为 <code>pallet-nicks</code>，使该 pallet 在 node template 运行时是可用的。例如，添加如下类似的一行：</p>
<pre><code class="language-bash editable noplayground">pallet-nicks = { version = &quot;4.0.0-dev&quot;, default-features = false, git = &quot;https://github.com/paritytech/substrate.git&quot;, branch = &quot;polkadot-v0.9.26&quot; }
</code></pre>
<ul>
<li>version 标识着你想导入的 crate 版本。</li>
<li>使用标准 Rust 库编译运行时的时候，是否包括 pallet 特性的默认行为。</li>
<li>用于检索 <code>pallet-nicks</code> crate 的存储库位置。</li>
<li>用于检索 crate 的分支。</li>
</ul>
<p>这些细节对于任何给定版本的 node tempalte 中的每个 pallet 都应该是相同的。</p>
<p>添加 <code>pallet-nicks/std</code> 特性到 <code>features</code> 列表中，以编译运行时的时候可以启用。</p>
<pre><code class="language-rust editable noplayground">[features]
default = [&quot;std&quot;]
std = [
  ...
  &quot;pallet-aura/std&quot;,
  &quot;pallet-balances/std&quot;,
  &quot;pallet-nicks/std&quot;,
  ...
]
</code></pre>
<p>如果你忘记更新 <code>Cargo.toml</code> 的 <code>features</code> 部分，在编译运行时二进制文件时，你可能会看到 <code>cannot find function</code> 错误。</p>
<p>通过以下命令检查依赖项是否被正确解析：</p>
<pre><code class="language-bash editable noplayground">cargo check -p node-template-runtime
</code></pre>
<h3 id="审查余额的配置"><a class="header" href="#审查余额的配置">审查余额的配置</a></h3>
<p>例如，查看你需要实现的 <code>nicks</code> pallet，你可以参考关于 <a href="https://paritytech.github.io/substrate/master/pallet_nicks/pallet/trait.Config.html"><code>pallet_nicks::Config</code></a> 的 Rust 文档或者 <a href="https://github.com/paritytech/substrate/blob/master/frame/nicks/src/lib.rs"><code>Nicks pallet 源码</code></a>中的 trait 定义。</p>
<p>在本节教程中，你可以看到 <code>nicks</code> pallet 中的 <code>Config</code> trait 声明了以下类型：
``rust,editable,noplayground
pub trait Config: Config {
type Event: From&lt;Event<Self>&gt; + IsType&lt;<Self as Config>::Event&gt;;
type Currency: ReservableCurrency<a href="blockchain/Self::AccountId">Self::AccountId</a>;
type ReservationFee: Get&lt;&lt;<Self as Config>::Currency as Currency&lt;<Self as Config>::AccountId&gt;&gt;::Balance&gt;;
type Slashed: OnUnbalanced&lt;&lt;<Self as Config>::Currency as Currency&lt;<Self as Config>::AccountId&gt;&gt;::NegativeImbalance&gt;;
type ForceOrigin: EnsureOrigin<a href="blockchain/Self::Origin">Self::Origin</a>;
type MinLength: Get<u32>;
type MaxLength: Get<u32>;
}</p>
<pre><code>确定 pallet 所需的类型后，需要向运行时添加代码以实现 `Config` 特性。查看为一个 pallet 怎样实现 `Config` trait，使用 **Balances** pallet 作为一个例子，打开 `runtime/src/lib.rs` 文件，找到 `Balances` pallet 的位置并注意它由以下实现（`impl`）代码块组成：
```rust,editable,noplayground
impl pallet_balances::Config for Runtime {
  type MaxLocks = ConstU32&lt;50&gt;;
  type MaxReserves = ();
  type ReserveIdentifier = [u8; 8];
  /// The type for recording an account's balance.
  type Balance = Balance;
  /// The ubiquitous event type.
  type Event = Event;
  /// The empty value, (), is used to specify a no-op callback function.
  type DustRemoval = ();
  /// Set the minimum balanced required for an account to exist on-chain
  type ExistentialDeposit = ConstU128&lt;500&gt;;
  /// The FRAME runtime system is used to track the accounts that hold balances.
  type AccountStore = System;
  /// Weight information is supplied to the Balances pallet by the node template runtime.
  type WeightInfo = pallet_balances::weights::SubstrateWeight&lt;Runtime&gt;;
}
</code></pre>
<p>正如你看到的这个例子，<code>impl pallet_balances::Config</code> 代码块允许你为指定的 Balances pallet <code>Config</code> trait 配置类型和参数。例如，此 <code>impl</code> 代码块配置 Balances pallet 使用 <code>u128</code> 类型来追述 balances。</p>
<h3 id="为nicks实现配置"><a class="header" href="#为nicks实现配置">为Nicks实现配置</a></h3>
<p>要实现 <code>nicks</code> pallet 在你的运行时，打开 <code>runtime/src/libs.rs</code> 文件，找到 Balances 代码块的最后一行，为 Nicks pallet 添加下面的代码块：</p>
<pre><code class="language-rust editable noplayground">impl pallet_nicks::Config for Runtime {
// The Balances pallet implements the ReservableCurrency trait.
// `Balances` is defined in `construct_runtime!` macro.
type Currency = Balances;

// Set ReservationFee to a value.
type ReservationFee = ConstU128&lt;100&gt;;

// No action is taken when deposits are forfeited.
type Slashed = ();

// Configure the FRAME System Root origin as the Nick pallet admin.
// https://paritytech.github.io/substrate/master/frame_system/enum.RawOrigin.html#variant.Root
type ForceOrigin = frame_system::EnsureRoot&lt;AccountId&gt;;

// Set MinLength of nick name to a desired value.
type MinLength = ConstU32&lt;8&gt;;

// Set MaxLength of nick name to a desired value.
type MaxLength = ConstU32&lt;32&gt;;

// The ubiquitous event type.
type Event = Event;
}
</code></pre>
<p>添加 Nicks 到 <code>construct_runtime!</code> 宏中，如下代码：</p>
<pre><code class="language-rust editable noplayground">construct_runtime!(
pub enum Runtime where
   Block = Block,
   NodeBlock = opaque::Block,
   UncheckedExtrinsic = UncheckedExtrinsic
 {
   /* --snip-- */
   Balances: pallet_balances,

   /*** Add This Line ***/
   Nicks: pallet_nicks,
 }
);
</code></pre>
<p>通过运行下面的命令检查新的依赖是否被正确解析：</p>
<pre><code class="language-bash editable noplayground">cargo check -p node-template-runtime
</code></pre>
<p>通过运行下面的命令以 release 模式编译 node：</p>
<pre><code class="language-bash editable noplayground">cargo build --release
</code></pre>
<h3 id="启动区块链节点"><a class="header" href="#启动区块链节点">启动区块链节点</a></h3>
<p>通过运行下面的命令以开发模式启动节点</p>
<pre><code class="language-bash editable noplayground">./target/release/node-template --dev
</code></pre>
<p>在上面这种例子中，<code>--dev</code> 选项使用预构建的 <code>development</code> chain specification 使节点运行在开发模式下。默认情况下，当你通过按下 Control-c 停止节点时，这个选项会删除所有活动数据，如 keys、区块链的数据库、网络信息。使用 <code>--dev</code> 选项确保在任何时候你停止或重启节点时都会有一个干净的网络状态。</p>
<p>通过查看终端中显示的输出，验证节点是否已启动并成功运行。如果块的最终确认后控制台输出中的数字还在增加，则你的区块链正在生成新的区块，并就它们所描述的状态达成共识。</p>
<h3 id="启动front-end-template-1"><a class="header" href="#启动front-end-template-1">启动front-end template</a></h3>
<p>现在你已经添加一个新的 pallet 到你的运行时，你可以使用 Substrate front-end template 跟 node template 进行交互，并且访问 Nicks pallet。在你已安装的 front-end template 目录中，通过运行下面的命令为 front-end template 启动 web server：</p>
<pre><code class="language-bash editable noplayground">yarn start
</code></pre>
<p>在浏览器中打开 <code>http://localhost:8000</code> 去查看 front-end template。</p>
<h3 id="使用nicks-pallet设置昵称"><a class="header" href="#使用nicks-pallet设置昵称">使用Nicks pallet设置昵称</a></h3>
<p>在账户列表选择 Alice 账户，在 Pallet Interactor 组件确认 <strong>Extrinsic</strong> 是已经被选择的，从可调用的 pallets 列表中选择 <code>nicks</code>，选择 <a href="https://paritytech.github.io/substrate/master/pallet_nicks/pallet/enum.Call.html#variant.set_name"><code>setname</code></a> 作为从 <code>nicks</code> pallet 中调用的函数，输入一个不少于 <code>MinNickLength</code>（8字符）且不超过 <code>MaxNickLength</code>（32字符）的昵称。</p>
<p><img src="https://awesomeprogram.gitee.io/imgdata/tech_bc_subsetname.jpg" alt="" /></p>
<p>点击 <strong>Signed</strong> 执行函数。</p>
<p>观察调用改变的状态，从 Ready 到 InBlock 到 Finalized，并且注意 Nicks pallet 发出的<a href="https://paritytech.github.io/substrate/master/pallet_nicks/pallet/enum.Event.html">事件</a>。</p>
<p><img src="https://awesomeprogram.gitee.io/imgdata/tech_bc_subsetresult.jpg" alt="" /></p>
<h3 id="使用nicks-pallet查询账户的信息"><a class="header" href="#使用nicks-pallet查询账户的信息">使用Nicks pallet查询账户的信息</a></h3>
<p>在账户列表选择 Alice 账户，在 Pallet Interactor 组件中选择 <strong>Query</strong> 作为交互的类型，从可调用的 pallets 列表中选择 <code>nicks</code>，选择 <a href="https://paritytech.github.io/substrate/master/pallet_nicks/pallet/enum.Call.html#variant.set_name"><code>nameOf</code></a> 作为要调用的函数，在 AccountId 字段中复制并粘贴 <code>alice</code> 账户的地址，然后点击 <strong>Query</strong>。</p>
<p><img src="https://awesomeprogram.gitee.io/imgdata/tech_bc_subqueryresult.jpg" alt="" /></p>
<p>返回的类型是一个包含两个值的元组：</p>
<ul>
<li>Alice 账户的16进制编码的昵称 <code>53756273747261746520737570657273746172202d20416c696365</code>。</li>
<li>从 Alice 的账户中预留的用于保存昵称的金额（<code>100</code>）。</li>
</ul>
<p>如果你要查询 Nicks pallet 中 Bob 账户的昵称，你将看到返回一个 <code>None</code> 值，因为 Bob 没有调用 <code>setname</code> 函数去预留一个昵称。</p>
<h3 id="探索其他功能"><a class="header" href="#探索其他功能">探索其他功能</a></h3>
<p>本节教程演示了如何向运行时添加一个简单的 pallet，并演示了如何使用前端模板与新 pallet 交互，你将 <code>nicks </code> pallet 添加到运行时，并使用前端模板调用 <code>set_name</code> 和 <code>nameOf</code> 函数。<code>nicks</code> pallet 还提供了两个附加函数：<code>clear_name</code> 函数和 <code>kill_name</code> 函数，使帐户所有者能够删除或保留名称，或者一个 root-level 用户能够强制删除帐户名称。通过探索这些功能的工作方式，你可以继续了解其他功能，如 Sudo pallet 和 origin accounts 的使用。</p>
<h2 id="配置合约pallet"><a class="header" href="#配置合约pallet">配置合约pallet</a></h2>
<h3 id="添加contracts-pallet依赖"><a class="header" href="#添加contracts-pallet依赖">添加contracts pallet依赖</a></h3>
<p>将 contracts pallet 的依赖项添加到运行时，导入 <code>pallet-contracts</code> crate，打开 <code>runtime/Cargo.toml</code> 文件，复制一个存在的 pallet 依赖项描述，然后把名字替换为 <code>pallet-contracts</code>，使该 pallet 在 node template 运行时是可用的。例如，添加如下类似的一行：</p>
<pre><code class="language-rust editable noplayground">pallet-contracts = { version = &quot;4.0.0-dev&quot;, default-features = false, git = &quot;https://github.com/paritytech/substrate.git&quot;, branch = &quot;polkadot-v0.9.26&quot; }
</code></pre>
<p>导入 <code>pallet-contracts-primitives</code> crate，通过将其添加到依赖项列表中，使其可用于 node template 运行时。在大多数情况下，你在任何给定版本的 node template 中为每个托盘指定相同的信息。然而，如果编译器指定的版本与你所指定的版本不同，你可能需要修改依赖项以匹配编译器识别的版本。例如，如果编译器发现 <code>pallet-contracts-primitives</code> crate 的版本是 6.0.0：</p>
<pre><code class="language-rust editable noplayground">pallet-contracts-primitives = { version = &quot;6.0.0&quot;, default-features = false, git = &quot;https://github.com/paritytech/substrate.git&quot;, branch = &quot;polkadot-v0.9.26&quot; }
</code></pre>
<p>将 Contracts pallet 添加到 <code>std</code> 特性列表中，这样当运行时作为平台原生二进制（非 Wasm 二进制）文件构建时，它的特性就包括在内了。</p>
<pre><code class="language-rust editable noplayground">[features]
default = [&quot;std&quot;]
std = [
  &quot;codec/std&quot;,
  &quot;scale-info/std&quot;,
  &quot;frame-executive/std&quot;,
  &quot;frame-support/std&quot;,
  &quot;frame-system-rpc-runtime-api/std&quot;,
  &quot;frame-system/std&quot;,
  &quot;pallet-aura/std&quot;,
  &quot;pallet-balances/std&quot;,
  &quot;pallet-contracts/std&quot;,
  &quot;pallet-contracts-primitives/std&quot;,
]
</code></pre>
<p>保存代码并关闭 <code>runtime/Cargo.toml</code> 文件。</p>
<p>通过运行下面的命令检查你的运行时编译是否正确：</p>
<pre><code class="language-rust editable noplayground">cargo check -p node-template-runtime
</code></pre>
<h3 id="实现-contracts-configuration-trait"><a class="header" href="#实现-contracts-configuration-trait">实现 Contracts configuration trait</a></h3>
<p>如果你查看 <code>pallet_contracts::Config</code> Rust API 文档，你将会注意到，该 pallet 不像 Nicks pallet 一样，有很多关联类型，因此本节教程的代码比之前的要更复杂。</p>
<p>为了在运行时给 Contracts pallet 实现 <code>Config</code> trait，打开 <code>runtime/src/lib.rs</code>，找到 <code>pub use frame_support</code> 代码块并添加 <code>Nothing</code> 到 traits 列表之中，如下：</p>
<pre><code class="language-rust editable noplayground">pub use frame_support::{
construct_runtime, parameter_types,
traits::{
  ConstU128, ConstU32, ConstU64, ConstU8, KeyOwnerProofSystem, Randomness, StorageInfo,Nothing
},
weights::{
 constants::{BlockExecutionWeight, ExtrinsicBaseWeight, RocksDbWeight, WEIGHT_PER_SECOND},
 IdentityFee, Weight,
},
StorageValue,
};
</code></pre>
<p>添加一行从 Contracts pallet 导入默认的 contract 权重，如下：</p>
<pre><code class="language-rust editable noplayground">pub use frame_system::Call as SystemCall;
pub use pallet_balances::Call as BalancesCall;
pub use pallet_timestamp::Call as TimestampCall;
use pallet_transaction_payment::CurrencyAdapter;
use pallet_contracts::DefaultContractAccessWeight; // Add this line
</code></pre>
<p>添加 Contracts pallet 所需的常量添加到运行时，如下：</p>
<pre><code class="language-rust editable noplayground">/* After this block */
// Time is measured by number of blocks.
pub const MINUTES: BlockNumber = 60_000 / (MILLISECS_PER_BLOCK as BlockNumber);
pub const HOURS: BlockNumber = MINUTES * 60;
pub const DAYS: BlockNumber = HOURS * 24;

/* Add this block */
// Contracts price units.
pub const MILLICENTS: Balance = 1_000_000_000;
pub const CENTS: Balance = 1_000 * MILLICENTS;
pub const DOLLARS: Balance = 100 * CENTS;

const fn deposit(items: u32, bytes: u32) -&gt; Balance {
items as Balance * 15 * CENTS + (bytes as Balance) * 6 * CENTS
}
const AVERAGE_ON_INITIALIZE_RATIO: Perbill = Perbill::from_percent(10);
/*** End Added Block ***/
</code></pre>
<p>在运行时中为 <code>pallet_contracts</code> 添加参数类型和实现 <code>Config</code> trait，如下</p>
<pre><code class="language-rust editable noplayground">/*** Add a block similar to the following ***/
parameter_types! {
  pub const DepositPerItem: Balance = deposit(1, 0);
  pub const DepositPerByte: Balance = deposit(0, 1);
  pub const DeletionQueueDepth: u32 = 128;
  pub DeletionWeightLimit: Weight = AVERAGE_ON_INITIALIZE_RATIO * BlockWeights::get().max_block;
  pub Schedule: pallet_contracts::Schedule&lt;Runtime&gt; = Default::default();
}

impl pallet_contracts::Config for Runtime {
  type Time = Timestamp;
  type Randomness = RandomnessCollectiveFlip;
  type Currency = Balances;
  type Event = Event;
  type Call = Call;
  type CallFilter = frame_support::traits::Nothing;
  type WeightPrice = pallet_transaction_payment::Pallet&lt;Self&gt;;
  type WeightInfo = pallet_contracts::weights::SubstrateWeight&lt;Self&gt;;
  type ChainExtension = ();
  type Schedule = Schedule;
  type CallStack = [pallet_contracts::Frame&lt;Self&gt;; 31];
  type DeletionQueueDepth = DeletionQueueDepth;
  type DeletionWeightLimit = DeletionWeightLimit;
  type DepositPerByte = DepositPerByte;
  type DepositPerItem = DepositPerItem;
  type AddressGenerator = pallet_contracts::DefaultAddressGenerator;
  type ContractAccessWeight = DefaultContractAccessWeight&lt;BlockWeights&gt;;
  type MaxCodeLen = ConstU32&lt;{ 256 * 1024 }&gt;;
  type RelaxedMaxCodeLen = ConstU32&lt;{ 512 * 1024 }&gt;;
  type MaxStorageKeyLen = ConstU32&lt;{ 512 * 1024 }&gt;;
}
/*** End added block ***/
</code></pre>
<p>关于 Contracts pallet 配置的更多信息以及类型和参数如何被使用的，可参考 <a href="https://github.com/paritytech/substrate/blob/master/frame/contracts/src/lib.rs">Contracts pallet source code</a></p>
<p>添加 <code>pallet_contracts</code> 到 <code>construct_runtime!</code> 宏中，如下：</p>
<pre><code class="language-rust editable noplayground">// Create the runtime by composing the FRAME pallets that were previously configured
construct_runtime!(
  pub enum Runtime where
    Block = Block,
    NodeBlock = opaque::Block,
    UncheckedExtrinsic = UncheckedExtrinsic
  {
     System: frame_system,
     RandomnessCollectiveFlip: pallet_randomness_collective_flip,
     Timestamp: pallet_timestamp,
     Aura: pallet_aura,
     Grandpa: pallet_grandpa,
     Balances: pallet_balances,
     TransactionPayment: pallet_transaction_payment,
     Sudo: pallet_sudo,
     Contracts: pallet_contracts,
  }
);
</code></pre>
<p>保存代码并关闭 <code>runtime/src/lib.rs</code> 文件。</p>
<p>通过运行下面的命令检查你的运行时编译是否正确：</p>
<pre><code class="language-bash editable noplayground">cargo check -p node-template-runtime
</code></pre>
<h3 id="暴露合约的api"><a class="header" href="#暴露合约的api">暴露合约的API</a></h3>
<p>一些 pallets，包括 Contracts pallet，暴露了自定义运行时 APIs 和 RPC 端点。你无需在 Contracts pallet 上启用 RPC 调用就可以在链上使用它。然而，暴露 Contracts pallet 的 API 和 endpoints 很有用，因为这样做可以使你执行以下任务：</p>
<ul>
<li>从链下读取合约状态。</li>
<li>在不进行交易的情况下调用节点存储。</li>
</ul>
<p>要暴露合约 RPC API，打开 <code>runtime/Cargo.toml</code> 文件，使用与其他 pallets 相同的版本和分支信息，将 <code>pallet-contracts-rpc-runtime-api</code> pallet 的相关代码描述添加到 <code>[dependencies]</code> 部分，如下：</p>
<pre><code class="language-rust editable noplayground">pallet-contracts-rpc-runtime-api = { version = &quot;4.0.0-dev&quot;, default-features = false, git = &quot;https://github.com/paritytech/substrate.git&quot;, branch = &quot;polkadot-v0.9.26&quot; }
</code></pre>
<p>将 <code>pallet-contracts-rpc-runtime-api</code> 添加到 <code>std</code> 特性列表中，以便在构建运行时为原生二进制时包含其特性。</p>
<pre><code class="language-rust editable noplayground">[features]
default = [&quot;std&quot;]
std = [
  &quot;codec/std&quot;,
  ...
  &quot;pallet-contracts/std&quot;,
  &quot;pallet-contracts-primitives/std&quot;,
  &quot;pallet-contracts-rpc-runtime-api/std&quot;,
  ...
]
</code></pre>
<p>保存代码并关闭 <code>runtime/Cargo.toml</code> 文件。</p>
<p>打开 <code>runtime/src/lib.rs</code> 文件，并通过添加以下常量启用合约调试：</p>
<pre><code class="language-rust editable noplayground">const CONTRACTS_DEBUG_OUTPUT: bool = true;
</code></pre>
<p>在 <code>impl_runtime_apis!</code> 宏中，接近运行时 <code>lib.rs</code> 文件末尾的地方，实现合约运行时 API，如在 <code>impl_runtime_apis! { }</code> 的部分：</p>
<pre><code class="language-rust editable noplayground">/*** Add this block ***/
impl pallet_contracts_rpc_runtime_api::ContractsApi&lt;Block, AccountId, Balance, BlockNumber, Hash&gt;
 for Runtime
 {
  fn call(
     origin: AccountId,
     dest: AccountId,
     value: Balance,
     gas_limit: u64,
     storage_deposit_limit: Option&lt;Balance&gt;,
     input_data: Vec&lt;u8&gt;,
  ) -&gt; pallet_contracts_primitives::ContractExecResult&lt;Balance&gt; {
     Contracts::bare_call(origin, dest, value, gas_limit, storage_deposit_limit, input_data, CONTRACTS_DEBUG_OUTPUT)
  }
  
  fn instantiate(
     origin: AccountId,
     value: Balance,
     gas_limit: u64,
     storage_deposit_limit: Option&lt;Balance&gt;,
     code: pallet_contracts_primitives::Code&lt;Hash&gt;,
     data: Vec&lt;u8&gt;,
     salt: Vec&lt;u8&gt;,
  ) -&gt; pallet_contracts_primitives::ContractInstantiateResult&lt;AccountId, Balance&gt; {
     Contracts::bare_instantiate(origin, value, gas_limit, storage_deposit_limit, code, data, salt, CONTRACTS_DEBUG_OUTPUT)
     }
     
  fn upload_code(
     origin: AccountId,
     code: Vec&lt;u8&gt;,
     storage_deposit_limit: Option&lt;Balance&gt;,
  ) -&gt; pallet_contracts_primitives::CodeUploadResult&lt;Hash, Balance&gt; {
     Contracts::bare_upload_code(origin, code, storage_deposit_limit)
  }
  
  fn get_storage(
     address: AccountId,
     key: Vec&lt;u8&gt;,
     ) -&gt; pallet_contracts_primitives::GetStorageResult {
     Contracts::get_storage(address, key)
     }
  }
</code></pre>
<p>保存代码并关闭 <code>runtime/src/lib.rs</code> 文件。</p>
<p>通过运行下面的命令检查你的运行时编译是否正确：</p>
<pre><code class="language-bash editable noplayground">cargo check -p node-template-runtime
</code></pre>
<h3 id="更新外部节点"><a class="header" href="#更新外部节点">更新外部节点</a></h3>
<p>要与 Contracts pallet 交互，必须扩展现有的 RPC server 以包括 Contracts pallet 和 Contracts RPC API。为了使 Contracts pallet 能够利用RPC endpoint API，你需要将自定义 RPC endpoint 添加到外部节点配置中。</p>
<p>将 RPC API 扩展添加到外部节点，打开 <code>node/Cargo.toml</code> 并且添加 <code>pallet-contracts</code> 和 <code>pallet-contracts-rpc</code> 到 <code>[dependencies]</code> 部分，如下：</p>
<pre><code class="language-toml editable noplayground">pallet-contracts = { version = &quot;4.0.0-dev&quot;, git = &quot;https://github.com/paritytech/substrate.git&quot;, branch = &quot;polkadot-v0.9.26&quot; }
pallet-contracts-rpc = { version = &quot;4.0.0-dev&quot;, git = &quot;https://github.com/paritytech/substrate.git&quot;, branch = &quot;polkadot-v0.9.26&quot; }
</code></pre>
<p>由于你已经暴露了运行时API，并且现在正在为外部节点编写代码，不需要使用 <code>no_std</code> 配置，所以你不必维护专用的 <code>std</code> 特性列表。</p>
<p>保存代码并关闭 <code>node/Cargo.toml</code> 文件。</p>
<p>打开 <code>node/src/rpc.rs</code> 文件，并找到下面这一行。</p>
<pre><code class="language-rust editable noplayground">use node_template_runtime::{opaque::Block, AccountId, Balance, Index};
</code></pre>
<p>将 <code>use pallet_contracts_rpc</code> 添加到文件中，如下：</p>
<pre><code class="language-rust editable noplayground">use pallet_transaction_payment_rpc::{TransactionPayment, TransactionPaymentApiServer};
use substrate_frame_rpc_system::{System, SystemApiServer};
use pallet_contracts_rpc::{Contracts, ContractsApiServer}; // Add this line
</code></pre>
<p>为 RPC 扩展添加 Contracts RPC pallet 到 <code>create_full</code> 函数中，如下：</p>
<pre><code class="language-rust editable noplayground">/// Instantiate all full RPC extensions.
pub fn create_full&lt;C, P&gt;(
  deps: FullDeps&lt;C, P&gt;,
) -&gt; Result&lt;RpcModule&lt;()&gt;, Box&lt;dyn std::error::Error + Send + Sync&gt;&gt;
where
  C: ProvideRuntimeApi&lt;Block&gt;,
  C: HeaderBackend&lt;Block&gt; + HeaderMetadata&lt;Block, Error = BlockChainError&gt; + 'static,
  C: Send + Sync + 'static,
  C::Api: substrate_frame_rpc_system::AccountNonceApi&lt;Block, AccountId, Index&gt;,
  C::Api: pallet_transaction_payment_rpc::TransactionPaymentRuntimeApi&lt;Block, Balance&gt;,
  C::Api: pallet_contracts_rpc::ContractsRuntimeApi&lt;Block, AccountId, Balance, BlockNumber, Hash&gt;, // Add this line
  C::Api: BlockBuilder&lt;Block&gt;,
  P: TransactionPool + 'static,
</code></pre>
<p>添加 Contracts RPC API 的扩展。</p>
<pre><code class="language-rust editable noplayground">module.merge(System::new(client.clone(), pool.clone(), deny_unsafe).into_rpc())?;
module.merge(TransactionPayment::new(client.clone()).into_rpc())?;
module.merge(Contracts::new(client.clone()).into_rpc())?; // Add this line
</code></pre>
<p>保存代码并关闭 <code>node/src/rpc.rs</code> 文件。</p>
<p>通过运行下面的命令检查你的运行时编译是否正确：</p>
<pre><code class="language-bash editable noplayground">cargo check -p node-template
</code></pre>
<p>如果检查没有错误，你可以通过运行下面的命令在 release 模式下编译节点：</p>
<pre><code class="language-bash editable noplayground">cargo build --release
</code></pre>
<h3 id="启动本地substrate节点"><a class="header" href="#启动本地substrate节点">启动本地Substrate节点</a></h3>
<p>节点编译完成之后，你可以从 <a href="https://paritytech.github.io/substrate/master/pallet_contracts/index.html">Contracts pallet</a> 增强功能的智能合约启动 Substrate 节点，并且使用 front-end template 与之进行交互。</p>
<p>在开发模式下启动本地节点，运行以下命令：</p>
<pre><code class="language-bash editable noplayground">./target/release/node-template --dev
</code></pre>
<p>通过查看终端中显示的输出，验证节点是否已启动并成功运行。如果在 <code>finalized</code> 后数字不断在增加，你的区块链正在生成新的块，并且就他们描述的状态达成新的共识，说明是成功运行了。</p>
<p>通过运行下面的命令启动 front-end template 的 web 服务：</p>
<pre><code class="language-bash editable noplayground">yarn start
</code></pre>
<p>在浏览器中打开 <code>http://localhost:8000/</code> 去访问 front-end template。</p>
<p>在 Pallet Interactor 组件中验证 <code>Extrinsic</code> 是被选中的，然后从可供调用的 pallets 列表中选择 <code>contracts</code>。</p>
<p><img src="https://awesomeprogram.gitee.io/imgdata/tech_bc_subcontpal.jpg" alt="" /></p>
<p><img src="https://awesomeprogram.gitee.io/imgdata/tech_bc_subaddwekno.jpg" alt="" /></p>
<h2 id="在自定义pallet中使用宏"><a class="header" href="#在自定义pallet中使用宏">在自定义pallet中使用宏</a></h2>
<h2 id="指定调用的来源"><a class="header" href="#指定调用的来源">指定调用的来源</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="开发智能合约-1"><a class="header" href="#开发智能合约-1">开发智能合约</a></h1>
<p>本教程指导你如何使用 <a href="https://ink.substrate.io/">ink! 编程语言</a> 用于构建在基于 Substrate 的区块链上运行的智能合约。本节中的教程使用预配置的 <code>contracts-node</code> 和托管 <a href="https://contracts-ui.substrate.io/">Contracts UI</a>。如果要使用标准 node template，需要将 Contracts pallet 和一些其他组件添加到开发环境中。在<strong>配置合约pallet</strong>中详细介绍了为构建智能合约准备 node template 的过程。</p>
<h2 id="准备第一份合约"><a class="header" href="#准备第一份合约">准备第一份合约</a></h2>
<h3 id="更新你的rust环境"><a class="header" href="#更新你的rust环境">更新你的Rust环境</a></h3>
<p>对于本节教程，你需要添加一些Rust源代码到你的Substrate开发环境之中，通过运行下面的命令更新你的Rust环境：</p>
<pre><code class="language-bash editable noplayground">rustup component add rust-src --toolchain nightly
</code></pre>
<p>通过运行下面的命令验证你已经安装了WebAssembly目标：</p>
<pre><code class="language-bash editable noplayground">rustup target add wasm32-unknown-unknown --toolchain nightly
</code></pre>
<p>如果目标已安装且是最新的，则该命令将显示类似于以下内容的输出：</p>
<pre><code class="language-bash editable noplayground">info: component 'rust-std' for target 'wasm32-unknown-unknown' is up to date
</code></pre>
<h3 id="安装substrate合约node"><a class="header" href="#安装substrate合约node">安装Substrate合约node</a></h3>
<p>为了简化本节教程，你可以为 Linux 和 macOS <a href="https://github.com/paritytech/substrate-contracts-node/releases">下载</a>预编译的 Substrate 节点，预编译的二进制文件默认情况下为智能合约包括了FRAME pallet。或者，你可以通过在你的本地计算机上运行 <code>cargo install contracts-node</code> 手动构建预配置的 <code>contracts-node</code>。</p>
<p>在 macOS 或 Linux 上安装对应 <a href="https://github.com/paritytech/substrate-contracts-node/releases">Releases</a> 版本的合约节点，为本地计算机下载合适的压缩文件。</p>
<p>如果无法下载预编译节点，则可以使用类似于以下的命令在本地编译它：</p>
<pre><code class="language-bash editable noplayground">cargo install contracts-node --git https://github.com/paritytech/substrate-contracts-node.git --tag &lt;latest-tag&gt; --force --locked
</code></pre>
<p>你可以在 <a href="https://github.com/paritytech/substrate-contracts-node/tags">Tags</a> 页面上发现最新的 tag。 </p>
<h3 id="安装其它软件包"><a class="header" href="#安装其它软件包">安装其它软件包</a></h3>
<p>编译 <code>contracts-node</code> 包后，你需要安装另外两个软件包：</p>
<ul>
<li>用于你的操作系统的 WebAssembly <strong>binaryen</strong> 包，为合约优化 WebAssembly 字节码。</li>
<li>用于配置智能合约项目的 <code>cargo-contract</code> 命令行接口。</li>
</ul>
<h4 id="安装webassembly优化器"><a class="header" href="#安装webassembly优化器">安装WebAssembly优化器</a></h4>
<p>在 Ubuntu 或 Debian 上运行下面的命令：</p>
<pre><code class="language-bash editable noplayground">sudo apt install binaryen
</code></pre>
<p>在 macOS 上运行下面的命令：</p>
<pre><code class="language-bash editable noplayground">brew install binaryen
</code></pre>
<p>对于其它的操作系统，你可以直接从 <a href="https://github.com/WebAssembly/binaryen/releases">WebAssembly releases</a> 上下载 <code>binaryen</code> release。</p>
<h4 id="安装cargo-contract包"><a class="header" href="#安装cargo-contract包">安装cargo-contract包</a></h4>
<p>在你安装 WebAssembly <code>binaryen</code> 包之后，你可以安装 <code>cargo-contract</code> 包。<code>cargo-contract</code> 包提供一个命令行接口，用于使用 <code>ink!</code> 语言处理智能合约。</p>
<p>安装 <code>dylint-link</code>，需要它来 lint ink! contracts，注意你使用 API 的方式可能存在会导致安全的问题：</p>
<pre><code class="language-bash editable noplayground">cargo install dylint-link
</code></pre>
<p>通过运行下面的命令安装 <code>cargo-contract</code>：</p>
<pre><code class="language-bash editable noplayground">cargo install cargo-contract --force
</code></pre>
<p>通过运行以下命令验证安装并尝试命令的可用选项：</p>
<pre><code class="language-bash editable noplayground">cargo contract --help
</code></pre>
<h3 id="创建一个新的智能合约项目"><a class="header" href="#创建一个新的智能合约项目">创建一个新的智能合约项目</a></h3>
<p>你现在可以开始开发新的智能合约项目了，为智能合约项目生成文件。通过运行下面的命令创建一个名叫 <code>flipper</code> 的新项目文件夹。</p>
<pre><code class="language-bash editable noplayground">cargo contract new flipper
</code></pre>
<p>切换到新项目文件夹中并列出文件夹中所有的内容：</p>
<pre><code class="language-bash editable noplayground">cd flipper/ &amp;&amp; ls -al
</code></pre>
<p>你应该可以看到文件夹中包含下面的文件：</p>
<pre><code class="language-bash editable noplayground">-rwxr-xr-x   1 dev-doc  staff   285 Mar  4 14:49 .gitignore
-rwxr-xr-x   1 dev-doc  staff  1023 Mar  4 14:49 Cargo.toml
-rwxr-xr-x   1 dev-doc  staff  2262 Mar  4 14:49 lib.rs
</code></pre>
<p>像其它 Rust 项目一样，<code>Cargo.tmol</code> 文件被用作提供包的依赖关系和配置信息。<code>lib.rs</code> 文件被用作为智能合约编写业务逻辑。</p>
<h4 id="浏览默认项目文件"><a class="header" href="#浏览默认项目文件">浏览默认项目文件</a></h4>
<p>默认情况下，创建一个新的智能合约项目生成一些模板源码。一个非常简单的合约，第一个函数 <code>flip()</code>，会将布尔变量从 true 更改为 false；还有第二个函数 <code>get()</code>，会获取当前布尔变量的值。<code>lib.rs</code> 文件还会包含两个为测试合约是否能按照期望工作的函数。</p>
<p>随着本节教程到最后，你会拥有一个更加高级完整的智能合约，像 <a href="https://github.com/paritytech/ink/blob/master/examples/flipper/lib.rs">Flipper example</a> 一样。</p>
<p>打开 <code>Cargo.toml</code> 文件并为查看合约的依赖关系，如有必要，在 <code>[dependencies]</code> 部分，修改 <code>scale</code> 和 <code>scale-info</code> 的配置：</p>
<pre><code class="language-toml editable noplayground">scale = { package = &quot;parity-scale-codec&quot;, version = &quot;3&quot;, default-features = false, features = [&quot;derive&quot;] }
scale-info = { version = &quot;2&quot;, default-features = false, features = [&quot;derive&quot;], optional = true }
</code></pre>
<p>保存对 <code>Cargo.tmol</code> 的任何变更，并关闭该文件。</p>
<p>打开 <code>lib.rs</code> 文件，并查看为合约定义的函数。</p>
<h4 id="测试默认的合约"><a class="header" href="#测试默认的合约">测试默认的合约</a></h4>
<p>在 <code>lib.rs</code> 原代码文件的底部，有一些简单的测试用例可以验证合约的功能性。你可以使用链下测试环境来测试此代码是否按照预期执行。</p>
<p>通过运行下面的命令，使用 <code>test</code> 子命令和 <code>nightly</code> 工具链来为 <code>flipper</code> 合约执行默认的测试用例：</p>
<pre><code class="language-bash editable noplayground">cargo +nightly test
</code></pre>
<p>该命令应显示类似于以下的输出，以表示成功完成测试用例：</p>
<pre><code class="language-bash editable noplayground">running 2 tests
test flipper::tests::it_works ... ok
test flipper::tests::default_works ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<h4 id="构建合约"><a class="header" href="#构建合约">构建合约</a></h4>
<p>测试完默认的合约之后，你就可以开始编译这个项目到 WebAssembly 了。
为智能合约构建 WebAssembly，通过运行下面的命令，编译 <code>flipper</code> 智能合约：</p>
<pre><code class="language-bash editable noplayground">cargo +nightly contract build
</code></pre>
<p>这个命令会为 <code>flipper</code> 项目构建一个 WebAssembly 二进制文件，一个元数据文件可以包含合约应用二进制接口（ABI），和一个你用来部署合约的 <code>.contract</code> 文件。例如，你应该可以看到类似于下面的输出：</p>
<pre><code class="language-bash editable noplayground">Original wasm size: 47.9K, Optimized: 22.8K

The contract was built in DEBUG mode.

Your contract artifacts are ready. You can find them in:
/Users/dev-doc/flipper/target/ink

- flipper.contract (code + metadata)
- flipper.wasm (the contract's code)
- metadata.json (the contract's metadata)
The `.contract` file can be used for deploying your contract to your chain.
</code></pre>
<p>在 <code>target/ink</code> 目录中的 <code>metadata.json</code> 文件描述了你可以用来与此合约交互的所有接口。这个文件包含了几个重要的部分：</p>
<ul>
<li><code>spec</code> 部分包含有关函数的信息，像可被调用的 <strong>constructors</strong> 和 <strong>messages</strong>，可被发出的 <strong>events</strong>，以及可现实的任何文档。这个部分也包括了一个 <code>selector</code> 字段，它包含一个函数名称的4字哈希，和用于将合约调用到正确的函数。</li>
<li><code>storage</code> 部分定义了由合约管理的所有存储项以及如何访问它们。</li>
<li><code>types</code> 部分提供 JSON 其余部分中使用的自定义数据类型。</li>
</ul>
<h3 id="启动substrate智能合约节点"><a class="header" href="#启动substrate智能合约节点">启动Substrate智能合约节点</a></h3>
<p>通过运行下面的命令在本地开发模式中启动预配置的 <code>contracts-node</code>：</p>
<pre><code class="language-bash editable noplayground">substrate-contracts-node --dev
</code></pre>
<p>你应该在终端中看到类似于以下内容的输出：</p>
<pre><code class="language-bash editable noplayground">2022-03-07 14:46:25 Substrate Contracts Node
2022-03-07 14:46:25 ✌️  version 0.8.0-382b446-x86_64-macos
2022-03-07 14:46:25 ❤️  by Parity Technologies &lt;admin@parity.io&gt;, 2021-2022
2022-03-07 14:46:25 📋 Chain specification: Development
2022-03-07 14:46:25 🏷  Node name: possible-plants-8517
2022-03-07 14:46:25 👤 Role: AUTHORITY
2022-03-07 14:46:25 💾 Database: RocksDb at /var/folders/2_/g86ns85j5l7fdnl621ptzn500000gn/T/substrateEdrJW9/chains/dev/db/full
2022-03-07 14:46:25 ⛓  Native runtime: substrate-contracts-node-100 (substrate-contracts-node-1.tx1.au1)
2022-03-07 14:46:25 🔨 Initializing Genesis block/state (state: 0xe9f1…4b89, header-hash: 0xa1b6…0194)
2022-03-07 14:46:25 👴 Loading GRANDPA authority set from genesis on what appears to be first startup.
2022-03-07 14:46:26 🏷  Local node identity is: 12D3KooWQ3P8BH7Z1C1ZoNSXhdGPCiPR7irRSeQCQMFg5k3W9uVd
2022-03-07 14:46:26 📦 Highest known block at #0
</code></pre>
<p>在几秒钟后，你还会看到区块被最终确认的状态。为了与区块链交互，你需要连接本节点。你可以通过打开 <a href="https://contracts-ui.substrate.io/">Contracts UI</a> 浏览器页面连接当前节点。然后点击 <strong>Yes allow this application access</strong>，选择本地节点。</p>
<h3 id="部署合约"><a class="header" href="#部署合约">部署合约</a></h3>
<p>在 Substrate 中，合约部署过程分为两个步骤：</p>
<ul>
<li>将合约代码上传到区块链。</li>
<li>创建合约的一个实例。</li>
</ul>
<p>通过这种模式，你可以将智能合约（如 ERC20标准）的代码存储在区块链上一次，然后将其实例化任意次数。你不需要重复加载相同的源代码，因此你的智能合约不会消耗区块链上不必要的资源。</p>
<h4 id="上传合约代码"><a class="header" href="#上传合约代码">上传合约代码</a></h4>
<p>在本节教程中，你将使用 Contracts UI 前端在 Substrate 链上部署 <code>flipper</code> 合约。</p>
<p>在 web 浏览器中打开 <a href="https://contracts-ui.substrate.io/">Contracts UI</a>，确认你已经连接到了 <strong>Local Node</strong>，点击 <strong>Add New Contract</strong>，点击 <strong>Upload New Contract Code</strong>，选择用于创建合约实例的 <strong>Account</strong>，你可以选择任何已存在的账户，包括一个预定义的账户，如 alice。输入一个智能合约的的名称，例如，Flipper Contract。</p>
<p>浏览并选择或拖放 <code>flipper.contract</code> 文件，包含绑定的 Wasm blob 和元数据文件到 upload section。</p>
<p><img src="https://awesomeprogram.gitee.io/imgdata/tech_bc_subuplocont.jpg" alt="" /></p>
<p>然后点击 <strong>Next</strong> 继续。</p>
<h4 id="在区块链上创建一个实例"><a class="header" href="#在区块链上创建一个实例">在区块链上创建一个实例</a></h4>
<p>智能合约作为 Substrate 区块链上账户系统的扩展而存在。当你创建此智能合约的实例时，Substrate 将创建一个新的 <code>AccountId</code>，以存储智能合约管理的任何余额，并允许你与该合约进行交互。</p>
<p>在你上传智能合约并点击 <strong>Next</strong> 之后，Contracts UI 会显示有关智能合约内容的信息。</p>
<p>查看并接受智能合约初始版本的默认 <code>Deployment Constructor</code> 选项，查看并接受默认的 <strong>Max Gas Allowed</strong> <code>200000</code>。</p>
<p><img src="https://awesomeprogram.gitee.io/imgdata/tech_bc_subcreainst.jpg" alt="" /></p>
<p>点击 <strong>Next</strong>，交易现在已开始进入队列，如果需要进行更改，可以点击 <strong>Go Back</strong> 修改输入。</p>
<p><img src="https://awesomeprogram.gitee.io/imgdata/tech_bc_subcomupl.jpg" alt="" /></p>
<p>点击 <strong>Upload and Instantiate</strong>，根据你使用的帐户，可能会提示你输入帐户密码。如果你使用了预定义的帐户，则不需要提供密码。</p>
<p><img src="https://awesomeprogram.gitee.io/imgdata/tech_bc_subfirstcon.jpg" alt="" /></p>
<h3 id="调用智能合约"><a class="header" href="#调用智能合约">调用智能合约</a></h3>
<p>现在，你的合约已经部署在区块链上了，你可以与之交互。默认的 <code>flipper</code> 智能合约有两个函数 <code>flip()</code> 和 <code>get()</code>，你可以使用  Contracts UI 来尝试使用它们。</p>
<h4 id="get函数"><a class="header" href="#get函数">get()函数</a></h4>
<p>当你实例化合约时，将 <code>flipper</code> 合约 <code>value</code> 的初始值设置为 <code>false</code>。你可以使用 <code>get()</code> 函数去验证当前值是否为 <code>false</code>。</p>
<p>为了测试 <code>get()</code> 函数，从 <strong>Account</strong> 列表中选择任意账户，此合约对允许谁发送这个 <code>get()</code> 请求没有限制，从 <strong>Message to Send</strong> 列表中选择 <strong>get(): bool</strong>，点击 <strong>Read</strong>，验证调用结果的返回值是否为 <code>false</code>。</p>
<p><img src="https://awesomeprogram.gitee.io/imgdata/tech_bc_subcallresget.jpg" alt="" /></p>
<h4 id="flip函数"><a class="header" href="#flip函数">flip()函数</a></h4>
<p><code>flip()</code> 函数把值从 <code>false</code> 改为 <code>true</code>。</p>
<p>为了测试 <code>flip()</code> 函数，从 <strong>Account</strong> 列表中选择任意预定义账户，<code>flip()</code> 函数是一个改变链状态的交易，需要一个有资金的帐户来执行调用。因此，你应该选择具有预定义余额的帐户，例如 <code>alice</code> 帐户。从 <strong>Message to Send</strong> 列表中选择 <strong>flip()</strong>，点击 <strong>Call</strong>，验证调用结果中的交易是否成功。</p>
<p><img src="https://awesomeprogram.gitee.io/imgdata/tech_bc_subsucctran.jpg" alt="" /></p>
<p>从 <strong>Message to Send</strong> 列表中选择 <strong>get(): bool</strong>，点击 <strong>Read</strong>，验证调用结果中的新值是 <code>true</code>。</p>
<p><img src="https://awesomeprogram.gitee.io/imgdata/tech_bc_subfliptrue.jpg" alt="" /></p>
<h2 id="开发一份智能合约"><a class="header" href="#开发一份智能合约">开发一份智能合约</a></h2>
<p>在本节教程中，你将开发一个新的智能合约，它将在每次执行函数调用时增加计数器值。</p>
<h3 id="智能合约与ink"><a class="header" href="#智能合约与ink">智能合约与ink!</a></h3>
<p>在上一节教程（准备第一份智能合约）之后，你已经位命令行访问 ink! 编程语言安装了 <code>cargo-contract</code> 包。ink! 语言是<a href="https://wiki.haskell.org/Embedded_domain_specific_language">嵌入式领域特定语言</a>。此语言使你能够使用 Rust 编程语言编写基于 WebAssembly 的智能合约。</p>
<p>该语言使用标准的 Rust 模式和专用的 <code>#[ink(...)]</code> 属性宏。这些属性宏描述了智能合约的不同部分，这样它们就可以被转换为与 Substrate 兼容的 WebAssembly 字节码。</p>
<h3 id="创建一份新的智能合约项目"><a class="header" href="#创建一份新的智能合约项目">创建一份新的智能合约项目</a></h3>
<p>本节教程中，你将会为 <code>incrementer</code> 智能合约创建一个新项目。创建的新项目会添加一个项目文件夹，在项目文件夹中有一个默认的启动文件，也可以叫做模板文件。你将会为 <code>incrementer</code> 项目修改这些启动模板文件，来构建智能合约所需的逻辑。</p>
<p>通过运行下面的命令创建一个名为 <code>incrementer</code> 的新项目：</p>
<pre><code class="language-bash editable noplayground">cargo contract new incrementer
</code></pre>
<p>进入 <strong>incrementer</strong> 文件夹后，打开 <code>lib.rs</code> 文件，默认情况下，<code>lib.rs</code> 模板文件包含 <code>flipper</code> 智能合约的源代码，只是把 <code>flipper</code> 合约的实例重命名为 <code>incrementer</code>。把默认模板的源代码替换为新的 <a href="https://docs.substrate.io/assets/tutorials/smart-contracts/incrementer-template.rs/"><strong>incrementer</strong></a> 源码。保存 <code>lib.rs</code> 文件的改变并关闭。</p>
<p>打开 <code>Cargo.toml</code> 文件，并为合约检查相关的依赖包。在 <code>[dependencies]</code> 部分，如果需要的话，修改 <code>scale</code> 和 <code>scale-info</code> 配置内容。</p>
<pre><code class="language-toml editable noplayground">scale = { package = &quot;parity-scale-codec&quot;, version = &quot;3&quot;, default-features = false, features = [&quot;derive&quot;] }
scale-info = { version = &quot;2&quot;, default-features = false, features = [&quot;derive&quot;], optional = true }
</code></pre>
<p>保存代码并关闭 <code>Cargo.toml</code> 文件。</p>
<p>通过运行下面的命令，验证程序是否编译并通过了简单的测试：</p>
<pre><code class="language-bash editable noplayground">cargo +nightly test
</code></pre>
<p>你可以忽略任何警告，因为此模板只是框架代码，该命令应显示类似以下的输出，以表示成功完成测试：</p>
<pre><code class="language-bash editable noplayground">running 1 test
test incrementer::tests::default_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
<p>通过运行以下命令，验证你可以为合约构建 WebAssembly。</p>
<pre><code class="language-bash editable noplayground">cargo +nightly contract build
</code></pre>
<p>如果程序成功编译，你就可以开始编码了。</p>
<h3 id="存储简单的值"><a class="header" href="#存储简单的值">存储简单的值</a></h3>
<p>现在已经有了一些 <code>incrementer</code> 智能合约的初始源代码，你可以再引入一些新的功能。例如，该合约需要存储简单的值。下面的代码解释了如何使用 <code>#[ink(storage)]</code> 属性宏为该合约存储简单的值。</p>
<pre><code class="language-rust editable noplayground">#[ink(storage)]
pub struct MyContract {
	// Store a bool
	my_bool: bool,
	// Store a number
	my_number: u32,
}
</code></pre>
<h4 id="支持的类型-1"><a class="header" href="#支持的类型-1">支持的类型</a></h4>
<p>Substrate 智能合约支持最常见的 Rust 数据类型，包括布尔类型，未签名和已签名的整数型，字符串，元组，以及数组。这些数据类型使用 <a href="https://github.com/paritytech/parity-scale-codec"><strong>Parity scale codec</strong></a> 进行编码和解码，以便可以在网络上高效的传输。</p>
<p>除了常见的 Rust 类型使用 scale codec 进行编码解码外，ink! 语言支持 Substrate 特性类型，像 <code>AccountId</code>，<code>Balance</code>，和 <code>Hash</code>，就好像它们是原始类型。下面的代码说明了如何为该合约存储一个 <code>AccountId</code> 和 <code>Balance</code>。</p>
<pre><code class="language-rust editable noplayground">// We are importing the default ink! types
use ink_lang as ink;

#[ink::contract]
mod MyContract {

	// Our struct will use those default ink! types
	#[ink(storage)]
	pub struct MyContract {
		// Store some AccountId
		my_account: AccountId,
		// Store some Balance
		my_balance: Balance,
	}
	/* --snip-- */
}
</code></pre>
<h4 id="构造函数"><a class="header" href="#构造函数">构造函数</a></h4>
<p>每一个 ink! 智能合约必须至少有一个在创建合约时运行的构造函数。然而，如果你需要，一个智能合约也可以有多个多个构造函数。下面的代码说明了如何使用多个构造函数：</p>
<pre><code class="language-rust editable noplayground">use ink_lang as ink;

#[ink::contract]
mod mycontract {

	#[ink(storage)]
	pub struct MyContract {
		number: u32,
	}

	impl MyContract {
		/// Constructor that initializes the `u32` value to the given `init_value`.
		#[ink(constructor)]
		pub fn new(init_value: u32) -&gt; Self {
			Self {
				number: init_value,
			}
		}

		/// Constructor that initializes the `u32` value to the `u32` default.
		///
		/// Constructors can delegate to other constructors.
		#[ink(constructor)]
		pub fn default() -&gt; Self {
			Self {
				number: Default::default(),
			}
		}
	/* --snip-- */
	}
}
</code></pre>
<h3 id="更新你的智能合约"><a class="header" href="#更新你的智能合约">更新你的智能合约</a></h3>
<p>现在你已经了解到如何存储简单的值，声明数据类型，以及使用构造函数，你可以更新你的智能合约源代码以实现下面的功能：</p>
<ul>
<li>创建一个名为 <code>value</code> 的存储值，数据类型为 <code>i32</code>。</li>
<li>创建一个新的 <code>Incrementer</code> 构造函数，并且将它的 <code>value</code> 设置为 <code>init_value</code>。</li>
<li>创建第二个名叫 <code>default</code> 的构造函数，该函数没有输入参数，并创建一个新的 <code>Incrementer</code>，将其 <code>value</code> 设置为 <code>0</code>。</li>
</ul>
<p>为了更新智能合约，打开 <code>lib.rs</code> 文件，通过声明名为 <code>value</code> 数据类型为 <code>i32</code> 的存储项，从而替换 <code>Storage Declaration</code> 注释。</p>
<pre><code class="language-rust editable noplayground">#[ink(storage)]
pub struct Incrementer {
   value: i32,
}
</code></pre>
<p>修改 <code>Incrementer</code> 构造函数，将其 <code>value</code> 设置为 <code>init_value</code>。</p>
<pre><code class="language-rust editable noplayground">impl Incrementer {
 #[ink(constructor)]
 pub fn new(init_value: i32) -&gt; Self {
       Self {
         value: init_value,
       }
 }
}
</code></pre>
<p>添加第二个名为 <code>default</code> 的构造函数，该函数创建一个新的 <code>Incrementer</code>，将其 <code>value</code> 设置为 <code>0</code>。</p>
<pre><code class="language-rust editable noplayground">#[ink(constructor)]
pub fn default() -&gt; Self {
   Self {
       value: 0,
   }
}
</code></pre>
<p>保存代码并关闭文件。</p>
<p>通过运行下面的命令使用 <code>test</code> 子命令和 <code>nightly</code> 工具链来测试你的工作。</p>
<pre><code class="language-rust editable noplayground">cargo +nightly test
</code></pre>
<p>该命令应该显示类似如下的输出，以表明测试成功完成：</p>
<pre><code class="language-bash editable noplayground">running 1 test
test incrementer::tests::default_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
<h3 id="添加一个函数来获取一个存储值"><a class="header" href="#添加一个函数来获取一个存储值">添加一个函数来获取一个存储值</a></h3>
<p>现在你已经创建并初始化了存储值，可以使用公共和私有函数与它进行交互。在本节教程中，你将添加一个公共函数来获取存储值。请注意，所有公共函数都必须使用 <code>#[ink(message)]</code> 属性宏。</p>
<p>在智能合约中添加公共函数，打开 <code>lib.rs</code> 文件，更新 <code>get</code> 公共函数，以返回数据类型为 <code>i32</code> 的存储项的 <code>value</code>。</p>
<pre><code class="language-rust editable noplayground">#[ink(message)]
pub fn get(&amp;self) -&gt; i32 {
   self.value
}
</code></pre>
<p>因为这个函数只从合约存储中读取数据，所以它使用 <code>&amp;self</code> 参数来访问合约函数和存储项，此函数不允许更改存储项 <code>value</code> 的状态。如果函数中的最后一个表达式没有分号（;），Rust 将则将其视为返回值。</p>
<p>将私有 <code>default_works</code> 函数中的 <code>Test Your Contract</code> 注释替换为测试 <code>get</code> 函数的代码。</p>
<pre><code class="language-rust editable noplayground">fn default_works() {
   let contract = Incrementer::default();
   assert_eq!(contract.get(), 0);
}
</code></pre>
<p>保存代码并关闭文件。</p>
<p>通过运行下面的命令使用 <code>test</code> 子命令和 <code>nightly</code> 工具链来测试你的工作。</p>
<pre><code class="language-bash editable noplayground">cargo +nightly test
</code></pre>
<h3 id="添加一个函数以修改一个存储值"><a class="header" href="#添加一个函数以修改一个存储值">添加一个函数以修改一个存储值</a></h3>
<p>此时，智能合约不允许用户修改存储项，要使用户能够修改存储项，必须将 <code>value</code> 显式标记为可变变量。</p>
<p>添加一个函数以增加存储项的值，打开 <code>lib.rs</code> 文件，添加一个新的 <code>inc</code> 公共函数以增加 <code>value</code> 存储，使用数据类型是 <code>i32</code> 的 <code>by</code> 参数</p>
<pre><code class="language-rust editable noplayground">#[ink(message)]
pub fn inc(&amp;mut self, by: i32) {
   self.value += by;
}
</code></pre>
<p>向源代码中添加一个新测试，以验证此函数。</p>
<pre><code class="language-rust editable noplayground">#[ink::test]
   fn it_works() {
       let mut contract = Incrementer::new(42);
       assert_eq!(contract.get(), 42);
       contract.inc(5);
       assert_eq!(contract.get(), 47);
       contract.inc(-50);
       assert_eq!(contract.get(), -3);
}
</code></pre>
<p>保存代码并关闭文件。</p>
<p>通过运行下面的命令使用 <code>test</code> 子命令和 <code>nightly</code> 工具链来测试你的工作。</p>
<pre><code class="language-bash editable noplayground">cargo +nightly test
</code></pre>
<p>该命令应该显示类似如下的输出，以表明测试成功完成：</p>
<pre><code class="language-bash editable noplayground">running 2 tests
test incrementer::tests::it_works ... ok
test incrementer::tests::default_works ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
<h4 id="为合约构建webassembly"><a class="header" href="#为合约构建webassembly">为合约构建WebAssembly</a></h4>
<p>在测试 <code>incrementer</code> 合约之后，就可以将此项目编译为 WebAssembly 了。将智能合约编译到 WebAssembly 后，你可以使用 <a href="https://contracts-ui.substrate.io/">Contracts UI</a> 在本地合约节点上部署和测试智能合约。</p>
<p>为智能合约构建WebAssembly，在 <code>incrementer</code> 项目文件夹里，通过运行下面的命令编译 <code>incrementer</code> 智能合约：</p>
<pre><code class="language-bash editable noplayground">cargo +nightly contract build
</code></pre>
<p>该命令显示如下类似的输出：</p>
<pre><code class="language-bash editable noplayground">Your contract artifacts are ready. You can find them in:
/Users/dev-docs/incrementer/target/ink

- incrementer.contract (code + metadata)
- incrementer.wasm (the contract's code)
- metadata.json (the contract's metadata)
</code></pre>
<h3 id="部署与测试智能合约"><a class="header" href="#部署与测试智能合约">部署与测试智能合约</a></h3>
<p>如果你已经在本地安装了 <code>substrate-contracts-node</code> 节点，你可以为智能合约启动一个本地区块链节点，然后使用 <a href="https://contracts-ui.substrate.io/">Contracts UI</a> 去部署和测试智能合约。</p>
<p>通过运行以下命令，在本地开发模式下启动合约节点：</p>
<pre><code class="language-bash editable noplayground">substrate-contracts-node --dev
</code></pre>
<p>打开 <a href="https://contracts-ui.substrate.io/">Contracts UI</a> 并验证其是否连接到本地节点。
点击 <strong>Add New Contract</strong>。
点击 <strong>Upload New Contract Code</strong>。
选择 <code>incrementer.contract</code> 文件，然后点击 <strong>Next</strong>。
点击 <strong>Upload and Instantiate</strong>。
使用 Contracts UI 探索智能合约并与之交互。</p>
<p>完整的合约代码：</p>
<pre><code class="language-rust editable noplayground">
#![cfg_attr(not(feature = &quot;std&quot;), no_std)]

use ink_lang as ink;

#[ink::contract]
mod incrementer {

    #[ink(storage)]
    pub struct Incrementer {
        value: i32,
    }

    impl Incrementer {
        #[ink(constructor)]
        pub fn new(init_value: i32) -&gt; Self {
            Self {
                value: init_value,
            }
        }

        #[ink(constructor)]
        pub fn default() -&gt; Self {
            Self {
                value: Default::default(),
            }
        }

        #[ink(message)]
        pub fn get(&amp;self) -&gt; i32 {
            self.value
        }

        #[ink(message)]
        pub fn inc(&amp;mut self, by: i32) {
            self.value += by;
        }
    }

    #[cfg(test)]
    mod tests {
        use super::*;
        use ink_lang as ink;

        #[ink::test]
        fn default_works() {
            let contract = Incrementer::default();
            assert_eq!(contract.get(), 0);
        }

        #[ink::test]
        fn it_works() {
            let mut contract = Incrementer::new(42);
            assert_eq!(contract.get(), 42);
            contract.inc(5);
            assert_eq!(contract.get(), 47);
            contract.inc(-50);
            assert_eq!(contract.get(), -3);
        }
    }
}
</code></pre>
<h2 id="使用maps存储值"><a class="header" href="#使用maps存储值">使用maps存储值</a></h2>
<p>本节教程说明了如何可以扩展智能合约的功能，以管理每个用户的一个号码。要添加这个功能，你将会使用 <a href="https://paritytech.github.io/ink/ink_storage/struct.Mapping.html"><code>Mapping</code></a> 类型。</p>
<p>ink! 语言提供 <a href="https://paritytech.github.io/ink/ink_storage/struct.Mapping.html"><code>Mapping</code></a> 类型，使你能够将数据存储为键值对。例如，下面的代码说明了映射一个用户到一个号码。</p>
<pre><code class="language-rust editable noplayground">#[ink(storage)]
pub struct MyContract {
	// Store a mapping from AccountIds to a u32
	my_number_map: ink_storage::Mapping&lt;AccountId, u32&gt;,
}
</code></pre>
<p>使用 <code>Mapping</code> 数据类型，可以为每个键存储值的唯一实例。本节教程中，每一个 <code>AccountId</code> 代表一个键，该键映射到一个且仅一个存储的数字 <code>my_value</code>。每个用户只能存储、增加和检索与其自己的 <code>AccountId</code> 关联的值。</p>
<h3 id="初始化一个mapping"><a class="header" href="#初始化一个mapping">初始化一个mapping</a></h3>
<p>第一步是初始化 <code>AccountId</code> 和存储值之间的映射。在你的合约中使用映射之前，你必须始终初始化映射，以避免映射错误和不一致。要初始化映射，需要执行以下操作：</p>
<ul>
<li>在存储结构上添加 <a href="https://paritytech.github.io/ink/ink_storage/traits/trait.SpreadAllocate.html"><code>SpreadAllocate</code></a></li>
<li>指定映射键和映射到它的值。</li>
<li>调用 <a href="https://paritytech.github.io/ink/ink_lang/utils/fn.initialize_contract.html"><code>ink_lang::utils::initalize_contract</code></a> 函数来初始化合约的映射。</li>
</ul>
<p>以下示例说明如何初始化一个映射并检索一个值：</p>
<pre><code class="language-rust editable noplayground">#![cfg_attr(not(feature = &quot;std&quot;), no_std)]

use ink_lang as ink;

#[ink::contract]
mod mycontract {
    use ink_storage::traits::SpreadAllocate;

    #[ink(storage)]
    #[derive(SpreadAllocate)]
    pub struct MyContract {
        // Store a mapping from AccountIds to a u32
        map: ink_storage::Mapping&lt;AccountId, u32&gt;,
    }

    impl MyContract {
        #[ink(constructor)]
        pub fn new(count: u32) -&gt; Self {
            // This call is required to correctly initialize the
            // Mapping of the contract.
            ink_lang::utils::initialize_contract(|contract: &amp;mut Self| {
                let caller = Self::env().caller();
                contract.map.insert(&amp;caller, &amp;count);
            })
        }

        #[ink(constructor)]
        pub fn default() -&gt; Self {
            ink_lang::utils::initialize_contract(|_| {})
        }

        // Get the number associated with the caller's AccountId, if it exists
        #[ink(message)]
        pub fn get(&amp;self) -&gt; u32 {
            let caller = Self::env().caller();
            self.map.get(&amp;caller).unwrap_or_default()
        }
    }
}
</code></pre>
<h4 id="识别合约的调用者"><a class="header" href="#识别合约的调用者">识别合约的调用者</a></h4>
<p>在前面的例子中，你可能注意到了 <code>self.env().caller()</code> 函数调用。这个函数在整个合约逻辑中都是可用的，并且总是返回 <strong>contract caller</strong>。重要的是要注意，<strong>contract caller</strong> 与 <strong>origin caller</strong> 是不同的。如果用户访问一个合约，然后再调用后来的合约，那么第二个合约中的 <code>self.env().caller()</code> 是第一个合约的地址，而不是 original user 的地址。</p>
<h4 id="使用合约的调用者"><a class="header" href="#使用合约的调用者">使用合约的调用者</a></h4>
<p>在许多情况下，合约调用者都是有用的。例如，你可以使用 <code>self.env().caller()</code> 来创建一个访问控制层，该层只允许用户访问自己的值。你还可以使用 <code>self.env().caller()</code> 在合同部署期间保存合约所有者。例如：</p>
<pre><code class="language-rust editable noplayground">#![cfg_attr(not(feature = &quot;std&quot;), no_std)]

use ink_lang as ink;

#[ink::contract]
mod mycontract {

	#[ink(storage)]
	pub struct MyContract {
		// Store a contract owner
		owner: AccountId,
	}

	impl MyContract {
		#[ink(constructor)]
		pub fn new() -&gt; Self {
			Self {
				owner: Self::env().caller();
			}
		}
		/* --snip-- */
	}
}
</code></pre>
<p>因为你已经使用 <code>owner</code> 标识符保存了合约调用者，所以你可以再后面编写函数来检查当前合约调用者是否是合同的所有者。</p>
<h3 id="添加mapping到智能合约中"><a class="header" href="#添加mapping到智能合约中">添加mapping到智能合约中</a></h3>
<p>为 <code>incrementer</code> 合约添加 storage map，在 <code>incrementer</code> 项目文件夹中，打开 <code>lib.rs</code>，为你的合约导入 <code>SpreadAllocate</code> 特征并追加派生宏。</p>
<pre><code class="language-rust editable noplayground">#[ink::contract]
mod incrementer {
   use ink_storage::traits::SpreadAllocate;

   #[ink(storage)]
   #[derive(SpreadAllocate)]
</code></pre>
<p>将映射键从 <code>AccountId</code> 添加到存储为 <code>my_value</code> 的 <code>i32</code> 数据类型。</p>
<pre><code class="language-rust editable noplayground">pub struct Incrementer {
   value: i32,
   my_value: ink_storage::Mapping&lt;AccountId, i32&gt;,
}
</code></pre>
<p>使用 <code>initialize_contract</code> 函数为合约中的 <code>new</code> 函数设置一个初始 <code>value</code> 和 <code>my_value</code>。</p>
<pre><code class="language-rust editable noplayground">#[ink(constructor)]
pub fn new(init_value: i32) -&gt; Self {
   ink_lang::utils::initialize_contract(|contract: &amp;mut Self| {
       contract.value = init_value;
       let caller = Self::env().caller();
       contract.my_value.insert(&amp;caller, &amp;0);
   })
}
</code></pre>
<p>使用 <code>initialize_contract</code> 函数为合约中的 <code>default</code> 函数设置一个初始 <code>value</code>。</p>
<pre><code class="language-rust editable noplayground">#[ink(constructor)]
pub fn default() -&gt; Self {
   ink_lang::utils::initialize_contract(|contract: &amp;mut Self| {
       contract.value = Default::default();
   })
}
</code></pre>
<p>添加一个 <code>get_mine</code> 函数，使用 Mapping API <code>get</code> 函数读取 <code>my_value</code>，并为合约调用者返回 <code>my_value</code>。</p>
<pre><code class="language-rust editable noplayground">#[ink(message)]
pub fn get_mine(&amp;self) -&gt; i32 {
   self.my_value.get(&amp;self.env().caller()).unwrap_or_default()
}
</code></pre>
<p>向初始化帐户添加一个新测试。</p>
<pre><code class="language-rust editable noplayground">#[ink::test]
fn my_value_works() {
   let contract = Incrementer::new(11);
   assert_eq!(contract.get(), 11);
   assert_eq!(contract.get_mine(), 0);
}
</code></pre>
<p>保存代码并关闭文件。</p>
<p>通过运行下面的命令使用 <code>test</code> 子命令和 <code>nightly</code> 工具链来测试你的工作。</p>
<pre><code class="language-bash editable noplayground">cargo +nightly test
</code></pre>
<p>该命令应该显示类似如下的输出，以表明测试成功完成：</p>
<pre><code class="language-bash editable noplayground">running 3 tests
test incrementer::tests::default_works ... ok
test incrementer::tests::it_works ... ok
test incrementer::tests::my_value_works ... ok

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
<h3 id="插入更新或删除值"><a class="header" href="#插入更新或删除值">插入，更新或删除值</a></h3>
<p><code>ink_storage</code> 映射提供对存储项的直接访问。例如，你可以用一个已存在的键调用 <code>Mapping::insert()</code> 来替换存储项之前保存的值。你也可以通过使用 <code>Mapping::insert()</code> 在存储中第一次读取值时，然后用 <code>Mapping::insert()</code> 更新这个值。如果不存在给定键的值，则 <code>Mapping::get()</code> 返回 <code>None</code>。因为 Mapping API 提供了对存储的直接访问，所以可以使用 <code>Mapping::remove()</code> 方法从存储中删除给定键的值。</p>
<p>要添加插入和删除函数到合约中，在 <code>incrementer</code> 项目文件夹中，打开 <code>lib.rs</code> 文件，添加一个 <code>inc_mine()</code> 函数，它允许合约调用者获取 <code>my_value</code> 存储项，并且在映射中插入递增的 <code>value</code>。</p>
<pre><code class="language-rust editable noplayground">#[ink(message)]
pub fn inc_mine(&amp;mut self, by: i32) {
   let caller = self.env().caller();
   let my_value = self.get_mine();
   self.my_value.insert(caller, &amp;(my_value + by));
}
</code></pre>
<p>添加一个 <code>remove_mine()</code> 函数，该函数允许合约调用者从存储中获取可删除的 <code>my_value</code> 存储项。</p>
<pre><code class="language-rust editable noplayground">#[ink(message)]
pub fn remove_mine(&amp;mut self) {
   self.my_value.remove(&amp;self.env().caller())
}
</code></pre>
<p>添加一个新测试，以验证 <code>inc_mine()</code> 函数是否按预期工作。</p>
<pre><code class="language-rust editable noplayground">#[ink::test]
fn inc_mine_works() {
   let mut contract = Incrementer::new(11);
   assert_eq!(contract.get_mine(), 0);
   contract.inc_mine(5);
   assert_eq!(contract.get_mine(), 5);
   contract.inc_mine(5);
   assert_eq!(contract.get_mine(), 10);
}
</code></pre>
<p>通过运行下面的命令使用 <code>test</code> 子命令和 <code>nightly</code> 工具链来测试你的工作。</p>
<pre><code class="language-bash editable noplayground">cargo +nightly test
</code></pre>
<p>该命令应该显示类似如下的输出，以表明测试成功完成：</p>
<pre><code class="language-bash editable noplayground">running 5 tests
test incrementer::tests::default_works ... ok
test incrementer::tests::it_works ... ok
test incrementer::tests::remove_mine_works ... ok
test incrementer::tests::inc_mine_works ... ok
test incrementer::tests::my_value_works ... ok

test result: ok. 5 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
<p>完整的代码如下：</p>
<pre><code class="language-rust editable noplayground">#![cfg_attr(not(feature = &quot;std&quot;), no_std)]

use ink_lang as ink;

#[ink::contract]
mod incrementer {
    use ink_storage::traits::SpreadAllocate;

    #[ink(storage)]
    #[derive(SpreadAllocate)]
    pub struct Incrementer {
        value: i32,
        my_value: ink_storage::Mapping&lt;AccountId, i32&gt;,
    }

    impl Incrementer {
        #[ink(constructor)]
        pub fn new(init_value: i32) -&gt; Self {
            // This call is required in order to correctly initialize the
            // `Mapping`s of our contract.
            ink_lang::utils::initialize_contract(|contract: &amp;mut Self| {
                contract.value = init_value;
                let caller = Self::env().caller();
                contract.my_value.insert(&amp;caller, &amp;0);
            })
        }

        #[ink(constructor)]
        pub fn default() -&gt; Self {
            // Even though we're not explicitly initializing the `Mapping`,
            // we still need to call this
            ink_lang::utils::initialize_contract(|contract: &amp;mut Self| {
                contract.value = Default::default();
            })
        }

        #[ink(message)]
        pub fn get(&amp;self) -&gt; i32 {
            self.value
        }

        #[ink(message)]
        pub fn inc(&amp;mut self, by: i32) {
            self.value += by;
        }

        #[ink(message)]
        pub fn get_mine(&amp;self) -&gt; i32 {
            self.my_value.get(&amp;self.env().caller()).unwrap_or_default()
        }

        #[ink(message)]
        pub fn inc_mine(&amp;mut self, by: i32) {
            let caller = self.env().caller();
            let my_value = self.get_mine();
            self.my_value.insert(caller, &amp;(my_value + by));
        }

        #[ink(message)]
        pub fn remove_mine(&amp;self) {
            self.my_value.remove(&amp;self.env().caller())
        }
    }

    #[cfg(test)]
    mod tests {
        use super::*;

        use ink_lang as ink;

        #[ink::test]
        fn default_works() {
            let contract = Incrementer::default();
            assert_eq!(contract.get(), 0);
        }

        #[ink::test]
        fn it_works() {
            let mut contract = Incrementer::new(42);
            assert_eq!(contract.get(), 42);
            contract.inc(5);
            assert_eq!(contract.get(), 47);
            contract.inc(-50);
            assert_eq!(contract.get(), -3);
        }

        #[ink::test]
        fn my_value_works() {
            let mut contract = Incrementer::new(11);
            assert_eq!(contract.get(), 11);
            assert_eq!(contract.get_mine(), 0);
            contract.inc_mine(5);
            assert_eq!(contract.get_mine(), 5);
            contract.inc_mine(10);
            assert_eq!(contract.get_mine(), 15);
        }

        #[ink::test]
        fn inc_mine_works() {
            let mut contract = Incrementer::new(11);
            assert_eq!(contract.get_mine(), 0);
            contract.inc_mine(5);
            assert_eq!(contract.get_mine(), 5);
            contract.inc_mine(5);
            assert_eq!(contract.get_mine(), 10);
        }

        #[ink::test]
        fn remove_mine_works() {
            let mut contract = Incrementer::new(11);
            assert_eq!(contract.get_mine(), 0);
            contract.inc_mine(5);
            assert_eq!(contract.get_mine(), 5);
            contract.remove_mine();
            assert_eq!(contract.get_mine(), 0);
        }
    }
}
</code></pre>
<h2 id="构建一个token合约"><a class="header" href="#构建一个token合约">构建一个token合约</a></h2>
<p>本节教程演示了如何使用 ink! 语言构建 ERC-20 代币合约，ERC-20 规范定义了可替换代币的通用标准。拥有定义代币属性的标准，使遵循规范的开发人员，能够构建与其他产品和服务互操作的应用程序。ERC-20 代币标准不是唯一的代币标准，但它是最常用的标准之一。</p>
<h3 id="erc-20标准的基础知识"><a class="header" href="#erc-20标准的基础知识">ERC-20标准的基础知识</a></h3>
<p>ERC-20 代币标准定义了运行在以太坊区块链上的大多数智能合约的接口。这些标准接口允许个人在现有的智能合约平台上部署自己的加密货币。</p>
<p>如果你查看该标准，你会发现有如下被定义的核心函数：</p>
<pre><code class="language-javascript editable noplayground">// ----------------------------------------------------------------------------
// ERC Token Standard #20 Interface
// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md
// ----------------------------------------------------------------------------

contract ERC20Interface {
    // Storage Getters
    function totalSupply() public view returns (uint);
    function balanceOf(address tokenOwner) public view returns (uint balance);
    function allowance(address tokenOwner, address spender) public view returns (uint remaining);

    // Public Functions
    function transfer(address to, uint tokens) public returns (bool success);
    function approve(address spender, uint tokens) public returns (bool success);
    function transferFrom(address from, address to, uint tokens) public returns (bool success);

    // Contract Events
    event Transfer(address indexed from, address indexed to, uint tokens);
    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);
}
</code></pre>
<p>用户余额映射到帐户地址，接口允许用户转移他们拥有的代币或允许第三方代表他们转移代币。最重要的是，必须实现智能合约逻辑，以确保资金不会被无意创建或销毁，并保护用户的资金免受恶意参与者的攻击。请注意，所有公共函数都返回一个 <code>bool</code> 值，该 <code>bool</code> 值仅指示调用是否成功。在Rust中，这些函数通常会返回一个 <code>Result</code>。</p>
<h3 id="创建token供应"><a class="header" href="#创建token供应">创建token供应</a></h3>
<p>处理 <code>ERC-20</code> 代币的智能合约类似于上一节教程<a href="blockchain/chapter_1_2_1_5.html#%E4%BD%BF%E7%94%A8maps%E5%AD%98%E5%82%A8%E5%80%BC">使用maps存储值</a>的 Incrementer 合约。对于本教程，ERC-20 合约由固定的代币供应组成，当部署合同时，这些代币全部存入与合同所有者相关联的帐户。然后，合同所有者可以将代币分发给其他用户。在本教程中创建的简单 ERC-20 合约并不是制造和分发代币的唯一方法。然而，这个 ERC-20 合约为扩展你在其他教程中所学到的知识，以及如何使用 ink! 语言用于构建更健壮的智能合约，提供了一个良好的基础。</p>
<p>对于 ERC-20 代币合约，初始存储包括：</p>
<ul>
<li><code>total_supply</code> 代表合约中代币的总供应量。</li>
<li><code>balances</code> 表示每个账户的个人余额。</li>
</ul>
<p>要构建一个 ERC-20 代币智能合约，通过运行以下命令创建一个名为 <code>erc20</code> 的新项目：</p>
<pre><code class="language-bash editable noplayground">cargo contract new erc20
</code></pre>
<p>在 <code>erc20</code> 目录中打开 <code>lib.rs</code> 文件，使用新 <a href="https://docs.substrate.io/assets/tutorials/smart-contracts/erc20-template.rs/">erc20</a> 源码替换默认的模板源码。</p>
<p>保存代码改变并关闭文件。</p>
<p>打开 <code>Cargo.toml</code> 文件，并检查合约的依赖关系。</p>
<p>如有必要，在 <code>[dependencies]</code> 部分，修改 <code>scale</code> 和 <code>scale-info</code> 的配置：</p>
<pre><code class="language-toml editable noplayground">scale = { package = &quot;parity-scale-codec&quot;, version = &quot;3&quot;, default-features = false, features = [&quot;derive&quot;] }
scale-info = { version = &quot;2&quot;, default-features = false, features = [&quot;derive&quot;], optional = true }
</code></pre>
<p>保存代码改变并关闭文件。</p>
<p>通过运行下面的命令，验证程序是否编译并通过了简单的测试：</p>
<pre><code class="language-bash editable noplayground">cargo +nightly test
</code></pre>
<p>该命令应该显示类似如下的输出，以表明测试成功完成：</p>
<pre><code class="language-bash editable noplayground">running 2 tests
test erc20::tests::new_works ... ok
test erc20::tests::balance_works ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
<p>通过运行以下命令，验证你可以为合约构建 WebAssembly。</p>
<pre><code class="language-bash editable noplayground">cargo +nightly contract build
</code></pre>
<p>如果程序编译成功，您就可以在当前状态上传它，或者开始向合约添加功能。</p>
<h3 id="上传并实例化合约"><a class="header" href="#上传并实例化合约">上传并实例化合约</a></h3>
<p>如果你想测试到目前为止所有的内容，你可以使用 <a href="https://contracts-ui.substrate.io/">Contracts UI</a> 上传该合约。</p>
<p>在添加新功能之前测试 ERC-20 合同：</p>
<ol>
<li>启动本地合约节点。</li>
<li>上传 <code>erc20.contract</code> 文件。</li>
<li>为 <code>new</code> 构造函数指定代币的初始供应。</li>
<li>在运行的本地节点上实例化合同。</li>
<li>选择 <code>totalSupply</code> 作为要发送的消息，然后点击 <strong>Read</strong> 以验证代币的总供应与初始供应相同。</li>
<li>选择 <code>balanceOf</code> 作为要发送的消息。</li>
<li>选择用于实例化合约的帐户 <code>AccountId</code>，然后点击 <strong>Read</strong>。
如果选择任何其他 <code>AccountId</code>，则点击 <strong>Read</strong>，余额为零，因为所有代币均由合约所有者所有。</li>
</ol>
<h3 id="转移tokens"><a class="header" href="#转移tokens">转移tokens</a></h3>
<p>此时，ERC-20 合约有一个用户帐户，该帐户拥有该合约代币的 total_supply。为了使该合约有用，合约所有者必须能够将代币转移到其他帐户。对于这个简单的 ERC-20 合约，你将添加一个公共 <code>transfer</code> 函数，使你作为合约调用者能够将你拥有的代币转移给另一个用户。</p>
<p>公共 <code>transfer</code> 函数调用私有 <code>transfer_from_to()</code> 函数。因为这是一个内部函数，所以不需要任何授权检查就可以调用它。但是，转账逻辑必须能够确定 <code>from</code> 帐户是否具有可转移到接收方 <code>to</code> 帐户的代币数量。<code>transfer_from_to()</code> 函数使用合约调用者（<code>self.env().caller()</code>）作为 <code>from</code> 帐户。在此上下文中，<code>transfer_from_to()</code> 函数执行以下操作：</p>
<ul>
<li>获取 <code>from</code> 帐户和 <code>to</code> 帐户的当前余额。</li>
<li>检查 <code>from </code> 余额是否小于要发送的代币的 <code>value </code>。</li>
</ul>
<pre><code class="language-rust editable noplayground">let from_balance = self.balance_of(from);
if from_balance &lt; value {
return Err(Error::InsufficientBalance)
}
</code></pre>
<p>从转移账户中减去该值，并将该值添加到接收账户。</p>
<pre><code class="language-rust editable noplayground">self.balances.insert(from, &amp;(from_balance - value));
let to_balance = self.balance_of(to);
self.balances.insert(to, &amp;(to_balance + value));
</code></pre>
<p>要添加转移函数到智能合约，在 <code>erc20</code> 项目目录中，打开 <code>lib.rs</code> 文件，添加一个 <code>Error</code> 声明，以在帐户中没有足够的代币来完成转账时返回一个错误。</p>
<pre><code class="language-rust editable noplayground">/// Specify ERC-20 error type.
#[derive(Debug, PartialEq, Eq, scale::Encode, scale::Decode)]
#[cfg_attr(feature = &quot;std&quot;, derive(scale_info::TypeInfo))]
pub enum Error {
/// Return if the balance cannot fulfill a request.
   InsufficientBalance,
}
</code></pre>
<p>添加一个 <code>Result</code> 返回类型，以返回 <code>InsufficientBalance</code> 错误。</p>
<pre><code class="language-rust editable noplayground">/// Specify the ERC-20 result type.
pub type Result&lt;T&gt; = core::result::Result&lt;T, Error&gt;;
</code></pre>
<p>添加 <code>transfer()</code> 公共函数，使合约调用者能够将代币转移到另一个帐户。</p>
<pre><code class="language-rust editable noplayground">#[ink(message)]
pub fn transfer(&amp;mut self, to: AccountId, value: Balance) -&gt; Result&lt;()&gt; {
   let from = self.env().caller();
   self.transfer_from_to(&amp;from, &amp;to, value)
}
</code></pre>
<p>添加 <code>transfer_from_to()</code> 私有函数，将代币从与合约调用者关联的帐户转移到接收帐户。</p>
<pre><code class="language-rust editable noplayground">fn transfer_from_to(
   &amp;mut self,
   from: &amp;AccountId,
   to: &amp;AccountId,
   value: Balance,
) -&gt; Result&lt;()&gt; {
    let from_balance = self.balance_of_impl(from);
    if from_balance &lt; value {
        return Err(Error::InsufficientBalance)
    }

    self.balances.insert(from, &amp;(from_balance - value));
    let to_balance = self.balance_of_impl(to);
    self.balances.insert(to, &amp;(to_balance + value));
    Ok(())
}
</code></pre>
<p>这段代码片段使用了 <code>balance_of_impl()</code> 函数，<code>balance_of_impl()</code> 函数与 <code>balance_of</code> 函数相同，不同的是它使用引用在 WebAssembly 中以更有效的方式查找帐户余额。在智能合约中添加如下函数即可使用该功能：</p>
<pre><code class="language-rust editable noplayground">#[inline]
fn balance_of_impl(&amp;self, owner: &amp;AccountId) -&gt; Balance {
   self.balances.get(owner).unwrap_or_default()
}
</code></pre>
<p>通过运行下面的命令，验证程序是否编译并通过了测试用例：</p>
<pre><code class="language-bash editable noplayground">cargo +nightly test
</code></pre>
<p>该命令应该显示类似如下的输出，以表明测试成功完成：</p>
<pre><code class="language-bash editable noplayground">running 3 tests
test erc20::tests::new_works ... ok
test erc20::tests::balance_works ... ok
test erc20::tests::transfer_works ... ok

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
<h3 id="创建事件"><a class="header" href="#创建事件">创建事件</a></h3>
<p>ERC-20 代币标准规定合约调用在提交一个交易时不能直接返回值。然而，你可能希望你的智能合约以某种方式发出已经发生事件的信号。例如，你可能希望你的智能合约显示交易完成的时间或转账通过的时间，你可以使用事件来发送这些类信号。你可以使用事件与任何类型的数据进行通信，为一个事件定义数据类似于定义 <code>struct</code>。事件应该使用 <code>#[ink(event)]</code> 属性被声明。</p>
<h4 id="添加一个转移事件"><a class="header" href="#添加一个转移事件">添加一个转移事件</a></h4>
<p>声明一个 <code>Transfer</code> 事件，以提供有关已完成转移操作的信息。<code>Transfer</code> 事件包含以下信息：</p>
<ul>
<li><code>Balance</code> 类型的值。</li>
<li><code>from</code> 帐户的一个 Option-wrapped <code>AccountId</code> 变量。</li>
<li><code>to</code> 帐户的一个 Option-wrapped <code>AccountId</code> 变量。</li>
</ul>
<p>为了更快地访问事件数据，可以使用索引字段。你可以通过在该字段上使用 <code>#[ink(topic)]</code> 属性标签来实现这一点。</p>
<p>要添加一个 <code>Transfer</code> 事件，打开 <code>lib.rs</code> 文件，使用 <code>#[ink(event)]</code> 属性宏声明事件。</p>
<pre><code class="language-rust editable noplayground">#[ink(event)]
pub struct Transfer {
   #[ink(topic)]
   from: Option&lt;AccountId&gt;,
   #[ink(topic)]
   to: Option&lt;AccountId&gt;,
   value: Balance,
 }
</code></pre>
<p>你可以使用 <code>.unwrap_or()</code> 函数为 <code>Option&lt;T&gt;</code> 变量检索数据。</p>
<h4 id="发出事件"><a class="header" href="#发出事件">发出事件</a></h4>
<p>现在你已经声明了事件并定义了事件包含的信息，接下来需要添加发出事件的代码。你可以通过调用 <code>self.env().emit_event()</code> 来实现这一点，将事件名称作为调用的唯一参数。</p>
<p>在这个 ERC-20 合约中，你希望在每次发生转移时发出一个 <code>Transfer</code> 事件，代码中有两个地方出现了这种情况</p>
<ul>
<li>在初始化合约的 <code>new</code> 调用期间。</li>
<li>每次调用 <code>transfer_from_to</code>。</li>
</ul>
<p><code>from</code> 和 <code>to</code> 字段的值是 <code>Option&lt;AccountId&gt;</code> 数据类型。然而，在 tokens 的初始转移过程中，为 initialsupply 设置的值不是来自任何其他帐户。在本例中，Transfer 事件的 <code>from</code> 值为 <code>None</code>。</p>
<p>要发出 Transfer 事件，打开 <code>lib.rs</code> 文件，在 <code>new</code> 构造函数中将 <code>Transfer</code> 事件添加到 <code>new_init()</code> 函数中。</p>
<pre><code class="language-rust editable noplayground">fn new_init(&amp;mut self, initial_supply: Balance) {
   let caller = Self::env().caller();
   self.balances.insert(&amp;caller, &amp;initial_supply);
   self.total_supply = initial_supply;
   Self::env().emit_event(Transfer {
       from: None,
       to: Some(caller),
       value: initial_supply,
     });
   }
</code></pre>
<p>将 <code>Transfer</code> 事件添加到 <code>transfer_from_to()</code> 函数中。</p>
<pre><code class="language-rust editable noplayground">self.balances.insert(from, &amp;(from_balance - value));
let to_balance = self.balance_of_impl(to);
self.balances.insert(to, &amp;(to_balance + value));
self.env().emit_event(Transfer {
   from: Some(*from),
   to: Some(*to),
   value,
});
</code></pre>
<p>注意 <code>value </code> 不需要 <code>Some()</code>，因为值没有存储在 <code>Option</code> 中。</p>
<p>添加一个将代币从一个帐户转移到另一个帐户的测试用例。</p>
<pre><code class="language-rust editable noplayground">#[ink::test]
fn transfer_works() {
   let mut erc20 = Erc20::new(100);
   assert_eq!(erc20.balance_of(AccountId::from([0x0; 32])), 0);
   assert_eq!(erc20.transfer((AccountId::from([0x0; 32])), 10), Ok(()));
   assert_eq!(erc20.balance_of(AccountId::from([0x0; 32])), 10);
}
</code></pre>
<p>通过运行以下命令验证程序的编译并且通过所有测试用例：</p>
<pre><code class="language-rust editable noplayground">cargo +nightly test
</code></pre>
<p>该命令应该显示类似以下的输出，以表示成功完成测试：</p>
<pre><code class="language-bash editable noplayground">running 3 tests
test erc20::tests::new_works ... ok
test erc20::tests::balance_works ... ok
test erc20::tests::transfer_works ... ok

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
<h3 id="启用第三方转账"><a class="header" href="#启用第三方转账">启用第三方转账</a></h3>
<p>ERC-20 代币合约现在可以在账户之间转移代币，并在发生这种情况时发出事件。作为最后一步，你可以添加 <code>approve</code> 和 <code>transfer_from</code> 函数以启用第三方转账。</p>
<p>允许一个账户代表另一个账户消费代币，允许你的智能合约支持去中心化的交易所。你可以批准你所拥有的一些代币以你的名义进行交易，而不是在合同中直接将你的代币转让给另一个用户。当你等待交易执行时，如果需要，你仍然可以控制和使用你的代币。你还可以批准多个合约或用户访问你的代币，因此，如果一个合约提供了最好的交易，你不需要将代币从一个合约移动到另一个合约，这可能是一个高成本和耗时的过程。</p>
<p>为了确保批准和转移可以安全完成，ERC-20 代币合约使用两步流程，分别从操作中进行批准和转移。</p>
<h4 id="添加批准逻辑"><a class="header" href="#添加批准逻辑">添加批准逻辑</a></h4>
<p>批准另一个帐户来使用你的代币是第三方转账流程的第一步。作为一个代币所有者，你可以指定任何帐户代表转账，以及转账任意数量的代币。你不需要批准帐户中的所有令牌，你可以指定批准一个帐户允许转账的最大数量。</p>
<p>当多次调用 <code>approve</code> 时，将用新值覆盖先前批准的值。默认情况下，任意两个帐户之间的批准值为 <code>0</code>。如果你想撤销帐户中对代币的访问，可以调用值为 <code>0</code> 的 <code>approve</code> 函数。</p>
<p>要在 ERC-20 合约中存储批准，你需要使用稍微复杂一些的 <code>Mapping</code> 键。由于每个帐户可以有不同的批准金额供其他任何帐户使用，因此需要使用元组作为映射到余额值的键。例如：</p>
<pre><code class="language-rust editable noplayground">pub struct Erc20 {
 /// Balances that can be transferred by non-owners: (owner, spender) -&gt; allowed
 allowances: ink_storage::Mapping&lt;(AccountId, AccountId), Balance&gt;,
}
</code></pre>
<p>元组使用 <code>(owner, spender)</code> 来标识 <code>spender</code> 帐户，该帐户被允许在指定 <code>allowance</code> 代表 <code>owner</code> 访问代币。</p>
<p>要为智能合约添加批准逻辑，打开 <code>lib.rs</code> 文件，使用 <code>#[ink(event)]</code> 属性宏声明 <code>Approval</code> 事件。</p>
<pre><code class="language-rust editable noplayground">#[ink(event)]
pub struct Approval {
   #[ink(topic)]
   owner: AccountId,
   #[ink(topic)]
   spender: AccountId,
   value: Balance,
}
</code></pre>
<p>添加一个 <code>Error</code> 声明，以便在转账请求超过帐户限额时返回一个错误。</p>
<pre><code class="language-rust editable noplayground">#[derive(Debug, PartialEq, Eq, scale::Encode, scale::Decode)]
#[cfg_attr(feature = &quot;std&quot;, derive(scale_info::TypeInfo))]
pub enum Error {
   InsufficientBalance,
   InsufficientAllowance,
}
</code></pre>
<p>将所有者和非所有者组合的存储映射添加到帐户余额。</p>
<pre><code class="language-rust editable noplayground">allowances: Mapping&lt;(AccountId, AccountId), Balance&gt;,
</code></pre>
<p>添加 <code>approve()</code> 函数来授权 <code>spender</code> 帐户从调用者的帐户中提取代币，直到取到最大 <code>value</code>。</p>
<pre><code class="language-rust editable noplayground">#[ink(message)]
pub fn approve(&amp;mut self, spender: AccountId, value: Balance) -&gt; Result&lt;()&gt; {
   let owner = self.env().caller();
   self.allowances.insert((&amp;owner, &amp;spender), &amp;value);
   self.env().emit_event(Approval {
     owner,
     spender,
     value,
   });
   Ok(())
}
</code></pre>
<p>添加一个 <code>allowance()</code> 函数来返回允许 <code>spender</code> 从 <code>owner</code> 帐户中提取的代币数量。</p>
<pre><code class="language-rust editable noplayground">#[ink(message)]
pub fn allowance(&amp;self, owner: AccountId, spender: AccountId) -&gt; Balance {
   self.allowance_impl(&amp;owner, &amp;spender)
}
</code></pre>
<p>这段代码片段使用了 <code>allowance_impl()</code> 函数。<code>allowance_impl()</code> 函数与 <code>allowance</code> 函数相同，不同之处是它使用引用来在 WebAssembly 中以更有效的方式查找代币限额。在智能合约中添加如下函数即可使用该功能：</p>
<pre><code class="language-rust editable noplayground">#[inline]
fn allowance_impl(&amp;self, owner: &amp;AccountId, spender: &amp;AccountId) -&gt; Balance {
   self.allowances.get((owner, spender)).unwrap_or_default()
}
</code></pre>
<h4 id="从逻辑中添加转账"><a class="header" href="#从逻辑中添加转账">从逻辑中添加转账</a></h4>
<p>现在你已经为一个帐户设置了代表另一个帐户转移代币的批准，你需要创建一个 <code>transfer_from</code> 函数，以允许已批准的用户转移代币。<code>transfer_from</code> 函数调用私有 <code>transfer_from_to</code> 函数来执行大部分转移逻辑。授权非所有者转让代币有几个要求：</p>
<ul>
<li><code>self.env().caller()</code> 合约调用者分配的必须是 <code>from</code> 帐户中可用的代币。</li>
<li>分配的存储作为 <code>allowance</code> 必须大于要转移的值。</li>
</ul>
<p>如果满足了这些要求，合约将更新的限额插入到 <code>allowance</code> 变量中，并使用指定的 <code>from</code> 和 <code>to</code> 帐户调用 <code>transfer_from_to()</code> 函数。</p>
<p>记住，在调用 <code>transfer_from</code> 时，<code>self.env().caller()</code> 和 <code>from</code> 帐户用于查找当前限额，但 <code>transfer_from</code> 函数是在指定的 <code>from</code> 和 <code>to</code> 帐户之间被调用的。</p>
<p>每当调用 <code>transfer_from</code> 时，将使用三个帐户变量，你需要确保正确使用它们。</p>
<p>要为智能合约添加 <code>transfer_from</code>，打开 <code>lib.rs</code> 文件，添加 <code>transfer_from()</code> 函数，以代表 <code>from</code> 帐户到 <code>to</code> 帐户转移代币的 <code>value</code>。</p>
<pre><code class="language-rust editable noplayground">/// Transfers tokens on the behalf of the `from` account to the `to account
#[ink(message)]
pub fn transfer_from(
   &amp;mut self,
   from: AccountId,
   to: AccountId,
   value: Balance,
) -&gt; Result&lt;()&gt; {
   let caller = self.env().caller();
   let allowance = self.allowance_impl(&amp;from, &amp;caller);
   if allowance &lt; value {
       return Err(Error::InsufficientAllowance)
   }
   self.transfer_from_to(&amp;from, &amp;to, value)?;
   self.allowances
       .insert((&amp;from, &amp;caller), &amp;(allowance - value));
   Ok(())
  }
</code></pre>
<p>为 <code>transfer_from()</code> 函数添加一个测试用例。</p>
<pre><code class="language-rust editable noplayground">#[ink::test]
fn transfer_from_works() {
   let mut contract = Erc20::new(100);
   assert_eq!(contract.balance_of(AccountId::from([0x1; 32])), 100);
   contract.approve(AccountId::from([0x1; 32]), 20);
   contract.transfer_from(AccountId::from([0x1; 32]), AccountId::from([0x0; 32]), 10);
   assert_eq!(contract.balance_of(AccountId::from([0x0; 32])), 10);
}
</code></pre>
<p>通过运行以下命令验证程序的编译并且通过所有测试用例：</p>
<pre><code class="language-bash editable noplayground">cargo +nightly test
</code></pre>
<p>该命令应显示类似如下的输出，以表示测试成功完成：</p>
<pre><code class="language-bash editable noplayground">running 5 tests
test erc20::tests::new_works ... ok
test erc20::tests::balance_works ... ok
test erc20::tests::transfer_works ... ok
test erc20::tests::transfer_from_works ... ok
test erc20::tests::allowances_works ... ok

test result: ok. 5 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
<p>通过运行以下命令验证你可以为该合约构建 WebAssemnbly</p>
<pre><code class="language-bash editable noplayground">cargo +nightly contract build
</code></pre>
<p>在构建了合约的 WebAssembly 之后，你可以使用 Contracts UI 上传并实例化它，如<a href="blockchain/chapter_1_2_1_5.html#%E4%B8%8A%E4%BC%A0%E5%B9%B6%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%90%88%E7%BA%A6">上传并实例化合约</a>中所述。</p>
<h3 id="编写测试用例"><a class="header" href="#编写测试用例">编写测试用例</a></h3>
<p>在本节教程中，你向 <code>lib.rs</code> 文件中添加了简单的单元测试。基本的测试用例通过给出指定的输入值并验证返回的结果来说明函数按预期工作。你可以通过编写额外的测试用例来提高代码的质量。例如，你可以添加测试，对无效输入、空值或超出预期范围的值进行错误处理。</p>
<p>erc20 最终代码：</p>
<pre><code class="language-rust editable noplayground">#![cfg_attr(not(feature = &quot;std&quot;), no_std)]

use ink_lang as ink;

#[ink::contract]
mod erc20 {
    use ink_storage::traits::SpreadAllocate;

    #[ink(event)]
    pub struct Transfer {
        #[ink(topic)]
        from: Option&lt;AccountId&gt;,
        #[ink(topic)]
        to: Option&lt;AccountId&gt;,
        #[ink(topic)]
        value: Balance,
    }

    #[ink(event)]
    pub struct Approval {
        #[ink(topic)]
        owner: AccountId,
        #[ink(topic)]
        spender: AccountId,
        #[ink(topic)]
        value: Balance,
    }

    #[cfg(not(feature = &quot;ink-as-dependency&quot;))]
    #[ink(storage)]
    #[derive(SpreadAllocate)]
    pub struct Erc20 {
        /// The total supply.
        total_supply: Balance,
        /// The balance of each user.
        balances: ink_storage::Mapping&lt;AccountId, Balance&gt;,
        /// Approval spender on behalf of the message's sender.
        allowances: ink_storage::Mapping&lt;(AccountId, AccountId), Balance&gt;,
    }

    impl Erc20 {
        #[ink(constructor)]
        pub fn new(initial_supply: Balance) -&gt; Self {
            ink_lang::utils::initialize_contract(|contract: &amp;mut Self| {
                contract.total_supply = initial_supply;
                let caller = Self::env().caller();
                contract.balances.insert(&amp;caller, &amp;initial_supply);

                // NOTE: `allowances` is default initialized by `initialize_contract`, so we don't
                // need to do anything here

                Self::env().emit_event(Transfer {
                    from: None,
                    to: Some(caller),
                    value: initial_supply,
                });
            })
        }

        #[ink(message)]
        pub fn total_supply(&amp;self) -&gt; Balance {
            self.total_supply
        }

        #[ink(message)]
        pub fn balance_of(&amp;self, owner: AccountId) -&gt; Balance {
            self.balances.get(&amp;owner).unwrap_or_default()
        }

        #[ink(message)]
        pub fn approve(&amp;mut self, spender: AccountId, value: Balance) -&gt; bool {
            // Record the new allowance.
            let owner = self.env().caller();
            self.allowances.insert(&amp;(owner, spender), &amp;value);

            // Notify offchain users of the approval and report success.
            self.env().emit_event(Approval {
                owner,
                spender,
                value,
            });

            true
        }

        #[ink(message)]
        pub fn allowance(&amp;self, owner: AccountId, spender: AccountId) -&gt; Balance {
            self.allowance_of_or_zero(&amp;owner, &amp;spender)
        }

        #[ink(message)]
        pub fn transfer_from(
            &amp;mut self,
            from: AccountId,
            to: AccountId,
            value: Balance,
        ) -&gt; bool {
            // Ensure that a sufficient allowance exists.
            let caller = self.env().caller();
            let allowance = self.allowance_of_or_zero(&amp;from, &amp;caller);
            if allowance &lt; value {
                return false
            }

            let transfer_result = self.transfer_from_to(from, to, value);
            // Check `transfer_result` because `from` account may not have enough balance
            //   and return false.
            if !transfer_result {
                return false
            }

            // Decrease the value of the allowance and transfer the tokens.
            self.allowances.insert((from, caller), &amp;(allowance - value));
            true
        }

        #[ink(message)]
        pub fn transfer(&amp;mut self, to: AccountId, value: Balance) -&gt; bool {
            self.transfer_from_to(self.env().caller(), to, value)
        }

        fn transfer_from_to(
            &amp;mut self,
            from: AccountId,
            to: AccountId,
            value: Balance,
        ) -&gt; bool {
            let from_balance = self.balance_of(from);
            if from_balance &lt; value {
                return false
            }

            // Update the sender's balance.
            self.balances.insert(&amp;from, &amp;(from_balance - value));

            // Update the receiver's balance.
            let to_balance = self.balance_of(to);
            self.balances.insert(&amp;to, &amp;(to_balance + value));

            self.env().emit_event(Transfer {
                from: Some(from),
                to: Some(to),
                value,
            });

            true
        }

        fn allowance_of_or_zero(
            &amp;self,
            owner: &amp;AccountId,
            spender: &amp;AccountId,
        ) -&gt; Balance {
            // If you are new to Rust, you may wonder what's the deal with all the asterisks and
            // ampersends.
            //
            // In brief, using `&amp;` if we want to get the address of a value (aka reference of the
            // value), and using `*` if we have the reference of a value and want to get the value
            // back (aka dereferencing).
            //
            // To read more: https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html
            self.allowances.get(&amp;(*owner, *spender)).unwrap_or_default()
        }
    }

    #[cfg(test)]
    mod tests {
        use super::*;

        use ink_lang as ink;

        #[ink::test]
        fn new_works() {
            let contract = Erc20::new(777);
            assert_eq!(contract.total_supply(), 777);
        }

        #[ink::test]
        fn balance_works() {
            let contract = Erc20::new(100);
            assert_eq!(contract.total_supply(), 100);
            assert_eq!(contract.balance_of(AccountId::from([0x1; 32])), 100);
            assert_eq!(contract.balance_of(AccountId::from([0x0; 32])), 0);
        }

        #[ink::test]
        fn transfer_works() {
            let mut contract = Erc20::new(100);
            assert_eq!(contract.balance_of(AccountId::from([0x1; 32])), 100);
            assert!(contract.transfer(AccountId::from([0x0; 32]), 10));
            assert_eq!(contract.balance_of(AccountId::from([0x0; 32])), 10);
            assert!(!contract.transfer(AccountId::from([0x0; 32]), 100));
        }

        #[ink::test]
        fn transfer_from_works() {
            let mut contract = Erc20::new(100);
            assert_eq!(contract.balance_of(AccountId::from([0x1; 32])), 100);
            contract.approve(AccountId::from([0x1; 32]), 20);
            contract.transfer_from(
                AccountId::from([0x1; 32]),
                AccountId::from([0x0; 32]),
                10,
            );
            assert_eq!(contract.balance_of(AccountId::from([0x0; 32])), 10);
        }

        #[ink::test]
        fn allowances_works() {
            let mut contract = Erc20::new(100);
            assert_eq!(contract.balance_of(AccountId::from([0x1; 32])), 100);
            contract.approve(AccountId::from([0x1; 32]), 200);
            assert_eq!(
                contract
                    .allowance(AccountId::from([0x1; 32]), AccountId::from([0x1; 32])),
                200
            );

            assert!(contract.transfer_from(
                AccountId::from([0x1; 32]),
                AccountId::from([0x0; 32]),
                50
            ));
            assert_eq!(contract.balance_of(AccountId::from([0x0; 32])), 50);
            assert_eq!(
                contract
                    .allowance(AccountId::from([0x1; 32]), AccountId::from([0x1; 32])),
                150
            );

            assert!(!contract.transfer_from(
                AccountId::from([0x1; 32]),
                AccountId::from([0x0; 32]),
                100
            ));
            assert_eq!(contract.balance_of(AccountId::from([0x0; 32])), 50);
            assert_eq!(
                contract
                    .allowance(AccountId::from([0x1; 32]), AccountId::from([0x1; 32])),
                150
            );
        }
    }
}
</code></pre>
<h2 id="智能合约的问题排查"><a class="header" href="#智能合约的问题排查">智能合约的问题排查</a></h2>
<p>本节介绍了在基于 Substrate 的区块链上编写和部署智能合约时可能遇到的一些常见问题，以及如何解决这些问题。</p>
<h3 id="意外的运行错误"><a class="header" href="#意外的运行错误">意外的运行错误</a></h3>
<p>如果你在不正确的情况下中断了一个正在运行的节点，例如，通过关闭终端或计算机切换到睡眠模式，你可能会看到以下错误</p>
<pre><code class="language-bash editable noplayground">ClientImport(&quot;Unexpected epoch change&quot;)
</code></pre>
<p>如果看到此错误，请使用以下命令重新启动节点：</p>
<pre><code class="language-bash editable noplayground">substrate-contracts-node --dev
</code></pre>
<p>此命令清除所有正在运行的节点状态。重新启动节点后，重复关闭节点之前执行的任何步骤。例如，重新部署你之前上传的所有合约。</p>
<h3 id="本地存储中的过期合约"><a class="header" href="#本地存储中的过期合约">本地存储中的过期合约</a></h3>
<p>Contracts UI 使用它自己的本地存储来跟踪你已经部署的合约。如果你使用 Contracts UI 部署合约，然后清除链上的节点数据，将提示你需要重置本地存储。重置 Contracts UI 的本地存储后，重复清除节点之前执行的所有步骤，并重新部署之前上传的所有合约。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="桥接其它链-1"><a class="header" href="#桥接其它链-1">桥接其它链</a></h1>
<p>本教程深入探讨了超越单链开发的更高级主题，包括如何将当前链连接到其它链。</p>
<h2 id="准备一个本地平行链的测试网准备一个本地中继链"><a class="header" href="#准备一个本地平行链的测试网准备一个本地中继链">准备一个本地平行链的测试网（准备一个本地中继链）</a></h2>
<p>在本教程中，你将配置一个本地中继链并连接一个平行链模板，以便在本地测试环境中使用。</p>
<h3 id="重点注意匹配版本"><a class="header" href="#重点注意匹配版本">重点注意匹配版本</a></h3>
<p>你必须使用本教程中规定的确切版本。平行链与它们所连接的中继链代码库紧密耦合，因为它们共享许多共同的依赖项。在使用整个 Substrate 文档中的任一示例时，请确保在任何其他软件中使用 Polkadot 的相应版本。你必须与中继链同步升级，你的平行链才能继续成功运行。如果你没有保持中继链的更新，很可能你的网络将停止生产区块。</p>
<h4 id="文档示例中的版本"><a class="header" href="#文档示例中的版本">文档示例中的版本</a></h4>
<p>文档中的所有教程都经过了测试，可以使用：</p>
<ul>
<li><a href="https://github.com/paritytech/polkadot/tree/release-v0.9.26">Polkadot <code>v0.9.26</code></a></li>
<li><a href="https://github.com/substrate-developer-hub/substrate-parachain-template/tree/polkadot-v0.9.26">Substrate Parachain Template <code>polkadot-v0.9.26</code></a></li>
<li><a href="https://github.com/polkadot-js/apps/commit/151c4cd75b6eb68ac275d90fd17f98b28b6e57a7">Polkadot-JS Apps <code>v0.116.2-34</code></a> 一般情况下<a href="https://polkadot.js.org/apps/?rpc=ws%3A%2F%2F127.0.0.1%3A9944#/explorer">托管的 Polkadot-JS Apps 插件 </a>可以正常使用。如果你有问题，请在此标签的 version/commit 下自行构建并运行 UI。</li>
</ul>
<h3 id="构建中继链节点"><a class="header" href="#构建中继链节点">构建中继链节点</a></h3>
<p>在 <code>rococo-local</code> 网络配置中稍加修改的 Polkadot 内置版本将作为本节教程的中继链。</p>
<pre><code class="language-bash editable noplayground"># Clone the Polkadot Repository, with correct version
git clone --depth 1 --branch release-v0.9.26 https://github.com/paritytech/polkadot.git

# Switch into the Polkadot directory
cd polkadot

# Build the relay chain Node
cargo b -r
</code></pre>
<p>编译节点可能需要十五分钟到六十分钟才能完成。</p>
<pre><code class="language-bash editable noplayground"># Check if the help page prints to ensure the node is built correctly
./target/release/polkadot --help
</code></pre>
<p>如果打印了帮助页面，则说明你已经成功构建了 Polkadot 节点。</p>
<h3 id="中继链specification"><a class="header" href="#中继链specification">中继链specification</a></h3>
<p>你需要一个中继链网络的 chain specification。当我们想要使用本地测试网时，可能需要一个自定义配置来为验证者、引导节点地址等设置开发或自定义键。</p>
<p>**一个中继链上运行的验证者（validator）节点必须比连接的平行链核对者（collator）的总数多一个。**为了测试，这些通常必须硬编码到你的 chain spec 中。例如，如果你想用一个 collator 连接两个平行链，请运行三个或更多的中继链验证者节点，并确保它们都在 chain spec 中指定。</p>
<p>无论你选择使用哪个 chain spec 文件，在下面的说明中，我们都将该文件简单地称为 <code>chain-spec.json</code>。你将需要为你正在使用的 chain spec 提供正确的路径。</p>
<h4 id="预先配置的chain-spec文件"><a class="header" href="#预先配置的chain-spec文件">预先配置的chain spec文件</a></h4>
<p>本节教程包括一个示例 chain specification 文件，其中两个验证者中继链节点 Alice 和 Bob 作为授权。你无需任何修改就可以对本地测试网络和单个平行链使用此示例 chain specification。这对于注册单个平行链非常有用：</p>
<ul>
<li><a href="https://github.com/substrate-developer-hub/substrate-docs/blob/main/static/assets/tutorials/cumulus/chain-specs/rococo-custom-2-plain.json">Plain <code>rococo-local</code> <strong>relay</strong> chain spec</a></li>
<li><a href="https://github.com/substrate-developer-hub/substrate-docs/blob/main/static/assets/tutorials/cumulus/chain-specs/rococo-custom-2-raw.json">Raw <code>rococo-local</code> <strong>relay</strong> chain spec</a></li>
</ul>
<p>你可以读取和编辑普通 chain specification 文件。然而 chain specification 文件必须被融合为 SCALE-encoded 编码的原始格式，然后才能用于启动节点。有关将 chain specification 转换为使用原始格式的信息，请参见<a href="https://docs.substrate.io/reference/how-to-guides/basics/customize-a-chain-specification/">Customize a chain specification</a>指南。</p>
<p>示例 chain specification 仅对具有两个验证者节点的单个平行链有效。如果你添加其他验证者，向中继链添加额外的平行链，或者希望使用自定义的 non-development keys，你将需要创建一个适合你需求的自定义 chain specification。</p>
<h3 id="启动你的中继链"><a class="header" href="#启动你的中继链">启动你的中继链</a></h3>
<p>在开始对一个平行链进行区块生产之前，你需要启动一个中继链来连接它们。本节描述如何使用 <a href="https://github.com/substrate-developer-hub/substrate-docs/blob/main/static/assets/tutorials/cumulus/chain-specs/rococo-custom-2-raw.json">two-validator raw chain spec</a> 启动两个节点，启动其他节点的步骤与此类似。</p>
<h4 id="启动alice验证者"><a class="header" href="#启动alice验证者">启动<code>alice</code>验证者</a></h4>
<pre><code class="language-bash editable noplayground"># Start Relay `Alice` node
./target/release/polkadot \
--alice \
--validator \
--base-path /tmp/relay/alice \
--chain &lt;path to spec json&gt; \
--port 30333 \
--ws-port 9944
</code></pre>
<p>命令中指定的端口（<code>port</code>）和 websocket 端口（<code>ws-port</code>）使用默认值，可以省略。但是，这里包含这些值是为了提醒你可以检查这些值。节点启动后，同一台本地计算机上的其他节点不能使用这些端口。</p>
<pre><code class="language-bash editable noplayground">🏷 Local node identity is: 12D3KooWGjsmVmZCM1jPtVNp6hRbbkGBK3LADYNniJAKJ19NUYiq
</code></pre>
<p>当节点启动时，你将看到一些日志消息，包括节点的 <strong>Peer ID</strong>。要注意这一点，因为在将其他节点连接到它时将需要它。</p>
<h4 id="启动bob验证者"><a class="header" href="#启动bob验证者">启动<code>bob</code>验证者</a></h4>
<p>启动第二个节点的命令类似于启动第一个节点的命令，但有一些重要的区别。</p>
<pre><code class="language-bash editable noplayground">./target/release/polkadot \
--bob \
--validator \
--base-path /tmp/relay-bob \
--chain &lt;path to spec json&gt; \
--bootnodes /ip4/&lt;Alice IP&gt;/tcp/30333/p2p/&lt;Alice Peer ID&gt; \
--port 30334 \
--ws-port 9945
</code></pre>
<p>注意，该命令使用不同的基本路径（<code>/tmp/relay-bob</code>）、验证器密钥（<code>--bob</code>）和端口（<code>30334</code> 和 <code>9945</code>）。</p>
<p>启动第二个节点的命令还包括 <code>--bootnodes</code> 命令行选项，用于指定第一个节点的 IP 地址和 peer 标识符。如果你在单个本地计算机上运行整个网络，那么 <code>bootnodes</code> 选项不是必须一定要的，但是当使用到非本地网络的连接而在 chain spec 中没有任何指定的 bootnodes 时，该选项是必要的，正如我们正在使用的 <a href="https://github.com/substrate-developer-hub/substrate-docs/blob/main/static/assets/tutorials/cumulus/chain-specs/rococo-custom-2-plain.json">rococo-custom-2-plain.json</a> 示例一样。</p>
<p>在本节教程中，你的最终 chain spec 文件名必须以 <code>rococo</code> 开头，否则节点将不知道要怎样包含运行时逻辑。</p>
<h3 id="其它资源"><a class="header" href="#其它资源">其它资源</a></h3>
<p>手动构建和配置中继链是一个很好的练习。然而，在你完成了几次之后，你可能希望自动化该过程。有很多方法可以做到这一点，这里有一些方法可供参考：</p>
<ul>
<li><a href="https://github.com/open-web3-stack/parachain-launch">parachain-launch</a> 是一个生成 docker compose 文件的脚本，允许你启动多个区块链节点的测试网络。</li>
<li><a href="https://github.com/paritytech/zombienet">zombienet</a> 是一个 CLI 工具，使你能够生成短暂的 Polkadot/Substrate 网络并对其执行测试。</li>
</ul>
<h2 id="连接本地平行链"><a class="header" href="#连接本地平行链">连接本地平行链</a></h2>
<p>本节教程演示了如何使用本地中继链预留平行链标识符，以及如何将本地平行链连接到该中继链。</p>
<h3 id="构建平行链模板"><a class="header" href="#构建平行链模板">构建平行链模板</a></h3>
<p>本节教程使用 <a href="https://github.com/substrate-developer-hub/substrate-parachain-template">Substrate parachain template</a> 来演示如何启动一个平行链去连接一个本地中继链。平行链模板类似于单链开发中使用的 <a href="https://github.com/substrate-developer-hub/substrate-node-template">node template</a>。你可以使用平行链模板作为开发自定义平行链项目的起点。</p>
<p>要构建平行链模板，下载用来配置中继链 release 分支相匹配的 <code>substrate-parachain-template</code> 存储库的分支。例如，如果你使用 <code>release-v0.9.28</code> Polkadot release 分支来配置本地中继链，那么对应平行链模板的分支则使用 <code>polkadot-v0.9.28</code>。</p>
<pre><code class="language-bash editable noplayground">git clone --depth 1 --branch polkadot-v0.9.28 https://github.com/substrate-developer-hub/substrate-parachain-template.git

cd substrate-parachain-template

#你现在有一个分离的分支。如果要保存更改并使分支易于识别，可以通过运行类似于以下的命令创建新分支：
git switch -c my-branch-v0.9.28

cargo build --release
</code></pre>
<p>编译节点最多需要60分钟，具体取决于硬件和软件配置。</p>
<h3 id="预留唯一标识符"><a class="header" href="#预留唯一标识符">预留唯一标识符</a></h3>
<p>每个平行链必须预留一个唯一的标识符 <code>ParaID</code>，使其能够连接到指定的中继链上。每个中继链为连接到它的平行链管理它的唯一标识符集合。该标识符被称为 <code>ParaID</code>，因为同一标识符可用于标识 <a href="https://wiki.polkadot.network/docs/learn-parachains">parachain</a> 占用的插槽或标识 <a href="https://wiki.polkadot.network/docs/learn-parathreads">parathread</a> 占用的插槽。</p>
<p>你应该注意到，你必须有一个账户有足够的资金，以便在中继链上预留一个插槽。你可以通过检查该中继链的 <code>paras_registrar</code> pallet 中的 <code>ParaDeposit</code> 配置来确定指定中继链需要的 tokens 数量。例如，Rococo 需要 5 ROC 预留一个标识符：</p>
<pre><code class="language-bash editable noplayground">parameter_types! {
	pub const ParaDeposit: Balance = 5 * DOLLARS;
	pub const DataDepositPerByte: Balance = deposit(0, 1);
}

impl paras_registrar::Config for Runtime {
	type Event = Event;
	type Origin = Origin;
	type Currency = Balances;
	type OnSwap = (Crowdloan, Slots);
	type ParaDeposit = ParaDeposit;
	type DataDepositPerByte = DataDepositPerByte;
	type WeightInfo = weights::runtime_common_paras_registrar::WeightInfo&lt;Runtime&gt;;
}
</code></pre>
<p>每个中继链分配自己的标识符从 <code>2000</code> 开始递增，为所有的非 <a href="https://wiki.polkadot.network/docs/learn-common-goods">common good parachains</a>。common good parachains 使用不同的方法来分配插槽标识符。</p>
<p>要预留平行链标识符，验证本地中继链的验证器是否正常运行，在浏览器中打开 <a href="https://polkadot.js.org/apps/?rpc=ws%3A%2F%2F127.0.0.1%3A9944#/parachains/parathreads">Polkadot/Substrate Portal</a>，连接一个本地中继链节点，点击 <strong>Network</strong> 并选择 <strong>Parachains</strong>。</p>
<p><img src="https://awesomeprogram.gitee.io/imgdata/tech_bc_subnetpacha.jpg" alt="" /></p>
<p>点击 <strong>Parathreads</strong>，再点击 <strong>ParaId</strong>。</p>
<p><img src="https://awesomeprogram.gitee.io/imgdata/tech_bc_subpaparid.jpg" alt="" /></p>
<p>查看交易的设置以预留标识符，然后点击 <strong>Submit</strong>。用于预留该标识符的帐户将是该交易的收费帐户，并且也是与该标识符关联的 parathread 的 origin 帐户。</p>
<p>点击 <strong>Sign and Submit</strong> 对交易进行授权。提交交易之后，点击 <strong>Network</strong> 并选择 <strong>Explorer</strong>。</p>
<p>检查最近成功的 <code>registrar.Reserved</code> 事件列表，点击事件以查看有关交易的详细信息。</p>
<p><img src="https://awesomeprogram.gitee.io/imgdata/tech_bc_subrepaev.jpg" alt="" /></p>
<p>现在可以准备 chain specification 并生成平行链使用预留标识符（<code>paraId</code> <code>2000</code>）连接到中继链所需的文件。</p>
<h3 id="修改默认的chain-specification"><a class="header" href="#修改默认的chain-specification">修改默认的chain specification</a></h3>
<p>要在本地中继链中注册平行链，必须修改默认的 chain specification 以使用预留的平行链标识符。</p>
<p>通过运行以下命令为平行链模板节点生成纯文本 chain specification：</p>
<pre><code class="language-bash editable noplayground">./target/release/parachain-template-node build-spec --disable-default-bootnode &gt; plain-parachain-chainspec.json
</code></pre>
<p>打开纯文本 chain specification 文件，将 <code>para_id</code> 设置为之前预留的平行链标识符。例如，如果你预留的标识符是 <code>2000</code>，那么就设置 <code>para_id</code> 的字段为 <code>2000</code>：</p>
<pre><code class="language-json editable noplayground">...
&quot;relay_chain&quot;: &quot;rococo-local&quot;,
&quot;para_id&quot;: 2000,
&quot;codeSubstitutes&quot;: {},
&quot;genesis&quot;: {
  ...
}
</code></pre>
<p>将 <code>parachainId</code> 设置为先前保留的平行链标识符。例如，如果你预留的标识符为 <code>2000</code>，则将 <code>parachainId</code> 字段设置为 <code>2000</code>：</p>
<pre><code class="language-json editable noplayground">...
  &quot;parachainSystem&quot;: null,
  &quot;parachainInfo&quot;: {
    &quot;parachainId&quot;: 2000
  },
...
</code></pre>
<p>保存代码并关闭纯文本 chain specification 文件。</p>
<p>通过运行以下命令，从修改的 chain specification 文件生成原始 chain specification 文件：</p>
<pre><code class="language-bash editable noplayground">./target/release/parachain-template-node build-spec --chain plain-parachain-chainspec.json --disable-default-bootnode --raw &gt; raw-parachain-chainspec.json
</code></pre>
<p>该命令生成一个新的原始 chain specification 文件，其中包含两个 collator。</p>
<pre><code class="language-bash editable noplayground">2022-08-30 13:00:50 Building chain spec    
2022-08-30 13:00:50 assembling new collators for new session 0 at #0    
2022-08-30 13:00:50 assembling new collators for new session 1 at #0
</code></pre>
<h3 id="准备平行链的collator"><a class="header" href="#准备平行链的collator">准备平行链的collator</a></h3>
<p>随着本地中继链的运行和对平行链链模板的原始 chain specification 的更新，你就可以启动平行链 collator 节点并导出其运行时和初始状态的信息。</p>
<p>准备要注册的平行链 collator，导出平行链的 WebAssembly 运行时。中继链需要 parachain-specific 的运行时验证逻辑来验证平行链区块，通过运行类似于以下的命令，你可以导出 parachain collator 节点的 WebAssembly 运行时：</p>
<pre><code class="language-bash editable noplayground">./target/release/parachain-template-node export-genesis-wasm --chain raw-parachain-chainspec.json para-2000-wasm
</code></pre>
<p>生成一个平行链的初始状态。为了注册一个平行链，中继链需要知道平行链的初始状态；通过运行类似于以下的命令，可以将整个初始状态（十六进制编码）导出到一个文件中：</p>
<pre><code class="language-bash editable noplayground">./target/release/parachain-template-node export-genesis-state --chain raw-parachain-chainspec.json para-2000-genesis-state
</code></pre>
<p>你应该注意到了导出的运行时和状态必须是针对 <em>genesis</em> 块的，你不能将前一个状态的平行链连接到中继器上。所有平行链必须从中继链上的块 0 开始。有关如何创建平行链模板以及如何将这个链逻辑（而不是它的历史状态迁移）转换为平行链的详细信息，请参见 <a href="https://docs.substrate.io/reference/how-to-guides/parachains/convert-a-solo-chain/">Convert a solo chain</a>。</p>
<p>使用类似于以下的命令启动 collator 节点：</p>
<pre><code class="language-bash editable noplayground">./target/release/parachain-template-node \
--alice \
--collator \
--force-authoring \
--chain raw-parachain-chainspec.json \
--base-path /tmp/parachain/alice \
--port 40333 \
--ws-port 8844 \
-- \
--execution wasm \
--chain ../polkadot/raw-local-chainspec.json \
--port 30343 \
--ws-port 9977
</code></pre>
<p>在这个命令中，在惟一的 <code>--</code> 参数之前传递的参数是用于平行链模板 collator 的。<code>--</code> 后面的参数用于嵌入式中继链节点。注意，这个命令同时指定了平行链的原始 chain specification 和中继链的原始 chain specification。在本例中，本地中继链的原始 chain specification 为 <code>polkadot</code> 目录中的 <code>raw-local-chainspec.json</code>。确保第二个 <code>--chain</code> 命令行为本地中继链指定了原始 chain specification 的路径。</p>
<p>如果你为平行链启动另一个节点，你将使用相同的中继链 chain specification 文件，但是使用不同的基本路径和端口号。</p>
<p>在启动平行链模板节点的终端中，你应该能看到类似以下输出：</p>
<pre><code class="language-bash editable noplayground">2022-08-30 13:49:17 Parachain Collator Template    
2022-08-30 13:49:17 ✌️  version 0.1.0-fd9771eed9c    
2022-08-30 13:49:17 ❤️  by Anonymous, 2020-2022    
2022-08-30 13:49:17 📋 Chain specification: Local Parachain Testnet    
2022-08-30 13:49:17 🏷  Node name: Alice    
2022-08-30 13:49:17 👤 Role: AUTHORITY    
2022-08-30 13:49:17 💾 Database: RocksDb at /tmp/parachain/alice/chains/local_testnet/db/full    
2022-08-30 13:49:17 ⛓  Native runtime: template-parachain-1 (template-parachain-0.tx1.au1)
2022-08-30 13:51:58 Parachain id: Id(2000)    
2022-08-30 13:51:58 Parachain Account: 5Ec4AhPUwPeyTFyuhGuBbD224mY85LKLMSqSSo33JYWCazU4    
2022-08-30 13:51:58 Parachain genesis state: 0x0000000000000000000000000000000000000000000000000000000000000000003c28ac319eab2cac949139fd0376f16bc97f698d1cde1bc3f46c2ec0edd1b9fb03170a2e7597b7b7e3d84c05391d139a62b157e78786d8c082f29dcf4c11131400    
2022-08-30 13:51:58 Is collating: yes    
2022-08-30 13:52:00 [Relaychain] 🏷  Local node identity is: 12D3KooWNNP9Z1D86KKgrzht6Pvd3WjKqxQaNkC6HpW5wVTUEEKR
...
</code></pre>
<p>你应该看到模板 collator 节点作为独立节点运行，它的中继节点作为对等节点与本地中继链验证器节点连接。如果你没有看到嵌入式中继链与本地中继链节点对接，请尝试禁用防火墙或添加带有中继节点地址的 <code>bootnodes</code> 参数。</p>
<p>它还没有开始创建平行链区块，创建块将在 collator 实际<strong>注册到中继链上</strong>时才开始。</p>
<h3 id="向本地中继链注册"><a class="header" href="#向本地中继链注册">向本地中继链注册</a></h3>
<p>当本地中继链和 collator 节点都正常运行时，你就可以在本地中继链上注册平行链了。在实时公共网络中，注册通常涉及<a href="https://wiki.polkadot.network/docs/learn-auction">平行链插槽拍卖</a>。在本节教程和本地测试中，你可以使用 Sudo 交易和 Polkadot/Substrate Portal。使用 Sudo 交易可以绕过获取平行链或平行线程插槽所需的步骤。</p>
<p>要注册平行链，验证本地中继链验证器是否正常运行，在浏览器中打开 <a href="https://polkadot.js.org/apps/?rpc=ws%3A%2F%2F127.0.0.1%3A9944#/parachains/parathreads">Polkadot/Substrate Portal</a>，如果需要连接到本地中继链节点，点击 <strong>Developer</strong> 并选择 <strong>Sudo</strong>。</p>
<p><img src="https://awesomeprogram.gitee.io/imgdata/tech_bc_subdevsudo.jpg" alt="" /></p>
<p>选择 <strong>paraSudoWrapper</strong>，然后选择 <strong>sudoScheduleParaInitialize(id, genesis)</strong> 来在下一个中继链会话开始时初始化预留的 paraID。</p>
<p>对于交易参数：</p>
<ul>
<li><code>id</code>：输入你预留的 ParaId。对于本节教程，保留标识符是 2000。</li>
<li><code>genesisHead</code>：点击 <strong>file upload</strong>，上传你为 parachain 导出的初始状态。对于本节教程，选择 <code>para-2000-genesis</code> 文件。</li>
<li><code>validationCode</code>：点击 <strong>file upload</strong> 并上传你为平行链导出的 WebAssembly 运行时。对于本节教程，选择 <code>para-2000-wasm</code> 文件。</li>
<li><code>parachain</code>：选择 <strong>Yes</strong>。</li>
</ul>
<p><img src="https://awesomeprogram.gitee.io/imgdata/tech_bc_subregsudo.jpg" alt="" /></p>
<p>点击 <strong>Submit Sudo</strong>。</p>
<p>查看交易详细信息，然后点击 <strong>Sign and Submit</strong> 对交易进行授权。提交交易之后，点击 <strong>Network</strong> 并选择 <strong>Explorer</strong>。</p>
<p>检查最近的事件列表是否有成功的 <code>sudo.Suid</code> 和点击事件查看交易的详细信息。</p>
<p><img src="https://awesomeprogram.gitee.io/imgdata/tech_bc_subsuregeve.jpg" alt="" /></p>
<p>初始化平行链后，通过点击 <strong>Network</strong> 然后选择 <strong>Parachains</strong>，你可以在 Polkadot/Substrate Portal 中看到它。</p>
<p><img src="https://awesomeprogram.gitee.io/imgdata/tech_bc_subvipach.jpg" alt="" /></p>
<p>点击 <strong>Network</strong>，选择 <strong>Parachains</strong>，等待新的 epic 开始。中继链跟踪每个平行链最近区块的块头。当一个中继链区块完成时，已经完成<a href="https://polkadot.network/blog/the-path-of-a-parachain-block/">验证过程</a>的平行链区块也完成了。这就是 Polkadot 为平行链实现 <strong>pooled, shared security</strong> 的方式。在平行链连接到下一个 epoch 的中继链并完成其第一个区块之后，你可以在 Polkadot/Substrate Portal 中看到有关它的信息。</p>
<p><img src="https://awesomeprogram.gitee.io/imgdata/tech_bc_subpaepoch.jpg" alt="" /></p>
<p>运行平行链的终端会显示类似如下的详细信息：</p>
<pre><code class="language-bash editable noplayground">2022-09-01 12:58:12 [Parachain] Starting collation. relay_parent=0x1ba093a16f8276459629b29b2bcee2b40e360a72a15a714cb208a5f6be576262 at=0x99951a12bbb25bad6e8878b517601a0fb65741189903d503789e12cd6d81810b
2022-09-01 12:58:16 [Relaychain] 💤 Idle (2 peers), best: #117 (0x1ba0…6262), finalized #113 (0x0798…07c2), ⬇ 0.6kiB/s ⬆ 0.4kiB/s    
2022-09-01 12:58:16 [Parachain] 💤 Idle (0 peers), best: #2 (0x9995…810b), finalized #1 (0x50e8…5acb), ⬇ 0 ⬆ 0    
...
2022-09-01 12:58:24 [Parachain] 🙌 Starting consensus session on top of parent 0x99951a12bbb25bad6e8878b517601a0fb65741189903d503789e12cd6d81810b    
2022-09-01 12:58:24 [Parachain] 🎁 Prepared block for proposing at 3 (0 ms) [hash: 0x614a7f68290d68ec8b441886dbc6bda95593028c856cf32a46a64ca85af5b51f; parent_hash: 0x9995…810b; extrinsics (2): [0xe698…6c13, 0x5225…a083]]    
2022-09-01 12:58:24 [Parachain] 🔖 Pre-sealed block for proposal at 3. Hash now 0x7ea49c65781d6c9a04bd8ae4f89b0c7bd84c7b3302233024ffa54909dc977a32, previously 0x614a7f68290d68ec8b441886dbc6bda95593028c856cf32a46a64ca85af5b51f.    
2022-09-01 12:58:24 [Parachain] ✨ Imported #3 (0x7ea4…7a32)    
2022-09-01 12:58:24 [Parachain] PoV size { header: 0.1787109375kb, extrinsics: 2.7470703125kb, storage_proof: 2.6123046875kb }
2022-09-01 12:58:24 [Parachain] Compressed PoV size: 4.802734375kb
2022-09-01 12:58:24 [Parachain] Produced proof-of-validity candidate. block_hash=0x7ea49c65781d6c9a04bd8ae4f89b0c7bd84c7b3302233024ffa54909dc977a32
2022-09-01 12:58:26 [Relaychain] 💤 Idle (2 peers), best: #119 (0x20a1…5579), finalized #116 (0x0c12…2ba3), ⬇ 0.7kiB/s ⬆ 1.4kiB/s    
2022-09-01 12:58:26 [Parachain] 💤 Idle (0 peers), best: #2 (0x9995…810b), finalized #1 (0x50e8…5acb), ⬇ 0 ⬆ 0    
...
2022-09-01 12:58:36 [Relaychain] 👶 New epoch 12 launching at block 0xa2a3…253c (block slot 277010386 &gt;= start slot 277010386).    
2022-09-01 12:58:36 [Relaychain] 👶 Next epoch starts at slot 277010396    
2022-09-01 12:58:36 [Relaychain] ✨ Imported #121 (0xa2a3…253c)    
2022-09-01 12:58:36 [Relaychain] Advanced session window for approvals update=Advanced { prev_window_start: 6, prev_window_end: 11, new_window_start: 7, new_window_end: 12 }
2022-09-01 12:58:36 [Parachain] Starting collation. relay_parent=0xa2a3fabb974f673d49cc6b50605e6d90595234ce16fd7bd01bce808bbdf0253c at=0x7ea49c65781d6c9a04bd8ae4f89b0c7bd84c7b3302233024ffa54909dc977a32
2022-09-01 12:58:36 [Relaychain] 💤 Idle (2 peers), best: #121 (0xa2a3…253c), finalized #117 (0x1ba0…6262), ⬇ 1.0kiB/s ⬆ 0.6kiB/s    
2022-09-01 12:58:36 [Parachain] 💤 Idle (0 peers), best: #3 (0x7ea4…7a32), finalized #2 (0x9995…810b), ⬇ 0 ⬆ 0    
...
</code></pre>
<h3 id="连接并提交交易"><a class="header" href="#连接并提交交易">连接并提交交易</a></h3>
<p>到目前为止，你已经使用 Polkadot/Substrate Portal 连接到本地网络，并将交易提交到本地中继链。现在已经有了一个运行的平行链并连接到中继链，你可以使用 Polkadot/Substrate Portal 向平行链提交交易。</p>
<p>要连接到平行链并提交交易，在浏览器中打开 <a href="https://polkadot.js.org/apps/#/explorer">Polkadot/Substrate Portal</a>，点击应用程序左上角的网络选择器。</p>
<p><img src="https://awesomeprogram.gitee.io/imgdata/tech_bc_subnetselec.jpg" alt="" /></p>
<p>将自定义端点更改为连接到平行链的 WebSocket 端口。如果你按照本节教程中的设置，则连接到 8844 端口。</p>
<p><img src="https://awesomeprogram.gitee.io/imgdata/tech_bc_subpaport.jpg" alt="" /></p>
<p>点击 <strong>Account</strong>，选择 <strong>Transfer</strong>，将资金从Alice账户转到另一个账户：</p>
<ul>
<li>选择要将资金发送到的帐户。</li>
<li>打印金额。</li>
<li>点击 <strong>Make Transfer</strong>。</li>
<li>查看交易记录，然后点击 <strong>Sign and Submit</strong> 以授权转账。</li>
</ul>
<p>点击 <strong>Accounts</strong> 以验证转账已完成且平行链交易成功。如果交易成功，你就有了一个正常工作的平行链。</p>
<h3 id="重置区块链状态"><a class="header" href="#重置区块链状态">重置区块链状态</a></h3>
<p>本节教程中连接到中继链的平行链 collator 包含平行链的所有区块链数据。在这个平行链网络中只有一个节点，所以你提交的任何交易都只存储在这个节点上。中继链不存储任何平行链状态。中继链只存储与之相连的平行链的区块头信息。</p>
<p>出于测试目的，你可能希望定期清除区块链状态以重新开始。但是应该记住，如果清除链状态或手动删除数据库，你将无法恢复数据或恢复链状态。如果你有想要保存的数据，那么在清除平行链状态之前应该确保有一个副本。</p>
<p>如果你想重新使用一个干净的环境进行测试，你应该完全删除本地中继链节点和平行链节点的链状态。</p>
<p>要重置区块状态，在运行平行链模板节点的终端中，按 Control-c，通过运行以下命令清除平行链 collator 状态：</p>
<pre><code class="language-bash editable noplayground">rm -rf /tmp/parachain
</code></pre>
<p>在 <code>alice</code> 验证者节点或 <code>bob</code> 验证者节点正在运行的终端中，按 Control-c，通过运行以下命令清除验证程序状态：</p>
<pre><code class="language-bash editable noplayground">rm -rf /tm/relay
</code></pre>
<h2 id="连接rococo测试网获取测试网插槽"><a class="header" href="#连接rococo测试网获取测试网插槽">连接Rococo测试网（获取测试网插槽）</a></h2>
<p>本节教程演示如何在公共测试网络（例如 <a href="https://wiki.polkadot.network/docs/build-pdk#rococo-testnet">Rococo</a> 测试网络）上部署一个平行链。公共测试网络比私有网络有更高的使用门槛，但也表示准备将一个平行链项目转移到生产网络的重要一步。</p>
<h3 id="从帐户和代币开始"><a class="header" href="#从帐户和代币开始">从帐户和代币开始</a></h3>
<p>要对 Rococo 执行任何操作，你需要 ROC 代币并存储代币，你必须能够访问与 Substrate-compatible 的数字货币钱包。你不能在任何公共设置中使用<a href="https://docs.substrate.io/reference/command-line-tools/subkey/#predefined-accounts-and-keys">开发密钥和帐户</a>进行操作。想要持有数字货币有很多选择，包括硬件钱包和基于浏览器的应用程序，其中一些比其他更有信誉。在选择一个之前，你应该自己做好调查。</p>
<p>但是，你可以使用 <a href="https://polkadot.js.org/apps/?rpc=wss%3A%2F%2Frococo-rpc.polkadot.io#/explorer">Polkadot/Substrate Portal</a> 网站开始测试。</p>
<p>要准备一个账户，将<a href="https://polkadot.js.org/apps/?rpc=wss%3A%2F%2Frococo-rpc.polkadot.io#/explorer">Polkadot/Substrate Portal</a>连接到 Rococo 网络，点击并选择 <strong>Accounts</strong>，点击 <strong>Add Account</strong>，复制你的 secret seed phrase，并把它放在一个安全的地方，然后点击 <strong>Next</strong>，输出一个账户的名称和密码，然后点击 <strong>Next</strong>，点击 <strong>Save</strong>，加入 <a href="https://matrix.to/#/#rococo-faucet:matrix.org">Rococo Element channel</a>，并使用 <code>!drip</code> 发送消息，为你的 Rococo 在钱包中获得 100 ROC 的公共地址。例如，发送类似以下内容的消息：</p>
<pre><code class="language-bash editable noplayground">!drip 5CVYesFxbDBU5rkZXYTAA6BnADbCoSpQkvexBQZvbtvyGTP1
</code></pre>
<h3 id="预留平行链标识符"><a class="header" href="#预留平行链标识符">预留平行链标识符</a></h3>
<p>你必须预留一个平行链标识符，然后才能注册为 Rococo 上的平行链。步骤与<a href="blockchain/chapter_1_2_1_6.html#%E8%BF%9E%E6%8E%A5%E6%9C%AC%E5%9C%B0%E5%B9%B3%E8%A1%8C%E9%93%BE">连接本地平行链</a>以保留本地中继链上的标识符中的步骤类似。但是，对于公共测试网，你将会被分配到下一个真实可用的标识符。</p>
<p>要预留一个标识符，将<a href="https://polkadot.js.org/apps/?rpc=wss%3A%2F%2Frococo-rpc.polkadot.io#/explorer">Polkadot/Substrate Portal</a>连接到 Rococo 网络，点击 <strong>Network</strong> 并选择 <strong>Parachains</strong>。</p>
<p><img src="https://awesomeprogram.gitee.io/imgdata/tech_bc_subrosepar.jpg" alt="" /></p>
<p>点击 <strong>Parathreads</strong>，然后点击 <strong>ParaId</strong>，检查交易并注意分配给你的平行链标识符，然后点击 <strong>Submit</strong>。输入您的密码以验证你的身份，然后点击 <strong>Sign and Submit</strong>。</p>
<p><img src="https://awesomeprogram.gitee.io/imgdata/tech_bc_subauroid.jpg" alt="" /></p>
<p>点击 <strong>Network</strong> 并选择 <strong>Explorer</strong> ，检查成功的 <code>registrar.Reserved</code> 的最近事件列表。</p>
<p><img src="https://awesomeprogram.gitee.io/imgdata/tech_bc_subroreidev.jpg" alt="" /></p>
<h3 id="修改chain-specification文件"><a class="header" href="#修改chain-specification文件">修改chain specification文件</a></h3>
<p>注册平行链所需的文件必须指定要连接的正确的中继链和已分配给你的平行链标识符。要进行这些修改，必须为平行链构建和修改 chain specification 文件。在本节教程中，中继链是 <code>rococo</code>，而不是在<strong>连接本地平行链</strong>教程中使用的 <code>rococo-local</code>，平行链标识符是 <code>4105</code>。</p>
<p>要修改 chain specification，通过运行以下命令生成平行链模板节点的纯文本chain specification：</p>
<pre><code class="language-bash editable noplayground">./target/release/parachain-template-node build-spec --disable-default-bootnode &gt; plain-parachain-chainspec.json
</code></pre>
<p>打开平行链模板节点的纯文本chain specification文件，将 <code>relay-chain</code> 设置为 <code>rococo</code>, <code>para_id</code> 设置为已分配的标识符。例如，如果你预留的标识符是 <code>4105</code>，则将 <code>para_id</code> 字段设置为 <code>4105</code>：</p>
<pre><code class="language-json editable noplayground">...
&quot;relay_chain&quot;: &quot;rococo&quot;,
&quot;para_id&quot;: 4105,
&quot;codeSubstitutes&quot;: {},
&quot;genesis&quot;: {
  ...
}
</code></pre>
<p>将 <code>parachainId</code> 设置为你之前预留的平行链标识符。</p>
<pre><code class="language-json editable noplayground">...
  &quot;parachainSystem&quot;: null,
  &quot;parachainInfo&quot;: {
    &quot;parachainId&quot;: 4105
  },
...
</code></pre>
<p>将你的帐户公钥添加到会话密钥部分。</p>
<pre><code class="language-json editable noplayground">...
  &quot;session&quot;: {
    &quot;keys&quot;: [
     [
       &quot;5CVYesFxbDBU5rkZXYTAA6BnADbCoSpQkvexBQZvbtvyGTP1&quot;,
       &quot;5CVYesFxbDBU5rkZXYTAA6BnADbCoSpQkvexBQZvbtvyGTP1&quot;,
       {
        &quot;aura&quot;: &quot;5CVYesFxbDBU5rkZXYTAA6BnADbCoSpQkvexBQZvbtvyGTP1&quot;
       }
     ],
    ]
  }
...
</code></pre>
<p>保存代码并关闭纯文本 chain specification 文件。</p>
<p>通过运行以下命令，从修改后的 chain specification 文件生成原始 chain specification  文件：</p>
<pre><code class="language-bash editable noplayground">./target/release/parachain-template-node build-spec --chain plain-parachain-chainspec.json --disable-default-bootnode --raw &gt; raw-parachain-chainspec.json
</code></pre>
<h3 id="导出必要的文件"><a class="header" href="#导出必要的文件">导出必要的文件</a></h3>
<p>准备要注册的平行链 collator，通过运行类似如下的命令导出平行链的 WebAssembly 运行时：</p>
<pre><code class="language-bash editable noplayground">./target/release/parachain-template-node export-genesis-wasm --chain raw-parachain-chainspec.json para-4105-wasm
</code></pre>
<p>通过运行类似如下的命令生成一个平行链初始状态：</p>
<pre><code class="language-bash editable noplayground">./target/release/parachain-template-node export-genesis-state --chain raw-parachain-chainspec.json para-4105-genesis-state
</code></pre>
<h3 id="启动collator节点"><a class="header" href="#启动collator节点">启动collator节点</a></h3>
<p>你必须具有 collator 公开可访问并且可发现的端口，以便使平行链节点与 Rococo 验证器节点进行 peer 连接，从而生成块。你可以使用 <code>--port</code> 命令行选项指定要使用的端口。例如，可以使用类似于以下的命令启动 collator：</p>
<pre><code class="language-bash editable noplayground./target/release/parachain-template-node --collator \">  --chain raw-parachain-chainspec.json \
  --base-path /tmp/parachain/pubs-demo \
  --port 50333 \
  --ws-port 8855 \
  -- \
  --execution wasm \
  --chain rococo \
  --port 50343 \
  --ws-port 9988
</code></pre>
<p>在此示例中，第一个 <code>--port</code> 为 collator 节点设置指定的端口，第二个 <code>--port</code> 指定嵌入式中继链节点的端口。第一个 <code>--ws-port</code> 设置指定可以使用 Polkadot-JS API 调用或 Polkadot/Substrate Portal 应用程序连接到 collator 的端口。第二个 <code>--ws-port</code> 指定使用 Polkadot-JS API 调用或 Polkadot/Substrate Portal 应用程序连接到嵌入式中继链的端口。</p>
<h3 id="注册为一个平行线程"><a class="header" href="#注册为一个平行线程">注册为一个平行线程</a></h3>
<p>你在公共中继链上租赁一个插槽，成为一个平行链之前，首先必须注册为 Rococo 上的平行线程。</p>
<p>要注册为一个平行线程，将<a href="https://polkadot.js.org/apps/?rpc=wss%3A%2F%2Frococo-rpc.polkadot.io#/explorer">Polkadot/Substrate Portal</a>连接到 Rococo 网络。点击 <strong>Network</strong> 并选择 <strong>Parachains</strong>。点击 <strong>Parathread</strong>，然后点击 <strong>ParaThread</strong>。</p>
<p><img src="https://awesomeprogram.gitee.io/imgdata/tech_bc_subroparth.jpg" alt="" /></p>
<p>验证平行链的所有者和平行链的标识符，并上传包含 WebAssembly 验证函数和平行链初始状态的文件，然后点击 <strong>Submit</strong>。输入密码验证你的身份，然后点击 <strong>Sign and Submit</strong>。向下滚动平行线程列表，并验证你的平行线程注册是否为 <strong>Onboarding</strong>：</p>
<p><img src="https://awesomeprogram.gitee.io/imgdata/tech_bc_subroconbo.jpg" alt="" /></p>
<p>你也可以通过在 Network Explorer 中 <code>registrar.Registered</code> 的事件来验证你的注册请求。提交注册请求后，需要两个<a href="https://wiki.polkadot.network/docs/glossary#session">会话</a>才能完成平行线程的加载。</p>
<h3 id="请求一个平行链插槽"><a class="header" href="#请求一个平行链插槽">请求一个平行链插槽</a></h3>
<p>在平行链作为一个平行线程被激活后，相关的项目团队应该在 Rococo 上打开一个<strong>永久</strong>或<strong>临时平行链插槽</strong>的<a href="https://github.com/paritytech/subport/issues/new?assignees=&amp;labels=Rococo&amp;template=rococo.yaml">请求</a>。</p>
<ul>
<li><strong>永久插槽</strong>通常分配给成功完成插槽租赁拍卖并在 Polkadot 上部署有插槽的平行链的团队。永久插槽使这些团队能够在实时公共环境中持续测试他们的代码库与最新 Polkadot 特性的兼容性。目前只有有限数量的永久插槽可用。</li>
<li><strong>临时插槽</strong>是以连续轮循的方式动态分配的平行链插槽。从每个租期开始时，在一定的租期内如果不超过中继链配置中定义的最大平行线程数，将自动升级为平行链。在租期结束时活跃的平行链将自动降级为平行线程，以释放槽位供其他人在随后的租期使用。具有动态分配的临时插槽使在 Polkadot 上没有平行链插槽的团队能够在现实的网络环境中更频繁地测试他们的运行时。</li>
</ul>
<h4 id="提交一个插槽请求"><a class="header" href="#提交一个插槽请求">提交一个插槽请求</a></h4>
<p>Rococo 运行时需要 <code>sudo</code> 访问来分配插槽。例如，Rococo 运行时指定用于分配插槽的帐户必须具有 root 级别权限：</p>
<pre><code class="language-rust editable noplayground">AssignSlotOrigin = EnsureRoot&lt;Self::AccountId&gt;;
</code></pre>
<p>最终，插槽分配将通过 Rococo 治理方式由社区驱动。然而，Rococo <code>sudo</code> 的密钥目前是由 Parity 公司控制。因此，你必须提交 <a href="https://github.com/paritytech/subport/issues/new?assignees=&amp;labels=Rococo&amp;template=rococo.yaml">Rococo Slot Request</a> 接收插槽分配。分配插槽后，你将收到通知，并准备连接。</p>
<h4 id="使用管理帐户分配一个插槽"><a class="header" href="#使用管理帐户分配一个插槽">使用管理帐户分配一个插槽</a></h4>
<p>如果你有一个具有 <code>AssignSlotOrigin</code> origin 帐户，你可以使用该帐户在 Rococo 网络上分配一个临时插槽。</p>
<p>要分配一个临时插槽，将<a href="https://polkadot.js.org/apps/?rpc=wss%3A%2F%2Frococo-rpc.polkadot.io#/explorer">Polkadot/Substrate Portal</a>连接到 Rococo 网络。点击 <strong>Developer</strong> 并选择 <a href="https://polkadot.js.org/apps/?rpc=wss%3A%2F%2Frococo-rpc.polkadot.io#/extrinsics"><strong>Extrinsics</strong></a>。选择要用于提交交易的帐户。选择 <code>assignedSlots</code> pallet。选择 <code>assignTempParachainSlot</code> 函数。输入分配给你的预留平行链标识符。为 <code>LeasePeriodStart</code> 选择 <code>Current</code>，如果当前的插槽已满，你将被分配到下一个可用的插槽。点击 <strong>Submit Transaction</strong>。输入密码以验证你的身份，然后点击 <strong>Sign and Submit</strong>。如果你的帐户没有足够的权限，则交易将失败，并出现 <strong>BadOrigin</strong> 错误。</p>
<h4 id="租赁期限"><a class="header" href="#租赁期限">租赁期限</a></h4>
<p>为在 Rococo 上分配的平行链插槽，当前租赁期限和插槽可用配置是：</p>
<ul>
<li><strong>永久插槽至少持续时间</strong>：1年（365天）</li>
<li><strong>临时插槽至少持续时间</strong>：3天</li>
<li><strong>永久插槽的最大数量</strong>：最多25个永久插槽</li>
<li><strong>临时插槽的最大数量</strong>：最多20个临时插槽</li>
<li><strong>每个租赁期分配的最大临时插槽</strong>：每3天临时租赁期最多5个临时插槽</li>
</ul>
<p>这些配置可能会根据社区的需求进行改变。</p>
<h3 id="测试你的平行链"><a class="header" href="#测试你的平行链">测试你的平行链</a></h3>
<p>在一个插槽被分配并被激活后，你可以在 Rococo 测试网络上测试你的平行链。注意当临时插槽租期结束时，平行链会自动降级为平行线程。已注册和已批准的插槽以轮询的方式自动循环，因此你可以继续不断地以平行链的形式重新连接。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="工具集成-1"><a class="header" href="#工具集成-1">工具集成</a></h1>
<p>本教程重点介绍了工一些具和节点扩展，这些工具和节点扩展使你能够部署与其他系统集成的节点，以及如何使用额外的生态系统工具，让你能够访问、同步，与你自己或其他区块链的信息进行交互。</p>
<h2 id="集成一个轻客户端节点"><a class="header" href="#集成一个轻客户端节点">集成一个轻客户端节点</a></h2>
<p>本节教程演示如何使用浏览器中运行的 WebAssembly 轻客户端连接到基于 Substrate 的区块链。在本节教程中，你将使用 Substrate Connect 浏览器扩展与区块链交互，而不使用 RPC 服务。</p>
<h3 id="什么是substrate-connect"><a class="header" href="#什么是substrate-connect">什么是Substrate Connect</a></h3>
<p>Substrate Connect是一个基于 WebAssembly 的轻客户端，可以直接在浏览器中运行。Substrate Connect light client 的核心软件组件是 <a href="https://github.com/paritytech/smoldot/">smoldot</a>。该软件需要的资源比完整节点更少，因此它可以在资源受限的环境中运行，包括浏览器、移动端点和物联网设备。轻客户端可以通过连接到一个完整的节点来同步链中的数据，而不是作为一个运行的 peer 并直接连接到区块链，以为了生产区块或导入区块。</p>
<h4 id="安全同步"><a class="header" href="#安全同步">安全同步</a></h4>
<p>软件钱包允许用户通过可信任的中间第三方节点来与区块链交互，与之不同的是，轻客户端从完整节点下载区块头，这样他们就可以使用区块头中的 Merkle trie root 来验证正在同步的信息是否被篡改。Merkle trie root 作为数据没有被修改的加密证明，而不需要轻客户端信任整个节点。</p>
<h4 id="substrate-connect作为一个浏览器扩展"><a class="header" href="#substrate-connect作为一个浏览器扩展">Substrate Connect作为一个浏览器扩展</a></h4>
<p>因为轻客户端不参与区块生成或共识，所以它们不需要在线，也不需要与网络进行持续通信。但是，如果你将轻客户端作为浏览器扩展来运行，那么你可以同时运行多个轻客户端，并且只要浏览器保持打开状态，就可以在浏览器会话中保持同步。</p>
<p>运行一个轻客户端作为浏览器扩展还避免了完整节点需要的使用 Transport Layer Security（TLS）和 Secure Socket Layer（SSL）证书。使用 Substrate Connect，同步在后台进行，而不需要通过 WebSocket 端口（一些浏览器会将其作为不安全连接并阻止）。运行Substrate Connect 作为浏览器扩展还提供了更好的应用程序性能和响应更快的用户体验。</p>
<h4 id="使用substrate-connect的应用程序和用户实践"><a class="header" href="#使用substrate-connect的应用程序和用户实践">使用Substrate Connect的应用程序和用户实践</a></h4>
<p>如果你使用 Substrate Connect 构建应用程序，<code>smoldot</code> 客户端可以检测到用户是否拥有浏览器扩展，并在浏览器扩展可用时自动使用该扩展。如果用户没有安装浏览器扩展，<code>smoldot</code> 会自动在你的 web 应用程序中创建一个 WebAssembly 轻客户端。虽然将 Substrate Connect 作为浏览器扩展运行是可选的，该扩展提供了以下优势：</p>
<ul>
<li>更好的资源使用效率。多个浏览器 tabs 可以共享一个连接到同一条链，而不是每个浏览器 tabs 或窗口打开自己的连接。</li>
<li>更好的同步速度。只要打开一个浏览器 tabs，浏览器扩展就自动开始与链同步，保持缓存以便连接到链，对于用户打开的每个新标签或浏览器窗口，同步几乎是瞬时的。如果没有浏览器扩展，同步一个链可能需要10到30秒。</li>
<li>更好的连通性。浏览器扩展可以连接到未安装 TLS/SSL 证书的节点。</li>
</ul>
<h3 id="下载substrate-connect"><a class="header" href="#下载substrate-connect">下载Substrate Connect</a></h3>
<p>由于 Substrate Connect 浏览器扩展提供的优势，第一步首先需要安装浏览器扩展。</p>
<ol>
<li>使用 Chrome 或 Firefox 打开链接 https://substrate.io/developers/substrate-connect/。</li>
<li>点击 <a href="https://chrome.google.com/webstore/detail/substrate-connect-extensi/khccbhhbocaaklceanjginbdheafklai">Chrome</a> 或 <a href="https://addons.mozilla.org/en-US/firefox/addon/substrate-connect/">Firefox</a>。</li>
<li>点击 <strong>Add to Chrome</strong> 或 <strong>Add to Firefox</strong>，然后确认你想要将扩展添加到浏览器。</li>
</ol>
<h3 id="连接到一个众所周知的链"><a class="header" href="#连接到一个众所周知的链">连接到一个众所周知的链</a></h3>
<p>在 Substrate Connect 轻客户端可以连接到网络之前，你必须有一个 web 应用程序，该应用程序指定了请客户端应该连接到的网络，用于通信的节点，以及它在初始阶段必须具有的共识临界状态。这些信息可以在网络的 chain specification 文件中获得。</p>
<p>Substrate Connect 预先配置为识别在 <a href="https://paritytech.github.io/substrate-connect/api/enums/connect_src.WellKnownChain.html">WellKnownChain</a> 列表中定义的几个链，这些知名的链是：</p>
<ul>
<li>Polkadot 被识别为 <code>polkadot</code></li>
<li>Kusama 被识别为 <code>ksmcc3</code></li>
<li>Rococo 被识别为 <code>rococo_v2_2</code></li>
<li>Westend 被识别为 <code>westend2</code></li>
</ul>
<p>要连接到这些链之一，通过以下命令克隆 <code>empty-webapp</code> 模板，创建使用 Substrate Connect 的 web 应用：</p>
<pre><code class="language-bash editable noplayground">git clone https://github.com/bernardoaraujor/empty-webapp

cd empty-webapp

# 通过运行以下命令安装来自 Polkadot-JS RPC 提供的依赖项
yarn add @polkadot/rpc-provider

# 通过运行以下命令安装 Polkadot-JS API 中的依赖项
yarn add @polkadot/api
</code></pre>
<p>安装这些依赖项之后，就可以在示例应用程序中使用它们。</p>
<p>在编辑器中打开 <code>empty-webapp/index.ts</code> 文件，复制并粘贴以下应用程序代码，使用 <code>substrate-connect</code> 作为提供以创建一个 Substrate Connect 实例，使用 <code>polkadot</code> chain specification 文件连接到 <code>Polkadot</code> 中继链。</p>
<pre><code class="language-javascript editable noplayground">import {
  ScProvider,
  WellKnownChain,
} from &quot;@polkadot/rpc-provider/substrate-connect&quot;;
import { ApiPromise } from &quot;@polkadot/api&quot;;

window.onload = () =&gt; {
  void (async () =&gt; {
    try {
      const provider = new ScProvider(WellKnownChain.polkadot);
      
      await provider.connect();
      const api = await ApiPromise.create({ provider });
      await api.rpc.chain.subscribeNewHeads(
        (lastHeader: { number: unknown; hash: unknown }) =&gt; {
          console.log(
            `New block #${lastHeader.number} has hash ${lastHeader.hash}`
          );
        }
      );
    } catch (error) {
      console.error(&lt;Error&gt;error);
    }
  })();
};
</code></pre>
<p>在 Polkadot-JS API 中，你可以像这样创建一个实例：</p>
<pre><code class="language-javascript editable noplayground">// Import
import { ApiPromise, WsProvider } from '@polkadot/api';

// Construct
const wsProvider = new WsProvider('wss://rpc.polkadot.io');
const api = await ApiPromise.create({ provider: wsProvider });
</code></pre>
<p>对于 Substrate Connect，你将 WebSocket（<code>WsProvider</code>）provider 替换为 Substrate Connect（<code>ScProvider</code>），并指定 Polkadot 网络（<code>WellKnownChain.polkadot</code>）的 chain specification，而不是 WebSocket URL 客户端地址。</p>
<p>通过运行以下命令安装任何剩余的依赖项：</p>
<pre><code class="language-bash editable noplayground">yarn
</code></pre>
<p>通过运行以下命令启动 web 应用程序：</p>
<pre><code class="language-bash editable noplayground">yarn dev
</code></pre>
<p>如果在启动本地服务器时出现编译器错误，你可能会缺少当前 <code>yarn</code> 配置中没有考虑到的依赖。如果缺少依赖项，可以通过运行类似以下的命令添加依赖包：</p>
<pre><code class="language-bash editable noplayground">yarn add -D buffer
</code></pre>
<p>打开 URL <code>http://localhost:3001/</code> 验证浏览器。</p>
<p>打开浏览器控制台。打开浏览器控制台的方法取决于所使用的浏览器和操作系统,例如，在 Chrome 上，选择更多工具，开发人员工具，然后单击控制台。</p>
<p>验证 <code>smoldot</code> 进程已初始化，然后是来自 Polkadot 传入块的哈希值。例如，控制台应该显示类似如下的日志信息：</p>
<pre><code class="language-bash editable noplayground">[smoldot] Smoldot v0.6.25
smoldot-light.js:41 [smoldot] Chain initialization complete for polkadot. Name: &quot;Polkadot&quot;. Genesis hash: 0x91b1…90c3. State root hash: 0x29d0d972cd27cbc511e9589fcb7a4506d5eb6a9e8df205f00472e5ab354a4e17. Network identity: 12D3KooWRse9u6Z9ukP4C92YCCH2gXziNm8ThRch2owaaFh9H6D1. Chain specification or database starting at: 0xae3e…f81d (#11228238)
...
New block #11322769 has hash 0x464c0199ede92a89920c54c21abc741ea47daca1d62d61d7b9af78062f04c7a3 index.ts:10 
New block #11322770 has hash 0xd66c61e5417249df228798f38535a6dd17b8b268c165e0a6b0e72ba74e954f9d index.ts:10
</code></pre>
<p>这个简单的 web 应用程序只连接到 Polkadot 检索块哈希值。此应用程序的主要目的是演示在不使用中心化的网络入口点（例如特定 RPC 节点的 URL）的情况下连接到链。但是，你可以扩展这个应用程序来做更多的事情，因为在你将 <code>WsProvider</code> 替换为 <code>ScProvider</code> 之后，你可以简单地使用现有的<a href="https://polkadot.js.org/docs/">Polkadot-JS API</a> 为你的应用程序编写代码。</p>
<p>按 Control-c 停止 <code>smoldot</code> 轻客户端节点。</p>
<h3 id="连接到自定义chain-specification"><a class="header" href="#连接到自定义chain-specification">连接到自定义chain specification</a></h3>
<p>连接到自定义 chain specification 或公共可访问的平行链类似于连接到 well-known 的链之一。代码中的主要区别在于，必须显式地标识要使用的 Substrate Connect 的 chain specification。这部分教程演示如何通过连接到 Statemint 平行链来连接到自定义 chain specification。Statemint 是一个连接到 Polkadot 的通用良好的平行链，并且有一个公开的 chain specification 文件。</p>
<p>要连接到这个链，从 <a href="https://github.com/paritytech/cumulus/blob/master/parachains/chain-specs/statemint.json">cumulus repository</a> 下载定制 chain specification 文件。将下载的 chain specification 复制到你在<a href="blockchain/chapter_1_2_1_7.html#%E8%BF%9E%E6%8E%A5%E5%88%B0%E4%B8%80%E4%B8%AA%E4%BC%97%E6%89%80%E5%91%A8%E7%9F%A5%E7%9A%84%E9%93%BE"><strong>连接到一个众所周知的链</strong></a>中创建的<code>empty-webapp</code> 目录。</p>
<p>在编辑器中打开 <code>index.ts</code> 文件，删除当前内容。复制并粘贴以下应用程序代码：</p>
<pre><code class="language-javascript editable noplayground">import { ScProvider, WellKnownChain } from &quot;@polkadot/rpc-provider/substrate-connect&quot;;import { ApiPromise } from &quot;@polkadot/api&quot;;
import jsonParachainSpec from &quot;./statemint.json&quot;;

window.onload = () =&gt; {
void (async () =&gt; {
  try {
    const relayProvider = new ScProvider(WellKnownChain.polkadot);
    const parachainSpec = JSON.stringify(jsonParachainSpec);
    const provider = new ScProvider(parachainSpec, relayProvider);
    
    await provider.connect();
    const api = await ApiPromise.create({ provider });
    await api.rpc.chain.subscribeNewHeads((lastHeader: { number: unknown; hash: unknown }) =&gt; {
      console.log(`New block #${lastHeader.number} has hash ${lastHeader.hash}`);
    });
  } catch (error) {
    console.error(&lt;Error&gt;error);
  }
})();
};
</code></pre>
<p>正如你看到的，这段代码有一些重要的区别。</p>
<ul>
<li><code>statemint.json</code> chain specification 文件导入到 <code>jsonParachainSpec</code> 对象中。</li>
<li>chain specification 被转换为一个 JSON-encoded 的字符串，并存储在 <code>parachainSpec</code> 变量中，这样它就可以与 web 服务器交换。</li>
</ul>
<p><code>ScProvider</code> provider 是为 <code>polkadot</code> 中继链创建的，但它被用作创建和连接到平行链 provider 的参数。Substrate Connect 需要此信息来确定与平行链通信的中继链。</p>
<p>运行如下命令启动 web 应用程序</p>
<pre><code class="language-bash editable noplayground">yarn dev
</code></pre>
<p>打开 URL <code>http://localhost:3001/</code> 验证浏览器。在浏览器中打开控制台。</p>
<p>验证 <code>smoldot</code> 进程已初始化，然后是来自 Polkadot 传入块的哈希值。例如，控制台应该显示类似如下的日志信息：</p>
<pre><code class="language-bash editable noplayground">[smoldot] Parachain initialization complete for statemint. Name: &quot;Statemint&quot;. Genesis hash: 0x68d5…de2f. State root hash: 0xc1ef26b567de07159e4ecd415fbbb0340c56a09c4d72c82516d0f3bc2b782c80. Network identity: 12D3KooWArq3iZHdK2jtRZSJzJkkWrKm17JTa9kjwjZkq9Htx5xR. Relay chain: polkadot (id: 1000 smoldot-light.js:41 
[smoldot] Smoldot v0.6.25. Current memory usage: 140 MiB. Average download: 35.4 kiB/s. Average upload: 423 B/s.
New block #1785421 has hash 0x88885ed331f94b4324c5f2eae8413cd36170808ef904b0ec0867646fa53770f7 index.ts:13 
New block #1785422 has hash 0x2ad4d96e061a681e27403694f1d870bb0c4e5c77b5be232a18c7a2e0b7fb2555 index.ts:13 
</code></pre>
<h3 id="高级应用程序开发"><a class="header" href="#高级应用程序开发">高级应用程序开发</a></h3>
<p>本节教程中的示例使用了 <code>@polkadot/rpc-provider/substrate-connect</code>，因为该 provider 可以直接创建使用 <a href="https://polkadot.js.org/docs/">Polkadot-JS API</a> 与链进行交互的应用程序。对于不依赖 Polkadot-JS API 的更高级应用程序开发，你可以安装并使用 <code>@substrate-connect</code>。例如，如果你正在构建自己的应用程序库或编程接口，则应通过运行以下命令安装 Substrate Connect 依赖项：</p>
<pre><code class="language-bash editable noplayground">yarn add @substrate/connect
</code></pre>
<h2 id="访问evm账户"><a class="header" href="#访问evm账户">访问EVM账户</a></h2>
<p>本节教程演示了如何使用 <a href="https://github.com/paritytech/frontier">Frontier</a> 项目中的 crates 来构建一个与<strong>以太坊兼容</strong>的区块链，该区块链可以访问基于以太坊的帐户并执行基于 Solidity 的智能合约。Frontier 项目的两个主要目标是使你能够执行以下操作：</p>
<ul>
<li>使用本地 Substrate 节点不加修改地运行以太坊去中心化应用。</li>
<li>从以太坊主网络导入状态</li>
</ul>
<p>本节教程使用预定义的节点模板提供的工作环境。模板是使用 <a href="https://github.com/paritytech/frontier/blob/master/docs/node-template-release.md">Frontier release guide</a> 中的说明生成的。</p>
<p>如果需要为自己生成独立的模板，可以使用 <a href="https://github.com/paritytech/frontier/blob/master/.maintain/node-template-release.sh">node-template-release.sh</a> 模板生成脚本。如果你使用 <a href="https://github.com/paritytech/frontier">frontier</a> 仓库或模板生成脚本构建自己的节点，请注意 frontier 使用自己版本的 Substrate crates，你可能需要更新 <code>Cargo</code> 文件中的依赖，以匹配项目中的依赖。</p>
<h3 id="创世配置"><a class="header" href="#创世配置">创世配置</a></h3>
<p><code>frontier-node-template</code> 中的开发 chain specification 定义了一个创世块，该块已经为 <code>alice</code> 帐户预配置了一个 EVM 帐户。当你在开发模式中启动该节点时，<code>alice</code> 的 EVM 帐户将使用默认的 Ether 资金额度。你将使用该帐户查看 EVM 帐户详细信息并调用以太坊智能合约。启动节点后，你将能够使用 <a href="https://polkadot.js.org/apps/#?rpc=ws://127.0.0.1:9944">Polkadot-JS application</a> 查看` 的 EVM 帐户的详细信息。</p>
<h3 id="编译一个frontier节点"><a class="header" href="#编译一个frontier节点">编译一个Frontier节点</a></h3>
<p>要编译 <a href="https://github.com/substrate-developer-hub/frontier-node-template">Frontier node template</a>，通过运行一下命令克隆 node template 仓库，并编译 node template：</p>
<pre><code class="language-bash editable noplayground">git clone https://github.com/substrate-developer-hub/frontier-node-template.git

cd frontier-node-template

cargo build --release
</code></pre>
<h3 id="连接到节点"><a class="header" href="#连接到节点">连接到节点</a></h3>
<p>在节点编译后，必须启动该节点才能开始研究预先配置的 EVM 帐户。</p>
<p>要启动本地 Substrate 节点，在 <code>frontier-node-template</code> 目录下，运行一下命令：</p>
<pre><code class="language-bash editable noplayground">./target/release/frontier-template-node --dev
</code></pre>
<p><code>--dev</code> 命令行选项指定节点使用预定义的 <code>development</code> chain specification 运行，该 chain specification 包括 <code>alice</code> 预定义的 EVM 帐户和用于测试的其他帐户。</p>
<p>通过检查终端中显示的输出，验证你的节点已成功启动并运行，终端应该显示类似这样的输出：</p>
<pre><code class="language-bash editable noplayground">2022-07-08 10:06:42 Frontier Node
2022-07-08 10:06:42 ✌️  version 0.0.0-1b6bff4-x86_64-macos
2022-07-08 10:06:42 ❤️  by Substrate DevHub &lt;https://github.com/substrate-developer-hub&gt;, 2021-2022
2022-07-08 10:06:42 📋 Chain specification: Development
2022-07-08 10:06:42 🏷  Node name: flippant-boat-0444
2022-07-08 10:06:42 👤 Role: AUTHORITY
...
</code></pre>
<p>使用 <a href="https://polkadot.js.org/apps/#?rpc=ws://127.0.0.1:9944">Polkadot-JS application</a> 连接本地节点。</p>
<p>点击 <strong>Settings</strong>，然后点击 <strong>Developer</strong>
<img src="https://awesomeprogram.gitee.io/imgdata/tech_bc_subsetdev.jpg" alt="" /></p>
<p>定义以下帐户信息来创建一个 EVM <code>Account</code> 类型，并允许该帐户发送交易和检查区块。要发送交易，你必须定义 <code>Address</code> 和 <code>LookupSource</code> 的值。要检查区块，你必须定义 <code>Transaction</code> 和 <code>Signature</code> 的值。</p>
<pre><code class="language-json editable noplayground">{
  &quot;Address&quot;: &quot;MultiAddress&quot;,
  &quot;LookupSource&quot;: &quot;MultiAddress&quot;,
  &quot;Account&quot;: {
     &quot;nonce&quot;: &quot;U256&quot;,
     &quot;balance&quot;: &quot;U256&quot;
  },
  &quot;Transaction&quot;: {
     &quot;nonce&quot;: &quot;U256&quot;,
     &quot;action&quot;: &quot;String&quot;,
     &quot;gas_price&quot;: &quot;u64&quot;,
     &quot;gas_limit&quot;: &quot;u64&quot;,
     &quot;value&quot;: &quot;U256&quot;,
     &quot;input&quot;: &quot;Vec&lt;u8&gt;&quot;,
     &quot;signature&quot;: &quot;Signature&quot;
  },
  &quot;Signature&quot;: {
     &quot;v&quot;: &quot;u64&quot;,
     &quot;r&quot;: &quot;H256&quot;,
     &quot;s&quot;: &quot;H256&quot;
  }
}
</code></pre>
<p>点击保存</p>
<h3 id="使用rpc查询余额"><a class="header" href="#使用rpc查询余额">使用RPC查询余额</a></h3>
<p>在为 EVM 帐户配置对应的设置后，可以使用 Polkadot-JS 应用程序查看 <code>alice</code> 的 EVM 帐户信息。</p>
<ol>
<li>验证你的节点仍在运行，并且 Polkadot-JS 应用程序已连接到该节点。</li>
<li>点击 <strong>Developer</strong>，然后选择 <strong>RPC calls</strong>。</li>
<li>在 <strong>Submission</strong> 选项卡上，选择 <strong>eth</strong> 作为要调用的端点。</li>
<li>从要调用的函数列表中选择 <strong>getBalance(address, number)</strong>。</li>
<li>为 <code>alice</code> 帐户的地址指定 EVM 帐户标识符。
预定义账户地址为 <code>0xd43593c715fdd31c61141abd04a99fd6822c8558</code>。帐户的地址是使用 <a href="https://github.com/substrate-developer-hub/frontier-node-template/tree/main/utils/README.md#--evm-address-address">Substrate EVM utilities</a> 从 <code>alice</code> 帐户的公钥计算出来的。</li>
<li>点击 <strong>Submit RPC call</strong>，该调用应该返回如下类似的输出：</li>
</ol>
<pre><code class="language-bash editable noplayground">2: eth.getBalance: U256
340,282,366,920,938,463,463,374,607,431,768,210,955
</code></pre>
<h3 id="部署一个智能合约"><a class="header" href="#部署一个智能合约">部署一个智能合约</a></h3>
<p>现在你已经了解了如何查询以太坊地址的余额，你可能还想探索如何部署和调用以太坊智能合约并测试相关功能。这部分内容会使用一个 <a href="https://www.trufflesuite.com/truffle">Truffle</a> 示例合约来定义 <a href="https://github.com/substrate-developer-hub/frontier-node-template/blob/main/examples/contract-erc20/truffle/contracts/MyToken.sol">ERC-20 token</a>。你也可以使用 Polkadot JS SDK 和 <a href="https://github.com/substrate-developer-hub/frontier-node-template/tree/main/examples/contract-erc20">Typescript</a> 创建一个 ERC-20 token 合约。</p>
<p>创建 ERC-20 合约。为了方便起见，你可以使用 <a href="https://github.com/substrate-developer-hub/frontier-node-template/blob/main/examples/contract-erc20/truffle/contracts/MyToken.json">MyToken.json</a> 中的 token 合约编译的 <code>bytecode</code>，然后将合约部署到 Substrate 区块链上。</p>
<p>验证你的节点仍在运行，并且 <a href="https://polkadot.js.org/apps/#?rpc=ws://127.0.0.1:9944">Polkadot-JS application</a> 已连接到该节点。</p>
<p>点击 <strong>Developer</strong>，然后选择 <strong>Extrinsics</strong>。</p>
<p>选择 <strong>ALICE</strong> 开发帐户作为用于提交交易的帐户。</p>
<p>选择 <strong>evm</strong>。</p>
<p>选择 <strong>create</strong> 函数。</p>
<p>配置该函数的参数：
|<strong>For this</strong>|<strong>Specify this</strong>|
|:-----|:-----|
|<code>source</code>|0xd43593c715fdd31c61141abd04a99fd6822c8558|
|<code>init</code>|<code>MyToken.json</code> 中的原始 <code>bytecode</code> 十六进制值|
|<code>value</code>|0|
|<code>gasLimit</code>|4294967295|
|<code>maxFeePerGas</code>|100000000|</p>
<p>你可以将可选参数保留为空，<code>nonce</code> 的值将增加源帐户的已知 nonce 值，并从 <code>0x0</code> 开始。根据所选函数的不同，你可能需要删除未使用的参数。</p>
<p>点击 <strong>Submit Transaction</strong>。</p>
<p>点击 <strong>Sign and Submit</strong> 对交易进行授权。</p>
<h3 id="查看智能合约"><a class="header" href="#查看智能合约">查看智能合约</a></h3>
<p>提交交易后，合约将部署到网络上，你可以使用 <a href="https://polkadot.js.org/apps/#?rpc=ws://127.0.0.1:9944">Polkadot-JS application</a> 查看有关它的信息。</p>
<p>验证你的节点仍在运行，并且 <a href="https://polkadot.js.org/apps/#?rpc=ws://127.0.0.1:9944">Polkadot-JS application</a> 已连接到该节点。</p>
<p>点击 <strong>Network</strong>，然后选择 <strong>Explorer</strong>。</p>
<p>点击 <strong>evm.Created</strong> 事件以验证新创建的合约的地址为 <code>0x8a50db1e0f9452cfd91be8dc004ceb11cb08832f</code>。
<img src="https://awesomeprogram.gitee.io/imgdata/tech_bc_subevmcre.jpg" alt="" /></p>
<p>您还可以使用浏览器的开发人员工具中的控制台查看有关事务的详细信息。因为EVM合同地址是由帐户标识符和合同创建者的nonce决定的，所以部署合同的地址是使用众所周知的帐户标识符0xd43593c715fdd31c61141abd04a99fd6822c8558和alice帐户的nonce 0x0计算的。</p>
<p>点击 <strong>Developer</strong>，然后选择 <strong>Chain State</strong>。</p>
<p>选择 <strong>evm</strong> 作为查询和 <strong>accountCodes</strong> 的状态。</p>
<p>为 <code>alice</code> 帐户指定帐户标识符 <code>0xd43593c715fdd31c61141abd04a99fd6822c8558</code>，注意帐户代码为空（<code>0x</code>）。</p>
<p>为你使用 <code>alice</code> 开发帐户部署的合约指定合约地址 <code>0x8a50db1e0f9452cfd91be8dc004ceb11cb08832f</code>，注意合约帐户代码是来自 Solidity 合约的字节码。</p>
<h3 id="查看账户存储"><a class="header" href="#查看账户存储">查看账户存储</a></h3>
<p>你部署的 ERC-20 合约是基于 <a href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol">OpenZeppelin ERC-20 implementation</a>。该合约包括一个构造函数，该构造函数生成最大数量的 tokens，并将它们存储在与合约创建者关联的帐户中。</p>
<p>要查询智能合约关联的账户存储信息：</p>
<p>在以 <strong>evm</strong> 作为要查询状态的 Chain State 中，选择 <strong>accountStorages</strong>。</p>
<p>指定 ERC-20 合约地址 <code>0x8a50db1e0f9452cfd91be8dc004ceb11cb08832f</code> 作为第一个参数。</p>
<p>将要读取的存储插槽指定为第二个参数 <code>0x045c0350b9cf0df39c4b40400c965118df2dca5ce0fbcf0de4aafc099aea4a14</code>。地址的存储槽是使用基于槽位 0 和帐户标识符 <code>0xd43593c715fdd31c61141abd04a99fd6822c8558</code> 的 <a href="https://github.com/substrate-developer-hub/frontier-node-template/tree/main/utils/README.md#--erc20-slot-slot-address">Substrate EVM utilities</a> 计算得到的。该值应该返回的是 <code>0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff</code>。如果你在部署合同之后检查 <code>alice</code> 帐户的余额，你会看到从帐户中提取了一笔费用，并且 <code>getBalance(address, number)</code> 调用返回一个类似于下面的值：</p>
<pre><code class="language-bash editable noplayground">340,282,366,920,938,463,463,374,603,530,233,757,803
</code></pre>
<h3 id="转移代币"><a class="header" href="#转移代币">转移代币</a></h3>
<p>到目前为止，你只使用了 <code>alice</code> 开发帐户。接下来是使用部署的合约将 tokens 转移到另一个帐户。</p>
<p>验证你的节点仍在运行，并且 <a href="https://polkadot.js.org/apps/#?rpc=ws://127.0.0.1:9944">Polkadot-JS application</a> 已连接到该节点。</p>
<p>点击 <strong>Developer</strong>，然后选择 <strong>Extrinsics</strong>。</p>
<p>选择 <strong>ALICE</strong> 开发帐户作为用于提交交易的帐户。</p>
<p>选择 <strong>evm</strong>。</p>
<p>选择 <strong>call</strong> 调用 ERC-20 合约上的 <code>transfer(address, uint256)</code> 函数。</p>
<p>配置该函数的参数：
|<strong>For this</strong>|<strong>Specify this</strong>|
|:-----|:-----|
|<code>source</code>|0xd43593c715fdd31c61141abd04a99fd6822c8558|
|<code>target</code>|0x8a50db1e0f9452cfd91be8dc004ceb11cb08832f|
|<code>input</code>|0xa9059cbb0000000000000000000000008eaf04151687736326c9fea17e25fc528761369300000000000000000000000000000000000000000000000000000000000000dd|
|<code>value</code>|0|
|<code>gasLimit</code>|4294967295|
|<code>maxFeePerGas</code>|100000000|</p>
<p><code>source</code> 表示持有 tokens 的帐户。在本例中，<code>source</code> 是合约创建者 <code>alice</code> 的 EVM 帐户。<code>target</code> 是将 tokens 从 <code>alice</code> 转移到 <code>bob</code> 的合约地址。<code>input</code> 参数是一个 EVM ABI-encoded 的函数调用，它指定执行转移的函数调用（<code>0xa9059cbb</code>）和函数所需的参数。对于这个函数，参数是 <code>bob</code> EVM 帐户标识符（<code>0x8eaf04151687736326c9fea17e25fc5287613693</code>）和要转移的 <code>tokens</code> 数量（221 或 <code>0xdd</code> 十六进制）。本节教程中的 input 值是使用 <a href="http://remix.ethereum.org/">Remix web IDE</a> 计算得到的。</p>
<p>点击 <strong>Submit Transaction</strong>。</p>
<p>点击 <strong>Sign and Submit</strong> 对交易进行授权。</p>
<h3 id="验证代币转移"><a class="header" href="#验证代币转移">验证代币转移</a></h3>
<p>提交交易后，合约将部署到网络上，你可以使用 <a href="https://polkadot.js.org/apps/#?rpc=ws://127.0.0.1:9944">Polkadot-JS application</a> 查看有关它的信息。</p>
<p>验证你的节点仍在运行，并且 <a href="https://polkadot.js.org/apps/#?rpc=ws://127.0.0.1:9944">Polkadot-JS application</a> 已连接到该节点。</p>
<p>点击 <strong>Network</strong>，然后选择 <strong>Explorer</strong>。</p>
<p>点击 <strong>evm.Executed</strong> 事件来验证已执行的合约地址为 <code>0x8a50db1e0f9452cfd91be8dc004ceb11cb08832f</code>。
<img src="https://awesomeprogram.gitee.io/imgdata/tech_bc_subevmexe.jpg" alt="" /></p>
<p>点击 <strong>Developer</strong>，然后选择 <strong>Chain State</strong>。</p>
<p>选择 <strong>evm</strong> 作为要查询的状态和 <strong>accountStorages</strong>。</p>
<p>查看存储合约地址 <code>0x8a50db1e0f9452cfd91be8dc004ceb11cb08832f</code> 和存储槽 <code>0x045c0350b9cf0df39c4b40400c965118df2dca5ce0fbcf0de4aafc099aea4a14</code>。
0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff22</p>
<p>如果你在部署合约之后检查 <code>alice</code> 帐户的余额，你会看到从帐户中提取了一笔费用，<code>getBalance(address, number)</code> 调用返回一个类似于下面的值：
340,282,366,920,938,463,463,374,603,530,233,366,411</p>
<h2 id="以太坊集成"><a class="header" href="#以太坊集成">以太坊集成</a></h2>
<p>通过使用 Frontier 项目的 crates，并将 EVM 和 Ethereum pallets 添加到你的运行时中，你可以构建一个基于 Substrate 的区块链，它支持 Ethereum-based 的账户，并允许执行 Solidity-based 的智能合约。</p>
<p>以太坊虚拟机（EVM）是一种虚拟计算机，其组件使以太坊网络参与者能够存储数据并就数据的状态达成一致。对于一个基于 Substrate 的区块链，EVM 的核心职责在 <strong>EVM pallet</strong> 中实现的。EVM pallet 负责执行以太坊合约字节码，这些智能合约是用像 Solidity 这样的高级语言编写的，然后编译为 EVM 字节码。下面的图表提供了一个简单的概述，以说明如何将 EVM pallet 和以太坊 RPC 调用集成到你的 Substrate 运行时中。
<img src="https://awesomeprogram.gitee.io/imgdata/tech_bc_subpalevm.jpg" alt="" /></p>
<p>除了 EVM pallet，Ethereum pallet 还负责存储 Ethereum-formatted 的块、交易收据和交易状态。当用户提交原始以太坊交易时，通过在运行时调用 <code>pallet_ethereum </code>中的 <code>transact</code> 函数，该交易首先会被转换为一个 Substrate transaction。
<img src="https://awesomeprogram.gitee.io/imgdata/tech_bc_subpaleth.jpg" alt="" /></p>
<p>请注意，使用单独一个私钥不能使以太坊账户和 Substrate 账户直接兼容。关于以太坊帐户、密钥映射到 Substrate 帐户、密钥的信息，请参见 Moonbeam 文档中的 <a href="https://docs.moonbeam.network/learn/features/unified-accounts/#substrate-evm-compatible-blockchain">Unified Accounts</a>。</p>
<h3 id="以太坊指定的运行时apis和rpcs"><a class="header" href="#以太坊指定的运行时apis和rpcs">以太坊指定的运行时APIs和RPCs</a></h3>
<p>运行时存储所有可以查询的 Ethereum-formatted 的信息。你可以调用运行时并使用节点 RPC 服务器、运行时 API 和 RPC 客户端调用检索该信息。
<img src="https://awesomeprogram.gitee.io/imgdata/tech_bc_subtorpc.jpg" alt="" /></p>
<h3 id="frontier区块导入"><a class="header" href="#frontier区块导入">Frontier区块导入</a></h3>
<p><img src="https://awesomeprogram.gitee.io/imgdata/tech_bc_subbloimp.jpg" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="测试-1"><a class="header" href="#测试-1">测试</a></h1>
<p>本节中的主题重点介绍了测试区块链逻辑的工具和技术。</p>
<h2 id="单元测试"><a class="header" href="#单元测试">单元测试</a></h2>
<p>在为运行时构建逻辑时，你需要例行地测试逻辑是否按预期工作。你可以使用 Rust 提供的单元测试框架为运行时创建单元测试。在创建一个或多个单元测试之后，可以使用 cargo test 命令执行测试。例如，可以通过运行以下命令运行为运行时创建的所有测试：</p>
<pre><code class="language-bash editable noplayground">cargo test
</code></pre>
<p>有关使用Rust cargo test 命令和测试框架的更多信息，可运行以下命令：</p>
<pre><code class="language-bash editable noplayground">cargo help test
</code></pre>
<h3 id="在一个mock运行时中测试pallet日志"><a class="header" href="#在一个mock运行时中测试pallet日志">在一个mock运行时中测试pallet日志</a></h3>
<p>除了可以使用 Rust 测试框架进行单元测试之外，还可以通过构建 mock 运行时环境来验证运行时中的逻辑。配置类型 <code>Test</code> 被定义为 Rust 枚举，其中包含模拟运行时中使用的每个 pallet configuration traits 的实现。</p>
<pre><code class="language-rust editable noplayground">frame_support::construct_runtime!(
 pub enum Test where
  Block = Block,
  NodeBlock = Block,
  UncheckedExtrinsic = UncheckedExtrinsic,
 {
  System: frame_system::{Pallet, Call, Config, Storage, Event&lt;T&gt;},
  TemplateModule: pallet_template::{Pallet, Call, Storage, Event&lt;T&gt;},
 }
);

impl frame_system::Config for Test {
 // -- snip --
 type AccountId = u64;
}
</code></pre>
<p>如果 <code>Test</code> 实现了 <code>pallet_balances::Config</code>，则可能使用 <code>u64</code> 作为 <code>Balance</code> 类型。例如:</p>
<pre><code class="language-rust editable noplayground">impl pallet_balances::Config for Test {
 // -- snip --
 type Balance = u64;
}
</code></pre>
<p>通过分配 <code>pallet_balances::Balance</code> 和 <code>frame_system::AccountId</code> 为 <code>u64</code>，测试帐户和余额仅需要在模拟运行时跟踪一个（<code>AccountId: u64, Balance: u64</code>）映射。</p>
<h3 id="在一个mock运行时中测试存储"><a class="header" href="#在一个mock运行时中测试存储">在一个mock运行时中测试存储</a></h3>
<p><a href="https://paritytech.github.io/substrate/master/sp_io/index.html"><code>sp-io</code></a> crate 公开了一个 <a href="https://paritytech.github.io/substrate/master/sp_io/type.TestExternalities.html"><code>TestExternalities</code></a> 实现，你可以使用它在一个模拟环境中测试存储。它是内存中的类型别名，它是substrate_state_machine <a href="https://paritytech.github.io/substrate/master/sp_state_machine/index.html"><code>substrate_state_machine</code></a> 中基于 hashmap 的外部性实现，称为 <a href="https://paritytech.github.io/substrate/master/sp_state_machine/struct.TestExternalities.html"><code>TestExternalities</code></a>。</p>
<p>下面的示例演示定义一个名为 <code>ExtBuilder</code> 的结构体来构建 <code>TestExternalities</code> 的实例，并将块号设置为 1。</p>
<pre><code class="language-rust editable noplayground">pub struct ExtBuilder;

impl ExtBuilder {
 pub fn build(self) -&gt; sp_io::TestExternalities {
  let mut t = system::GenesisConfig::default().build_storage::&lt;TestRuntime&gt;().unwrap();
  let mut ext = sp_io::TestExternalities::new(t);
  ext.execute_with(|| System::set_block_number(1));
  ext
 }
}
</code></pre>
<p>要在单元测试中创建测试环境，调用构建方法来使用默认的创世配置生成 <code>TestExternalities</code>。</p>
<pre><code class="language-rust editable noplayground">#[test]
fn fake_test_example() {
 ExtBuilder::default().build_and_execute(|| {
  // ...test logics...
 });
}
</code></pre>
<p><a href="https://paritytech.github.io/substrate/master/sp_externalities/index.html">Externalities</a> 的自定义实现允许你构建提供对外部节点特性访问的运行时环境。另一个例子可以在 <a href="https://paritytech.github.io/substrate/master/sp_core/offchain/index.html"><code>offchain</code></a> 模块中找到。<code>offchain</code> 模块维护自己的 <a href="https://paritytech.github.io/substrate/master/sp_core/offchain/trait.Externalities.html">Externalities</a> 实现。</p>
<h3 id="创世配置-1"><a class="header" href="#创世配置-1">创世配置</a></h3>
<p>在前面的示例中，<code>ExtBuilder::build()</code> 方法使用默认的起源配置来构建模拟运行时环境。在许多情况下，在测试之前设置存储是很方便的。例如你可能希望在测试之前预设置帐户的余额。</p>
<p>在 <code>frame_system::Config</code> 的实现中，<code>AccountId</code> 和 <code>Balance</code> 都被设置为 <code>u64</code>。你可以将 <code>(u64, u64)</code> 一对放在 <code>balances</code> vec中，以 seed <code>(AccountId, Balance)</code> 一对作为帐户 balances。例如：</p>
<pre><code class="language-rust editable noplayground">impl ExtBuilder {
 pub fn build(self) -&gt; sp_io::TestExternalities {
  let mut t = frame_system::GenesisConfig::default().build_storage::&lt;Test&gt;().unwrap();
  pallet_balances::GenesisConfig::&lt;Test&gt; {
   balances: vec![
    (1, 10),
    (2, 20),
    (3, 30),
    (4, 40),
    (5, 50),
    (6, 60)
   ],
  }
   .assimilate_storage(&amp;mut t)
   .unwrap();

  let mut ext = sp_io::TestExternalities::new(t);
  ext.execute_with(|| System::set_block_number(1));
  ext
 }
}
</code></pre>
<p>在本例中，账户 1 有余额 10，账户 2 有余额 20，以此类推。</p>
<p>用于定义 pallet 的创世配置的确切结构取决于 pallet 的 <code>GenesisConfig</code> 结构定义。例如在 Balances pallet 中，它被定义为：</p>
<pre><code class="language-rust editable noplayground">pub struct GenesisConfig&lt;T: Config&lt;I&gt;, I: 'static = ()&gt; {
 pub balances: Vec&lt;(T::AccountId, T::Balance)&gt;,
}
</code></pre>
<h3 id="区块生产"><a class="header" href="#区块生产">区块生产</a></h3>
<p>模拟区块生产以验证预期行为在区块生产中是否存在是有用的。</p>
<p>一种简单的方法是，使用 <code>System::block_number()</code> 作为唯一输入，在来自所有模块的 <code>on_initialize</code> 和 <code>on_finalize</code> 调用之间递增 System 模块的区块号。尽管对运行时代码来说缓存对存储或系统模块的调用是很重要的，但是测试环境脚手架应该优先考虑可读性，以促进未来可继续容易的维护。</p>
<pre><code class="language-rust editable noplayground">fn run_to_block(n: u64) {
 while System::block_number() &lt; n {
  if System::block_number() &gt; 1 {
   ExamplePallet::on_finalize(System::block_number());
   System::on_finalize(System::block_number());
  }
  System::set_block_number(System::block_number() + 1);
  System::on_initialize(System::block_number());
  ExamplePallet::on_initialize(System::block_number());
 }
}
</code></pre>
<p><code>on_finalize</code> 和 <code>on_initialize</code> 方法只能从 <code>ExamplePallet</code> 调用，如果 pallet trait 实现了 <code>frame_support::traits::{OnInitialize, OnFinalize}</code> traits，分别在每个块之前和之后执行运行时方法中编码的逻辑。</p>
<p>然后按以下方式调用此函数。</p>
<pre><code class="language-rust editable noplayground">#[test]
fn my_runtime_test() {
 with_externalities(&amp;mut new_test_ext(), || {
  assert_ok!(ExamplePallet::start_auction());
  run_to_block(10);
  assert_ok!(ExamplePallet::end_auction());
 });
}
</code></pre>
<h2 id="调试"><a class="header" href="#调试">调试</a></h2>
<p>在软件开发的各个阶段，调试都是必要的，区块链也不例外。大多数常见的 Rust 调试工具同样也适用于 Substrate。</p>
<h3 id="日志工具"><a class="header" href="#日志工具">日志工具</a></h3>
<p>你可以使用 Rust 的日志 API 调试运行时，它附带了许多宏，包括 <a href="https://docs.rs/log/0.4.14/log/macro.debug.html"><code>debug</code></a> 和 <a href="https://docs.rs/log/0.4.14/log/macro.info.html"><code>info</code></a>。</p>
<p>例如在更新带有 <a href="https://crates.io/crates/log"><code>log</code> crate</a> 的 pallet 的 <code>Cargo.toml</code> 的文件之后，只需使用 <code>log::info!</code> log 到你的 console：</p>
<pre><code class="language-rust editable noplayground">pub fn do_something(origin) -&gt; DispatchResult {

	let who = ensure_signed(origin)?;
	let my_val: u32 = 777;

	Something::put(my_val);

	log::info!(&quot;called by {:?}&quot;, who);

	Self::deposit_event(RawEvent::SomethingStored(my_val, who));
	Ok(())
}
</code></pre>
<h3 id="可打印trait"><a class="header" href="#可打印trait">可打印trait</a></h3>
<p>可打印trait 是一种在 <code>no_std</code> 和在 <code>std</code> 情况下从运行时打印的方法。<code>print</code> 函数适用于实现了 <a href="https://paritytech.github.io/substrate/master/sp_runtime/traits/trait.Printable.html"><code>Printable</code> trait</a> 的任何类型。Substrate 默认为某些类型（<code>u8</code>, <code>u32</code>, <code>u64</code>, <code>usize</code>, <code>&amp;[u8]</code>, <code>&amp;str</code>）实现此特性。你也可以为你的自定义类型实现它，下面是一个使用 node-template 作为示例代码库为 pallet 的 <code>Error</code> 类型实现它的示例。</p>
<pre><code class="language-rust editable noplayground">use sp_runtime::traits::Printable;
use sp_runtime::print;
</code></pre>
<pre><code class="language-rust editable noplayground">#[frame_support::pallet]
pub mod pallet {
	// The pallet's errors
	#[pallet::error]
	pub enum Error&lt;T&gt; {
		/// Value was None
		NoneValue,
		/// Value reached maximum and cannot be incremented further
		StorageOverflow,
	}

	impl&lt;T: Config&gt; Printable for Error&lt;T&gt; {
		fn print(&amp;self) {
			match self {
				Error::NoneValue =&gt; &quot;Invalid Value&quot;.print(),
				Error::StorageOverflow =&gt; &quot;Value Exceeded and Overflowed&quot;.print(),
				_ =&gt; &quot;Invalid Error Case&quot;.print(),
			}
		}
	}
}
</code></pre>
<pre><code class="language-rust editable noplayground">/// takes no parameters, attempts to increment storage value, and possibly throws an error
pub fn cause_error(origin) -&gt; dispatch::DispatchResult {
	// Check it was signed and get the signer. See also: ensure_root and ensure_none
	let _who = ensure_signed(origin)?;

	print!(&quot;My Test Message&quot;);

	match Something::get() {
		None =&gt; {
			print(Error::&lt;T&gt;::NoneValue);
			Err(Error::&lt;T&gt;::NoneValue)?
		}
		Some(old) =&gt; {
			let new = old.checked_add(1).ok_or(
				{
					print(Error::&lt;T&gt;::StorageOverflow);
					Error::&lt;T&gt;::StorageOverflow
				})?;
			Something::put(new);
			Ok(())
		},
	}
}
</code></pre>
<p>运行带有 RUST_LOG 环境变量的节点二进制文件以打印值。</p>
<pre><code class="language-rust editable noplayground">RUST_LOG=runtime=debug ./target/release/node-template --dev
</code></pre>
<p>每次调用运行时函数时，这些值都打印在终端或标准输出中。</p>
<pre><code class="language-bash editable noplayground">2020-01-01 tokio-blocking-driver DEBUG runtime  My Test Message  &lt;-- str implements Printable by default
2020-01-01 tokio-blocking-driver DEBUG runtime  Invalid Value    &lt;-- the custom string from NoneValue
2020-01-01 tokio-blocking-driver DEBUG runtime  DispatchError
2020-01-01 tokio-blocking-driver DEBUG runtime  8
2020-01-01 tokio-blocking-driver DEBUG runtime  0                &lt;-- index value from the Error enum definition
2020-01-01 tokio-blocking-driver DEBUG runtime  NoneValue        &lt;-- str which holds the name of the ident of the error
</code></pre>
<p>请记住，向运行时添加打印函数会增加 Rust 和 Wasm 二进制文件的大小，在生产环境中不要加入调试代码。</p>
<h3 id="substrate自身的打印函数"><a class="header" href="#substrate自身的打印函数">Substrate自身的打印函数</a></h3>
<p>对于传统用例，Substrate 为 <code>Print</code> debugging（或 tracing）提供了额外的工具。你可以使用 <a href="https://paritytech.github.io/substrate/master/sp_runtime/fn.print.html"><code>print</code> function</a> 记录运行时执行的状态。</p>
<pre><code class="language-rust editable noplayground">use sp_runtime::print;

// --snip--
pub fn do_something(origin) -&gt; DispatchResult {
	print!(&quot;Execute do_something&quot;);

	let who = ensure_signed(origin)?;
	let my_val: u32 = 777;

	Something::put(my_val);

	print!(&quot;After storing my_val&quot;);

	Self::deposit_event(RawEvent::SomethingStored(my_val, who));
	Ok(())
}
// --snip--
</code></pre>
<p>使用 <code>RUST_LOG</code> 环境变量启动链，以查看打印日志。</p>
<pre><code class="language-rust editable noplayground">RUST_LOG=runtime=debug ./target/release/node-template --dev
</code></pre>
<p>如果 Error 被触发，这些值将打印在终端或标准输出中。</p>
<pre><code class="language-bash editable noplayground">2020-01-01 00:00:00 tokio-blocking-driver DEBUG runtime  Execute do_something
2020-01-01 00:00:00 tokio-blocking-driver DEBUG runtime  After storing my_val
</code></pre>
<h3 id="if-std"><a class="header" href="#if-std">If std</a></h3>
<p>传统的 <code>print</code> 函数允许你打印并获得 <code>Printable</code> trait 的实现。然而有一些传统的用例，可能想要做更多的事情，而不仅仅是打印，或者仅仅为了调试目的，而不必考虑 Substrate-specific traits。 <a href="https://paritytech.github.io/substrate/master/sp_std/macro.if_std.html"><code>if_std!</code> macro</a> 在这种情况下是有用的。</p>
<p>使用此宏的一个警告是，只有当你实际运行 runtime 的 native 版本时，内部的代码才会执行。</p>
<pre><code class="language-rust editable noplayground">use sp_std::if_std; // Import into scope the if_std! macro.
</code></pre>
<p><code>println!</code> 语句应该在 <code>if_std</code> 宏中。</p>
<pre><code class="language-rust editable noplayground">#[pallet::call]
impl&lt;T: Config&lt;I&gt;, I: 'static&gt; Pallet&lt;T, I&gt; {
		// --snip--
		pub fn do_something(origin) -&gt; DispatchResult {

			let who = ensure_signed(origin)?;
			let my_val: u32 = 777;

			Something::put(my_val);

			if_std! {
				// This code is only being compiled and executed when the `std` feature is enabled.
				println!(&quot;Hello native world!&quot;);
				println!(&quot;My value is: {:#?}&quot;, my_val);
				println!(&quot;The caller account is: {:#?}&quot;, who);
			}

			Self::deposit_event(RawEvent::SomethingStored(my_val, who));
			Ok(())
		}
		// --snip--
}
</code></pre>
<p>每次调用运行时函数时，这些值都打印在终端或标准输出中。</p>
<pre><code class="language-bash editable noplayground">$		2020-01-01 00:00:00 Substrate Node
		2020-01-01 00:00:00   version x.y.z-x86_64-linux-gnu
		2020-01-01 00:00:00   by Anonymous, 2017, 2020
		2020-01-01 00:00:00 Chain specification: Development
		2020-01-01 00:00:00 Node name: my-node-007
		2020-01-01 00:00:00 Roles: AUTHORITY
		2020-01-01 00:00:00 Imported 999 (0x3d7a…ab6e)
		# --snip--
-&gt;		Hello native world!
-&gt;		My value is: 777
-&gt;		The caller account is: d43593c715fdd31c61141abd04a99fd6822c8558854ccde39a5684e7a56da27d (5GrwvaEF...)
		# --snip--
		2020-01-01 00:00:00 Imported 1000 (0x3d7a…ab6e)
</code></pre>
<h2 id="基准测试"><a class="header" href="#基准测试">基准测试</a></h2>
<p>Substrate 和 FRAME 为你的区块链开发自定义逻辑提供了一个灵活的框架。这种灵活性使你能够设计复杂的交互式 pallet 并实现复杂的运行时逻辑。然而，确定分配给 pallet 中函数的适当<a href="https://docs.substrate.io/reference/glossary/#weight">权重</a>可能是一项困难的任务。基准测试使你能够测量在运行时和不同条件下执行不同函数所需的时间。如果你使用基准测试为函数调用分配准确的权重，你可以防止你的区块链过载、无法生成区块或受到恶意参与者的拒绝服务（DoS）攻击。</p>
<h3 id="为什么要对pallet进行基准测试"><a class="header" href="#为什么要对pallet进行基准测试">为什么要对pallet进行基准测试</a></h3>
<p>理解执行不同函数所需的计算资源是很重要的，包括像 <code>on_initialize</code> 和 <code>verify_unsigned</code> 这样的运行时函数，以保证运行时的安全，并允许运行时根据可用的资源需要包含哪些交易还是排除哪些交易。</p>
<p>基于可用资源包含或排除交易的能力确保运行时可以继续生成和导入区块，而不会中断服务。例如如果你有一个需要密集计算的函数调用，执行该调用可能会超过生成或导入块所允许的最大时间，从而中断块处理过程或完全停止区块链进程。基准测试帮助你验证不同函数所需的执行时间是否在合理的范围内。</p>
<p>同样恶意用户可能会试图通过反复执行需要密集计算或无法准确反映其所需计算的函数调用来破坏网络服务。如果执行函数调用的成本无法准确反映所消耗的计算资源，则无法阻止恶意用户攻击网络。由于基准测试可帮助你评估与执行交易相关的权重，因此它还可以帮助你确定适当的交易费用。根据你的基准测试，你可以设置代表通过对区块链执行指定调用所消耗的资源的费用。</p>
<h3 id="开发一个线性模型"><a class="header" href="#开发一个线性模型">开发一个线性模型</a></h3>
<p>在高水平上，基准测试需要执行以下步骤：</p>
<ul>
<li>编写自定义基准测试逻辑，为一个函数执行指定代码路径。</li>
<li>在 WebAssembly 执行环境中使用指定的硬件集合和指定的运行时配置执行基准测试逻辑。</li>
<li>在可能影响函数所需执行时间的受控范围内执行基准逻辑。</li>
<li>对函数中的每个组件执行多次基准测试，以隔离和删除异常值。</li>
<li></li>
</ul>
<p>根据通过执行基准逻辑生成的结果，基准测试工具创建了一个函数的线性模型，该模型跨越所有组件。函数的线性模型使你能够估计执行指定代码路径所需的时间，并做出明智的决策，而无需在运行时实际花费大量资源。基准测试假设所有交易都具有线性复杂性，因为较高复杂性的函数被认为对运行时是危险的，因为随着运行时状态或输入变得过于复杂，这些函数的权重可能会爆炸。</p>
<h3 id="基准测试和权重"><a class="header" href="#基准测试和权重">基准测试和权重</a></h3>
<p>如<a href="blockchain/./chapter_1_2_1_2.html#%E4%BA%A4%E6%98%93%E6%9D%83%E9%87%8D%E5%92%8C%E8%B4%B9%E7%94%A8">交易、权重和费用</a>中所述，基于 Substrate 的链使用<strong>权重</strong>概念表示在区块中执行交易所需的时间。在交易中执行任何特定调用所需的时间取决于几个因素，包括以下几项：</p>
<ul>
<li>计算复杂性。</li>
<li>存储复杂性。</li>
<li>数据库读写操作需要的。</li>
<li>使用的硬件。</li>
</ul>
<p>要计算交易的适当权重，可以使用基准参数来测量在不同硬件上执行函数调用所需的时间，使用不同的变量值，并重复多次。然后你可以使用基准测试的结果来建立近似的最坏情况权重，以表示执行每个函数调用和每个代码路径所需的资源。费用基于最坏情况权重。如果实际调用的性能优于最坏情况，则调整权重并返回任何超额费用。</p>
<p>因为权重是基于指定物理机器的计算时间的通用度量单位，所以任何函数的权重都可以基于用于基准测试的指定硬件而改变。</p>
<p>通过建模每个运行时函数的预期权重，区块链能够计算在特定时间段内可以执行多少交易或系统级调用。</p>
<p>在 FRAME 内，可以调度的每个函数调用必须具有 <code>#[weight]</code> 注释，该注释可以返回给定输入的该函数最坏情况下执行的预期权重。基准测试框架会自动为你生成一个包含这些公式的文件。</p>
<h3 id="基准测试工具"><a class="header" href="#基准测试工具">基准测试工具</a></h3>
<p><a href="https://paritytech.github.io/substrate/master/frame_benchmarking/index.html">基准测试框架</a>提供的工具可帮助你在运行时添加、测试、运行和分析函数的 benchmarks。帮助你确定执行函数调用所需时间的基准测试工具包括：</p>
<ul>
<li>
<p><a href="https://github.com/paritytech/substrate/blob/master/frame/benchmarking/src/lib.rs">基准测试宏</a>，帮助你编写、测试和添加运行时基准测试。</p>
</li>
<li>
<p><a href="https://github.com/paritytech/substrate/blob/master/frame/benchmarking/src/analysis.rs">线性回归分析函数</a>用于处理基准测试数据。</p>
</li>
<li>
<p><a href="https://github.com/paritytech/substrate/tree/master/utils/frame/benchmarking-cli">命令行接口（CLI）</a>使你能够在节点上执行基准测试。</p>
</li>
</ul>
<p>编译节点时，默认情况下禁用端到端基准测试管道。如果要运行基准测试，则需要编译一个带有 <code>runtime-benchmarks</code> Rust 特性标志的节点。</p>
<h3 id="编写基准测试"><a class="header" href="#编写基准测试">编写基准测试</a></h3>
<p>编写运行时基准测试类似于为 pallet 编写单元测试。与单元测试一样，基准测试必须在代码中执行特定的逻辑路径。在单元测试中，你将检查代码的成功和失败结果。对于基准测试，你希望执行 <strong>most computationally intensive</strong> 的路径。</p>
<p>在编写基准测试时，你应该考虑可能影响函数复杂性的特定条件，如存储或运行时状态。例如如果在 <code>For</code> 循环中触发更多迭代会增加数据库读写操作的数量，则应设置触发此条件的基准测试，以更准确地表示函数将如何执行。</p>
<p>如果一个函数根据用户输入或其他条件执行不同的代码路径，你可能不知道哪个路径是计算最密集的路径。为了帮助你了解代码中的复杂性可能变得难以管理的地方，你应该为每个可能的执行路径创建一个基准测试。基准测试可以帮助你确定代码中可能需要强制识别的边界，例如通过限制向量中的元素数量或限制 <code>for</code> 循环中的迭代次数来控制用户如何与 pallet 交互。</p>
<p>你可以在所有预构建的 <a href="https://github.com/paritytech/substrate/tree/master/frame">FRAME pallets</a> 中找到端到端基准的的示例。</p>
<h3 id="测试基准测试"><a class="header" href="#测试基准测试">测试基准测试</a></h3>
<p>你可以使用为单元测试 pallet 创建类似的模拟运行时执行基准测试。使用的基准测试宏在你的 <code>benchmarking.rs</code> 模块中可以自动的生成测试函数。例如：</p>
<pre><code class="language-rust editable noplayground">fn test_benchmark_[benchmark_name]&lt;T&gt;::() -&gt; Result&lt;(), &amp;'static str&gt;
</code></pre>
<p>你可以将基准测试函数添加到单元测试中，并确保函数的结果是 <code>Ok(())</code>。</p>
<h4 id="验证块"><a class="header" href="#验证块">验证块</a></h4>
<p>通常你只需要检查基准测试是否返回 <code>Ok(())</code>，因为该结果表明函数已成功执行。但是如果你想要验证任何最终条件，比如运行时的最终状态，你可以选择在基准测试中包含一个 <code>verify</code> 块。额外的 <code>verify</code> 块不会影响你的最终基准测试过程的结果。</p>
<h4 id="使用benchmarks运行单元测试"><a class="header" href="#使用benchmarks运行单元测试">使用benchmarks运行单元测试</a></h4>
<p>要运行基准测试，你需要指定要测试的包并启用 <code>runtime-benchmarks</code> 特性。例如你可以通过运行以下命令来测试 Balances pallet：</p>
<pre><code class="language-bash editable noplayground">cargo test --package pallet-balances --features runtime-benchmarks
</code></pre>
<h3 id="添加基准测试"><a class="header" href="#添加基准测试">添加基准测试</a></h3>
<p>每个 pallet 中包含的基准测试不会自动添加到节点中。要执行这些基准测试，你需要实现框架 <code>frame_benchmarking::Benchmark</code> trait。你可以在 <a href="https://github.com/paritytech/substrate/blob/master/bin/node/runtime/src/lib.rs">Substrate 节点</a>中看到如何操作的示例。</p>
<p>假设你的节点上已经设置了一些基准测试，你只需要将 pallet 添加到 <code>define_benchmarks!</code> 宏：</p>
<pre><code class="language-rust editable noplayground">#[cfg(feature = &quot;runtime-benchmarks&quot;)]
mod benches {
	define_benchmarks!(
		[frame_benchmarking, BaselineBench::&lt;Runtime&gt;]
		[pallet_assets, Assets]
		[pallet_babe, Babe]
    ...
    [pallet_mycustom, MyCustom]
    ...
</code></pre>
<p>在添加了 pallet 之后，使用 <code>runtime-benchmarks</code> 特性标志编译节点二进制文件。例如：</p>
<pre><code class="language-bash editable noplayground">cd bin/node/cli
cargo build --profile=production --features runtime-benchmarks
</code></pre>
<p><code>production</code> 配置文件应用了各种编译器优化。这些优化大大降低了编译过程的速度。如果你只是在测试，不需要最终的指标，请使用 <code>--release</code> 命令行选项而不是 <code>production</code> 配置文件。</p>
<h3 id="运行基准测试"><a class="header" href="#运行基准测试">运行基准测试</a></h3>
<p>在编译了启用基准测试的节点二进制代码之后，你需要执行基准测试。如果使用 <code>production</code> 配置文件编译节点，则可以通过运行以下命令列出可用的基准测试：</p>
<pre><code class="language-bash editable noplayground">./target/production/node-template benchmark pallet --list
</code></pre>
<h4 id="对所有pallets中的所有函数进行基准测试"><a class="header" href="#对所有pallets中的所有函数进行基准测试">对所有pallets中的所有函数进行基准测试</a></h4>
<p>要执行运行时的所有基准测试，可以运行类似于以下的命令：</p>
<pre><code class="language-bash editable noplayground">./target/production/node-template benchmark pallet \
    --chain dev \
    --execution=wasm \
    --wasm-execution=compiled \
    --pallet &quot;*&quot; \
    --extrinsic &quot;*&quot; \
    --steps 50 \
    --repeat 20 \
    --output pallets/all-weight.rs
</code></pre>
<p>在本例中该命令创建一个输出文件，名为  <code>all-weight.rs</code> 为你的运行时实现了 <code>WeightInfo</code> trait。</p>
<h4 id="在pallet中对特定的函数进行基准测试"><a class="header" href="#在pallet中对特定的函数进行基准测试">在pallet中对特定的函数进行基准测试</a></h4>
<p>要在特定 pallet 中为特定函数执行基准测试，可以运行类似于下面的命令：</p>
<pre><code class="language-bash editable noplayground">./target/production/node-template benchmark pallet \
    --chain dev \
    --execution=wasm \
    --wasm-execution=compiled \
    --pallet pallet_balances \
    --extrinsic transfer \
    --steps 50 \
    --repeat 20 \
    --output pallets/transfer-weight.rs
</code></pre>
<p>该命令为选定的 pallet 创建一个输出文件，例如 <code>transfer-weight.rs</code> 为 <code>pallet_balances</code> pallet 实现了 <code>WeightInfo</code> trait。</p>
<h4 id="使用一个格式化基准测试的模板"><a class="header" href="#使用一个格式化基准测试的模板">使用一个格式化基准测试的模板</a></h4>
<p>基准测试命令行接口使用 Handlebars 模板来格式化最终输出文件。你可以选择传递 <code>--template</code> 命令行选项来指定自定义模板而不是默认模板。在模板中，你可以访问基准测试命令行接口中 <code>TemplateData</code> 结构提供的所有数据。</p>
<p>输出生成中包含了一些自定义 Handlebars 帮助程序：</p>
<ul>
<li><code>underscore</code>：将下划线添加到字符串右侧的第三个字符。主要用于界定大数。</li>
<li><code>join</code>：为模板加入字符串数组，以空格分隔的字符串。主要用于连接传递给 CLI 的所有参数。</li>
</ul>
<p>要获取 <code>benchmark</code> 子命令的完整列表，请运行：</p>
<pre><code class="language-bash editable noplayground">./target/production/node-template benchmark --help
</code></pre>
<p>要获取 <code>benchmark pallet</code> 子命令可用选项的完整列表，请运行：</p>
<pre><code class="language-bash editable noplayground">./target/production/node-template benchmark pallet --help
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p><img src="https://awesomeprogram.gitee.io/imgdata/techs/202207061914193.png" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><p><img src="https://awesomeprogram.gitee.io/imgdata/techs/202207061914193.png" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><p><img src="https://awesomeprogram.gitee.io/imgdata/techs/202207061914193.png" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><p><img src="https://awesomeprogram.gitee.io/imgdata/techs/202207061914193.png" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><p><img src="https://awesomeprogram.gitee.io/imgdata/techs/202207061914193.png" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><p><img src="https://awesomeprogram.gitee.io/imgdata/techs/202207061914193.png" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="move-与-solidity"><a class="header" href="#move-与-solidity">Move 与 Solidity</a></h1>
<p><img src="https://awesomeprogram.gitee.io/imgdata/techs/202207061914193.png" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="move教程"><a class="header" href="#move教程">Move教程</a></h1>
<p>欢迎来到 Move 语言教程，在本教程中，我们通过一些具体的步骤进行 Move 语言代码的开发，包括 Move 模块的设计、实现、单元测试和形式化验证。</p>
<p>整个过程共包含9个步骤：</p>
<ul>
<li><a href="blockchain/chapter_1_3_1.html#move%E6%95%99%E7%A8%8B">Move教程</a>
<ul>
<li><a href="blockchain/chapter_1_3_1.html#0%E5%AE%89%E8%A3%85-move-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83">0.安装 Move 开发环境</a></li>
<li><a href="blockchain/chapter_1_3_1.html#1%E7%BC%96%E5%86%99%E7%AC%AC%E4%B8%80%E4%B8%AA-move-%E6%A8%A1%E5%9D%97">1.编写第一个 Move 模块</a></li>
<li><a href="blockchain/chapter_1_3_1.html#2%E7%BB%99%E6%A8%A1%E5%9D%97module%E6%B7%BB%E5%8A%A0%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95">2.给模块（Module）添加单元测试</a>
<ul>
<li><a href="blockchain/chapter_1_3_1.html#%E7%BB%83%E4%B9%A0">练习</a></li>
</ul>
</li>
<li><a href="blockchain/chapter_1_3_1.html#3%E8%AE%BE%E8%AE%A1%E8%87%AA%E5%B7%B1%E7%9A%84-basiccoin-%E6%A8%A1%E5%9D%97module">3.设计自己的 <code>BasicCoin</code> 模块（Module）</a>
<ul>
<li><a href="blockchain/chapter_1_3_1.html#%E8%BF%9B%E9%98%B6%E4%B8%BB%E9%A2%98-advanced-topics-">进阶主题 (Advanced topics) ：</a></li>
</ul>
</li>
<li><a href="blockchain/chapter_1_3_1.html#4basiccoin-%E6%A8%A1%E5%9D%97module%E7%9A%84%E5%AE%9E%E7%8E%B0">4.<code>BasicCoin</code> 模块（Module）的实现</a>
<ul>
<li><a href="blockchain/chapter_1_3_1.html#%E7%BC%96%E8%AF%91%E4%BB%A3%E7%A0%81">编译代码</a></li>
<li><a href="blockchain/chapter_1_3_1.html#%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0">方法的实现</a></li>
<li><a href="blockchain/chapter_1_3_1.html#%E7%BB%83%E4%B9%A0-1">练习</a>
<ul>
<li><a href="blockchain/chapter_1_3_1.html#%E9%A2%9D%E5%A4%96%E7%BB%83%E4%B9%A0">额外练习</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="blockchain/chapter_1_3_1.html#5%E7%BB%99-basiccoin-%E6%A8%A1%E5%9D%97%E6%B7%BB%E5%8A%A0%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95">5.给 <code>BasicCoin</code> 模块添加单元测试</a></li>
<li><a href="blockchain/chapter_1_3_1.html#6%E4%BD%BF%E7%94%A8%E6%B3%9B%E5%9E%8Bgeneric%E7%BC%96%E5%86%99-basiccoin-%E6%A8%A1%E5%9D%97">6.使用泛型（generic）编写 <code>BasicCoin</code> 模块</a>
<ul>
<li><a href="blockchain/chapter_1_3_1.html#%E8%BF%9B%E9%98%B6%E4%B8%BB%E9%A2%98">进阶主题：</a></li>
<li><a href="blockchain/chapter_1_3_1.html#%E8%BF%9B%E9%98%B6%E6%AD%A5%E9%AA%A4">进阶步骤</a></li>
</ul>
</li>
<li><a href="blockchain/chapter_1_3_1.html#7%E4%BD%BF%E7%94%A8-move-prover">7.使用 <code>Move prover</code></a></li>
<li><a href="blockchain/chapter_1_3_1.html#8%E4%B8%BA-basiccoin-%E6%A8%A1%E5%9D%97%E7%BC%96%E5%86%99%E5%BD%A2%E5%BC%8F%E5%8C%96%E8%A7%84%E8%8C%83formal-specification">8.为 <code>BasicCoin</code> 模块编写形式化规范（formal specification）</a></li>
</ul>
</li>
</ul>
<h2 id="0安装-move-开发环境"><a class="header" href="#0安装-move-开发环境">0.安装 Move 开发环境</a></h2>
<p>如果你还没有安装过 Move，首先打开命令终端(terminal) 并clone <a href="https://github.com/move-language/move">Move代码库</a>:</p>
<pre><code class="language-bash">git clone https://github.com/move-language/move.git
</code></pre>
<p>进入到 <code>move</code> 文件夹下，执行 <code>dev_setup.sh</code> 脚本:</p>
<pre><code class="language-bash">cd move
./scripts/dev_setup.sh -ypt
</code></pre>
<p>根据脚本命令的提示，按顺序安装 Move 的所有依赖项。 脚本将会将(move命令所在路径)环境变量写入到 <code>~/.profile</code> 文件中。</p>
<p>执行如下命令使环境变量生效：</p>
<pre><code class="language-bash">source ~/.profile
</code></pre>
<p>然后执行如下命令来安装 Move 命令行工具：</p>
<pre><code class="language-bash">cargo install --path language/tools/move-cli
</code></pre>
<p>通过如下运行命令可以检查 move 命令是否可正常：</p>
<pre><code class="language-bash">move --help
</code></pre>
<p>你应该会看到类似这样的内容以及许多命令的列表和描述：</p>
<pre><code class="language-bash">move-package
Execute a package command. Executed in the current directory or the closest containing Move package

USAGE:
    move [OPTIONS] &lt;SUBCOMMAND&gt;

OPTIONS:
        --abi                          Generate ABIs for packages
...
</code></pre>
<p>如果想了解有支持哪引命令及其作用, 执行命令或子命令时添加 <code>--help</code> 标记，此时会打印帮助文档。</p>
<p>在执行下一步骤之前，请先执行 cd 命令进入到教程对应目录下:</p>
<pre><code class="language-bash">cd &lt;path_to_move&gt;/language/documentation/tutorial
</code></pre>
<details>
<summary>Visual Studio Code Move 支持</summary>
Visual Studio Code 有正式的 Move 语言支持, 您需要先安装 move analyzer :
<pre><code class="language-bash">cargo install --path language/move-analyzer
</code></pre>
<p>现在你可以打开 VS Code 并安装 Move 扩展插件了，在扩展页面下找到 move-analyzer 并安装即可。关于扩展的详细信息可以查看扩展的<a href="https://github.com/move-language/move/tree/main/language/move-analyzer/editors/code">README</a>。</p>
</details>
<h2 id="1编写第一个-move-模块"><a class="header" href="#1编写第一个-move-模块">1.编写第一个 Move 模块</a></h2>
<p>切换当前目录到 <code>step_1/BasicCoin</code> 下，你将看到 <code>sources</code> 子目录 -- 这个包(package)下所有的 Move 代码都在此目录中，同时你还会看到一个 <code>Move.toml</code> 文件。该文件指定当前包的依赖列表和其他信息。 如果您熟悉 <code>Rust</code> 和 <code>Cargo</code>，那 <code>Move.toml</code> 文件类似 <code>Cargo.toml</code> 文件，<code>sources</code> 目录类似 <code>src</code> 目录(它们的作用是一样的)</p>
<p>来一起看看 Move 语言代码内容！ 用你的编辑器打开 <code>sources/FirstModule.move</code> 文件，会看到如下内容：</p>
<pre><code class="language-bash">// sources/FirstModule.move
module 0xCAFE::BasicCoin {
    ...
}
</code></pre>
<p>这是一个 Move <a href="blockchain/">module(模块)</a>的定义。模块是 Move 语言的代码块, 并且它使用指定的地址(address)进行定义 -- 模块只能在该地址下发布。 当前 <code>BasicCoin</code> 模块只能被发布在 <code>0xCAFE</code> 地址下。</p>
<p>再看这个文件的下一部分，这里定义了一个具有字段 value 的结构体 <code>Coin</code>：</p>
<pre><code class="language-bash">module 0xCAFE::BasicCoin {
    struct Coin has key {
        value: u64,
    }
    ...
}
</code></pre>
<p>再看文件剩余部分，我们会看到一个函数，它会创建一个 Coin 结构体，并将其保存在某个账号(account)下：</p>
<pre><code class="language-bash">module 0xCAFE::BasicCoin {
    struct Coin has key {
        value: u64,
    }

    public fun mint(account: signer, value: u64) {
        move_to(&amp;account, Coin { value })
    }
}
</code></pre>
<p>让我们来看看这个函数和它的含义:</p>
<ul>
<li>此函数需要一个 <code>signer</code> 参数 -- 表示不可伪造的 token 受此特定地址的控制; 和一个需要铸造的数量参数 <code>value</code>。</li>
<li>此函数使用给定的参数值铸造一个 Coin，然后通过 <code>move_to</code> 操作将其保存在(全局存储中)给定的 <code>account</code> 账户下。</li>
</ul>
<p>我们需要确保它真的执行，这可以通过在包文件夹(<code>step_1/BasicCoin</code>)下的运行 <code>build</code> 命令来完成：</p>
<pre><code class="language-bash">move build
</code></pre>
<details>
<summary>进阶概念及参考引用</summary>
<ul>
<li>你可以通过以下命令创建一个空的 Move 包(move package):
<pre><code class="language-bash">move new &lt;pkg_name&gt;
</code></pre>
</li>
<li>Move 代码也可以放在其他很多地方, 更多关于 Move 包系统的信息请参阅<a href="blockchain/">Move book</a></li>
<li>更多关于 <code>Move.toml</code> 文件的信息可以参阅<a href="blockchain/">package section of the Move book</a>.</li>
<li>Move语言也支持命名地址的概念(<a href="blockchain/">named addresses</a>), 命名地址是一种参数化 Move 源代码的方法， 就是如果对 <code>NamedAddr</code> 使用的不同赋值编译，编译后会获得部署到你控制地址的不同字节码. 这种用法很常见，一般都将地址变量其定义在 <code>Move.toml</code> 文件 的 <code>[addresses]</code> 部分. 例如:</li>
</ul>
<pre><code class="language-bash">[addresses]
SomeNamedAddress = &quot;0xC0FFEE&quot;
</code></pre>
<ul>
<li>
<p>Move 结构体可以通过给类型设定不同的能力abilities让类型支持对应的行为. 有四种能力:</p>
<ul>
<li>
<p><code>copy</code>: 允许此类型的值被复制</p>
</li>
<li>
<p><code>drop</code>: 允许此类型的值被弹出/丢弃</p>
</li>
<li>
<p><code>store</code>: 允许此类型的值存在于全局存储的某个结构体中</p>
</li>
<li>
<p><code>key</code>: 允许此类型作为全局存储中的键(具有 <code>key</code> 能力的类型才能保存到全局存储中)</p>
<p>所以 <code>BasicCoin</code> 模块下的 <code>Coin</code> 结构体可以用作全局存储(global storage)的键(key)， 因为它又不具备其他能力，它不能 被拷贝，不能被丢弃, 也不能作为非key来保存在(全局)存储里. 你无法复制 <code>Coin</code>，也不会意外弄丢它.</p>
</li>
</ul>
</li>
<li>
<p>函数<a href="blockchain/">Functions</a>默认是私有的(private), 也可以声明为 <code>public</code> <a href="blockchain/">public(friend)</a>, <code>public(script)</code>. 最后一个声明(指 <code>public(script)</code>)的函数可以被事务脚本调用。<code>public(script)</code> 函数也可以被其他 <code>public(script)</code> 函数调用。(注意：在最新版本的 Move中，<code>public(script)</code> 已经被废弃，被 <code>public entry</code> 取代，下同，译者注)</p>
</li>
<li>
<p>move_to 是<a href="blockchain/">五种不同的全局存储操作</a>之一</p>
</li>
</ul>
</details>
<h2 id="2给模块module添加单元测试"><a class="header" href="#2给模块module添加单元测试">2.给模块（Module）添加单元测试</a></h2>
<p>现在我们已经完成了我们的第一个 Move 模块，我们将切换到目录 <code>step_2/BasicCoin</code> 下并完成一个测试，确保铸币按我们预期的方式工作。 如果你熟悉它们(Move 和 Rust)的话，Move 中的单元测试类似于 Rust 中的单元测试 —— 测试代码使用 #[test] 注解，并像编写普通的 Move 函数一样。</p>
<p>可以通过 move test 命令来执行测试:</p>
<pre><code class="language-bash">move test
</code></pre>
<p>现在我们来完成文件 <code>FirstModule.move</code> 的具体内容，你将看到的第一个新事项是这个测试:</p>
<pre><code class="language-bash">module 0xCAFE::BasicCoin {
    ...
    // Declare a unit test. It takes a signer called `account` with an
    // address value of `0xC0FFEE`.
    #[test(account = @0xC0FFEE)]
    fun test_mint_10(account: signer) acquires Coin {
        let addr = signer::address_of(&amp;account);
        mint(account, 10);
        // Make sure there is a `Coin` resource under `addr` with a value of `10`.
        // We can access this resource and its value since we are in the
        // same module that defined the `Coin` resource.
        assert!(borrow_global&lt;Coin&gt;(addr).value == 10, 0);
    }
}

</code></pre>
<p>这里声明了一个命名为 <code>test_mint_10</code> 的单元测试，它在 <code>account</code> 账户地址下铸造了一个包含 <code>value</code> 为 <code>10</code> 的 <code>Coin</code>，然后通过 <code>assert!</code> 断言检查已经铸造成功并保存在(全局)存储中的 <code>Coin</code> 的值是否与期望值一致。如果断言 <code>assert</code> 执行失败，则单元测试失败。</p>
<details>
<summary>进阶概念及参考练习 (Advanced concepts and exercises)</summary>
<ul>
<li>很多测试相关的注解(annotations)都值得仔细探索, 参阅<a href="https://github.com/move-language/move/blob/main/language/changes/4-unit-testing.md#testing-annotations-their-meaning-and-usage">用法</a>。 在 <code>Step 5</code> 中会看到更多用法.</li>
<li>执行测试之前，需要设定Move标准库依赖关系，找到 <code>Move.toml</code> 并在 <code>[dependencies]</code> 段内进行设定, 例如</li>
</ul>
<pre><code class="language-bash">[dependencies]
MoveStdlib = { local = &quot;../../../../move-stdlib/&quot;, addr_subst = { &quot;Std&quot; = &quot;0x1&quot; } }
</code></pre>
<p>注意, 需要修改 <code>&lt;path_to_move&gt;/language</code> 中的内容来匹配实际 <code>move-stdlib</code> 所在的目录路径. 也可以用 <code>git</code> 方式指定依赖, 关于 Move 包依赖(package denpendices)信息可参阅<a href="blockchain/">package文档</a></p>
</details>
<h3 id="练习"><a class="header" href="#练习">练习</a></h3>
<ul>
<li>将断言值改为 11 将导致断言执行失败, 找一个可以传递给 move test 命令的标志，当测试失败时它会显示全局状态。看起来像这样：
<pre><code class="language-bash">┌── test_mint_10 ──────
│ error[E11001]: test failure
│    ┌─ ./sources/FirstModule.move:24:9
│    │
│ 18 │     fun test_mint_10(account: signer) acquires Coin {
│    │         ------------ In this function in 0xcafe::BasicCoin
│    ·
│ 24 │         assert!(borrow_global&lt;Coin&gt;(addr).value == 11, 0);
│    │         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Test was not expected to abort but it aborted with 0 here
│
│
│ ────── Storage state at point of failure ──────
│ 0xc0ffee:
│       =&gt; key 0xcafe::BasicCoin::Coin {
│           value: 10
│       }
│
└──────────────────
</code></pre>
</li>
<li>找一个允许你收集测试覆盖率信息的标志，然后使用 <code>move coverage</code> 命令查看覆盖率统计信息和源码覆盖率。</li>
</ul>
<h2 id="3设计自己的-basiccoin-模块module"><a class="header" href="#3设计自己的-basiccoin-模块module">3.设计自己的 <code>BasicCoin</code> 模块（Module）</a></h2>
<p>在本节中，我们将设计一个具有基本代币和余额(balance)接口功能的模块，通过他们来实现币的挖矿铸造，不同地址之下钱包的转账。</p>
<p>Move 语言的 <code>public function</code> 签名如下：</p>
<pre><code>/// Publish an empty balance resource under `account`'s address. This function must be called before
/// minting or transferring to the account.
public fun publish_balance(account: &amp;signer) { ... }

/// Mint `amount` tokens to `mint_addr`. Mint must be approved by the module owner.
public fun mint(module_owner: &amp;signer, mint_addr: address, amount: u64) acquires Balance { ... }

/// Returns the balance of `owner`.
public fun balance_of(owner: address): u64 acquires Balance { ... }

/// Transfers `amount` of tokens from `from` to `to`.
public fun transfer(from: &amp;signer, to: address, amount: u64) acquires Balance { ... }
</code></pre>
<p>接下来再看本模块所需要各数据结构.</p>
<p>Move 语言的模块没有自己的数据存储，相反的是 Move 语言提供按地址(addresses) 索引的 <strong>全局存储</strong> (也是就是我们所说的区块链状态(blockchain state)). 每个地址之下包含有 Move 模块(代码)和 Move 资源 (数据)。</p>
<p>在 Rust 语法中，全局存储看起来有点像这样：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct GlobalStorage {
    resources: Map&lt;address, Map&lt;ResourceType, ResourceValue&gt;&gt;
    modules: Map&lt;address, Map&lt;ModuleName, ModuleBytecode&gt;&gt;
}
<span class="boring">}
</span></code></pre></pre>
<p>每个地址下的 Move 资源存储是一个类型到数值的映射。(细心的读者也许已经注意到每个地址, 每个类型下只能对应一个具体值)。这方便地为我们提供了一个按地址索引的本地映射。
在 <code>BasicCoin</code> 模块中，定义了每个 <code>Balance</code> (钱包，余额)资源表示每个地址下持有的币的数量：</p>
<pre><code>/// Struct representing the balance of each address.
struct Balance has key {
    coin: Coin // same Coin from Step 1
}
</code></pre>
<p>区块链状态(<code>Move blockchain state</code>)看起来大致如下：
<img src="https://awesomeprogram.gitee.io/imgdata/tech_bc_move_state.png" alt="" /></p>
<h3 id="进阶主题-advanced-topics-"><a class="header" href="#进阶主题-advanced-topics-">进阶主题 (Advanced topics) ：</a></h3>
<details>
<summary><code>public(script)</code> functions</summary>
<p>只有<code>public(script)</code>可见行的函数才能直接被交易调用，所以如果你要直接在交易内调用 <code>transfer</code> 方法，那么需要将函数签改成如下格式:</p>
<pre><code>public(script) fun transfer(from: signer, to: address, amount: u64) acquires Balance { ... }
</code></pre>
<p>关于函数可见性的更多信息，请参阅<a href="blockchain/">Move function visibilities</a>。</p>
</details>
<details>
<summary>与 Ethereum/Solidity 的比较 (Comparison with Ethereum/Solidity)</summary>
<p>在大多数以太坊<a href="blockchain/(https://ethereum.org/en/developers/docs/standards/tokens/erc-20/)">ERC-20</a>智能合约中，各个账户地址下的余额保存在类型为 <code>mapping(address =&gt; uint256)</code>的 <strong>状态变量</strong> 中，此状态变量存储在具体的智能合约内部存储中。</p>
<p>以太坊区块链的状态看起来大致如下:
<img src="https://awesomeprogram.gitee.io/imgdata/tech_bc_solidity_state.png" alt="" /></p>
</details>
<h2 id="4basiccoin-模块module的实现"><a class="header" href="#4basiccoin-模块module的实现">4.<code>BasicCoin</code> 模块（Module）的实现</a></h2>
<p>我们已经在 <code>step_4</code> 文件夹上创建了名叫 <code>BasicCoin</code> 的 Move 包。<code>sources</code> 文件夹包含所有的 Move 包(package)的模块源码，包括 <code>BasicCoin.move</code>。在本节中，我们将仔细研究 <code>BasicCoin.move</code> 内部方法的实现。</p>
<h3 id="编译代码"><a class="header" href="#编译代码">编译代码</a></h3>
<p>首先尝试在文件夹<a href="blockchain/">step_4/BasicCoin</a>中运行以下命令，使用 Move 包构建代码：</p>
<pre><code class="language-bash">move build
</code></pre>
<h3 id="方法的实现"><a class="header" href="#方法的实现">方法的实现</a></h3>
<p>现在仔细看看 <code>BasicCoin.move</code> 中内部方法的实现。</p>
<details>
<summary><code>publish_balance</code>方法</summary>
<p>此方法将 <code>Balance</code> 资源发布到指定地址名下。由于此资源需要通过铸造或转账来接收代币，必须由用户先调用方法 <code>publish_balance</code> 才能接收钱，包括模块所有者。</p>
<p>此方法使用 <code>move_to</code> 操作来发布资源：</p>
<pre><code class="language-bash">let empty_coin = Coin { value: 0 };
move_to(account, Balance { coin:  empty_coin });
</code></pre>
</details>
<details>
<summary><code>mint</code>方法</summary>
<p><code>mint</code> 方法将代币铸造到指定的帐户。在此我们要求 <code>mint</code> 必须得到模块所有者的批准。我们使用 <code>assert</code> 语句强制执行此操作：</p>
<pre><code class="language-bash">assert!(signer::address_of(&amp;module_owner) == MODULE_OWNER, errors::requires_address(ENOT_MODULE_OWNER));
</code></pre>
<p>Move 中的 <code>assert</code> 语句可以这样使用：<code>assert!(&lt;predicate&gt;, &lt;abort_code&gt;);</code>。这意味着如果 <code>&lt;predicate&gt;</code> 为假，则使用中止错误码 <code>&lt;abort_code&gt;</code> 来终止交易。此处的 <code>MODULE_OWNER</code> 和 <code>ENOT_MODULE_OWNER</code> 都是在模块开头定义的常量。<code>errors</code> 模块定义了我们可以使用的常见错误种类。重点是我们需要注意 Move 在其执行过程中是事务性的-- 因此，如果触发<a href="blockchain/">中止(abort)</a>，并不用回退已执行状态的，因为该事务的任何更改都不会持久保存到区块链。</p>
<p>然后将数量为 <code>amount</code> 的代币存入 <code>mint_addr</code> 的余额中。</p>
<pre><code>deposit(mint_addr, Coin { value: amount });
</code></pre>
</details>
<details>
<summary><code>balance_of</code>方法</summary>
<p>我们使用全局存储操作之一的 <code>borrow_global</code> 从全局存储中读取资源(数据)。</p>
<pre><code>borrow_global&lt;Balance&gt;(owner).coin.value
                 |       |       \    /
        resource type  address  field names
</code></pre>
</details>
<details>
<summary><code>transfer</code>方法</summary>
<p>该函数从 <code>from</code> 的余额中提取代币并将代币存入 <code>to</code> 的余额中。我们仔细研究帮助函数 <code>withdraw</code>：</p>
<pre><code>fun withdraw(addr: address, amount: u64) : Coin acquires Balance {
    let balance = balance_of(addr);
    assert!(balance &gt;= amount, EINSUFFICIENT_BALANCE);
    let balance_ref = &amp;mut borrow_global_mut&lt;Balance&gt;(addr).coin.value;
    *balance_ref = balance - amount;
    Coin { value: amount }
}
</code></pre>
<p>在方法开始，我们断言提款账户有足够的余额。然后我们使用 <code>borrow_global_mut</code> 来获得全局存储的可变引用，并用 <code>&amp;mut</code> 创建结构体字段的<a href="blockchain/">可变引用</a>。然后我们通过这个可变引用修改余额并返回一个带有提取金额的新代币。</p>
</details>
<h3 id="练习-1"><a class="header" href="#练习-1">练习</a></h3>
<p>在模块中有两个 TODOs，留给读者练习：</p>
<ul>
<li>完成 <code>publish_balance</code> 方法的实现。</li>
<li>实现 <code>deposit</code> 方法。</li>
</ul>
<p>此练习的解决方案可以在<code>step_4_sol</code>文件夹中找到。</p>
<h4 id="额外练习"><a class="header" href="#额外练习">额外练习</a></h4>
<ul>
<li>如果我们在余额中存入太多会发生什么？</li>
</ul>
<h2 id="5给-basiccoin-模块添加单元测试"><a class="header" href="#5给-basiccoin-模块添加单元测试">5.给 <code>BasicCoin</code> 模块添加单元测试</a></h2>
<p>在这一步中，来看看我们为覆盖在 <code>step 4</code> 中编写的代码而编写的所有不同的单元测试。还将看看我们可以用来帮助我们编写测试用例的一些工具。</p>
<p>首先，请在文件夹 <code>step_5/BasicCoin</code> 中运行 <code>move test</code> 命令。</p>
<pre><code class="language-bash">move test
</code></pre>
<p>你应该看到如下内容：</p>
<pre><code>INCLUDING DEPENDENCY MoveStdlib
BUILDING BasicCoin
Running Move unit tests
[ PASS    ] 0xcafe::BasicCoin::can_withdraw_amount
[ PASS    ] 0xcafe::BasicCoin::init_check_balance
[ PASS    ] 0xcafe::BasicCoin::init_non_owner
[ PASS    ] 0xcafe::BasicCoin::publish_balance_already_exists
[ PASS    ] 0xcafe::BasicCoin::publish_balance_has_zero
[ PASS    ] 0xcafe::BasicCoin::withdraw_dne
[ PASS    ] 0xcafe::BasicCoin::withdraw_too_much
Test result: OK. Total tests: 7; passed: 7; failed: 0
</code></pre>
<details>
<summary>(练习)</summary>
<p>在查看测试之后，尝试在 <code>BasicCoin</code> 模块中编写一个单元测试 <code>balance_of_dne</code>，测试地址没有 <code>Balance</code> 资源的情况，调用 <code>balance_of</code> 方法的执行结果。它应该只有几行代码。</p>
<p>练习的答案可以在<code>step_5_sol</code>中找到。</p>
</details>
<h2 id="6使用泛型generic编写-basiccoin-模块"><a class="header" href="#6使用泛型generic编写-basiccoin-模块">6.使用泛型（generic）编写 <code>BasicCoin</code> 模块</a></h2>
<p>在 Move 语言中，我们可以使用泛型来定义不同输入数据类型的函数和结构体。泛型是库代码的重要组成部分。在本节中，我们将使我们的简单 <code>BasicCoin</code> 模块泛型化，以便它可以用作其他用户模块可以使用的模块库。</p>
<p>首先，我们将类型参数添加到我们的数据结构中：</p>
<pre><code>struct Coin&lt;phantom CoinType&gt; has store {
    value: u64
}

struct Balance&lt;phantom CoinType&gt; has key {
    coin: Coin&lt;CoinType&gt;
}
</code></pre>
<p>我们还以相同的方式将类型参数添加到我们的方法中。例如，<code>withdraw</code> 变成如下：</p>
<pre><code>fun withdraw&lt;CoinType&gt;(addr: address, amount: u64) : Coin&lt;CoinType&gt; acquires Balance {
    let balance = balance_of&lt;CoinType&gt;(addr);
    assert!(balance &gt;= amount, EINSUFFICIENT_BALANCE);
    let balance_ref = &amp;mut borrow_global_mut&lt;Balance&lt;CoinType&gt;&gt;(addr).coin.value;
    *balance_ref = balance - amount;
    Coin&lt;CoinType&gt; { value: amount }
}
</code></pre>
<p>查看<code>step_6/BasicCoin/sources/BasicCoin.move</code>完整的实现。</p>
<p>此时，熟悉以太坊的读者可能会注意到，该模块的用途与<a href="https://ethereum.org/en/developers/docs/standards/tokens/erc-20/">ERC20 token standard</a>类似，后者提供了在智能合约中实现可替代代币的接口。使用泛型的一个关键优势是能够重用代码，因为泛型模块库已经提供了标准实现，并且实例化模块可以通过包装标准实现提供定制化功能。</p>
<p>我们提供了一个称为<a href="blockchain/">MyOddCoin</a>并实例化 <code>Coin</code> 类型并自定义其转移策略的小模块：只能转移奇数个代币。其还包括两个 <a href="blockchain/">tests</a> 来测试这种行为。你可以使用在第 2 步和第 5 步中学到的命令来运行测试。</p>
<h3 id="进阶主题"><a class="header" href="#进阶主题">进阶主题：</a></h3>
<details>
<summary><code>phantom</code> 类型参数</summary>
<p>在 <code>Coin</code> 和 <code>Balance</code> 的定义中，我们将类型参数 <code>CoinType</code> 声明为phantom，因为 <code>CoinType</code> 没有在结构体定义中使用或仅用作 phantom 类型参数。
阅读更多有关 <a href="blockchain/">phantom 类型参数</a> 信息.</p>
</details>
<h3 id="进阶步骤"><a class="header" href="#进阶步骤">进阶步骤</a></h3>
<p>在继续下一步之前，确保您已安装所有的验证器依赖项。</p>
<p>尝试运行 <code>boogie /version</code>。如果出现错误消息“找不到命令：boogie”，你将必须运行安装脚本并更新环境配置(source ~/.profile)：</p>
<pre><code class="language-bash"># run the following in move repo root directory
./scripts/dev_setup.sh -yp
source ~/.profile
</code></pre>
<h2 id="7使用-move-prover"><a class="header" href="#7使用-move-prover">7.使用 <code>Move prover</code></a></h2>
<p>部署在区块链上的智能合约可能会操纵高价值资产。作为一种使用严格的数学方式来描述计算机系统的行为和推理正确性的技术，形式化验证已被用于区块链，以防止智能合约中错误的产生。 <a href="blockchain/">Move验证器</a>是一种在进化中、用Move 语言编写的智能合约形式化验证工具。用户可以使用<a href="blockchain/">Move语言规范(Move Specification Language (MSL))</a>指定智能合约的功能属性，然后使用验证器自动静态检查它们。 为了说明如何使用验证器，我们在<a href="blockchain/">BasicCoin.move</a>中添加了以下代码片段：</p>
<pre><code>    spec balance_of {
        pragma aborts_if_is_strict;
    }
</code></pre>
<p>通俗地说，代码块 <code>spec balance_of {...}</code> 包含 <code>balance_of</code> 方法的属性规范说明。</p>
<p>首先在<a href="blockchain/">BasicCoin directory</a>目录中使用以下命令运行验证器。</p>
<pre><code class="language-bash">move prove
</code></pre>
<p>它输出以下错误信息：</p>
<pre><code>error: abort not covered by any of the `aborts_if` clauses
   ┌─ ./sources/BasicCoin.move:38:5
   │
35 │           borrow_global&lt;Balance&lt;CoinType&gt;&gt;(owner).coin.value
   │           ------------- 由于执行失败这里发生中止
   ·
38 │ ╭     spec balance_of {
39 │ │         pragma aborts_if_is_strict;
40 │ │     }
   │ ╰─────^
   │
   =     at ./sources/BasicCoin.move:34: balance_of
   =         owner = 0x29
   =     at ./sources/BasicCoin.move:35: balance_of
   =         中止

Error: exiting with verification errors
</code></pre>
<p>验证器大体上告诉我们，我们需要明确指定函数 <code>balance_of</code> 中止的条件，中止原因是 <code>owner</code>(函数调用者)在没有资源 <code>Balance&lt;CoinType&gt;</code> 的情况下调用 <code>borrow_global</code> 函数导致的。要去掉此错误信息，我们添加如下 aborts_if 条件：</p>
<pre><code>    spec balance_of {
        pragma aborts_if_is_strict;
        aborts_if !exists&lt;Balance&lt;CoinType&gt;&gt;(owner);
    }
</code></pre>
<p>添加此条件后，再次尝试运行prove命令，确认没有验证错误：</p>
<pre><code class="language-bash">move prove
</code></pre>
<p>除了中止条件，我们还想定义功能属性。在第 8 步中，我们将通过为定义 <code>BasicCoin</code> 模块的方法指定属性来更详细地介绍验证器。</p>
<h2 id="8为-basiccoin-模块编写形式化规范formal-specification"><a class="header" href="#8为-basiccoin-模块编写形式化规范formal-specification">8.为 <code>BasicCoin</code> 模块编写形式化规范（formal specification）</a></h2>
<details>
<summary> 取款方法 </summary>
<p>取款(<code>withdraw</code>) 方法的签名如下：</p>
<pre><code>fun withdraw&lt;CoinType&gt;(addr: address, amount: u64) : Coin&lt;CoinType&gt; acquires Balance
</code></pre>
<p>该方法从地址 <code>addr</code> 中提取数量为 <code>amount</code> 的代币，然后创建数量为 <code>amount</code> 的代币并将其返回。当出现如下情况会中止：</p>
<ol>
<li>地址 <code>addr</code> 没有资源 <code>Balance&lt;CoinType&gt;</code>，或</li>
<li>地址 <code>addr</code> 中的代币数量小于 <code>amount</code> 时，<code>withdraw</code> 。</li>
</ol>
<p>我们可以这样定义条件：</p>
<pre><code>    spec withdraw {
        let balance = global&lt;Balance&lt;CoinType&gt;&gt;(addr).coin.value;
        aborts_if !exists&lt;Balance&lt;CoinType&gt;&gt;(addr);
        aborts_if balance &lt; amount;
    }
</code></pre>
<p>正如我们在这里看到的，一个 spec 块可以包含 <code>let</code> 绑定，它为表达式引入名称。
<code>global&lt;T&gt;(address): T</code> 是一个返回 <code>addr</code> 资源值的内置函数。<code>balance</code> 是 <code>addr</code> 拥有的代币数量。
<code>exists&lt;T&gt;(address): bool</code> 是一个内置函数，如果指定的地址(address)在(全局存储中)有资源 <code>T</code> 则返回 <code>true</code> 。
两个 <code>aborts_if</code> 子句对应上述两个条件。通常，如果一个函数有多个 <code>aborts_if</code> 条件，这些条件之间是相互对等的。默认情况下，如果用户想要指定中止条件，则需要列出所有可能的条件。否则验证器将产生验证错误。
但是，如果在 <code>spec</code> 代码块中定义了 <code>pragma aborts_if_is_partial</code>，则组合中止条件（或对等的单个条件）仅 <em>暗示</em> 函数中止。
读者可以参考 <a href="blockchain/">MSL</a> 文档了解更多信息。</p>
<p>下一步是定义功能属性，这些属性在下面的两个 <code>ensures</code> 子句中进行了描述。首先，通过使用 <code>let post</code> 绑定，<code>balance_post</code> 表示地址 <code>addr</code> 执行后的余额，应该等于 <code>balance - amount</code>。那么，返回值（表示为 <code>result</code> ）应该是一个价值为 <code>amount</code> 的代币。</p>
<pre><code>    spec withdraw {
        let balance = global&lt;Balance&lt;CoinType&gt;&gt;(addr).coin.value;
        aborts_if !exists&lt;Balance&lt;CoinType&gt;&gt;(addr);
        aborts_if balance &lt; amount;

        let post balance_post = global&lt;Balance&lt;CoinType&gt;&gt;(addr).coin.value;
        ensures balance_post == balance - amount;
        ensures result == Coin&lt;CoinType&gt; { value: amount };
    }
</code></pre>
</details>
<details>
<summary> 存款方法 </summary>
<p>存款(<code>deposit</code>)方法的签名如下：</p>
<pre><code>fun deposit&lt;CoinType&gt;(addr: address, check: Coin&lt;CoinType&gt;) acquires Balance
</code></pre>
<p>该方法将代币 <code>check</code> 存入地址 <code>addr</code>. 规范定义如下：</p>
<pre><code>    spec deposit {
        let balance = global&lt;Balance&lt;CoinType&gt;&gt;(addr).coin.value;
        let check_value = check.value;

        aborts_if !exists&lt;Balance&lt;CoinType&gt;&gt;(addr);
        aborts_if balance + check_value &gt; MAX_U64;

        let post balance_post = global&lt;Balance&lt;CoinType&gt;&gt;(addr).coin.value;
        ensures balance_post == balance + check_value;
    }
</code></pre>
<p><code>balance</code> 表示 <code>addr</code> 执行前的代币数量，<code>check_value</code> 表示要存入的代币数量。方法出现如下情况将会中止：
1) 地址 <code>addr</code> 没有 <code>Balance&lt;CoinType&gt;</code> 资源， 或
2) <code>balance</code> 与 <code>check_value</code> 之和大于 <code>u64</code> 的最大值。</p>
<p>该功能属性检查执行后余额是否正确更新。</p>
</details>
<details>
<summary> 转账方法 </summary>
<p>转账(<code>transfer</code>)方法的签名如下：</p>
<pre><code>public fun transfer&lt;CoinType: drop&gt;(from: &amp;signer, to: address, amount: u64, _witness: CoinType) acquires Balance
</code></pre>
<p>该方法将数量为 <code>amount</code> 的代币从帐户 <code>from</code> 转账给地址 <code>to</code>。规范如下：</p>
<pre><code>    spec transfer {
        let addr_from = signer::address_of(from);

        let balance_from = global&lt;Balance&lt;CoinType&gt;&gt;(addr_from).coin.value;
        let balance_to = global&lt;Balance&lt;CoinType&gt;&gt;(to).coin.value;
        let post balance_from_post = global&lt;Balance&lt;CoinType&gt;&gt;(addr_from).coin.value;
        let post balance_to_post = global&lt;Balance&lt;CoinType&gt;&gt;(to).coin.value;

        ensures balance_from_post == balance_from - amount;
        ensures balance_to_post == balance_to + amount;
    }
</code></pre>
<p><code>addr_from</code> 是账户 <code>from</code> 的地址，然后获取执行前两个地址 <code>addr_from</code> 和 <code>to</code> 的余额。
<code>ensures</code> 子句指定从 <code>addr_from</code> 减去 <code>amount</code> 数量的代币，添加到 <code>to</code>。然而，验证器会生成以下错误：</p>
<pre><code>error: post-condition does not hold
   ┌─ ./sources/BasicCoin.move:57:9
   │
62 │         ensures balance_from_post == balance_from - amount;
   │         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   │
   ...
</code></pre>
<p>当 <code>addr_from</code> 等于 <code>to</code> 时，这个属性无效。因此，我们可以在方法中添加一个断言，<code>assert!(from_addr != to)</code> 来确保 <code>addr_from</code> 不等于 <code>to</code>。</p>
</details>
<details>
<summary> 练习 </summary>
<ul>
<li>Implement the <code>aborts_if</code> conditions for the <code>transfer</code> method.</li>
<li>为<code> transfer</code> 方法实现 <code>aborts_if</code> 条件。</li>
<li>Implement the specification for the <code>mint</code> and <code>publish_balance</code> method.</li>
<li>为 <code>mint</code> 和 <code>publish_balance</code> 方法实现规范。</li>
</ul>
<p>练习的解答可以在 <a href="blockchain/"><code>step_8_sol</code></a>中找到。</p>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solidity"><a class="header" href="#solidity">Solidity</a></h1>
<h2 id="solidity-0813-官网中文教程重新发行版"><a class="header" href="#solidity-0813-官网中文教程重新发行版"><a href="https://awesomeprogram.gitee.io/solidity">Solidity-0.8.13 官网中文教程重新发行版</a></a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hardhat教程"><a class="header" href="#hardhat教程">Hardhat教程</a></h1>
<h2 id="1-hardhat概述"><a class="header" href="#1-hardhat概述">1. Hardhat概述</a></h2>
<p>欢迎来到我们的以太坊合约和 dApp 开发初学者指南。本教程旨在快速让您从头开始构建一些东西。</p>
<p>为了协调这个过程，我们将使用 Hardhat，这是一种有助于在以太坊上构建的开发环境。它可以帮助开发人员管理和自动化构建智能合约和 dApp 过程中固有的重复性任务，并且它允许你围绕此工作流程轻松引入更多功能。这意味着 hardhat 在最核心的地方进行编译和测试。</p>
<p>Hardhat 还内置了 Hardhat 网络，这是一个专为开发而设计的本地以太坊网络。它允许你部署合约、运行测试和调试代码。</p>
<p>在本教程中，我们将引导您完成：</p>
<ul>
<li>为以太坊开发设置 Node.js 环境</li>
<li>创建和配置 Hardhat 项目</li>
<li>实现 Solidity 智能合约代币</li>
<li>使用 Hardhat 为你的合约编写自动化测试</li>
<li>使用Hardhat EVM的 <code>console.log()</code> 调试 Solidity</li>
<li>将您的合约部署到 Hardhat EVM 和以太坊测试网</li>
</ul>
<p>要遵循本教程，你应该能够：</p>
<ul>
<li>用 [JavaScript] 编写代码(https://developer.mozilla.org/en-US/docs/Learn/Getting_started_with_the_web/JavaScript_basics)</li>
<li>操作 <a href="https://en.wikipedia.org/wiki/Terminal_emulator">terminal</a></li>
<li>使用 <a href="https://git-scm.com/doc">git</a></li>
<li>了解 <a href="https://ethereum.org/learn/#smart-contracts">智能合约</a> 如何工作的基础知识</li>
<li>设置 <a href="https://metamask.io/">Metamask</a> 钱包</li>
</ul>
<p>如果你无法执行上述任何操作，请点击链接并花一些时间学习基础知识。</p>
<h2 id="2-搭建环境"><a class="header" href="#2-搭建环境">2. 搭建环境</a></h2>
<p>大多数以太坊库和工具都是用 JavaScript 编写的，Hardhat 也是如此。如果你不熟悉 Node.js，它是基于 Chrome 的 V8 JavaScript 引擎构建的 JavaScript 运行时。它是在 Web 浏览器之外运行 JavaScript 的最流行的解决方案，而 Hardhat 就是在它之上构建的。</p>
<p>:::提示</p>
<p><a href="https://marketplace.visualstudio.com/items?itemName=NomicFoundation.hardhat-solidity">Hardhat for Visual Studio Code</a> 是官方的 Hardhat 扩展，它为 VSCode 添加了对 Solidity 的高级支持。如果你使用 Visual Studio Code，可尝试一下！</p>
<p>:::</p>
<h3 id="安装nodejs"><a class="header" href="#安装nodejs">安装Node.js</a></h3>
<p>如果你已经安装了的 Node.js <code>&gt;=16.0</code>，则可以<a href="blockchain/chapter_1_3_3.html#3-%E5%88%9B%E5%BB%BA%E6%96%B0%E7%9A%84hardhat%E9%A1%B9%E7%9B%AE">跳到下一节</a>。如果没有，请按照以下步骤在 Ubuntu，MacOS 和 Windows 上安装它。</p>
<h4 id="linux"><a class="header" href="#linux">Linux</a></h4>
<h5 id="ubuntu"><a class="header" href="#ubuntu">Ubuntu</a></h5>
<p>将以下命令复制并粘贴到终端中：</p>
<pre><code>sudo apt update
sudo apt install curl git
curl -fsSL https://deb.nodesource.com/setup_18.x | sudo -E bash -
sudo apt-get install -y nodejs
</code></pre>
<h4 id="macos"><a class="header" href="#macos">MacOS</a></h4>
<p>确保你已安装 <code>git</code>。否则，请遵循<a href="https://www.atlassian.com/git/tutorials/install-git">这些说明</a>安装.</p>
<p>在 MacOS 上有多种安装 Node.js 的方法。我们将使用 Node 版本管理器（nvm）。将以下命令复制并粘贴到终端中：</p>
<pre><code>curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.1/install.sh | bash
nvm install 18
nvm use 18
nvm alias default 18
npm install npm --global # Upgrade npm to the latest version
</code></pre>
<h4 id="windows"><a class="header" href="#windows">Windows</a></h4>
<p>如果你使用 Windows，我们强烈推荐你使用用于 Linux 的 Windows 子系统（也就是 WSL2）。你可以不用它来使用 Hardhat，但如果你使用它，效果会更好。</p>
<p>要使用 WSL2 来安装 Node.js，可参考<a href="https://docs.microsoft.com/en-us/windows/dev-environment/javascript/nodejs-on-wsl">这篇手册</a>.</p>
<p>还要确保你已经<a href="https://docs.microsoft.com/en-us/windows/wsl/tutorials/wsl-git">在 WSL2 上安装了 git</a>.</p>
<h3 id="升级nodejs"><a class="header" href="#升级nodejs">升级Node.js</a></h3>
<p>如果你的 Node.js 版本很老的并且<a href="https://hardhat.org/hardhat-runner/docs/reference/stability-guarantees#node.js-versions-support">不被 Hardhat 支持</a>，则需要通过以下指引升级。</p>
<h4 id="linux-1"><a class="header" href="#linux-1">Linux</a></h4>
<h5 id="ubuntu-1"><a class="header" href="#ubuntu-1">Ubuntu</a></h5>
<ol>
<li>在终端运行 <code>sudo apt remove nodejs</code> 命令来删除 Node.js。</li>
<li>在<a href="https://github.com/nodesource/distributions#debinstall">这里</a>查找你希望安装的 Node.js 版本并且按照指令来安装。</li>
<li>在终端运行 <code>sudo apt update &amp;&amp; sudo apt install nodejs</code> 命令来再次安装 Node.js。</li>
</ol>
<h4 id="macos-1"><a class="header" href="#macos-1">MacOS</a></h4>
<p>你可以使用 <a href="http://github.com/creationix/nvm">nvm</a>来切换你的 Node.js 版本。在终端运行以下命令升级到 Node.js <code>18.x</code>：</p>
<pre><code>nvm install 18
nvm use 18
nvm alias default 18
npm install npm --global # 升级 npm 到最新的版本
</code></pre>
<h4 id="windows-1"><a class="header" href="#windows-1">Windows</a></h4>
<p>你需要遵循与之前<a href="blockchain/chapter_1_3_3.html#windows">相同的安装说明</a>，但选择不同的版本。你可以<a href="https://nodejs.org/en/download/releases/">在此处</a>查看所有可用版本的列表。</p>
<h2 id="3-创建新的hardhat项目"><a class="header" href="#3-创建新的hardhat项目">3. 创建新的Hardhat项目</a></h2>
<p>我们将使用 Node.js 的包管理器（<code>npm</code>）来安装 Hardhat，NPM 是一个 Node.js 软件包管理器和一个 JavaScript 代码库。</p>
<p>你可以使用 Node.js 的其它包管理器，但是我们建议你按照这个手册使用 npm 7 或者更高的版本。如果你遵循了之前的章节步骤，那么应该已经安装了它。</p>
<p>打开一个新终端，运行以下命令来创建一个新的目录：</p>
<pre><code>mkdir hardhat-tutorial
cd hardhat-tutorial
</code></pre>
<p>然后初始化一个 npm 项目，如下所示。系统将提示你回答一些问题。</p>
<p>::::提示</p>
<p>使用代码段中的选项卡选择首选的包管理器。我们建议使用 npm7 或更高版本，因为它使安装 Hardhat 的依赖关系变得更容易。</p>
<p>::::</p>
<p>::::tabsgroup{options=&quot;npm 7+,npm 6,yarn&quot;}</p>
<p>:::tab{value=&quot;npm 7+&quot;}</p>
<pre><code>npm init
</code></pre>
<p>:::</p>
<p>:::tab{value=&quot;npm 6&quot;}</p>
<pre><code>npm init
</code></pre>
<p>:::</p>
<p>:::tab{value=yarn}</p>
<pre><code>yarn init
</code></pre>
<p>:::</p>
<p>::::</p>
<p>现在我们可以安装 Hardhat：</p>
<p>::::tabsgroup{options=&quot;npm 7+,npm 6,yarn&quot;}</p>
<p>:::tab{value=&quot;npm 7+&quot;}</p>
<pre><code>npm install --save-dev hardhat
</code></pre>
<p>:::</p>
<p>:::tab{value=&quot;npm 6&quot;}</p>
<pre><code>npm install --save-dev hardhat
</code></pre>
<p>:::</p>
<p>:::tab{value=yarn}</p>
<pre><code>yarn add --dev hardhat
</code></pre>
<p>:::</p>
<p>::::</p>
<p>在安装 Hardhat 的同一目录中运行以下命令：</p>
<pre><code>npx hardhat
</code></pre>
<p>使用你的键盘选择 <code>Create an empty hardhat.config.js</code> 并且按下回车键。</p>
<pre><code class="language-markup{16}">$ npx hardhat
888    888                      888 888               888
888    888                      888 888               888
888    888                      888 888               888
8888888888  8888b.  888d888 .d88888 88888b.   8888b.  888888
888    888     &quot;88b 888P&quot;  d88&quot; 888 888 &quot;88b     &quot;88b 888
888    888 .d888888 888    888  888 888  888 .d888888 888
888    888 888  888 888    Y88b 888 888  888 888  888 Y88b.
888    888 &quot;Y888888 888     &quot;Y88888 888  888 &quot;Y888888  &quot;Y888

👷 Welcome to Hardhat v2.9.9 👷‍

? What do you want to do? …
  Create a JavaScript project
  Create a TypeScript project
❯ Create an empty hardhat.config.js
  Quit
</code></pre>
<p>当 Hardhat 在运行时，它从当前工作目录开始搜索最近的 <code>hardhat.config.js</code> 文件。这个文件通常存在你项目的根目录下，而且一个空的 <code>hardhat.config.js</code> 文件已经足够可以让 Hardhat 去工作了。你的整个配置都包含在这个文件中。</p>
<h3 id="hardhat的架构"><a class="header" href="#hardhat的架构">Hardhat的架构</a></h3>
<p>Hardhat 是围绕任务和插件的概念设计的。Hardhat 的大部分功能来自插件，你可以自由选择想要使用的<a href="https://hardhat.org/hardhat-runner/plugins">插件</a>。</p>
<h4 id="任务"><a class="header" href="#任务">任务</a></h4>
<p>每次从命令行运行 Hardhat 时，都在运行一个任务。例如，<code>npx hardhat compile</code> 正在运行 <code>compile</code> 任务。要查看项目中当前可用的任务，运行 <code>npx hardhat</code>。你可以通过运行 <code>npx hardhat help [task]</code> 来探索任何任务。</p>
<p>:::提示</p>
<p>你可以创建你自己的任务，可参阅<a href="https://hardhat.org/hardhat-runner/docs/advanced/create-task">创建任务指南</a>。</p>
<p>:::</p>
<h4 id="插件"><a class="header" href="#插件">插件</a></h4>
<p>就最终使用的工具而言，Hardhat 是独立的，但它确实有一些内置的默认值。所有这些都可以被覆盖。大多数情况下，使用给定工具的方法是使用将其集成到 Hardhat 中的插件。</p>
<p>在本教程中，我们将使用我们推荐的插件，<a href="https://hardhat.org/hardhat-runner/plugins/nomicfoundation-hardhat-toolbox"><code>@nomicfoundation/hardhat-toolbox</code></a>，它提供了开发智能合约所需的一切。</p>
<p>要安装它，请在项目目录中运行此命令：</p>
<p>::::tabsgroup{options=&quot;npm 7+,npm 6,yarn&quot;}</p>
<p>:::tab{value=&quot;npm 7+&quot;}</p>
<pre><code>npm install --save-dev @nomicfoundation/hardhat-toolbox
</code></pre>
<p>:::</p>
<p>:::tab{value=&quot;npm 6&quot;}</p>
<pre><code>npm install --save-dev @nomicfoundation/hardhat-toolbox @nomicfoundation/hardhat-network-helpers @nomicfoundation/hardhat-chai-matchers @nomiclabs/hardhat-ethers @nomiclabs/hardhat-etherscan chai ethers hardhat-gas-reporter solidity-coverage @typechain/hardhat typechain @typechain/ethers-v5 @ethersproject/abi @ethersproject/providers
</code></pre>
<p>:::</p>
<p>:::tab{value=yarn}</p>
<pre><code>yarn add --dev @nomicfoundation/hardhat-toolbox @nomicfoundation/hardhat-network-helpers @nomicfoundation/hardhat-chai-matchers @nomiclabs/hardhat-ethers @nomiclabs/hardhat-etherscan chai ethers hardhat-gas-reporter solidity-coverage @typechain/hardhat typechain @typechain/ethers-v5 @ethersproject/abi @ethersproject/providers
</code></pre>
<p>:::</p>
<p>::::</p>
<p>将高亮显示的行添加到 <code>hardhat.config.js</code> 中，使其看起来像这样：</p>
<pre><code class="language-js{1}">require(&quot;@nomicfoundation/hardhat-toolbox&quot;);

/** @type import('hardhat/config').HardhatUserConfig */
module.exports = {
  solidity: &quot;0.8.9&quot;,
};
</code></pre>
<h2 id="4-编写和编译合约"><a class="header" href="#4-编写和编译合约">4. 编写和编译合约</a></h2>
<p>我们将创建一个简单的智能合约，它会实现一个可以交易的 token。Token 合约最常用于交换和存储价值。在本教程中，我们不会深入研究合约的 Solidity 代码，但你应该知道我们实现的一些逻辑：</p>
<ul>
<li>Token 的总供应量是固定的，不能更改。</li>
<li>Token 的整个供应量分配给部署合约的账户地址。</li>
<li>任何人都可以收到 Token。</li>
<li>任何拥有至少一个 Token 的人都可以转移 Token。</li>
<li>Token 是不可分割的。你可以转移1、2、3或37个 Token，但不能转移2.5个。</li>
</ul>
<p>:::提示</p>
<p>你可能听说过 ERC-20，这是以太坊的一个 token 标准。token 如 DAI 和 USDC 实现了 ERC-20 标准，这使得它们都可以与任何可以处理 ERC-20 token 的软件兼容。为了简单起见，我们将要构建的 token 不实现 ERC-20 标准。</p>
<p>:::</p>
<h3 id="编写智能合约"><a class="header" href="#编写智能合约">编写智能合约</a></h3>
<p>开始创建一个名为 <code>contracts</code> 的新文件夹，并且在文件中创建一个名为 <code>Token.sol</code> 的文件。</p>
<p>粘贴下面的的代码到文件中，并且花一分钟通读以下这段代码。它很简单，而且充满了解释 Solidity 基本原理的注释。</p>
<p>:::提示</p>
<p>要在 Visual Studio Code 中为 solididity 获得语法高亮显示和编辑帮助，请尝试在<a href="https://marketplace.visualstudio.com/items?itemName=NomicFoundation.hardhat-solidity">Hardhat for Visual Studio Code</a>。</p>
<p>:::</p>
<pre><code class="language-solidity">//SPDX-License-Identifier: UNLICENSED

// Solidity文件必须以这个pragma开头。
// 它将被Solidity编译器用来验证它的版本。
pragma solidity ^0.8.9;


// 这是智能合约的主要构建模块。
contract Token {
    // 一些用于标识token的字符串类型变量。
    string public name = &quot;My Hardhat Token&quot;;
    string public symbol = &quot;MHT&quot;;

    // 固定数量的tokens，存储在无符号整数类型变量中。
    uint256 public totalSupply = 1000000;

    // 一个地址类型变量被用作存储以太坊账户。
    address public owner;

    // 一个key/value键值对map映射。我们在这里存储每个账户的余额。
    mapping(address =&gt; uint256) balances;

    // 这个转让事件帮助链下应用理解在你的合约中发生的什么。
    event Transfer(address indexed _from, address indexed _to, uint256 _value);

    /**
     * 合约初始化。
     */
    constructor() {
        // 这个总供应量被分配给交易发送者，它是部署这个合约的账户。
        balances[msg.sender] = totalSupply;
        owner = msg.sender;
    }

    /**
     * 转移tokens的函数。
     *
     * 这个 `external` 修饰符会使一个函数仅可以在这个合约外部被调用。
     */
    function transfer(address to, uint256 amount) external {
        // 检查这个交易发送者是否有足够的tokens。
        // 如果 `require` 的第一个参数等价于 `false` 那么这个交易将会恢复。
        require(balances[msg.sender] &gt;= amount, &quot;Not enough tokens&quot;);

        // 转移金额。
        balances[msg.sender] -= amount;
        balances[to] += amount;

        // 将转移通知链下应用程序。
        emit Transfer(msg.sender, to, amount);
    }

    /**
     * 只读函数，用于检索给定账户的token余额。
     * 这个 `view` 修饰符表明它不能修改合约的状态，它允许我们不需要执行一个交易而调用它。
     */
    function balanceOf(address account) external view returns (uint256) {
        return balances[account];
    }
}
</code></pre>
<p>:::提示</p>
<p><code>*.sol</code> 是Solidity合约文件的后缀。我们建议将文件名与其包含的合约名保持一致，这是一种常见的做法。</p>
<p>:::</p>
<h3 id="编译智能合约"><a class="header" href="#编译智能合约">编译智能合约</a></h3>
<p>要编译合约，可在你的终端中运行 <code>npx hardhat compile</code>。<code>compile</code> 任务是内置任务之一。</p>
<pre><code>$ npx hardhat compile
Compiling 1 file with 0.8.9
Compilation finished successfully
</code></pre>
<p>这个合约已经成功编译了，它可以准备被使用了。</p>
<h2 id="5-测试合约"><a class="header" href="#5-测试合约">5. 测试合约</a></h2>
<p>在构建智能合约时编写自动化测试是至关重要的，因为这关系到用户的钱。</p>
<p>为了测试我们的合约，我们将使用 Hardhat Network，这是一个为开发而设计的本地以太坊网络。它内置在 Hardhat 中，被用作默认网络。使用它不需要设置任何东西。</p>
<p>在我们的测试中，我将使用 <a href="https://docs.ethers.io/v5/">ethers.js</a> 与我们在上一节中构建的以太坊合约进行交互，并且我们将使用 <a href="https://mochajs.org/">Mocha</a> 作为我们的测试运行者。</p>
<h3 id="编写测试"><a class="header" href="#编写测试">编写测试</a></h3>
<p>在项目根目录中创建一个名为 <code>test</code> 的新目录，并在其中创建一个名为 <code>Token.js</code> 的新文件。</p>
<p>让我们从下面的代码开始。接下来我们将解释它，但现在将其粘贴到 <code>Token.js</code> 中：</p>
<pre><code class="language-js">const { expect } = require(&quot;chai&quot;);

describe(&quot;Token contract&quot;, function () {
  it(&quot;Deployment should assign the total supply of tokens to the owner&quot;, async function () {
    const [owner] = await ethers.getSigners();

    const Token = await ethers.getContractFactory(&quot;Token&quot;);

    const hardhatToken = await Token.deploy();

    const ownerBalance = await hardhatToken.balanceOf(owner.address);
    expect(await hardhatToken.totalSupply()).to.equal(ownerBalance);
  });
});
</code></pre>
<p>在你的终端中运行 <code>npx hardhat test</code>。你应该会看到如下的输出：</p>
<pre><code>$ npx hardhat test

  Token contract
    ✓ Deployment should assign the total supply of tokens to the owner (654ms)


  1 passing (663ms)
</code></pre>
<p>这意味着测试通过了。现在让我们解释每一行代码：</p>
<pre><code class="language-js">const [owner] = await ethers.getSigners();
</code></pre>
<p>ethers.js 中的 <code>Signer</code> 是代表以太坊帐户的对象。它被用于向合约和其他账户发送交易。这里我们得到连接到了节点上的账户列表，在本例中是 Hardhat Network，我们只保留第一个。</p>
<p><code>ethers</code> 变量在全局作用域中可用。如果你希望你的代码总是显式的，你可以在顶部添加这一行：</p>
<pre><code class="language-js">const { ethers } = require(&quot;hardhat&quot;);
</code></pre>
<p>:::提示</p>
<p>要学习更多关于 <code>Signer</code> 的内容，你可以查看 <a href="https://docs.ethers.io/v5/api/signer/">Signers 文档</a>。</p>
<p>:::</p>
<pre><code class="language-js">const Token = await ethers.getContractFactory(&quot;Token&quot;);
</code></pre>
<p>ethers.js 中的 <code>ContractFactory</code> 是一个用于部署新智能合约的抽象，因此这里的 <code>Token</code> 是 token 合约实例的工厂。</p>
<pre><code class="language-js">const hardhatToken = await Token.deploy();
</code></pre>
<p>在 <code>ContractFactory</code> 上调用 <code>deploy()</code> 将启动部署，并且返回一个解决为 <code>Contract</code> 的 <code>Promise</code>。这个对象为每个智能合约函数都提供了一个方法。</p>
<pre><code class="language-js">const ownerBalance = await hardhatToken.balanceOf(owner.address);
</code></pre>
<p>一旦这个合约被部署后，我们可以在 <code>hardhatToken</code> 上调用我们的合约方法。这里我们通过调用合约的 <code>balanceOf()</code> 方法，获得所有者账户的余额。</p>
<p>重新调用将会获得部署 token 的帐户的全部供应总量。默认情况下，<code>ContractFactory</code> 和 <code>Contract</code> 实例连接到第一个签名者。这意味着 <code>owner</code> 变量中的帐户执行了部署，并且 <code>balanceOf()</code> 应该返回整个供应总额。</p>
<pre><code class="language-js">expect(await hardhatToken.totalSupply()).to.equal(ownerBalance);
</code></pre>
<p>这里在我们的 Solidity 代码中，我们再次使用 <code>Contract</code> 实例去调用一个智能合约函数。<code>totalSupply()</code> 返回这个 token 供应总额，并且我们将检查它是否等价于 <code>ownerBalance</code>，正如它应该的那样。</p>
<p>为此，我们使用了 <a href="https://www.chaijs.com/">Chai</a>，这是一个流行的 JavaScript 断言库。这些断言函数被叫做 &quot;matchers&quot;，我们在这里使用的是来自 <a href="https://hardhat.org/hardhat-runner/plugins/nomicfoundation-hardhat-chai-matchers"><code>@nomicfoundation/hardhat-chai-matchers</code></a> 插件，它扩展了 Chai，提供了许多用于测试智能合约的匹配器。</p>
<h4 id="使用不同的账户"><a class="header" href="#使用不同的账户">使用不同的账户</a></h4>
<p>如果你需要从默认帐户以外的其他帐户（或 ethers.js 中的 <code>Signer</code>）发送交易来测试代码，则可以在 ethers.js 的 <code>Contract</code> 中使用 <code>connect()</code> 方法来将其连接到其他帐户，像这样：</p>
<pre><code class="language-js{18}">const { expect } = require(&quot;chai&quot;);

describe(&quot;Token contract&quot;, function () {
  // ...previous test...

  it(&quot;Should transfer tokens between accounts&quot;, async function() {
    const [owner, addr1, addr2] = await ethers.getSigners();

    const Token = await ethers.getContractFactory(&quot;Token&quot;);

    const hardhatToken = await Token.deploy();

    // Transfer 50 tokens from owner to addr1
    await hardhatToken.transfer(addr1.address, 50);
    expect(await hardhatToken.balanceOf(addr1.address)).to.equal(50);

    // Transfer 50 tokens from addr1 to addr2
    await hardhatToken.connect(addr1).transfer(addr2.address, 50);
    expect(await hardhatToken.balanceOf(addr2.address)).to.equal(50);
  });
});
</code></pre>
<h4 id="使用fixtures复用常见的测试配置"><a class="header" href="#使用fixtures复用常见的测试配置">使用fixtures复用常见的测试配置</a></h4>
<p>我们编写的两个测试从它们的设置开始，在本例中这意味着部署 token 合约。在更复杂的项目中，此设置可能涉及多个部署和其他事务。在每个测试中都这样做意味着大量的重复代码。另外，在每个测试开始时执行许多事务会使测试套件变得更慢。</p>
<p>通过使用 <strong>fixtures</strong>，你可以避免代码重复并提高测试套件的性能。fixture 是只在第一次调用时运行的设置函数。在随后的调用中，Hardhat 不会重新运行它，而是将网络的状态重置为 fixture 最初执行后的状态。</p>
<pre><code class="language-js">const { loadFixture } = require(&quot;@nomicfoundation/hardhat-network-helpers&quot;);
const { expect } = require(&quot;chai&quot;);

describe(&quot;Token contract&quot;, function () {
  async function deployTokenFixture() {
    const Token = await ethers.getContractFactory(&quot;Token&quot;);
    const [owner, addr1, addr2] = await ethers.getSigners();

    const hardhatToken = await Token.deploy();

    await hardhatToken.deployed();

    // Fixtures can return anything you consider useful for your tests
    return { Token, hardhatToken, owner, addr1, addr2 };
  }

  it(&quot;Should assign the total supply of tokens to the owner&quot;, async function () {
    const { hardhatToken, owner } = await loadFixture(deployTokenFixture);

    const ownerBalance = await hardhatToken.balanceOf(owner.address);
    expect(await hardhatToken.totalSupply()).to.equal(ownerBalance);
  });

  it(&quot;Should transfer tokens between accounts&quot;, async function () {
    const { hardhatToken, owner, addr1, addr2 } = await loadFixture(
      deployTokenFixture
    );

    // Transfer 50 tokens from owner to addr1
    await expect(
      hardhatToken.transfer(addr1.address, 50)
    ).to.changeTokenBalances(hardhatToken, [owner, addr1], [-50, 50]);

    // Transfer 50 tokens from addr1 to addr2
    // We use .connect(signer) to send a transaction from another account
    await expect(
      hardhatToken.connect(addr1).transfer(addr2.address, 50)
    ).to.changeTokenBalances(hardhatToken, [addr1, addr2], [-50, 50]);
  });
});
</code></pre>
<p>在这里，我们编写了一个 <code>deployTokenFixture</code> 函数，该函数执行必要的设置并返回稍后在测试中使用的每个值。然后在每个测试中，我们使用 <code>loadFixture</code> 来运行 fixture 并获取这些值。<code>loadFixture</code> 将在第一次运行设置，并在其他测试中迅速返回到该状态。</p>
<h4 id="完整的测试覆盖"><a class="header" href="#完整的测试覆盖">完整的测试覆盖</a></h4>
<p>现在我们已经介绍了测试合约所需的基本知识，下面是 token 的完整测试套件，其中包含大量关于 Mocha 以及如何组织测试的附加信息。我们建议你仔细阅读。</p>
<pre><code class="language-js">// This is an example test file. Hardhat will run every *.js file in `test/`,
// so feel free to add new ones.

// Hardhat tests are normally written with Mocha and Chai.

// We import Chai to use its asserting functions here.
const { expect } = require(&quot;chai&quot;);

// We use `loadFixture` to share common setups (or fixtures) between tests.
// Using this simplifies your tests and makes them run faster, by taking
// advantage of Hardhat Network's snapshot functionality.
const { loadFixture } = require(&quot;@nomicfoundation/hardhat-network-helpers&quot;);

// `describe` is a Mocha function that allows you to organize your tests.
// Having your tests organized makes debugging them easier. All Mocha
// functions are available in the global scope.
//
// `describe` receives the name of a section of your test suite, and a
// callback. The callback must define the tests of that section. This callback
// can't be an async function.
describe(&quot;Token contract&quot;, function () {
  // We define a fixture to reuse the same setup in every test. We use
  // loadFixture to run this setup once, snapshot that state, and reset Hardhat
  // Network to that snapshot in every test.
  async function deployTokenFixture() {
    // Get the ContractFactory and Signers here.
    const Token = await ethers.getContractFactory(&quot;Token&quot;);
    const [owner, addr1, addr2] = await ethers.getSigners();

    // To deploy our contract, we just have to call Token.deploy() and await
    // its deployed() method, which happens once its transaction has been
    // mined.
    const hardhatToken = await Token.deploy();

    await hardhatToken.deployed();

    // Fixtures can return anything you consider useful for your tests
    return { Token, hardhatToken, owner, addr1, addr2 };
  }

  // You can nest describe calls to create subsections.
  describe(&quot;Deployment&quot;, function () {
    // `it` is another Mocha function. This is the one you use to define each
    // of your tests. It receives the test name, and a callback function.
    //
    // If the callback function is async, Mocha will `await` it.
    it(&quot;Should set the right owner&quot;, async function () {
      // We use loadFixture to setup our environment, and then assert that
      // things went well
      const { hardhatToken, owner } = await loadFixture(deployTokenFixture);

      // `expect` receives a value and wraps it in an assertion object. These
      // objects have a lot of utility methods to assert values.

      // This test expects the owner variable stored in the contract to be
      // equal to our Signer's owner.
      expect(await hardhatToken.owner()).to.equal(owner.address);
    });

    it(&quot;Should assign the total supply of tokens to the owner&quot;, async function () {
      const { hardhatToken, owner } = await loadFixture(deployTokenFixture);
      const ownerBalance = await hardhatToken.balanceOf(owner.address);
      expect(await hardhatToken.totalSupply()).to.equal(ownerBalance);
    });
  });

  describe(&quot;Transactions&quot;, function () {
    it(&quot;Should transfer tokens between accounts&quot;, async function () {
      const { hardhatToken, owner, addr1, addr2 } = await loadFixture(
        deployTokenFixture
      );
      // Transfer 50 tokens from owner to addr1
      await expect(
        hardhatToken.transfer(addr1.address, 50)
      ).to.changeTokenBalances(hardhatToken, [owner, addr1], [-50, 50]);

      // Transfer 50 tokens from addr1 to addr2
      // We use .connect(signer) to send a transaction from another account
      await expect(
        hardhatToken.connect(addr1).transfer(addr2.address, 50)
      ).to.changeTokenBalances(hardhatToken, [addr1, addr2], [-50, 50]);
    });

    it(&quot;should emit Transfer events&quot;, async function () {
      const { hardhatToken, owner, addr1, addr2 } = await loadFixture(
        deployTokenFixture
      );

      // Transfer 50 tokens from owner to addr1
      await expect(hardhatToken.transfer(addr1.address, 50))
        .to.emit(hardhatToken, &quot;Transfer&quot;)
        .withArgs(owner.address, addr1.address, 50);

      // Transfer 50 tokens from addr1 to addr2
      // We use .connect(signer) to send a transaction from another account
      await expect(hardhatToken.connect(addr1).transfer(addr2.address, 50))
        .to.emit(hardhatToken, &quot;Transfer&quot;)
        .withArgs(addr1.address, addr2.address, 50);
    });

    it(&quot;Should fail if sender doesn't have enough tokens&quot;, async function () {
      const { hardhatToken, owner, addr1 } = await loadFixture(
        deployTokenFixture
      );
      const initialOwnerBalance = await hardhatToken.balanceOf(owner.address);

      // Try to send 1 token from addr1 (0 tokens) to owner.
      // `require` will evaluate false and revert the transaction.
      await expect(
        hardhatToken.connect(addr1).transfer(owner.address, 1)
      ).to.be.revertedWith(&quot;Not enough tokens&quot;);

      // Owner balance shouldn't have changed.
      expect(await hardhatToken.balanceOf(owner.address)).to.equal(
        initialOwnerBalance
      );
    });
  });
});
</code></pre>
<p>这是针对完整测试套件的 <code>npx hardhat test</code> 的输出：</p>
<pre><code>$ npx hardhat test

  Token contract
    Deployment
      ✓ Should set the right owner
      ✓ Should assign the total supply of tokens to the owner
    Transactions
      ✓ Should transfer tokens between accounts (199ms)
      ✓ Should fail if sender doesn’t have enough tokens
      ✓ Should update balances after transfers (111ms)


  5 passing (1s)
</code></pre>
<p>请记住，当你运行 <code>npx hardhat test</code> 时，如果自上次运行测试以来合约发生了更改，则会自动编译它们。</p>
<h2 id="6-使用hardhat网络进行调试"><a class="header" href="#6-使用hardhat网络进行调试">6. 使用Hardhat网络进行调试</a></h2>
<p>Hardhat 内置了 Hardhat 网络，这是一个专为开发设计的以太坊网络。它允许你部署合约，运行测试和调试代码，所有这些都在本地机器的范围内。它是 Hardhat 所连接的默认网络，因此你无需任何设置即可工作。你只需运行测试就好。</p>
<h2 id="solidity-consolelog"><a class="header" href="#solidity-consolelog">Solidity <code>console.log</code></a></h2>
<p>在 Hardhat 网络上运行合约和测试时，你可以在 Solidity 代码中调用 <code>console.log()</code> 打印日志信息和合约变量。你必须先从合约代码中导入 <code>hardhat/console.sol</code> 再使用它。</p>
<p>就像这样：</p>
<pre><code class="language-solidity{3}">pragma solidity ^0.8.9;

import &quot;hardhat/console.sol&quot;;

contract Token {
  //...
}
</code></pre>
<p>就像在 JavaScript 中使用一样，然后你只需在 <code>transfer()</code> 函数中添加一些 <code>console.log</code> 调用：</p>
<pre><code class="language-solidity{4-9}">function transfer(address to, uint256 amount) external {
    require(balances[msg.sender] &gt;= amount, &quot;Not enough tokens&quot;);

    console.log(
        &quot;Transferring from %s to %s %s tokens&quot;,
        msg.sender,
        to,
        amount
    );

    balances[msg.sender] -= amount;
    balances[to] += amount;

    emit Transfer(msg.sender, to, amount);
}
</code></pre>
<p>运行测试时将显示日志输出：</p>
<pre><code class="language-markup{8-11 14-17}">$ npx hardhat test

  Token contract
    Deployment
      ✓ Should set the right owner
      ✓ Should assign the total supply of tokens to the owner
    Transactions
Transferring from 0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266 to 0x70997970c51812dc3a010c7d01b50e0d17dc79c8 50 tokens
Transferring from 0x70997970c51812dc3a010c7d01b50e0d17dc79c8 to 0x3c44cdddb6a900fa2b585dd299e03d12fa4293bc 50 tokens
      ✓ Should transfer tokens between accounts (373ms)
      ✓ Should fail if sender doesn’t have enough tokens
Transferring from 0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266 to 0x70997970c51812dc3a010c7d01b50e0d17dc79c8 50 tokens
Transferring from 0x70997970c51812dc3a010c7d01b50e0d17dc79c8 to 0x3c44cdddb6a900fa2b585dd299e03d12fa4293bc 50 tokens
      ✓ Should update balances after transfers (187ms)


  5 passing (2s)
</code></pre>
<p>查看<a href="https://hardhat.org/hardhat-network/docs/overview#console.log">文档</a>以了解更多关于该特性的信息。</p>
<h2 id="7-部署到真实网络"><a class="header" href="#7-部署到真实网络">7. 部署到真实网络</a></h2>
<p>一旦你准备好与其他人分享 dApp 后，你可能要做的就是将其部署到一个真实的以太坊网络中。这样，其他人就可以访问不在本地系统上运行的实例了。</p>
<p>具有处理真实金钱的以太坊网络被称为“主网”，然后还有一些独立的“测试网”可以使用。这些测试网提供了共享的登录环境，可以很好地模拟真实世界的场景，而不需要投入真正的金钱，这里有几个<a href="https://ethereum.org/zh/developers/docs/networks/#ethereum-testnets">以太坊测试网</a>，像 <em>Goerli</em> 和 <em>Sepolia</em>。我们推荐你部署你的合约到 <em>Goerli</em> 测试网。</p>
<p>在软件级别，部署到测试网与部署到主网相同。唯一的区别是你连接到的哪个网络。让我们看看使用 ether.js 部署合约的代码是什么样的。</p>
<p>使用的主要概念是 <code>Signer</code>、<code>ContractFactory</code> 和 <code>Contract</code>，我们在<a href="blockchain/chapter_1_3_3.html#5-%E6%B5%8B%E8%AF%95%E5%90%88%E7%BA%A6">测试</a>部分中对此进行了解释。与测试相比，没有什么新东西需要做，因为当你测试合约时，实际上是在向开发网络进行部署。这使得代码非常相似，甚至完全相同。</p>
<p>让我们在项目根目录中创建一个新的目录 <code>scripts</code>，并将以下内容粘贴到该目录中的 <code>deploy.js</code> 文件中：</p>
<pre><code class="language-js">async function main() {
  const [deployer] = await ethers.getSigners();

  console.log(&quot;Deploying contracts with the account:&quot;, deployer.address);

  console.log(&quot;Account balance:&quot;, (await deployer.getBalance()).toString());

  const Token = await ethers.getContractFactory(&quot;Token&quot;);
  const token = await Token.deploy();

  console.log(&quot;Token address:&quot;, token.address);
}

main()
  .then(() =&gt; process.exit(0))
  .catch((error) =&gt; {
    console.error(error);
    process.exit(1);
  });
</code></pre>
<p>要告诉 Hardhat 连接到特定的以太坊网络，可以在运行任何任务时使用 <code>--network</code> 参数，如下所示</p>
<pre><code>npx hardhat run scripts/deploy.js --network &lt;network-name&gt;
</code></pre>
<p>对于我们当前的配置，在没有 <code>--network</code> 参数的情况下运行它将导致代码针对 Hardhat 网络的嵌入式实例运行。在这种情况下，当 Hardhat 完成运行时，部署实际上会丢失，但测试我们的部署代码是否有效仍然很有用：</p>
<pre><code>$ npx hardhat run scripts/deploy.js
Deploying contracts with the account: 0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266
Account balance: 10000000000000000000000
Token address: 0x5FbDB2315678afecb367f032d93F642f64180aa3
</code></pre>
<h2 id="部署到远程网络"><a class="header" href="#部署到远程网络">部署到远程网络</a></h2>
<p>要部署到诸如主网或任何测试网之类的远程网络，你需要添加一个 <code>network</code> 入口到你的 <code>hardhat.config.js</code> 文件中。在这个例子中，我们将使用 Goerli，但是你也可以添加任何类似的网络：</p>
<pre><code class="language-js{5 11 15-20}">require(&quot;@nomicfoundation/hardhat-toolbox&quot;);

// Go to https://www.alchemyapi.io, sign up, create
// a new App in its dashboard, and replace &quot;KEY&quot; with its key
const ALCHEMY_API_KEY = &quot;KEY&quot;;

// Replace this private key with your Goerli account private key
// To export your private key from Metamask, open Metamask and
// go to Account Details &gt; Export Private Key
// Beware: NEVER put real Ether into testing accounts
const GOERLI_PRIVATE_KEY = &quot;YOUR GOERLI PRIVATE KEY&quot;;

module.exports = {
  solidity: &quot;0.8.9&quot;,
  networks: {
    goerli: {
      url: `https://eth-goerli.alchemyapi.io/v2/${ALCHEMY_API_KEY}`,
      accounts: [GOERLI_PRIVATE_KEY]
    }
  }
};
</code></pre>
<p>我们使用了 <a href="https://www.alchemyapi.io">Alchemy</a>, 但是你将 <code>url</code> 指向其他任何以太坊节点或网关都是可以的。请填入你自己的 <code>ALCHEMY_API_KEY</code>。</p>
<p>要在 Goerli 上进行部署，你需要发送一些 Goerli ether 给将要进行部署的地址。你可以从水龙头获得测试网以太，这是一项免费分发测试 ETH 的服务。下面这些是给 Goerli 的：</p>
<ul>
<li><a href="https://faucets.chain.link/">Chainlink faucet</a></li>
<li><a href="https://goerlifaucet.com/">Alchemy Goerli Faucet</a></li>
</ul>
<p>你必须在交易前将 Metamask 的网络更改为 Goerli。</p>
<p>:::提示</p>
<p>你可以在 <a href="https://ethereum.org/zh/developers/docs/networks/#ethereum-testnets">ethereum.org</a> 网站上了解更多关于其他测试网的信息，并找到它们的水龙头链接。</p>
<p>:::</p>
<p>最终，运行：</p>
<pre><code>npx hardhat run scripts/deploy.js --network goerli
</code></pre>
<p>如果一切正常，你应该会看到部署的合约地址。</p>
<h2 id="8-前端模板项目"><a class="header" href="#8-前端模板项目">8. 前端模板项目</a></h2>
<p>如果你想要快速开始使用 dApp 或使用前端查看整个项目，可以使用我们的 <a href="https://github.com/NomicFoundation/hardhat-boilerplate">boilerplate 库</a>。</p>
<h2 id="包含哪些内容"><a class="header" href="#包含哪些内容">包含哪些内容</a></h2>
<ul>
<li>本次教程中我们使用的 Solidity 合约</li>
<li>测试合约的整个功能</li>
<li>使用 ethers.js 与合约进行交互的最小 React 前端</li>
</ul>
<h3 id="solidity合约与测试"><a class="header" href="#solidity合约与测试">Solidity合约与测试</a></h3>
<p>在代码库的根目录中，你将找到我们通过本教程与 <code>Token</code> 合约组合在一起的 Hardhat 项目。</p>
<ul>
<li>token 的总供应量是固定的，不能更改。</li>
<li>整个供应被分配给部署合约的地址。</li>
<li>任何人都可以接收 token。</li>
<li>任何人至少有一个 token 都可以转让 token。</li>
<li>这个 token 是不可以分割的。你可以转让1、2、3或37个代币，但不能转让2.5个。</li>
</ul>
<h3 id="前端app"><a class="header" href="#前端app">前端app</a></h3>
<p>在 <code>frontend</code> 你会发现一个简单的 app，允许用户做两件事：</p>
<ul>
<li>检查连接钱包的余额</li>
<li>发送 token 到一个地址</li>
</ul>
<p>它是一个独立的 npm 项目，它是用 <code>create-react-app</code> 创建的，这意味着它使用了 webpack 和 babel。</p>
<h3 id="前端文件目录结构"><a class="header" href="#前端文件目录结构">前端文件目录结构</a></h3>
<ul>
<li><code>src/</code> 包含了所有代码
<ul>
<li><code>src/components</code> 包含了 react 组件
<ul>
<li><code>Dapp.js</code> 是唯一具有业务逻辑的文件。如果你把它用作为模板，可在此处用自己的代码替换它。</li>
<li>其他组件仅渲染HTML，没有逻辑。</li>
<li><code>src/contracts</code> 具有合约的 ABI 和地址，这些由部署脚本自动生成。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="如何使用它"><a class="header" href="#如何使用它">如何使用它</a></h2>
<p>首先克隆代码库，然后准备部署合约：</p>
<pre><code>cd hardhat-boilerplate
npm install
npx hardhat node
</code></pre>
<p>在这里，我们仅需要安装 npm 项目的依赖项，然后运行 <code>npx hardhat node</code> 启动一个可以供 MetaMask 连接的 Hardhat 网络。在同一目录下的另一个终端中运行如下命令：</p>
<pre><code>npx hardhat --network localhost run scripts/deploy.js
</code></pre>
<p>这会将合约部署到 Hardhat 网络。完成后，启动 react web app：</p>
<pre><code>cd frontend
npm install
npm run start
</code></pre>
<p>然后在你的浏览器中打开 <a href="http://127.0.0.1:3000/">http://127.0.0.1:3000/</a>，你应该会看到如下所示：
<img src="https://awesomeprogram.gitee.io/imgdata/tech_bc_hardfront-5.png" alt="" /></p>
<p>将 MetaMask 中的网络设置为 <code>127.0.0.1:8545</code>。</p>
<p>现在点击 web app 的按钮。你应该会看到如下所示：
<img src="https://awesomeprogram.gitee.io/imgdata/tech_bc_hardfront-2.png" alt="" /></p>
<p>这里发生的情况是，显示当前钱包余额，前端代码检测到余额为 <code>0</code>，因此你无法尝试转账功能。通过运行如下命令：</p>
<pre><code>npx hardhat --network localhost faucet &lt;your address&gt;
</code></pre>
<p>你将运行我们包含的自定义 Hardhat 任务，该任务使用部署帐户的余额向你的地址发送100个MHT和1个ETH。这将允许你向另一个地址发送 token。</p>
<p>你可以在 <a href="https://github.com/NomicFoundation/hardhat-boilerplate/blob/master/tasks/faucet.js"><code>/tasks/faucet.js</code></a> 查看该任务的代码，这是从 <code>hardhat.config.js</code> 中需要的。</p>
<pre><code>$ npx hardhat --network localhost faucet 0x0987a41e73e69f60c5071ce3c8f7e730f9a60f90
Transferred 1 ETH and 100 tokens to 0x0987a41e73e69f60c5071ce3c8f7e730f9a60f90
</code></pre>
<p>在运行 <code>npx hardhat node</code> 的终端中，你还应该看到：</p>
<pre><code class="language-markup{10-11}">eth_sendTransaction
  Contract call:       Token#transfer
  Transaction:         0x460526d98b86f7886cd0f218d6618c96d27de7c745462ff8141973253e89b7d4
  From:                0xc783df8a850f42e7f7e57013759c285caa701eb6
  To:                  0x7c2c195cd6d34b8f845992d380aadb2730bb9c6f
  Value:               0 ETH
  Gas used:            37098 of 185490
  Block #8:            0x6b6cd29029b31f30158bfbd12faf2c4ac4263068fd12b6130f5655e70d1bc257

  console.log:
    Transferring from 0xc783df8a850f42e7f7e57013759c285caa701eb6 to 0x0987a41e73e69f60c5071ce3c8f7e730f9a60f90 100 tokens
</code></pre>
<p>在我们的合约中显示 <code>transfer()</code> 函数的 <code>console.log</code> 输出，这就是运行水龙头任务后 web app 的样子：
<img src="https://awesomeprogram.gitee.io/imgdata/tech_bc_hardfront-6.png" alt="" /></p>
<p>尝试使用它并阅读代码。它充满了注释，解释了发生了什么，并清楚地指出什么是以太坊 boilerplate 代码，什么是 dApp 逻辑。这将使代码库易于为你的项目复用。</p>
<h2 id="9-最后的想法"><a class="header" href="#9-最后的想法">9. 最后的想法</a></h2>
<p>恭喜你完成本教程！</p>
<p>这里有一些链接，你可能会发现在你的 dApp 开发旅程中有用：</p>
<ul>
<li><a href="https://github.com/NomicFoundation/hardhat-boilerplate">Hardhat's Boilerplate</a></li>
<li><a href="https://hardhat.org/docs">Hardhat's documentation site</a></li>
<li><a href="https://hardhat.org/hardhat-runner/plugins/nomicfoundation-hardhat-toolbox">Hardhat Toolbox's documenation</a></li>
<li><a href="https://discord.com/invite/TETZs2KK4k">Hardhat Support Discord server</a></li>
<li><a href="https://docs.ethers.io/">Ethers.js Documentation</a></li>
<li><a href="https://mochajs.org/">Mocha Documentation</a></li>
<li><a href="https://www.chaijs.com/">Chai Documentation</a></li>
</ul>
<p>Happy hacking!</p>
<p><img src="https://awesomeprogram.gitee.io/imgdata/tech_bc_hardcool.svg" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><p><img src="https://awesomeprogram.gitee.io/imgdata/techs/202207061914193.png" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><p><img src="https://awesomeprogram.gitee.io/imgdata/techs/202207061914193.png" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><p><img src="https://awesomeprogram.gitee.io/imgdata/techs/202207061914193.png" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><p><img src="https://awesomeprogram.gitee.io/imgdata/techs/202207061914193.png" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><p><img src="https://awesomeprogram.gitee.io/imgdata/techs/202207061914193.png" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><p><img src="https://awesomeprogram.gitee.io/imgdata/techs/202207061914193.png" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="隐私计算技术"><a class="header" href="#隐私计算技术">隐私计算技术</a></h1>
<h2 id="一句话概念解释"><a class="header" href="#一句话概念解释">一句话概念解释</a></h2>
<ul>
<li>零知识证明（Zero—Knowledge Proof）：指证明者能够在不向验证者提供任何有用的信息的情况下，使验证者相信某个论断是正确的。</li>
<li>MPC（Secure Multi-Party Computation）：用于解决一组互不信任的参与方各自持有秘密数据，协同计算一个既定函数的问题。</li>
<li>差分隐私（Differential privacy，DP）：是密码学中的一种手段，旨在提供一种当从统计数据库查询时，最大化数据查询的准确性，同时最大限度减少识别其记录的机会。</li>
<li>秘密共享：一种将秘密分割存储的密码技术，怎样更好的设计拆分和恢复，阻止秘密过于集中。</li>
<li>同态加密（Homomorphic Encryption）：同态加密是基于数学难题的计算复杂性理论的密码学技术。对经过同态加密的数据进行处理得到一个输出，将这一输出进行解密，其结果与用同一方法处理未加密的原始数据得到的输出结果是一样的。</li>
<li>可信执行环境（Trusted execution environment，TEE）：intel SGX、arm TrustZone、 amd SEV、TPM、HSM等技术实现。</li>
<li>联邦学习（Federated Learning）：是一种分布式机器学习技术 [1]  ，其核心思想是通过在多个拥有本地数据的数据源之间进行分布式模型训练，在不需要交换本地个体或样本数据的前提下，仅通过交换模型参数或中间结果的方式，构建基于虚拟融合数据下的全局模型，从而实现数据隐私保护和数据共享计算的平衡，即“数据可用不可见”、“数据不动模型动”。</li>
</ul>
<h2 id="目录-3"><a class="header" href="#目录-3">目录</a></h2>
<ul>
<li><a href="privacy/./chapter_1_1.html">密码学相关</a>
<ul>
<li><a href="privacy/./chapter_1_1_1.html">零知识证明</a></li>
<li><a href="privacy/./chapter_1_1_2.html">MPC</a></li>
<li><a href="privacy/./chapter_1_1_3.html">差分隐私</a></li>
<li><a href="privacy/./chapter_1_1_4.html">秘密共享</a></li>
<li><a href="privacy/./chapter_1_1_5.html">同态加密</a></li>
</ul>
</li>
<li><a href="privacy/./chapter_1_2.html">可信执行环境</a></li>
<li><a href="privacy/./chapter_1_3.html">联邦学习</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><p><img src="https://awesomeprogram.gitee.io/imgdata/techs/202207061914193.png" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><p><img src="https://awesomeprogram.gitee.io/imgdata/techs/202207061914193.png" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><p><img src="https://awesomeprogram.gitee.io/imgdata/techs/202207061914193.png" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><p><img src="https://awesomeprogram.gitee.io/imgdata/techs/202207061914193.png" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><p><img src="https://awesomeprogram.gitee.io/imgdata/techs/202207061914193.png" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="量子计算"><a class="header" href="#量子计算">量子计算</a></h1>
<h2 id="目录-4"><a class="header" href="#目录-4">目录</a></h2>
<ul>
<li><a href="quantum/./chapter_1_1.html">量子状态与量子比特</a></li>
<li><a href="quantum/./chapter_1_2.html">多量子比特与量子纠缠</a></li>
<li><a href="quantum/./chapter_1_3.html">量子协议和量子算法</a></li>
<li><a href="quantum/./chapter_1_4.html">量子算法的应用</a></li>
<li><a href="quantum/./chapter_1_5.html">使用量子电路研究量子硬件</a></li>
<li><a href="quantum/./chapter_1_6.html">使用微波脉冲研究量子硬件</a></li>
<li><a href="quantum/./chapter_1_7.html">量子计算实验室</a></li>
<li><a href="quantum/./chapter_1_8.html">量子计算游戏和演示</a></li>
<li><a href="quantum/./chapter_1_9.html">量子计算应用开发</a></li>
</ul>
<h2 id="量子计算入门"><a class="header" href="#量子计算入门">量子计算入门</a></h2>
<h3 id="什么是量子"><a class="header" href="#什么是量子">什么是量子？</a></h3>
<p>“量子物理学”是一个广泛使用但鲜为人知的术语。它是一种数学模型，最初用于描述实验室中小物体的行为，它暴露了先前“经典”物理学理论的空白。量子理论解释了这种行为，并为我们提供了更完整的宇宙图景。我们已经意识到我们可以使用这种以前无法解释的行为来执行我们以前认为不可能的某些计算。我们称之为量子计算。</p>
<p>量子计算是让您的可以深入了解量子物理学的完美方式。它将量子物理学的核心概念提炼成最简单的形式，去除了物理世界的复杂性。本节将带您踏上发现（并解释！）一些奇怪的量子现象的短途旅程，并让您领略什么是“量子”。</p>
<h3 id="经典概率回顾"><a class="header" href="#经典概率回顾">经典概率回顾</a></h3>
<p>为了涵盖量子现象，我们需要首先提醒自己“经典”概率。从这个意义上说，“经典”只是指前量子，即你应该在学校看到的正态概率树。如果您已经熟悉此材料，则应快速浏览它。如果您对此不是很感兴趣，那么请不要担心——我们只会涵盖一些最简单的概率问题。</p>
<h4 id="概率树"><a class="header" href="#概率树">概率树</a></h4>
<p>希望您会记住学校的概率树。这个想法很简单——我们用一张图画出每一种可能发生的情况，然后我们可以计算出它发生的可能性。</p>
<p>假设我们有一枚硬币，首先，我们将它放在手中。如果我们随后抛掷这枚公平的硬币并观察它，我们有 50% 的机会再次看到正面，而有 50% 的机会看到反面。我们可以像这样在概率树上绘制它：</p>
<p><img src="https://awesomeprogram.gitee.io/imgdata/tech_quan_whatis1.png" alt="" /></p>
<p>我们在每个分支的末尾绘制结果，并在分支上绘制每次出现的概率。同样，如果我们从反面状态开始并抛硬币，我们将有 50% 的机会看到正面，50% 的机会看到反面。</p>
<p><img src="https://awesomeprogram.gitee.io/imgdata/tech_quan_whatis2.png" alt="" /></p>
<p>我们可以通过尝试来测试它是否有效。你可以物理地拿出一枚硬币，抛多次，并记录每个结果；您最终会看到大约 50% 的结果是正面，50% 是反面。大约 500 到 1000 次抛掷应该足以获得可靠的结果。</p>
<h4 id="更进一步"><a class="header" href="#更进一步">更进一步</a></h4>
<p>看起来我们的概率树模型正确地预测了我们的实验结果。我们可以更进一步，将我们的概率树链接在一起，以预测事件链的结果。例如，假设我们从正面开始，抛硬币，然后再抛硬币，我们会看到什么？我们可以使用树来计算：</p>
<p><img src="https://awesomeprogram.gitee.io/imgdata/tech_quan_whatis3.png" alt="" /></p>
<p>你可能还记得在学校，我们沿着分支相乘来计算每个事件组合的概率：</p>
<p><img src="https://awesomeprogram.gitee.io/imgdata/tech_quan_whatis4.gif" alt="" /></p>
<p>然后我们将结果加在一起以计算每个结果的概率：</p>
<p><img src="https://awesomeprogram.gitee.io/imgdata/tech_quan_whatis5.gif" alt="" /></p>
<p>并且我们可以看到抛两次后看到正面的概率是 50%，抛两次之后看到反面的概率也是 50%。</p>
<p>双掷硬币也一样，经过足够多的抛掷，我们的结果符合预期：测量正面或反面的机会均等。</p>
<h3 id="量子币"><a class="header" href="#量子币">量子币</a></h3>
<p>现在我们对经典硬币有了完整的描述，是时候介绍一种量子“硬币”了。我们的量子硬币被称为“量子比特”。</p>
<p>量子比特是你只能在实验室里玩的东西，因为它们很难操纵。多年的科技进步创造了我们今天拥有的量子位，但通过量子计算学习的美妙之处在于我们可以忽略物理上的复杂性，只要记住当我们测量一个量子位时，它会是两个中的一个状态：我们称我们的量子比特的两个状态为 0 和 1，而不是两个状态 正面 和 反面。</p>
<h4 id="量子抛硬币"><a class="header" href="#量子抛硬币">量子抛硬币</a></h4>
<p>让我们试验一下我们的量子硬币，看看它的行为方式。我们将进行一次量子抛掷，测量硬币的状态并记录下来。这就像上一节中的经典抛硬币。</p>
<p>我们将尝试使用概率树来描述我们的量子硬币。这看起来像是，从 0 状态开始，抛硬币给了我们 50-50 的机会来测量 0 或 1。让我们像处理经典硬币一样在树上绘制它：</p>
<p><img src="https://awesomeprogram.gitee.io/imgdata/tech_quan_whatis6.png" alt="" /></p>
<p>类似地，从状态 1 开始，抛硬币给了我们 50-50 的机会测量到 0 或 1。概率树如下所示：</p>
<p><img src="https://awesomeprogram.gitee.io/imgdata/tech_quan_whatis7.png" alt="" /></p>
<h4 id="双量子掷硬币"><a class="header" href="#双量子掷硬币">双量子掷硬币</a></h4>
<p>我们现在有一个模型可以预测量子硬币的行为。像优秀的科学家一样，我们现在想在新的场景中测试它，看看它是否成立。让我们像以前一样尝试抛两次硬币。就像经典硬币一样，我们的量子硬币模型预测有 50-50 的机会测量 0 或 1，无论我们从哪个状态开始：</p>
<p><img src="https://awesomeprogram.gitee.io/imgdata/tech_quan_whatis8.png" alt="" /></p>
<p>所以让我们试试吧！我们将抛两次量子硬币：</p>
<p>这与我们的预测完全不符！我们的模型让我们失望了！这与物理学家在 20 世纪初遇到的问题相同。寻找答案导致了量子物理学的发展，这就是我们将用来描述我们的量子掷硬币的东西。</p>
<h3 id="量子模型"><a class="header" href="#量子模型">量子模型</a></h3>
<p>简而言之，量子论是负数的概率论。</p>
<p>这是什么意思？我们不能有负概率，因为那没有意义。为了适应这一点，我们使用了一个新的数量，我们称之为振幅，并将它们绘制在树上。为了解决我们不能有负概率以及所有概率加起来必须为 1 的事实，我们使用了一个数学技巧：我们对幅值求平方来计算概率。</p>
<p>让我们看一个例子。我们单次量子硬币抛掷的振幅树如下所示：</p>
<p><img src="https://awesomeprogram.gitee.io/imgdata/tech_quan_whatis9.png" alt="" /></p>
<p>我们可以看到，从状态 0 开始，量子掷硬币为两个结果分配了相等的振幅。当我们对这些振幅进行平方时，它们会为我们提供测量 0 或 1 的正确概率（50-50 机会）。我们怎么知道振幅是二分之一的开方？因为它们是给我们正确答案的价值观！</p>
<p>从状态 1 开始，振幅树就不同了：</p>
<p><img src="https://awesomeprogram.gitee.io/imgdata/tech_quan_whatis10.png" alt="" /></p>
<p>在这里，我们可以看到我们的第一个负数出现在 1 结果的振幅中。当我们对振幅求平方来计算概率时，这个负号消失了（记住负数乘以负数就是正数），我们看到上面测量的 50-50 的机会。有趣的结果是当我们将这些概率链接在一起时。</p>
<h3 id="解释双量子抛硬币"><a class="header" href="#解释双量子抛硬币">解释双量子抛硬币</a></h3>
<p>就像经典概率一样，我们沿着分支乘以振幅来计算每个结果的振幅：</p>
<p><img src="https://awesomeprogram.gitee.io/imgdata/tech_quan_whatis11.gif" alt="" /></p>
<p>为了计算出测量每个结果的概率，我们将这些振幅相加，然后平方：</p>
<p><img src="https://awesomeprogram.gitee.io/imgdata/tech_quan_whatis12.gif" alt="" /></p>
<p>我们可以看到在状态 1 中找硬币（量子比特）的振幅相互抵消，我们称这种效应为干扰。您应该自己验证此模型在初始状态为 1 时是否有效。</p>
<h3 id="什么是量子计算"><a class="header" href="#什么是量子计算">什么是量子计算？</a></h3>
<p>这很酷，但它有什么用呢？事实证明，这些干扰效应可以为我们所用；我们可以结合诸如量子抛硬币之类的操作来构建更高效的算法。这些算法可以利用干扰效应让错误的答案迅速抵消，让我们有很高的概率测出正确答案。这就是量子计算背后的理念。</p>
<h2 id="量子电路教程入门"><a class="header" href="#量子电路教程入门">量子电路教程入门</a></h2>
<h3 id="电路基础"><a class="header" href="#电路基础">电路基础</a></h3>
<p>在这里，我们提供了使用 Qiskit 的概述。Qiskit 提供了对量子计算机进行编程所必需的基本构建块。Qiskit 的基本单元是量子电路。使用 Qiskit 的基本工作流程包括两个阶段：构建和运行。Build 允许您生成代表您正在解决的问题的不同量子电路，而 Run 允许您在不同的后端运行它们。作业运行后，根据所需的输出收集数据并进行后处理。</p>
<pre><code>import numpy as np
from qiskit import QuantumCircuit
</code></pre>
<h4 id="构建电路"><a class="header" href="#构建电路">构建电路</a></h4>
<p>您的第一个程序所需的基本元素是 QuantumCircuit。我们首先创建一个由三个量子位组成的 <code>QuantumCircuit</code>。</p>
<pre><code># Create a Quantum Circuit acting on a quantum register of three qubits
circ = QuantumCircuit(3)
</code></pre>
<p>使用寄存器创建电路后，您可以添加门（“操作”）来操作寄存器。随着教程的进行，您会发现更多的门和电路；下面是产生三量子位 GHZ 状态的量子电路示例</p>
<p>$$|\psi\rangle = \left(|000\rangle+|111\rangle\right)/\sqrt{2}.$$</p>
<p>为了创建这样的状态，我们从一个三量子比特的量子寄存器开始。默认情况下，寄存器中的每个量子位都被初始化为 <math xmlns="http://www.w3.org/1998/Math/MathML"><mo stretchy="false">|</mo><mn>0</mn><mo fence="false" stretchy="false">⟩</mo></math>. 为了形成 GHZ 状态，我们应用以下门：</p>
<ul>
<li>一个 Hadamard 门 <em><strong>H</strong></em> 在量子位 0 上，使其进入叠加态 <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow data-mjx-texclass="INNER"><mo data-mjx-texclass="OPEN">(</mo><mrow data-mjx-texclass="ORD"><mo stretchy="false">|</mo></mrow><mn>0</mn><mo fence="false" stretchy="false">⟩</mo><mo>+</mo><mrow data-mjx-texclass="ORD"><mo stretchy="false">|</mo></mrow><mn>1</mn><mo fence="false" stretchy="false">⟩</mo><mo data-mjx-texclass="CLOSE">)</mo></mrow><mrow data-mjx-texclass="ORD"><mo>/</mo></mrow><msqrt><mn>2</mn></msqrt></math>.</li>
<li>一个 Controlled-NOT 操作 (<math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>C</mi><mrow data-mjx-texclass="ORD"><mi>X</mi></mrow></msub></math>) 在量子位 0 和量子位 1 之间。</li>
<li>量子位 0 和量子位 2 之间的一个 Controlled-NOT 操作。</li>
</ul>
<p>在理想的量子计算机上，运行该电路产生的状态将是上面的 GHZ 状态。</p>
<p>在 Qiskit 中，可以在电路中逐一添加操作，如下所示。</p>
<pre><code># Add a H gate on qubit 0, putting this qubit in superposition.
circ.h(0)
# Add a CX (CNOT) gate on control qubit 0 and target qubit 1, putting
# the qubits in a Bell state.
circ.cx(0, 1)
# Add a CX (CNOT) gate on control qubit 0 and target qubit 2, putting
# the qubits in a GHZ state.
circ.cx(0, 2)

&lt;qiskit.circuit.instructionset.InstructionSet at 0x7f12b87bddf0&gt;
</code></pre>
<h4 id="可视化电路"><a class="header" href="#可视化电路">可视化电路</a></h4>
<p>您可以使用 Qiskit 可视化您的电路 <code>QuantumCircuit.draw()</code>，它以许多教科书中的形式绘制电路。</p>
<pre><code>circ.draw('mpl')
</code></pre>
<p><img src="https://awesomeprogram.gitee.io/imgdata/tech_quan_cir7.png" alt="" /></p>
<p>在此电路中，量子位按顺序排列，量子位 0 在顶部，量子位 2 在底部。从左到右读取电路（这意味着电路中较早应用的门显示在更左侧）。</p>
<p>在表示多量子位系统的状态时，Qiskit 中使用的张量阶与大多数物理教科书中使用的不同。假设有 <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>n</mi></math> 个量子比特和 <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>j</mi></math> 个量子位被标记，则表示 <math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>Q</mi><mrow data-mjx-texclass="ORD"><mi>j</mi></mrow></msub></math>. Qiskit 使用一种排序方式 <math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>n</mi><mrow data-mjx-texclass="ORD"><mrow data-mjx-texclass="ORD"><mi data-mjx-auto-op="false">th</mi></mrow></mrow></msup></math>，其中量子比特位于张量积的左侧，因此基向量标记为 <math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>Q</mi><mrow data-mjx-texclass="ORD"><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>⊗</mo><mo>⋯</mo><mo>⊗</mo><msub><mi>Q</mi><mn>1</mn></msub><mo>⊗</mo><msub><mi>Q</mi><mn>0</mn></msub></math>.</p>
<p>例如，如果量子位 0 处于状态 0，量子位 1 处于状态 0，量子位 2 处于状态 1，Qiskit 会将此状态表示为 <math xmlns="http://www.w3.org/1998/Math/MathML"><mo stretchy="false">|</mo><mn>100</mn><mo fence="false" stretchy="false">⟩</mo></math>，而许多物理教科书将其表示为 <math xmlns="http://www.w3.org/1998/Math/MathML"><mo stretchy="false">|</mo><mn>100</mn><mo fence="false" stretchy="false">⟩</mo></math>.</p>
<p>这种标记差异会影响多量子位运算表示为矩阵的方式。例如，Qiskit 表示一个 controlled-X (<math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>C</mi><mrow data-mjx-texclass="ORD"><mi>X</mi></mrow></msub></math>) 以量子位 0 为控制，量子位 1 为目标的操作
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mtable displaystyle="true" columnalign="right" columnspacing="0em" rowspacing="3pt"><mtr><mtd><msub><mi>C</mi><mi>X</mi></msub><mo>=</mo><mrow data-mjx-texclass="INNER"><mo data-mjx-texclass="OPEN">(</mo><mtable columnalign="center" columnspacing="1em" rowspacing="4pt"><mtr><mtd><mn>1</mn></mtd><mtd><mn>0</mn></mtd><mtd><mn>0</mn></mtd><mtd><mn>0</mn></mtd></mtr><mtr><mtd><mn>0</mn></mtd><mtd><mn>0</mn></mtd><mtd><mn>0</mn></mtd><mtd><mn>1</mn></mtd></mtr><mtr><mtd><mn>0</mn></mtd><mtd><mn>0</mn></mtd><mtd><mn>1</mn></mtd><mtd><mn>0</mn></mtd></mtr><mtr><mtd><mn>0</mn></mtd><mtd><mn>1</mn></mtd><mtd><mn>0</mn></mtd><mtd><mn>0</mn></mtd></mtr></mtable><mo data-mjx-texclass="CLOSE">)</mo></mrow><mo>.</mo></mtd></mtr></mtable></math></p>
<h4 id="模拟电路"><a class="header" href="#模拟电路">模拟电路</a></h4>
<p>为了模拟电路，我们使用 Qiskit 中的 quant_info 模块。该模拟器返回量子态，这是一个复杂的维度向量 <math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mn>2</mn><mi>n</mi></msup></math>， 在哪里 <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>n</mi></math> 是量子位的数量（所以要小心使用它，因为它很快就会变得太大而无法在你的机器上运行）。</p>
<p>模拟器有两个阶段。第一个是设置输入状态，第二个是通过量子电路演化状态。</p>
<pre><code>from qiskit.quantum_info import Statevector

# Set the intial state of the simulator to the ground state using from_int
state = Statevector.from_int(0, 2**3)

# Evolve the state by the quantum circuit
state = state.evolve(circ)

#draw using latex
state.draw('latex')
</code></pre>
<p>$$\frac{\sqrt{2}}{2} |000\rangle+\frac{\sqrt{2}}{2} |111\rangle$$</p>
<pre><code>from qiskit.visualization import array_to_latex

#Alternative way of representing in latex
array_to_latex(state)
</code></pre>
<p>$$
\begin{bmatrix}
\frac{\sqrt{2}}{2} &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; \frac{\sqrt{2}}{2}  \
\end{bmatrix}
$$</p>
<p>Qiskit 还提供了一个可视化工具箱，让您可以查看状态。</p>
<p>下面，我们使用可视化函数绘制 qsphere 和表示状态密度矩阵 <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>ρ</mi></math> 的实部和虚部的 hinton。</p>
<pre><code>state.draw('qsphere')
</code></pre>
<p><img src="https://awesomeprogram.gitee.io/imgdata/tech_quan_cir14.png" alt="" /></p>
<pre><code>state.draw('hinton')
</code></pre>
<p><img src="https://awesomeprogram.gitee.io/imgdata/tech_quan_cir15.png" alt="" /></p>
<h4 id="电路的单一表示"><a class="header" href="#电路的单一表示">电路的单一表示</a></h4>
<p>Qiskit 的 quant_info 模块也有一个运算符方法，可用于为电路制作单一运算符。这计算了 <math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mn>2</mn><mi>n</mi></msup><mo>×</mo><msup><mn>2</mn><mi>n</mi></msup></math> 表示量子电路的矩阵。</p>
<pre><code>from qiskit.quantum_info import Operator

U = Operator(circ)

# Show the results
U.data

数组（[[ 0.70710678+0.j，0.70710678+0.j，0.+0.j，
         0.+0.j，0.+0.j，0.+0.j，
         0.+0.j, 0.+0.j],
       [ 0.+0.j, 0.+0.j, 0.+0.j,
         0.+0.j，0.+0.j，0.+0.j，
         0.70710678+0.j, -0.70710678+0.j],
       [ 0.+0.j, 0.+0.j, 0.70710678+0.j,
         0.70710678+0.j, 0.+0.j, 0.+0.j,
         0.+0.j, 0.+0.j],
       [ 0.+0.j, 0.+0.j, 0.+0.j,
         0.+0.j, 0.70710678+0.j, -0.70710678+0.j,
         0.+0.j, 0.+0.j],
       [ 0.+0.j, 0.+0.j, 0.+0.j,
         0.+0.j, 0.70710678+0.j, 0.70710678+0.j,
         0.+0.j, 0.+0.j],
       [ 0.+0.j, 0.+0.j, 0.70710678+0.j,
        -0.70710678+0.j, 0.+0.j, 0.+0.j,
         0.+0.j, 0.+0.j],
       [ 0.+0.j, 0.+0.j, 0.+0.j,
         0.+0.j，0.+0.j，0.+0.j，
         0.70710678+0.j, 0.70710678+0.j],
       [ 0.70710678+0.j, -0.70710678+0.j, 0.+0.j,
         0.+0.j，0.+0.j，0.+0.j，
         0.+0.j, 0.+0.j]])
</code></pre>
<h4 id="openqasm-后端"><a class="header" href="#openqasm-后端">OpenQASM 后端</a></h4>
<p>上面的模拟器很有用，因为它们提供了有关理想电路输出的状态和电路的矩阵表示的信息。然而，一个真正的实验通过测量每个量子位来终止（通常在计算 <math xmlns="http://www.w3.org/1998/Math/MathML"><mo stretchy="false">|</mo><mn>0</mn><mo fence="false" stretchy="false">⟩</mo><mo>,</mo><mrow data-mjx-texclass="ORD"><mo stretchy="false">|</mo></mrow><mn>1</mn><mo fence="false" stretchy="false">⟩</mo></math>, <math xmlns="http://www.w3.org/1998/Math/MathML"><mo stretchy="false">|</mo><mn>0</mn><mo fence="false" stretchy="false">⟩</mo><mo>,</mo><mrow data-mjx-texclass="ORD"><mo stretchy="false">|</mo></mrow><mn>1</mn><mo fence="false" stretchy="false">⟩</mo></math> 基础）。没有测量，我们就无法获得有关状态的信息。测量导致量子系统坍缩成经典比特。</p>
<p>例如，假设我们对三量子位 GHZ 状态的每个量子位进行独立测量</p>
<p>$$
|\psi\rangle = (|000\rangle +|111\rangle)/\sqrt{2},
$$</p>
<p>然后让 <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>x</mi><mi>y</mi><mi>z</mi></math> 表示结果的位串。回想一下，在 Qiskit 使用的量子位标签下，<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>x</mi></math> 将对应于 qubit 2 的结果，<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>y</mi></math> 表示 qubit 1 的结果，和 <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>z</mi></math> 表示 qubit 0 的结果。</p>
<p>注意：这种位串表示法将最高有效位 (MSB) 放在左侧，将最低有效位 (LSB) 放在右侧。这是二进制位串的标准排序。我们以相同的方式对量子位进行排序（表示 MSB 的量子位具有索引 0），这就是 Qiskit 使用非标准张量积顺序的原因。</p>
<p>回想一下，获得结果 <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>x</mi><mi>y</mi><mi>z</mi></math> 的概率由下式给出</p>
<p>$$
\mathrm{Pr}(xyz) = |\langle xyz | \psi \rangle |^{2}
$$</p>
<p>因此，获得 000 或 111 的 GHZ 状态概率均为 1/2。</p>
<p>要模拟包含测量的电路，我们需要将测量添加到上面的原始电路，并使用不同的 Aer 后端。</p>
<pre><code># Create a Quantum Circuit
meas = QuantumCircuit(3, 3)
meas.barrier(range(3))
# map the quantum measurement to the classical bits
meas.measure(range(3), range(3))

# The Qiskit circuit object supports composition.
# Here the meas has to be first and front=True (putting it before)
# as compose must put a smaller circuit into a larger one.
qc = meas.compose(circ, range(3), front=True)

#drawing the circuit
qc.draw('mpl')
</code></pre>
<p><img src="https://awesomeprogram.gitee.io/imgdata/tech_quan_cir21.png" alt="" /></p>
<p>该电路添加了一个经典寄存器和三个用于将量子位结果映射到经典位的测量值。</p>
<p>为了模拟这个电路，我们使用了 <code>qasm_simulator</code> Qiskit Aer。该电路的每次运行都会产生位串 000 或 111。要建立关于位串分布的统计数据（例如，估计 <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow data-mjx-texclass="ORD"><mi data-mjx-auto-op="false">Pr</mi></mrow><mo stretchy="false">(</mo><mn>000</mn><mo stretchy="false">)</mo></math>)，我们需要多次重复电路。电路重复的次数可以通过关键字 <code>shots</code> 在 <code>execute</code> 函数中指定。</p>
<pre><code># Adding the transpiler to reduce the circuit to QASM instructions
# supported by the backend
from qiskit import transpile

# Use AerSimulator
from qiskit_aer import AerSimulator

backend = AerSimulator()

# First we have to transpile the quantum circuit
# to the low-level QASM instructions used by the
# backend
qc_compiled = transpile(qc, backend)

# Execute the circuit on the qasm simulator.
# We've set the number of repeats of the circuit
# to be 1024, which is the default.
job_sim = backend.run(qc_compiled, shots=1024)

# Grab the results from the job.
result_sim = job_sim.result()
</code></pre>
<p>一旦你获得对象结果后，你可以通过函数 <code>get_counts(circuit)</code> 访问统计次数。这为你提供了你提交的电路的聚合二进制结果。</p>
<pre><code>counts = result_sim.get_counts(qc_compiled)
print(counts)

{'000': 486, '111': 538}
</code></pre>
<p>大约 50% 的时间，输出位串是 000。Qiskit 还提供了一个函数 <code>plot_histogram</code>，可以让你查看结果。</p>
<pre><code>from qiskit.visualization import plot_histogram
plot_histogram(counts)
</code></pre>
<p><img src="https://awesomeprogram.gitee.io/imgdata/tech_quan_cir27.png" alt="" /></p>
<p>估计 <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow data-mjx-texclass="ORD"><mi data-mjx-auto-op="false">Pr</mi></mrow><mo stretchy="false">(</mo><mn>000</mn><mo stretchy="false">)</mo></math> 和 <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow data-mjx-texclass="ORD"><mi data-mjx-auto-op="false">Pr</mi></mrow><mo stretchy="false">(</mo><mn>111</mn><mo stretchy="false">)</mo></math> 的结果概率是通过获取汇总计数并除以拍摄次数（重复电路的次数）来计算。尝试更改 <code>execute</code> 函数中的 <code>shots</code> 关键字，看看估计的概率如何变化。</p>
<pre><code>import qiskit.tools.jupyter
%qiskit_version_table
%qiskit_copyright
</code></pre>
<p><strong>Version Information</strong></p>
<table><tr><th>Qiskit Software</th><th>Version</th></tr><tr><td><code>qiskit-terra</code></td><td>0.23.1</td></tr><tr><td><code>qiskit-aer</code></td><td>0.11.2</td></tr><tr><td><code>qiskit-ibmq-provider</code></td><td>0.20.0</td></tr><tr><td><code>qiskit</code></td><td>0.41.0</td></tr><tr><td><code>qiskit-nature</code></td><td>0.5.2</td></tr><tr><td><code>qiskit-finance</code></td><td>0.3.4</td></tr><tr><td><code>qiskit-optimization</code></td><td>0.5.0</td></tr><tr><td><code>qiskit-machine-learning</code></td><td>0.5.0</td></tr><tr><th>System information</th></tr><tr><td>Python version</td><td>3.8.16</td></tr><tr><td>Python compiler</td><td>GCC 11.3.0</td></tr><tr><td>Python build</td><td>default, Jan 11 2023 00:28:51</td></tr><tr><td>OS</td><td>Linux</td></tr><tr><td>CPUs</td><td>2</td></tr><tr><td>Memory (Gb)</td><td>6.781219482421875</td></tr><tr><td colspan='2'>Fri Feb 03 18:56:55 2023 UTC</td></tr></table><div style="break-before: page; page-break-before: always;"></div><h1 id="量子状态与量子比特"><a class="header" href="#量子状态与量子比特">量子状态与量子比特</a></h1>
<h2 id="简介"><a class="header" href="#简介">简介</a></h2>
<p>如果您认为量子力学听起来很有挑战性，那么您并不孤单。我们所有的直觉都基于日常经验，因此比原子或电子更能理解球和香蕉的行为。尽管量子物体起初看起来随机且混乱，但它们只是遵循一套不同的规则。一旦我们知道这些规则是什么，我们就可以使用它们来创造新的强大技术。量子计算将是这方面最具革命性的例子。</p>
<p><img src="https://awesomeprogram.gitee.io/imgdata/tech_quan_atoms10.png" alt="" /></p>
<p>为了让您开始您的量子计算之旅，让我们测试一下您已经知道的内容。以下哪项是对 <em>bit</em> 的正确描述？</p>
<ul>
<li>木匠使用的刀片。</li>
<li>最小的信息单位：0或1。</li>
<li>你放在马嘴里的东西。</li>
</ul>
<p>实际上，它们都是正确的：这是一个非常多用途的词！但是，如果您选择了第二个，则表明您的思路已经正确。信息可以存储和处理为一系列 0 和 1 的想法是一个相当大的概念障碍，但这是今天大多数人甚至都没有考虑过的事情。以此为起点，我们可以开始想象遵守量子力学规则的比特。这些 quantum bits，或 qubits，将使我们能够以新的和不同的方式处理信息。</p>
<p>我们将开始更深入地研究量子比特的世界。为此，我们需要一些方法来跟踪我们应用门时他们在做什么。最有效的方法是使用向量和矩阵的数学语言。</p>
<p><img src="https://awesomeprogram.gitee.io/imgdata/tech_quan_bloch.png" alt="" /></p>
<p>本章对于已经熟悉向量和矩阵的读者来说最为有效。那些不熟悉的人也可能没问题，尽管不时查阅我们的<a href="https://qiskit.org/textbook/ch-appendix/linear_algebra.html">量子计算线性代数简介</a>可能会有用。</p>
<p>由于我们将使用基于 Python 的量子计算框架 Qiskit，因此了解 Python 的基础知识也很有用。需要入门的可以查阅<a href="https://qiskit.org/textbook/ch-prerequisites/python-and-jupyter-notebooks.html">Introduction to Python and Jupyter notebooks</a>。</p>
<h2 id="计算的原子"><a class="header" href="#计算的原子">计算的原子</a></h2>
<p>现在，任何人都可以在自己舒适的家中为量子计算机编程。</p>
<p>但是要创造什么？到底什么是量子程序？其实，什么是量子计算机？</p>
<p>这些问题可以通过与标准数字计算机进行比较来回答。不幸的是，大多数人实际上也不了解数字计算机的工作原理。在本文中，我们将了解这些设备背后的基本原理。为了帮助我们稍后过渡到量子计算，我们将使用与量子计算相同的工具来完成它。</p>
<p>如果我们想使用此页面中的代码，下面是我们需要运行的一些 Python 代码：</p>
<pre><code>from qiskit import QuantumCircuit, assemble, Aer
from qiskit.visualization import plot_histogram
</code></pre>
<h3 id="将信息拆分成比特"><a class="header" href="#将信息拆分成比特">将信息拆分成比特</a></h3>
<p>我们需要了解的第一件事是比特的概念。这些被设计成世界上最简单的字母表。只有两个字符，0 和 1，我们可以表示任何信息。</p>
<p>一个例子是数字。你可能习惯用0、1、2、3、4、5、6、7、8、9这十位数字的串来表示一个数，在这串数字中，每一位代表这个数的次数包含一定的十次方。例如，当我们写 9213 时，我们的意思是</p>
<p>$$
9000 + 200 + 10 + 3
$$</p>
<p>或者，以强调十的幂的方式表达</p>
<p>$$
(9\times10^3) + (2\times10^2) + (1\times10^1) + (3\times10^0)
$$</p>
<p>虽然我们通常使用基于数字 10 的系统，但我们也可以轻松地使用基于任何其他数字的系统。例如，二进制数字系统是基于数字二的。这意味着使用 0 和 1 这两个字符将数字表示为 2 的幂的倍数。例如，9213 变为 10001111111101，因为</p>
<p>$$
9213  = (1 \times 2^{13}) + (0 \times 2^{12}) + (0 \times 2^{11})+ (0 \times 2^{10}) +(1 \times 2^9) + (1 \times 2^8) + (1 \times 2^7) \\ ,,,   + (1 \times 2^6) + (1 \times 2^5) + (1 \times 2^4) + (1 \times 2^3) + (1 \times 2^2) + (0 \times 2^1) + (1 \times 2^0)
$$</p>
<p>在这里，我们将数字表示为 2、4、8、16、32 等的倍数，而不是 10、100、1000 等。</p>
<pre><code>from qiskit_textbook.widgets import binary_widget
binary_widget(nbits=5)
</code></pre>
<p>这些位串，称为二进制串，不仅可以用来表示数字。例如，有一种方法可以使用位来表示任何文本。对于您要使用的任何字母、数字或标点符号，您可以使用<a href="https://www.ibm.com/docs/en/aix/7.2?topic=adapters-ascii-decimal-hexadecimal-octal-binary-conversion-table">此表</a>找到对应的最多八位的字符串。尽管这些标准相当武断，但这是一个得到广泛认可的标准。事实上，它就是用来通过互联网向您传送这篇文章的。</p>
<p>这就是所有信息在计算机中的表示方式。无论是数字、字母、图像还是声音，都以二进制字符串的形式存在。</p>
<p>与我们的标准数字计算机一样，量子计算机也是基于同样的基本思想。主要区别在于它们使用 <em>qubits</em>，这是比特对量子力学的扩展。在本教科书的其余部分，我们将探讨什么是量子比特、它们能做什么以及它们是如何做到的。然而，在本节中，我们根本不讨论量子。所以，我们只是像使用比特一样使用量子比特。</p>
<p>快速练习 </p>
<ul>
<li>想一个数字并尝试用二进制写下来。</li>
<li>如果你有n个bit，它们可以处于多少种不同的状态？</li>
</ul>
<h3 id="以图表形式计算"><a class="header" href="#以图表形式计算">以图表形式计算</a></h3>
<p>无论我们使用的是量子比特还是经典比特，我们都需要操作它们，以便将我们拥有的输入转化为我们需要的输出。对于比特数很少的最简单程序，用称为电路图的图表来表示此过程很有用。这些在左边有输入，在右边有输出，中间有神秘符号表示的操作。这些操作被称为“门”，主要是出于历史原因。</p>
<p>下面是标准的基于位的计算机的电路示例。您不需要了解它的作用。它应该只是让您了解这些电路的外观。</p>
<p><img src="https://awesomeprogram.gitee.io/imgdata/tech_quan_classical_circuit.png" alt="" /></p>
<p>对于量子计算机，我们使用相同的基本思想，但对于如何表示输入、输出和用于运算的符号有不同的约定。这是代表与上述相同过程的量子电路。</p>
<p><img src="https://awesomeprogram.gitee.io/imgdata/tech_quan_quantum_circuit.png" alt="" /></p>
<p>在本节的其余部分，我们将解释如何构建电路。最后，您将了解如何创建上面的电路、它的作用以及它为什么有用。</p>
<h3 id="你的第一个量子电路"><a class="header" href="#你的第一个量子电路">你的第一个量子电路</a></h3>
<p>在电路中，我们通常需要做三项工作：首先，对输入进行编码，然后进行一些实际计算，最后提取输出。对于您的第一个量子电路，我们将专注于这些工作中的最后一个。我们首先创建一个具有八个量子位和八个输出的电路。</p>
<pre><code>qc_output = QuantumCircuit(8)
</code></pre>
<p>这个电路，我们称之为qc_output，是由 Qiskit 使用创建的QuantumCircuit。将QuantumCircuit量子电路中的量子比特数作为参数。</p>
<p>量子电路中输出的提取是使用称为 <code>measure_all()</code> 的操作完成的。每次测量都会告诉指定的量子位输出为指定的经典位。该命令 <code>qc_output.measure_all()</code> 向电路 <code>qc_output</code> 中的每个量子位添加一个测量值，还添加一些经典位以写入输出。</p>
<pre><code>qc_output.measure_all()
</code></pre>
<p>现在我们的电路已经有了一些东西，让我们来看看它。</p>
<pre><code>qc_output.draw(initial_state=True) 
</code></pre>
<p><img src="https://awesomeprogram.gitee.io/imgdata/tech_quan_qc1.png" alt="" /></p>
<p>量子位总是被初始化输出为0。由于我们没有对上面电路中的量子比特做任何事情，这正是我们测量它们时得到的结果。我们可以通过多次运行电路并在直方图中绘制结果来看到这一点。我们会发现每个量子比特的结果总是 00000000: a 0。</p>
<pre><code>sim = Aer.get_backend('aer_simulator') 
result = sim.run(qc_output).result()
counts = result.get_counts()
plot_histogram(counts)
</code></pre>
<p><img src="https://awesomeprogram.gitee.io/imgdata/tech_quan_qc1x.png" alt="" /></p>
<p>多次运行并将结果显示为直方图的原因是因为量子计算机的结果可能具有一些随机性。在这种情况下，由于我们没有做任何量子的事情，我们只能得到00000000的结果是确定的。</p>
<p>请注意，此结果来自量子模拟器，这是一台标准计算机，用于计算理想量子计算机的功能。模拟只能用于少量的量子位（~30 qubits），但在设计您的第一个量子电路时它们仍然是一个非常有用的工具。要在真实设备上运行，您只需替换 <code>Aer.get_backend('aer_simulator')</code> 为您要使用的设备的后端对象。</p>
<h3 id="示例创建加法器电路"><a class="header" href="#示例创建加法器电路">示例：创建加法器电路</a></h3>
<h4 id="编码一个输入"><a class="header" href="#编码一个输入">编码一个输入</a></h4>
<p>现在让我们看看如何将不同的二进制字符串编码为输入。为此，我们需要所谓的 <strong>NOT</strong> 门。这是您可以在计算机上执行的最基本的操作。它只是翻转位值：0成为1和1成为0。对于量子位，它是一个称为 X 的操作，可以完成 NOT 的作业。</p>
<p>下面我们创建一个专用于编码工作的新电路，并将其称为 qc_encode。现在，我们只指定量子位的数量。</p>
<pre><code>qc_encode = QuantumCircuit(8)
qc_encode.x(7)
qc_encode.draw()
</code></pre>
<p><img src="https://awesomeprogram.gitee.io/imgdata/tech_quan_qc2.png" alt="" /></p>
<p>可以使用我们之前的电路来提取结果：qc_output。</p>
<pre><code>qc_encode.measure_all()
qc_encode.draw()
</code></pre>
<p><img src="https://awesomeprogram.gitee.io/imgdata/tech_quan_qc3.png" alt="" /></p>
<p>现在我们可以运行组合电路并查看结果。</p>
<pre><code>sim = Aer.get_backend('aer_simulator') 
result = sim.run(qc_encode).result()
counts = result.get_counts()
plot_histogram(counts)
</code></pre>
<p><img src="https://awesomeprogram.gitee.io/imgdata/tech_quan_qc4.png" alt="" /></p>
<p>现在我们的计算机输出字符串10000000。</p>
<p>我们翻转的位来自量子位 7，位于字符串的最左侧。这是因为 Qiskit 从右到左对字符串中的位进行编号。有些人喜欢用相反的方式给他们的位编号，但是当我们使用位来表示数字时，Qiskit 的系统肯定有它的优势。具体来说，这意味着量子比特 7 告诉我们有多少个 2^7 有我们的数字。所以通过翻转这个位，我们现在已经在我们简单的 8 位计算机中写入了数字 128。</p>
<p>现在尝试为自己写另一个数字。例如，你可以做你的年龄。只需使用搜索引擎找出数字在二进制中的样子（如果它包含 <code>0b</code>，请忽略它），然后如果你的年龄小于 128，则在左侧添加一些 0。</p>
<pre><code>qc_encode = QuantumCircuit(8)
qc_encode.x(1)
qc_encode.x(5)

qc_encode.draw()
</code></pre>
<p><img src="https://awesomeprogram.gitee.io/imgdata/tech_quan_qc5.png" alt="" /></p>
<p>现在我们知道如何在计算机中对信息进行编码。下一步是处理它：获取我们已经编码的输入，并将其转换为我们需要的输出。</p>
<h4 id="记住如何做加法"><a class="header" href="#记住如何做加法">记住如何做加法</a></h4>
<p>要了解将输入转化为输出，我们需要解决一个问题。让我们做一些基本的数学运算。在小学，您会学习到如何处理大型数学问题并将它们分解成易于管理的部分。例如，您将如何解决以下问题？</p>
<pre><code>   9213
+  1854
=  ????
</code></pre>
<p>一种方法是从右到左逐位进行。所以我们从 3+4 开始</p>
<pre><code>   9213
+  1854
=  ???7
</code></pre>
<p>然后1+5</p>
<pre><code>   9213
+  1854
=  ??67
</code></pre>
<p>那么我们有 2+8=10。由于这是一个两位数的答案，我们需要将其转移到下一栏。</p>
<pre><code>   9213
+  1854
=  ?067
</code></pre>
<p>最后我们有9+1+1=11，得到我们的答案</p>
<pre><code>   9213
+  1854
= 11067
</code></pre>
<p>这可能只是简单的加法，但它演示了所有算法背后的原理。无论算法是设计用于解决数学问题还是处理文本或图像，我们总是将大任务分解为小而简单的步骤。</p>
<p>要在计算机上运行，​​需要将算法编译成尽可能最小和最简单的步骤。为了看看这些看起来像什么，让我们再次做上面的加法问题，但是用二进制。</p>
<pre><code>   10001111111101
+  00011100111110
=  ??????????????
</code></pre>
<p>请注意，第二个数字的左侧有一堆额外的 0。这只是为了使两个字符串的长度相同。</p>
<p>我们的第一个任务是对右侧的列执行 1+0。在二进制中，与在任何数字系统中一样，答案是 1。对于第二列的 0+1，我们得到相同的结果。</p>
<pre><code>   10001111111101
+  00011100111110
=  ????????????11
</code></pre>
<p>接下来，我们有 1+1。您一定会知道，1+1=2。在二进制中，数字 2 被写为10，因此需要两位。这意味着我们需要携带 1，就像我们携带十进制数 10 一样。</p>
<pre><code>   10001111111101
+  00011100111110
=  ???????????011 
</code></pre>
<p>下一列现在要求我们计算1+1+1。这意味着将三个数字相加，因此对于我们的计算机而言，事情变得越来越复杂。但是我们仍然可以将它编译成更简单的操作，并且只需要我们将两个位加在一起。为此，我们可以只从前两个 1 开始。</p>
<pre><code>   1
+  1
= 10
</code></pre>
<p>现在我们需要把这个 10 加到最后的 1，这可以使用我们通常的遍历列的方法来完成。</p>
<pre><code>  10
+ 01
= 11
</code></pre>
<p>最后的答案是11（也称为3）。</p>
<p>现在我们可以回到问题的其余部分了。有了 的答案 11，我们就有了另一个进位。</p>
<pre><code>   10001111111101
+  00011100111110
=  ??????????1011
</code></pre>
<p>所以现在我们还有另一个 1+1+1 要做。但我们已经知道如何做到这一点，所以这没什么大不了的。</p>
<p>事实上，到目前为止剩下的一切都是我们已经知道该怎么做的事情。这是因为，如果您将所有内容分解为仅添加两位，那么您将只需要计算四种可能的事情。这是四个基本求和（我们将用两位写出所有答案以保持一致）。</p>
<pre><code>0+0 = 00 (in decimal, this is 0+0=0)
0+1 = 01 (in decimal, this is 0+1=1)
1+0 = 01 (in decimal, this is 1+0=1)
1+1 = 10 (in decimal, this is 1+1=2)
</code></pre>
<p>这称为半加法器。如果我们的计算机可以实现这一点，并且可以将它们都连接在一起，那么它就可以进行任何加法操作。</p>
<h4 id="使用-qiskit-的加法器"><a class="header" href="#使用-qiskit-的加法器">使用 Qiskit 的加法器</a></h4>
<p>让我们使用 Qiskit 制作我们自己的半加法器。这将包括对输入进行编码的电路部分、执行算法的部分以及提取结果的部分。每当我们想要使用新输入时，都需要更改第一部分，但其余部分将始终保持不变。</p>
<p><img src="https://awesomeprogram.gitee.io/imgdata/tech_quan_half_adder.svg" alt="" /></p>
<p>我们要添加的两个比特编码在量子位0和1中。上面的例子在这两个量子位中都编码了1，因此它试图找到 <code>1+1</code> 的解。结果将是一个由两位组成的字符串，我们将从量子位 2 和 3 中读出，并分别存储在经典位 0 和 1 中。剩下的就是填写实际的程序，它位于中间的空白处。</p>
<p>图中的虚线只是为了区分电路的不同部分（尽管它们也可以有更有趣的用途）。它们是使用 <code>barrier</code> 命令制作的。</p>
<p>计算机的基本构建块称为逻辑门。我们已经使用了非门，但这还不足以构成我们的半加器。我们只能用它来手动写出答案。由于我们希望计算机为我们进行实际计算，因此我们需要一些更强大的门。</p>
<p>为了了解我们需要什么，让我们再看看我们的半加器需要做什么。</p>
<pre><code>0+0 = 00
0+1 = 01
1+0 = 01
1+1 = 10
</code></pre>
<p>所有这四个答案中最右边的位完全取决于我们添加的两位是相同还是不同。所以对于0+0和1+1，当两位相等时，答案的最右边的位就出来了0。对于0+1和1+0，我们在其中添加不同的位值，最右边的位是1。</p>
<p>为了使解的这一部分正确，我们需要一些东西来确定两个位是否不同。传统上，在数字计算的研究中，这被称为异或门。</p>
<table><thead><tr><th style="text-align: center">Input 1</th><th style="text-align: center">Input 2</th><th style="text-align: center">XOR Output</th></tr></thead><tbody>
<tr><td style="text-align: center">0</td><td style="text-align: center">0</td><td style="text-align: center">0</td></tr>
<tr><td style="text-align: center">0</td><td style="text-align: center">1</td><td style="text-align: center">1</td></tr>
<tr><td style="text-align: center">1</td><td style="text-align: center">0</td><td style="text-align: center">1</td></tr>
<tr><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">0</td></tr>
</tbody></table>
<p>在量子计算机中，异或门的工作由受控非门完成。由于这个名字很长，我们通常将其称为 CNOT。在 Qiskit 中它的名字是cx，更短。在电路图中，它如下图所示。</p>
<pre><code>qc_cnot = QuantumCircuit(2)
qc_cnot.cx(0,1)
qc_cnot.draw()
</code></pre>
<p><img src="https://awesomeprogram.gitee.io/imgdata/tech_quan_pair01.jpg" alt="" /></p>
<p>这适用于一对量子位。一个充当控制量子位（这是带有小点的那个）。另一个充当目标量子位（大圆圈里面有一个 +）。</p>
<p>有多种方法可以解释 CNOT 的影响。一种是说它查看它的两个输入位，看它们是否相同或不同。接下来，用结果覆盖目标量子位。如果它们相同，则目标位变为0，如果它们不同就变为1。</p>
<p><img src="https://awesomeprogram.gitee.io/imgdata/tech_quan_cnot_xor.svg" alt="" /></p>
<p>另一种解释 CNOT 的方法是说，如果控件是1，它对目标执行 NOT，否则不执行任何操作。这个解释与前一个解释一样有效（事实上，正是这个解释才有了门的名字）。</p>
<p>通过尝试每个可能的输入来亲自尝试 CNOT。例如，这是一个使用输入测试 CNOT 的电路01。</p>
<pre><code>qc = QuantumCircuit(2,2)
qc.x(0)
qc.cx(0,1)
qc.measure(0,0)
qc.measure(1,1)
qc.draw()
</code></pre>
<p><img src="https://awesomeprogram.gitee.io/imgdata/tech_quan_meas2b.jpg" alt="" /></p>
<p>如果你执行这个电路，你会发现输出是11。我们可以认为这种情况的发生是由于以下任一原因。</p>
<ul>
<li>
<p>CNOT计算输入值是否不同，发现不同，则表示要输出1。它通过覆盖 qubit 1 的状态（记住，它位于位串的左侧），01变成11.</p>
</li>
<li>
<p>CNOT 看到量子位 0 处于状态1，因此将 NOT 应用于量子位 1。这会将量子位 1 的 0 翻转为 1，因此 01 变为 11。</p>
</li>
</ul>
<p>下表显示了 CNOT 门的所有可能输入和相应输出：</p>
<table><thead><tr><th style="text-align: center">Input (q1 q0)</th><th style="text-align: center">Output (q1 q0)</th></tr></thead><tbody>
<tr><td style="text-align: center">00</td><td style="text-align: center">00</td></tr>
<tr><td style="text-align: center">01</td><td style="text-align: center">11</td></tr>
<tr><td style="text-align: center">10</td><td style="text-align: center">10</td></tr>
<tr><td style="text-align: center">11</td><td style="text-align: center">01</td></tr>
</tbody></table>
<p>对于我们的半加器，我们不想覆盖我们的输入之一。相反，我们想将结果写在一对不同的量子位上。为此，我们可以使用两个 CNOT。</p>
<pre><code>qc_ha = QuantumCircuit(4,2)
# encode inputs in qubits 0 and 1
qc_ha.x(0) # For a=0, remove this line. For a=1, leave it.
qc_ha.x(1) # For b=0, remove this line. For b=1, leave it.
qc_ha.barrier()
# use cnots to write the XOR of the inputs on qubit 2
qc_ha.cx(0,2)
qc_ha.cx(1,2)
qc_ha.barrier()
# extract outputs
qc_ha.measure(2,0) # extract XOR value
qc_ha.measure(3,1)

qc_ha.draw()
</code></pre>
<p><img src="https://awesomeprogram.gitee.io/imgdata/tech_quan_qc6.png" alt="" /></p>
<p>我们现在已经完成了半加法器的一半工作。我们只剩下输出的另一部分要做：就是存在于量子位 3 上的那个。</p>
<p>如果您再次查看四个可能的总和，您会注意到只有一种情况是 1 而不是 0：1+1=10。只有当我们添加的两个位都是1.</p>
<p>要计算这部分输出，我们可以让我们的计算机查看两个输入是否都是1。如果它们是——并且仅当它们是——我们需要在量子位 3 上做一个非门。这将把它翻转到1仅适用于这种情况的所需值，为我们提供我们需要的输出。</p>
<p>为此，我们需要一个新门：类似于 CNOT，但控制在两个量子位上，而不是一个。只有当两个控件都处于状态 1 时，这才会对目标量子位执行 NOT 1。这座新城门叫做 <em>Toffoli</em>。对于那些熟悉布尔逻辑门的人来说，它基本上是一个 AND 门。</p>
<p>在 Qiskit 中，<em>Toffoli</em> 用 ccx 命令表示。</p>
<pre><code>qc_ha = QuantumCircuit(4,2)
# encode inputs in qubits 0 and 1
qc_ha.x(0) # For a=0, remove the this line. For a=1, leave it.
qc_ha.x(1) # For b=0, remove the this line. For b=1, leave it.
qc_ha.barrier()
# use cnots to write the XOR of the inputs on qubit 2
qc_ha.cx(0,2)
qc_ha.cx(1,2)
# use ccx to write the AND of the inputs on qubit 3
qc_ha.ccx(0,1,3)
qc_ha.barrier()
# extract outputs
qc_ha.measure(2,0) # extract XOR value
qc_ha.measure(3,1) # extract AND value

qc_ha.draw()
</code></pre>
<p><img src="https://awesomeprogram.gitee.io/imgdata/tech_quan_qc7.jpg" alt="" /></p>
<p>在这个例子中，我们正在计算1+1，因为两个输入位都是1。让我们看看我们得到了什么。</p>
<pre><code>qobj = assemble(qc_ha)
counts = sim.run(qobj).result().get_counts()
plot_histogram(counts)

/home/divs/.local/lib/python3.8/site-packages/qiskit/utils/deprecation.py:62: DeprecationWarning: Using a qobj for run() is deprecated as of qiskit-aer 0.9.0 and will be removed no sooner than 3 months from that release date. Transpiled circuits should now be passed directly using `backend.run(circuits, **run_options).
  return func(*args, **kwargs)
</code></pre>
<p><img src="https://awesomeprogram.gitee.io/imgdata/tech_quan_qc8.png" alt="" /></p>
<p>结果是10，这是数字 2 的二进制表示。我们建造了一台可以解决著名数学问题 1+1 的计算机！</p>
<p>现在您可以尝试其他三个可能的输入，并证明我们的算法也能为这些输入提供正确的结果。</p>
<p>半加器包含加法所需的一切。使用 NOT、CNOT 和 Toffoli 门，我们可以创建程序来进行任意大小的任意数字集合的加法运算。</p>
<p>这三个门也足以完成计算中的所有其他事情。事实上，我们甚至可以不用 CNOT。此外，只有在创建具有值 1 的位时才真正需要非门。<em>Toffoli</em> 本质上是数学的原子。它是最简单的元素，其他任何解决问题的技巧都可以从它中编译出来。</p>
<p>正如我们所见，在量子计算中我们分裂了原子。</p>
<pre><code>import qiskit.tools.jupyter
%qiskit_version_table

/home/divs/.local/lib/python3.8/site-packages/qiskit/aqua/__init__.py:86: DeprecationWarning: The package qiskit.aqua is deprecated. It was moved/refactored to qiskit-terra For more information see &lt;https://github.com/Qiskit/qiskit-aqua/blob/main/README.md#migration-guide&gt;
  warn_package('aqua', 'qiskit-terra')
</code></pre>
<p><strong>Version Information</strong></p>
<table><tr><th>Qiskit Software</th><th>Version</th></tr><tr><td><code>qiskit-terra</code></td><td>0.18.2</td></tr><tr><td><code>qiskit-aer</code></td><td>0.9.0</td></tr><tr><td><code>qiskit-ignis</code></td><td>0.6.0</td></tr><tr><td><code>qiskit-ibmq-provider</code></td><td>0.16.0</td></tr><tr><td><code>qiskit-aqua</code></td><td>0.9.5</td></tr><tr><td><code>qiskit</code></td><td>0.30.0</td></tr><tr><td><code>qiskit-nature</code></td><td>0.2.1</td></tr><tr><td><code>qiskit-finance</code></td><td>0.2.1</td></tr><tr><td><code>qiskit-optimization</code></td><td>0.2.2</td></tr><tr><td><code>qiskit-machine-learning</code></td><td>0.2.1</td></tr><tr><th>System information</th></tr><tr><td>Python</td><td>3.8.10 (default, Jun  2 2021, 10:49:15) 
[GCC 9.4.0]</td></tr><tr><td>OS</td><td>Linux</td></tr><tr><td>CPUs</td><td>2</td></tr><tr><td>Memory (Gb)</td><td>7.521877288818359</td></tr><tr><td colspan='2'>Sun Oct 03 22:50:56 2021 IST</td></tr></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="多量子比特与量子纠缠"><a class="header" href="#多量子比特与量子纠缠">多量子比特与量子纠缠</a></h1>
<p><img src="https://awesomeprogram.gitee.io/imgdata/techs/202207061914193.png" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="量子协议和量子算法"><a class="header" href="#量子协议和量子算法">量子协议和量子算法</a></h1>
<p><img src="https://awesomeprogram.gitee.io/imgdata/techs/202207061914193.png" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="量子算法的应用"><a class="header" href="#量子算法的应用">量子算法的应用</a></h1>
<p><img src="https://awesomeprogram.gitee.io/imgdata/techs/202207061914193.png" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="使用量子电路研究量子硬件"><a class="header" href="#使用量子电路研究量子硬件">使用量子电路研究量子硬件</a></h1>
<p><img src="https://awesomeprogram.gitee.io/imgdata/techs/202207061914193.png" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="使用微波脉冲研究量子硬件"><a class="header" href="#使用微波脉冲研究量子硬件">使用微波脉冲研究量子硬件</a></h1>
<p><img src="https://awesomeprogram.gitee.io/imgdata/techs/202207061914193.png" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="量子计算实验室"><a class="header" href="#量子计算实验室">量子计算实验室</a></h1>
<p><img src="https://awesomeprogram.gitee.io/imgdata/techs/202207061914193.png" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="量子计算游戏和演示"><a class="header" href="#量子计算游戏和演示">量子计算游戏和演示</a></h1>
<p><img src="https://awesomeprogram.gitee.io/imgdata/techs/202207061914193.png" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="量子计算应用开发"><a class="header" href="#量子计算应用开发">量子计算应用开发</a></h1>
<p><img src="https://awesomeprogram.gitee.io/imgdata/techs/202207061914193.png" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><p><img src="https://awesomeprogram.gitee.io/imgdata/techs/202207061914193.png" alt="" /></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>


        <!-- Google Analytics Tag -->
        <script type="text/javascript">
            var localAddrs = ["localhost", "127.0.0.1", ""];

            // make sure we don't activate google analytics if the developer is
            // inspecting the book locally...
            if (localAddrs.indexOf(document.location.hostname) === -1) {
                (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
                m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
                })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

                ga('create', 'G-ZHWPPT6ESV', 'auto');
                ga('send', 'pageview');
            }
        </script>


        <script type="text/javascript">
            window.playground_copyable = true;
        </script>

        <script src="ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>

        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </body>
</html>
