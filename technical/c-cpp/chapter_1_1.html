<!DOCTYPE HTML>
<html lang="zh-CN" class="sidebar-visible no-js navy">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>C与C++ 语法结构 - 信息技术 | AwesomeProgram</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="所思即所见，所见即所得，所得皆所想，技术从未停歇，也未曾缺乏">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "navy";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('navy')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../PrefixChapter.html">前言</a></li><li class="chapter-item expanded "><a href="../rust/chapter_1.html"><strong aria-hidden="true">1.</strong> Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../rust/chapter_1_1.html"><strong aria-hidden="true">1.1.</strong> Rust 语法结构</a></li><li class="chapter-item expanded "><a href="../rust/chapter_1_4.html"><strong aria-hidden="true">1.2.</strong> Rust 标准库</a></li><li class="chapter-item expanded "><a href="../rust/chapter_1_5.html"><strong aria-hidden="true">1.3.</strong> Rust 工具链</a></li><li class="chapter-item expanded "><a href="../rust/chapter_1_6.html"><strong aria-hidden="true">1.4.</strong> Rust 类型操作</a></li><li class="chapter-item expanded "><a href="../rust/chapter_1_7.html"><strong aria-hidden="true">1.5.</strong> Rust 编码范式</a></li></ol></li><li class="chapter-item expanded "><a href="../go/chapter_1.html"><strong aria-hidden="true">2.</strong> Go</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../go/chapter_1_1.html"><strong aria-hidden="true">2.1.</strong> Go 语法结构</a></li><li class="chapter-item expanded "><a href="../go/chapter_1_2.html"><strong aria-hidden="true">2.2.</strong> Go 标准库</a></li></ol></li><li class="chapter-item expanded "><a href="../js-ts/chapter_1.html"><strong aria-hidden="true">3.</strong> JavaScript-TypeScript</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../js-ts/chapter_1_1.html"><strong aria-hidden="true">3.1.</strong> JS与TS 语法结构</a></li><li class="chapter-item expanded "><a href="../js-ts/chapter_1_2.html"><strong aria-hidden="true">3.2.</strong> JS与TS 标准库</a></li></ol></li><li class="chapter-item expanded "><a href="../c-cpp/chapter_1.html"><strong aria-hidden="true">4.</strong> C-C++</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../c-cpp/chapter_1_1.html" class="active"><strong aria-hidden="true">4.1.</strong> C与C++ 语法结构</a></li><li class="chapter-item expanded "><a href="../c-cpp/chapter_1_2.html"><strong aria-hidden="true">4.2.</strong> C与C++ 标准库</a></li></ol></li><li class="chapter-item expanded "><a href="../chapter_3.html"><strong aria-hidden="true">5.</strong> 各语言对比</a></li><li class="chapter-item expanded "><a href="../blockchain/chapter_1.html"><strong aria-hidden="true">6.</strong> 区块链</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../blockchain/chapter_1_1.html"><strong aria-hidden="true">6.1.</strong> 区块链简史</a></li><li class="chapter-item expanded "><a href="../blockchain/chapter_1_2.html"><strong aria-hidden="true">6.2.</strong> 区块链框架</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../blockchain/chapter_1_2_1.html"><strong aria-hidden="true">6.2.1.</strong> substrate</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../blockchain/chapter_1_2_1_1.html"><strong aria-hidden="true">6.2.1.1.</strong> 基本原理</a></li><li class="chapter-item expanded "><a href="../blockchain/chapter_1_2_1_2.html"><strong aria-hidden="true">6.2.1.2.</strong> 构建与编码</a></li><li class="chapter-item expanded "><a href="../blockchain/chapter_1_2_1_3.html"><strong aria-hidden="true">6.2.1.3.</strong> 启动区块链网络</a></li><li class="chapter-item expanded "><a href="../blockchain/chapter_1_2_1_4.html"><strong aria-hidden="true">6.2.1.4.</strong> 自定义pallet</a></li><li class="chapter-item expanded "><a href="../blockchain/chapter_1_2_1_5.html"><strong aria-hidden="true">6.2.1.5.</strong> 开发智能合约</a></li><li class="chapter-item expanded "><a href="../blockchain/chapter_1_2_1_6.html"><strong aria-hidden="true">6.2.1.6.</strong> 桥接其它链</a></li><li class="chapter-item expanded "><a href="../blockchain/chapter_1_2_1_7.html"><strong aria-hidden="true">6.2.1.7.</strong> 工具集成</a></li><li class="chapter-item expanded "><a href="../blockchain/chapter_1_2_1_8.html"><strong aria-hidden="true">6.2.1.8.</strong> 测试</a></li></ol></li><li class="chapter-item expanded "><a href="../blockchain/chapter_1_2_2.html"><strong aria-hidden="true">6.2.2.</strong> fabric</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../blockchain/chapter_1_2_2_1.html"><strong aria-hidden="true">6.2.2.1.</strong> 基本原理</a></li><li class="chapter-item expanded "><a href="../blockchain/chapter_1_2_2_2.html"><strong aria-hidden="true">6.2.2.2.</strong> 构建与开发</a></li></ol></li><li class="chapter-item expanded "><a href="../blockchain/chapter_1_2_3.html"><strong aria-hidden="true">6.2.3.</strong> EOSIO</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../blockchain/chapter_1_2_3_1.html"><strong aria-hidden="true">6.2.3.1.</strong> 基本原理</a></li><li class="chapter-item expanded "><a href="../blockchain/chapter_1_2_3_2.html"><strong aria-hidden="true">6.2.3.2.</strong> 构建与开发</a></li></ol></li><li class="chapter-item expanded "><a href="../blockchain/chapter_1_3.html"><strong aria-hidden="true">6.2.4.</strong> 智能合约与DApp</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../blockchain/chapter_1_3_1.html"><strong aria-hidden="true">6.2.4.1.</strong> Move</a></li><li class="chapter-item expanded "><a href="../blockchain/chapter_1_3_2.html"><strong aria-hidden="true">6.2.4.2.</strong> Solidity</a></li><li class="chapter-item expanded "><a href="../blockchain/chapter_1_3_3.html"><strong aria-hidden="true">6.2.4.3.</strong> Hardhat</a></li></ol></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../cloud/chapter_1.html"><strong aria-hidden="true">7.</strong> 云计算</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../cloud/chapter_1_1.html"><strong aria-hidden="true">7.1.</strong> 云计算简史</a></li><li class="chapter-item expanded "><a href="../cloud/chapter_1_2.html"><strong aria-hidden="true">7.2.</strong> 资源编排框架</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../cloud/chapter_1_2_1.html"><strong aria-hidden="true">7.2.1.</strong> kubernetes</a></li><li class="chapter-item expanded "><a href="../cloud/chapter_1_2_2.html"><strong aria-hidden="true">7.2.2.</strong> openstack</a></li></ol></li><li class="chapter-item expanded "><a href="../cloud/chapter_1_3.html"><strong aria-hidden="true">7.3.</strong> 虚拟化</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../cloud/chapter_1_3_1.html"><strong aria-hidden="true">7.3.1.</strong> 计算</a></li><li class="chapter-item expanded "><a href="../cloud/chapter_1_3_2.html"><strong aria-hidden="true">7.3.2.</strong> 网络</a></li><li class="chapter-item expanded "><a href="../cloud/chapter_1_3_3.html"><strong aria-hidden="true">7.3.3.</strong> 存储</a></li></ol></li><li class="chapter-item expanded "><a href="../cloud/chapter_1_4.html"><strong aria-hidden="true">7.4.</strong> 容器</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../cloud/chapter_1_4_1.html"><strong aria-hidden="true">7.4.1.</strong> docker</a></li><li class="chapter-item expanded "><a href="../cloud/chapter_1_4_2.html"><strong aria-hidden="true">7.4.2.</strong> containerd</a></li><li class="chapter-item expanded "><a href="../cloud/chapter_1_4_3.html"><strong aria-hidden="true">7.4.3.</strong> podman</a></li></ol></li><li class="chapter-item expanded "><a href="../cloud/chapter_1_5.html"><strong aria-hidden="true">7.5.</strong> 高级语言虚拟机</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../cloud/chapter_1_5_1.html"><strong aria-hidden="true">7.5.1.</strong> wasm</a></li><li class="chapter-item expanded "><a href="../cloud/chapter_1_5_2.html"><strong aria-hidden="true">7.5.2.</strong> jvm</a></li><li class="chapter-item expanded "><a href="../cloud/chapter_1_5_3.html"><strong aria-hidden="true">7.5.3.</strong> evm</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../privacy/chapter_1.html"><strong aria-hidden="true">8.</strong> 隐私计算</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../privacy/chapter_1_1.html"><strong aria-hidden="true">8.1.</strong> 密码学相关</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../privacy/chapter_1_1_1.html"><strong aria-hidden="true">8.1.1.</strong> 零知识证明</a></li><li class="chapter-item expanded "><a href="../privacy/chapter_1_1_2.html"><strong aria-hidden="true">8.1.2.</strong> MPC</a></li><li class="chapter-item expanded "><a href="../privacy/chapter_1_1_3.html"><strong aria-hidden="true">8.1.3.</strong> 差分隐私</a></li><li class="chapter-item expanded "><a href="../privacy/chapter_1_1_4.html"><strong aria-hidden="true">8.1.4.</strong> 秘密共享</a></li><li class="chapter-item expanded "><a href="../privacy/chapter_1_1_5.html"><strong aria-hidden="true">8.1.5.</strong> 同态加密</a></li></ol></li><li class="chapter-item expanded "><a href="../privacy/chapter_1_2.html"><strong aria-hidden="true">8.2.</strong> 可信执行环境</a></li><li class="chapter-item expanded "><a href="../privacy/chapter_1_3.html"><strong aria-hidden="true">8.3.</strong> 联邦学习</a></li></ol></li><li class="chapter-item expanded "><a href="../quantum/chapter_1.html"><strong aria-hidden="true">9.</strong> 量子计算</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../quantum/chapter_1_1.html"><strong aria-hidden="true">9.1.</strong> 量子状态与量子比特</a></li><li class="chapter-item expanded "><a href="../quantum/chapter_1_2.html"><strong aria-hidden="true">9.2.</strong> 多量子比特与量子纠缠</a></li><li class="chapter-item expanded "><a href="../quantum/chapter_1_3.html"><strong aria-hidden="true">9.3.</strong> 量子协议和量子算法</a></li><li class="chapter-item expanded "><a href="../quantum/chapter_1_4.html"><strong aria-hidden="true">9.4.</strong> 量子算法的应用</a></li><li class="chapter-item expanded "><a href="../quantum/chapter_1_5.html"><strong aria-hidden="true">9.5.</strong> 使用量子电路研究量子硬件</a></li><li class="chapter-item expanded "><a href="../quantum/chapter_1_6.html"><strong aria-hidden="true">9.6.</strong> 使用微波脉冲研究量子硬件</a></li><li class="chapter-item expanded "><a href="../quantum/chapter_1_7.html"><strong aria-hidden="true">9.7.</strong> 量子计算实验室</a></li><li class="chapter-item expanded "><a href="../quantum/chapter_1_8.html"><strong aria-hidden="true">9.8.</strong> 量子计算游戏和演示</a></li><li class="chapter-item expanded "><a href="../quantum/chapter_1_9.html"><strong aria-hidden="true">9.9.</strong> 量子计算应用开发</a></li></ol></li><li class="chapter-item expanded "><a href="../chapter_8.html"><strong aria-hidden="true">10.</strong> 软考记录</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">信息技术 | AwesomeProgram</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="c语言的语法"><a class="header" href="#c语言的语法">C语言的语法</a></h2>
<h4 id="hello-c"><a class="header" href="#hello-c">Hello, C!</a></h4>
<pre><code class="language-c editable">#include &lt;stdio.h&gt;
int main()
{
    puts(&quot;Hello, AwesomeProgram!&quot;);
    return 0;
}

gcc main.c
</code></pre>
<h4 id="数据类型"><a class="header" href="#数据类型">数据类型</a></h4>
<pre><code class="language-c editable">#include &lt;stdio.h&gt;
#include &lt;float.h&gt;
 
int main()
{
    printf(&quot;int 存储大小 : %lu \n&quot;, sizeof(int)); // int 存储大小 : 4
    printf(&quot;float 存储最大字节数 : %lu \n&quot;, sizeof(float)); // float 存储最大字节数 : 4
    printf(&quot;float 最小值: %E\n&quot;, FLT_MIN ); // float 最小值: 1.175494E-38
    printf(&quot;float 最大值: %E\n&quot;, FLT_MAX ); // float 最大值: 3.402823E+38
    printf(&quot;精度值: %d\n&quot;, FLT_DIG ); // 精度值: 6

    int i = 10;
    float f = 3.14;
    double d = i + f; // 隐式将int类型转换为double类型
   
    double d = 3.14159;
    int i = (int)d; // 显式将double类型转换为int类型

    return 0;
}
</code></pre>
<h4 id="变量"><a class="header" href="#变量">变量</a></h4>
<pre><code class="language-c editable">#include &lt;stdio.h&gt;
 
// 函数外定义变量 x 和 y
int x;
int y;
int addtwonum()
{
    // 函数内声明变量 x 和 y 为外部变量
    extern int x;
    extern int y;
    // 给外部变量（全局变量）x 和 y 赋值
    x = 1;
    y = 2;
    return x+y;
}
 
int main()
{
    int result;
    // 调用函数 addtwonum
    result = addtwonum();
    
    printf(&quot;result 为: %d&quot;,result); // result 为: 3
    return 0;
}
</code></pre>
<pre><code class="language-c editable">// addtwonum.c 文件代码：
#include &lt;stdio.h&gt;
/*外部变量声明*/
extern int x ;
extern int y ;
int addtwonum()
{
    return x+y;
}
</code></pre>
<pre><code class="language-c editable">// test.c 文件代码：
#include &lt;stdio.h&gt;
  
/*定义两个全局变量*/
int x=1;
int y=2;
int addtwonum();
int main(void)
{
    int result;
    result = addtwonum();
    printf(&quot;result 为: %d\n&quot;,result);
    return 0;
}

$ gcc addtwonum.c test.c -o main
$ ./main  // result 为: 3
</code></pre>
<h4 id="常量"><a class="header" href="#常量">常量</a></h4>
<pre><code class="language-c editable">#include &lt;stdio.h&gt;
 
#define LENGTH 10   
#define WIDTH  5
#define NEWLINE '\n'
 
int main()
{
 
   int area;  
  
   area = LENGTH * WIDTH;
   printf(&quot;value of area : %d&quot;, area); // value of area : 50
   printf(&quot;%c&quot;, NEWLINE);
 
   return 0;
}
</code></pre>
<pre><code class="language-c editable">#include &lt;stdio.h&gt;
 
int main()
{
   const int  LENGTH = 10;
   const int  WIDTH  = 5;
   const char NEWLINE = '\n';
   int area;  
   
   area = LENGTH * WIDTH;
   printf(&quot;value of area : %d&quot;, area); // value of area : 50
   printf(&quot;%c&quot;, NEWLINE);
 
   return 0;
}
</code></pre>
<h4 id="存储类"><a class="header" href="#存储类">存储类</a></h4>
<pre><code class="language-c editable">// auto 存储类是所有局部变量默认的存储类。
// 定义在函数中的变量默认为 auto 存储类，这意味着它们在函数开始时被创建，在函数结束时被销毁。
{
   int mount;
   auto int month;
}

// register 存储类用于定义存储在寄存器中而不是 RAM 中的局部变量。这意味着变量的最大尺寸等于寄存器的大小（通常是一个字），且不能对它应用一元的 '&amp;' 运算符（因为它没有内存位置）。
// register 存储类定义存储在寄存器，所以变量的访问速度更快，但是它不能直接取地址，因为它不是存储在 RAM 中的。在需要频繁访问的变量上使用 register 存储类可以提高程序的运行速度。
{
   register int  miles;
}

// static 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。因此，使用 static 修饰局部变量可以在函数调用之间保持局部变量的值。
// static 修饰符也可以应用于全局变量。当 static 修饰全局变量时，会使变量的作用域限制在声明它的文件内。
// 全局声明的一个 static 变量或方法可以被任何函数或方法调用，只要这些方法出现在跟 static 变量或方法同一个文件中。
// 静态变量在程序中只被初始化一次，即使函数被调用多次，该变量的值也不会重置。
// 以下实例演示了 static 修饰全局变量和局部变量的应用：
#include &lt;stdio.h&gt;
 
/* 函数声明 */
void func1(void);
 
static int count=10;        /* 全局变量 - static 是默认的 */
 
int main()
{
  while (count--) {
      func1();
  }
  return 0;
}
 
void func1(void)
{
/* 'thingy' 是 'func1' 的局部变量 - 只初始化一次
 * 每次调用函数 'func1' 'thingy' 值不会被重置。
 */                
  static int thingy=5;
  thingy++;
  printf(&quot; thingy 为 %d ， count 为 %d\n&quot;, thingy, count);
}

 thingy 为 6 ， count 为 9
 thingy 为 7 ， count 为 8
 thingy 为 8 ， count 为 7
 thingy 为 9 ， count 为 6
 thingy 为 10 ， count 为 5
 thingy 为 11 ， count 为 4
 thingy 为 12 ， count 为 3
 thingy 为 13 ， count 为 2
 thingy 为 14 ， count 为 1
 thingy 为 15 ， count 为 0

// extern 存储类用于定义在其他文件中声明的全局变量或函数。当使用 extern 关键字时，不会为变量分配任何存储空间，而只是指示编译器该变量在其他文件中定义。
// extern 存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。当您使用 extern 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置。
// 当您有多个文件且定义了一个可以在其他文件中使用的全局变量或函数时，可以在其他文件中使用 extern 来得到已定义的变量或函数的引用。可以这么理解，extern 是用来在另一个文件中声明一个全局变量或函数。
// extern 修饰符通常用于当有两个或多个文件共享相同的全局变量或函数的时候，如下所示：
// 第一个文件：main.c
#include &lt;stdio.h&gt;
 
int count ;
extern void write_extern();
 
int main()
{
   count = 5;
   write_extern();
}

// 第二个文件：support.c
#include &lt;stdio.h&gt;
 
extern int count;
 
void write_extern(void)
{
   printf(&quot;count is %d\n&quot;, count);
}

$ gcc main.c support.c  // count is 5
</code></pre>
<h4 id="运算符"><a class="header" href="#运算符">运算符</a></h4>
<ul>
<li>算术运算符
下表显示了 C 语言支持的所有算术运算符。假设变量 A 的值为 10，变量 B 的值为 20，则：</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>运算符</th><th>描述</th><th>实例</th></tr></thead><tbody>
<tr><td>+</td><td>把两个操作数相加</td><td>A + B 将得到 30</td></tr>
<tr><td>-</td><td>从第一个操作数中减去第二个操作数</td><td>A - B 将得到 -10</td></tr>
<tr><td>*</td><td>把两个操作数相乘</td><td>A * B 将得到 200</td></tr>
<tr><td>/</td><td>分子除以分母</td><td>B / A 将得到 2</td></tr>
<tr><td>%</td><td>取模运算符，整除后的余数</td><td>B % A 将得到 0</td></tr>
<tr><td>++</td><td>自增运算符，整数值增加 1</td><td>A++ 将得到 11</td></tr>
<tr><td>--</td><td>自减运算符，整数值减少 1</td><td>A-- 将得到 9</td></tr>
</tbody></table>
</div>
<ul>
<li>关系运算符
下表显示了 C 语言支持的所有关系运算符。假设变量 A 的值为 10，变量 B 的值为 20，则：</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>运算符</th><th>描述</th><th>实例</th></tr></thead><tbody>
<tr><td>==	检查两个操作数的值是否相等，如果相等则条件为真。</td><td>(A == B) 为假。</td><td></td></tr>
<tr><td>!=	检查两个操作数的值是否相等，如果不相等则条件为真。</td><td>(A != B) 为真。</td><td></td></tr>
<tr><td>&gt;	检查左操作数的值是否大于右操作数的值，如果是则条件为真。</td><td>(A &gt; B) 为假。</td><td></td></tr>
<tr><td>&lt;	检查左操作数的值是否小于右操作数的值，如果是则条件为真。</td><td>(A &lt; B) 为真。</td><td></td></tr>
<tr><td>&gt;=	检查左操作数的值是否大于或等于右操作数的值，如果是则条件为真。</td><td>(A &gt;= B) 为假。</td><td></td></tr>
<tr><td>&lt;=	检查左操作数的值是否小于或等于右操作数的值，如果是则条件为真。</td><td>(A &lt;= B) 为真。</td><td></td></tr>
</tbody></table>
</div>
<ul>
<li>逻辑运算符
下表显示了 C 语言支持的所有关系逻辑运算符。假设变量 A 的值为 1，变量 B 的值为 0，则：</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>运算符</th><th>描述</th><th>实例</th></tr></thead><tbody>
<tr><td>&amp;&amp;</td><td>称为逻辑与运算符。如果两个操作数都非零，则条件为真。</td><td>(A &amp;&amp; B) 为假。</td></tr>
<tr><td>|</td><td>称为逻辑或运算符。如果两个操作数中有任意一个非零，则条件为真。</td><td>(A || B) 为真。</td></tr>
<tr><td>!</td><td>称为逻辑非运算符。用来逆转操作数的逻辑状态。如果条件为真则逻辑非运算符将使其为假。</td><td>!(A &amp;&amp; B) 为真。</td></tr>
</tbody></table>
</div>
<ul>
<li>位运算符
位运算符作用于位，并逐位执行操作。&amp;、 | 和 ^ 的真值表如下所示：</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>p</th><th>q</th><th>p &amp; q</th><th>p | q</th><th>p ^ q</th></tr></thead><tbody>
<tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>
<tr><td>0</td><td>1</td><td>0</td><td>1</td><td>1</td></tr>
<tr><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td></tr>
<tr><td>1</td><td>0</td><td>0</td><td>1</td><td>1</td></tr>
</tbody></table>
</div>
<ul>
<li>赋值运算符
下表列出了 C 语言支持的赋值运算符：</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>运算符</th><th>描述</th><th>实例</th></tr></thead><tbody>
<tr><td>=</td><td>简单的赋值运算符，把右边操作数的值赋给左边操作数</td><td>C = A + B 将把 A + B 的值赋给 C</td></tr>
<tr><td>+=</td><td>加且赋值运算符，把右边操作数加上左边操作数的结果赋值给左边操作数</td><td>C += A 相当于 C = C + A</td></tr>
<tr><td>-=</td><td>减且赋值运算符，把左边操作数减去右边操作数的结果赋值给左边操作数</td><td>C -= A 相当于 C = C - A</td></tr>
<tr><td>*=</td><td>乘且赋值运算符，把右边操作数乘以左边操作数的结果赋值给左边操作数</td><td>C *= A 相当于 C = C * A</td></tr>
<tr><td>/=</td><td>除且赋值运算符，把左边操作数除以右边操作数的结果赋值给左边操作数</td><td>C /= A 相当于 C = C / A</td></tr>
<tr><td>%=</td><td>求模且赋值运算符，求两个操作数的模赋值给左边操作数</td><td>C %= A 相当于 C = C % A</td></tr>
<tr><td>&lt;&lt;=</td><td>左移且赋值运算符</td><td>C &lt;&lt;= 2 等同于 C = C &lt;&lt; 2</td></tr>
<tr><td>&gt;&gt;=</td><td>右移且赋值运算符</td><td>C &gt;&gt;= 2 等同于 C = C &gt;&gt; 2</td></tr>
<tr><td>&amp;=</td><td>按位与且赋值运算符</td><td>C &amp;= 2 等同于 C = C &amp; 2</td></tr>
<tr><td>^=</td><td>按位异或且赋值运算符</td><td>C ^= 2 等同于 C = C ^ 2</td></tr>
<tr><td>|=</td><td>按位或且赋值运算符</td><td>C |= 2 等同于 C = C | 2</td></tr>
</tbody></table>
</div>
<ul>
<li>杂项运算符 ↦ sizeof &amp; 三元
下表列出了 C 语言支持的其他一些重要的运算符，包括 sizeof 和 ? :</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>运算符</th><th>描述</th><th>实例</th></tr></thead><tbody>
<tr><td>sizeof()</td><td>返回变量的大小。</td><td>sizeof(a) 将返回 4，其中 a 是整数。</td></tr>
<tr><td>&amp;</td><td>返回变量的地址。</td><td>&amp;a; 将给出变量的实际地址。</td></tr>
<tr><td>*</td><td>指向一个变量。</td><td>*a; 将指向一个变量。</td></tr>
<tr><td>? :</td><td>条件表达式</td><td>如果条件为真 ? 则值为 X : 否则值为 Y</td></tr>
</tbody></table>
</div>
<ul>
<li>C 中的运算符优先级
下表将按运算符优先级从高到低列出各个运算符，具有较高优先级的运算符出现在表格的上面，具有较低优先级的运算符出现在表格的下面。在表达式中，较高优先级的运算符会优先被计算。</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>类别</th><th>运算符</th><th>结合性</th></tr></thead><tbody>
<tr><td>后缀</td><td>() [] -&gt; . ++ - -</td><td>从左到右</td></tr>
<tr><td>一元</td><td>+ - ! ~ ++ - - (type)* &amp; sizeof</td><td>从右到左</td></tr>
<tr><td>乘除</td><td>* / %</td><td>从左到右</td></tr>
<tr><td>加减</td><td>+ -</td><td>从左到右</td></tr>
<tr><td>移位</td><td>&lt;&lt; &gt;&gt;</td><td>从左到右</td></tr>
<tr><td>关系</td><td>&lt; &lt;= &gt; &gt;=</td><td>从左到右</td></tr>
<tr><td>相等</td><td>== !=</td><td>从左到右</td></tr>
<tr><td>位与 AND</td><td>&amp;</td><td>从左到右</td></tr>
<tr><td>位异或 XOR</td><td>^</td><td>从左到右</td></tr>
<tr><td>位或 OR</td><td>|</td><td>从左到右</td></tr>
<tr><td>逻辑与 AND</td><td>&amp;&amp;</td><td>从左到右</td></tr>
<tr><td>逻辑或 OR</td><td>||</td><td>从左到右</td></tr>
<tr><td>条件</td><td>?:</td><td>从右到左</td></tr>
<tr><td>赋值</td><td>= += -= *= /= %=&gt;&gt;= &lt;&lt;= &amp;= ^= |=</td><td>从右到左</td></tr>
<tr><td>逗号</td><td>,</td><td>从左到右</td></tr>
</tbody></table>
</div>
<h4 id="判断"><a class="header" href="#判断">判断</a></h4>
<p>C 语言把任何非零和非空的值假定为 true，把零或 null 假定为 false。</p>
<ul>
<li>判断语句</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>语句</th><th>描述</th></tr></thead><tbody>
<tr><td>if 语句</td><td>一个 if 语句 由一个布尔表达式后跟一个或多个语句组成。</td></tr>
<tr><td>if...else 语句</td><td>一个 if 语句 后可跟一个可选的 else 语句，else 语句在布尔表达式为假时执行。</td></tr>
<tr><td>嵌套 if 语句</td><td>您可以在一个 if 或 else if 语句内使用另一个 if 或 else if 语句。</td></tr>
<tr><td>switch 语句</td><td>一个 switch 语句允许测试一个变量等于多个值时的情况。</td></tr>
<tr><td>嵌套 switch 语句</td><td>您可以在一个 switch 语句内使用另一个 switch 语句。</td></tr>
</tbody></table>
</div>
<ul>
<li>? : 运算符(三元运算符)</li>
</ul>
<pre><code class="language-c editable">#include&lt;stdio.h&gt;
 
int main()
{
    int num;
 
    printf(&quot;输入一个数字 : &quot;);
    scanf(&quot;%d&quot;,&amp;num);
    // Exp1 ? Exp2 : Exp3;
    (num%2==0)?printf(&quot;偶数&quot;):printf(&quot;奇数&quot;);
}
</code></pre>
<h4 id="循环"><a class="header" href="#循环">循环</a></h4>
<ul>
<li>循环类型</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>循环类型</th><th>描述</th></tr></thead><tbody>
<tr><td>while 循环</td><td>当给定条件为真时，重复语句或语句组。它会在执行循环主体之前测试条件。</td></tr>
<tr><td>for 循环</td><td>多次执行一个语句序列，简化管理循环变量的代码。</td></tr>
<tr><td>do...while 循环</td><td>除了它是在循环主体结尾测试条件外，其他与 while 语句类似。</td></tr>
<tr><td>嵌套循环</td><td>您可以在 while、for 或 do..while 循环内使用一个或多个循环。</td></tr>
</tbody></table>
</div>
<ul>
<li>循环控制语句
循环控制语句改变你代码的执行顺序。通过它你可以实现代码的跳转。C 提供了下列的循环控制语句：</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>控制语句</th><th>描述</th></tr></thead><tbody>
<tr><td>break 语句</td><td>终止循环或 switch 语句，程序流将继续执行紧接着循环或 switch 的下一条语句。</td></tr>
<tr><td>continue 语句</td><td>告诉一个循环体立刻停止本次循环迭代，重新开始下次循环迭代。</td></tr>
<tr><td>goto 语句</td><td>将控制转移到被标记的语句。但是不建议在程序中使用 goto 语句。</td></tr>
</tbody></table>
</div>
<ul>
<li>无限循环
如果条件永远不为假，则循环将变成无限循环。for 循环在传统意义上可用于实现无限循环。由于构成循环的三个表达式中任何一个都不是必需的，您可以将某些条件表达式留空来构成一个无限循环。</li>
</ul>
<pre><code class="language-c editable">#include &lt;stdio.h&gt;
 
int main ()
{
   for( ; ; )
   {
      printf(&quot;该循环会永远执行下去！\n&quot;);
   }
   return 0;
}
</code></pre>
<p>当条件表达式不存在时，它被假设为真。您也可以设置一个初始值和增量表达式，但是一般情况下，C 程序员偏向于使用 for(;;) 结构来表示一个无限循环。</p>
<h4 id="函数"><a class="header" href="#函数">函数</a></h4>
<pre><code class="language-c editable">#include &lt;stdio.h&gt;
 
/* 函数声明 */
int max(int num1, int num2);
 
int main ()
{
   /* 局部变量定义 */
   int a = 100;
   int b = 200;
   int ret;
 
   /* 调用函数来获取最大值 */
   ret = max(a, b);
 
   printf( &quot;Max value is : %d\n&quot;, ret ); // Max value is : 200
 
   return 0;
}
 
/* 函数返回两个数中较大的那个数 */
int max(int num1, int num2) 
{
   /* 局部变量声明 */
   int result;
 
   if (num1 &gt; num2)
      result = num1;
   else
      result = num2;
 
   return result; 
}
</code></pre>
<ul>
<li>函数参数
如果函数要使用参数，则必须声明接受参数值的变量。这些变量称为函数的形式参数。形式参数就像函数内的其他局部变量，在进入函数时被创建，退出函数时被销毁。当调用函数时，有两种向函数传递参数的方式：</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>调用类型</th><th>描述</th></tr></thead><tbody>
<tr><td>传值调用</td><td>该方法把参数的实际值复制给函数的形式参数。在这种情况下，修改函数内的形式参数不会影响实际参数。</td></tr>
<tr><td>引用调用</td><td>通过指针传递方式，形参为指向实参地址的指针，当对形参的指向操作时，就相当于对实参本身进行的操作。</td></tr>
</tbody></table>
</div>
<p>默认情况下，C 使用传值调用来传递参数。一般来说，这意味着函数内的代码不能改变用于调用函数的实际参数。</p>
<h4 id="作用域规则"><a class="header" href="#作用域规则">作用域规则</a></h4>
<ul>
<li>局部变量
在某个函数或块的内部声明的变量称为局部变量。它们只能被该函数或该代码块内部的语句使用。局部变量在函数外部是不可知的。下面是使用局部变量的实例。在这里，所有的变量 a、b 和 c 是 main() 函数的局部变量。</li>
</ul>
<pre><code class="language-c editable">#include &lt;stdio.h&gt;
 
int main ()
{
  /* 局部变量声明 */
  int a, b;
  int c;
 
  /* 实际初始化 */
  a = 10;
  b = 20;
  c = a + b;
 
  printf (&quot;value of a = %d, b = %d and c = %d\n&quot;, a, b, c);
 
  return 0;
}
</code></pre>
<ul>
<li>全局变量
全局变量是定义在函数外部，通常是在程序的顶部。全局变量在整个程序生命周期内都是有效的，在任意的函数内部能访问全局变量。
全局变量可以被任何函数访问。也就是说，全局变量在声明后整个程序中都是可用的。下面是使用全局变量和局部变量的实例：</li>
</ul>
<pre><code class="language-c editable">#include &lt;stdio.h&gt;
 
/* 全局变量声明 */
int g;
 
int main ()
{
  /* 局部变量声明 */
  int a, b;
 
  /* 实际初始化 */
  a = 10;
  b = 20;
  g = a + b;
 
  printf (&quot;value of a = %d, b = %d and g = %d\n&quot;, a, b, g);
 
  return 0;
}
</code></pre>
<ul>
<li>形式参数
函数的参数，形式参数，被当作该函数内的局部变量，如果与全局变量同名它们会优先使用。下面是一个实例：</li>
</ul>
<pre><code class="language-c editable">#include &lt;stdio.h&gt;
 
/* 全局变量声明 */
int a = 20;
 
int main ()
{
  /* 在主函数中的局部变量声明 */
  int a = 10;
  int b = 20;
  int c = 0;
  int sum(int, int);
 
  printf (&quot;value of a in main() = %d\n&quot;,  a);
  c = sum( a, b);
  printf (&quot;value of c in main() = %d\n&quot;,  c);
 
  return 0;
}
 
/* 添加两个整数的函数 */
int sum(int a, int b)
{
    printf (&quot;value of a in sum() = %d\n&quot;,  a);
    printf (&quot;value of b in sum() = %d\n&quot;,  b);
 
    return a + b;
}

// value of a in main() = 10
// value of a in sum() = 10
// value of b in sum() = 20
// value of c in main() = 30
</code></pre>
<ul>
<li>全局变量与局部变量在内存中的区别：</li>
</ul>
<p>全局变量保存在内存的全局存储区中，占用静态的存储单元；
局部变量保存在栈中，只有在所在函数被调用时才动态地为变量分配存储单元。</p>
<ul>
<li>初始化局部变量和全局变量</li>
</ul>
<p>当局部变量被定义时，系统不会对其初始化，您必须自行对其初始化。定义全局变量时，系统会自动对其初始化，如下所示：</p>
<div class="table-wrapper"><table><thead><tr><th>数据类型</th><th>初始化默认值</th></tr></thead><tbody>
<tr><td>int</td><td>0</td></tr>
<tr><td>char</td><td>'\0'</td></tr>
<tr><td>float</td><td>0</td></tr>
<tr><td>double</td><td>0</td></tr>
<tr><td>pointer</td><td>NULL</td></tr>
</tbody></table>
</div>
<p>正确地初始化变量是一个良好的编程习惯，否则有时候程序可能会产生意想不到的结果，因为未初始化的变量会导致一些在内存位置中已经可用的垃圾值。</p>
<h4 id="数组"><a class="header" href="#数组">数组</a></h4>
<pre><code class="language-c editable">#include &lt;stdio.h&gt;
 
int main ()
{
   int n[ 10 ]; /* n 是一个包含 10 个整数的数组 */
   int i,j;
 
   /* 初始化数组元素 */         
   for ( i = 0; i &lt; 10; i++ )
   {
      n[ i ] = i + 100; /* 设置元素 i 为 i + 100 */
   }
   
   /* 输出数组中每个元素的值 */
   for (j = 0; j &lt; 10; j++ )
   {
      printf(&quot;Element[%d] = %d\n&quot;, j, n[j] );
   }
 
   return 0;
}

//   Element[0] = 100
//   Element[1] = 101
//   Element[2] = 102
//   Element[3] = 103
//   Element[4] = 104
//   Element[5] = 105
//   Element[6] = 106
//   Element[7] = 107
//   Element[8] = 108
//   Element[9] = 109
</code></pre>
<p>在 C 中，数组是非常重要的，我们需要了解更多有关数组的细节。下面列出了 C 程序员必须清楚的一些与数组相关的重要概念：</p>
<div class="table-wrapper"><table><thead><tr><th>概念</th><th>描述</th></tr></thead><tbody>
<tr><td>多维数组</td><td>C 支持多维数组。多维数组最简单的形式是二维数组。</td></tr>
<tr><td>传递数组给函数</td><td>您可以通过指定不带索引的数组名称来给函数传递一个指向数组的指针。</td></tr>
<tr><td>从函数返回数组</td><td>C 允许从函数返回数组。</td></tr>
<tr><td>指向数组的指针</td><td>您可以通过指定不带索引的数组名称来生成一个指向数组中第一个元素的指针。</td></tr>
</tbody></table>
</div>
<h4 id="enum枚举"><a class="header" href="#enum枚举">enum(枚举)</a></h4>
<pre><code class="language-c editable">#include &lt;stdio.h&gt;
 
enum DAY
{
      MON=1, TUE, WED, THU, FRI, SAT, SUN
};
 
int main()
{
    enum DAY day;
    day = WED;
    printf(&quot;%d&quot;,day); // 3
    return 0;
}
</code></pre>
<pre><code class="language-c editable">#include &lt;stdio.h&gt;
 
enum DAY
{
      MON=1, TUE, WED, THU, FRI, SAT, SUN
} day;
int main()
{
    // 遍历枚举元素
    for (day = MON; day &lt;= SUN; day++) {
        printf(&quot;枚举元素：%d \n&quot;, day);
    }
}

// 枚举元素：1 
// 枚举元素：2 
// 枚举元素：3 
// 枚举元素：4 
// 枚举元素：5 
// 枚举元素：6 
// 枚举元素：7

以下枚举类型不连续，这种枚举无法遍历。

enum
{
    ENUM_0,
    ENUM_10 = 10,
    ENUM_11
};
</code></pre>
<pre><code class="language-c editable">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
int main()
{
 
    enum color { red=1, green, blue };
 
    enum  color favorite_color;
 
    /* 用户输入数字来选择颜色 */
    printf(&quot;请输入你喜欢的颜色: (1. red, 2. green, 3. blue): &quot;);
    scanf(&quot;%u&quot;, &amp;favorite_color);
 
    /* 输出结果 */
    switch (favorite_color)
    {
    case red:
        printf(&quot;你喜欢的颜色是红色&quot;);
        break;
    case green:
        printf(&quot;你喜欢的颜色是绿色&quot;);
        break;
    case blue:
        printf(&quot;你喜欢的颜色是蓝色&quot;);
        break;
    default:
        printf(&quot;你没有选择你喜欢的颜色&quot;);
    }
 
    return 0;
}

// 请输入你喜欢的颜色: (1. red, 2. green, 3. blue): 1
// 你喜欢的颜色是红色
</code></pre>
<pre><code class="language-c editable">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
 
int main()
{
 
    enum day
    {
        saturday,
        sunday,
        monday,
        tuesday,
        wednesday,
        thursday,
        friday
    } workday;
 
    int a = 1;
    enum day weekend;
    weekend = ( enum day ) a;  //类型转换
    //weekend = a; //错误
    printf(&quot;weekend:%d&quot;,weekend); // weekend:1
    return 0;
}
</code></pre>
<h4 id="指针"><a class="header" href="#指针">指针</a></h4>
<pre><code class="language-c editable">#include &lt;stdio.h&gt;
 
int main ()
{
   int  var = 20;   /* 实际变量的声明 */
   int  *ip;        /* 指针变量的声明 */
 
   ip = &amp;var;  /* 在指针变量中存储 var 的地址 */
 
   printf(&quot;var 变量的地址: %p\n&quot;, &amp;var  );
 
   /* 在指针变量中存储的地址 */
   printf(&quot;ip 变量存储的地址: %p\n&quot;, ip );
 
   /* 使用指针访问值 */
   printf(&quot;*ip 变量的值: %d\n&quot;, *ip );
 
   return 0;
}

// var 变量的地址: 0x7ffeeef168d8
// ip 变量存储的地址: 0x7ffeeef168d8
// *ip 变量的值: 20
</code></pre>
<ul>
<li>NULL 指针</li>
</ul>
<pre><code class="language-c editable">#include &lt;stdio.h&gt;
 
int main ()
{
   int  *ptr = NULL;
 
   printf(&quot;ptr 的地址是 %p\n&quot;, ptr  ); // ptr 的地址是 0x0
 
   return 0;
}
</code></pre>
<p>如需检查一个空指针，您可以使用 if 语句，如下所示：</p>
<pre><code class="language-c editable">if(ptr)     /* 如果 p 非空，则完成 */
if(!ptr)    /* 如果 p 为空，则完成 */
</code></pre>
<ul>
<li>指针详解</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>概念</th><th>描述</th></tr></thead><tbody>
<tr><td>指针的算术运算</td><td>可以对指针进行四种算术运算：++、--、+、-</td></tr>
<tr><td>指针数组</td><td>可以定义用来存储指针的数组。</td></tr>
<tr><td>指向指针的指针</td><td>C 允许指向指针的指针。</td></tr>
<tr><td>传递指针给函数</td><td>通过引用或地址传递参数，使传递的参数在调用函数中被改变。</td></tr>
<tr><td>从函数返回指针</td><td>C 允许函数返回指针到局部变量、静态变量和动态内存分配。</td></tr>
</tbody></table>
</div>
<h4 id="函数指针"><a class="header" href="#函数指针">函数指针</a></h4>
<pre><code class="language-c editable">#include &lt;stdio.h&gt;
 
int max(int x, int y)
{
    return x &gt; y ? x : y;
}
 
int main(void)
{
    /* p 是函数指针 */
    int (* p)(int, int) = &amp; max; // &amp;可以省略
    int a, b, c, d;
 
    printf(&quot;请输入三个数字:&quot;);
    scanf(&quot;%d %d %d&quot;, &amp; a, &amp; b, &amp; c);
 
    /* 与直接调用函数等价，d = max(max(a, b), c) */
    d = p(p(a, b), c); 
 
    printf(&quot;最大的数字是: %d\n&quot;, d);
 
    return 0;
}

// 请输入三个数字:1 2 3
// 最大的数字是: 3
</code></pre>
<h4 id="回调函数"><a class="header" href="#回调函数">回调函数</a></h4>
<p>实例中 populate_array() 函数定义了三个参数，其中第三个参数是函数的指针，通过该函数来设置数组的值。实例中我们定义了回调函数 getNextRandomValue()，它返回一个随机值，它作为一个函数指针传递给 populate_array() 函数。populate_array() 将调用 10 次回调函数，并将回调函数的返回值赋值给数组。</p>
<pre><code class="language-c editable">#include &lt;stdlib.h&gt;  
#include &lt;stdio.h&gt;
 
void populate_array(int *array, size_t arraySize, int (*getNextValue)(void))
{
    for (size_t i=0; i&lt;arraySize; i++)
        array[i] = getNextValue();
}
 
// 获取随机值
int getNextRandomValue(void)
{
    return rand();
}
 
int main(void)
{
    int myarray[10];
    /* getNextRandomValue 不能加括号，否则无法编译，因为加上括号之后相当于传入此参数时传入了 int , 而不是函数指针*/
    populate_array(myarray, 10, getNextRandomValue);
    for(int i = 0; i &lt; 10; i++) {
        printf(&quot;%d &quot;, myarray[i]);
    }
    printf(&quot;\n&quot;);
    return 0;
}

// 16807 282475249 1622650073 984943658 1144108930 470211272 101027544 1457850878 1458777923 2007237709 
</code></pre>
<h4 id="字符串"><a class="header" href="#字符串">字符串</a></h4>
<p>其实，您不需要把 null 字符放在字符串常量的末尾。C 编译器会在初始化数组时，自动把 \0 放在字符串的末尾。</p>
<pre><code class="language-c editable">#include &lt;stdio.h&gt;
 
int main ()
{
   char site[7] = {'R', 'U', 'N', 'O', 'O', 'B', '\0'};
 
   printf(&quot;AwesomeProgram: %s\n&quot;, site ); // 菜鸟教程: RUNOOB
 
   return 0;
}
</code></pre>
<ul>
<li>C 中有大量操作字符串的函数：</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>序号</th><th>函数 &amp; 目的</th></tr></thead><tbody>
<tr><td>1</td><td>strcpy(s1, s2); 复制字符串 s2 到字符串 s1。</td></tr>
<tr><td>2</td><td>strcat(s1, s2); 连接字符串 s2 到字符串 s1 的末尾。</td></tr>
<tr><td>3</td><td>strlen(s1); 返回字符串 s1 的长度。</td></tr>
<tr><td>4</td><td>strcmp(s1, s2); 如果 s1 和 s2 是相同的，则返回 0；如果 s1&lt;s2 则返回小于 0；如果 s1&gt;s2 则返回大于 0。</td></tr>
<tr><td>5</td><td>strchr(s1, ch); 返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。</td></tr>
<tr><td>6</td><td>strstr(s1, s2); 返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。</td></tr>
</tbody></table>
</div>
<p>下面的实例使用了上述的一些函数：</p>
<pre><code class="language-c editable">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
 
int main ()
{
   char str1[16] = &quot;awesome&quot;;
   char str2[16] = &quot;program&quot;;
   char str3[16];
   int  len ;
 
   /* 复制 str1 到 str3 */
   strcpy(str3, str1);
   printf(&quot;strcpy( str3, str1) :  %s\n&quot;, str3 ); // strcpy( str3, str1) :  awesome
 
   /* 连接 str1 和 str2 */
   strcat( str1, str2);
   printf(&quot;strcat( str1, str2):   %s\n&quot;, str1 ); // strcat( str1, str2):   awesomeprogram
 
   /* 连接后，str1 的总长度 */
   len = strlen(str1);
   printf(&quot;strlen(str1) :  %d\n&quot;, len ); // strlen(str1) :  12
 
   return 0;
}
</code></pre>
<h4 id="结构体"><a class="header" href="#结构体">结构体</a></h4>
<p>一般情况下，结构体标签、结构体成员变量、结构体变量 这 3 部分至少要出现 2 个。以下为实例：</p>
<pre><code class="language-c editable">//此声明声明了拥有3个成员的结构体，分别为整型的a，字符型的b和双精度的c
//同时又声明了结构体变量s1
//这个结构体并没有标明其标签
struct 
{
    int a;
    char b;
    double c;
} s1;
 
//此声明声明了拥有3个成员的结构体，分别为整型的a，字符型的b和双精度的c
//结构体的标签被命名为SIMPLE,没有声明变量
struct SIMPLE
{
    int a;
    char b;
    double c;
};
//用SIMPLE标签的结构体，另外声明了变量t1、t2、t3
struct SIMPLE t1, t2[20], *t3;
 
//也可以用typedef创建新类型
typedef struct
{
    int a;
    char b;
    double c; 
} Simple2;
//现在可以用Simple2作为类型声明新的结构体变量
Simple2 u1, u2[20], *u3;
</code></pre>
<p>结构体的成员可以包含其他结构体，也可以包含指向自己结构体类型的指针，而通常这种指针的应用是为了实现一些更高级的数据结构如链表和树等。</p>
<pre><code class="language-c editable">//此结构体的声明包含了其他的结构体
struct COMPLEX
{
    char string[100];
    struct SIMPLE a;
};
 
//此结构体的声明包含了指向自己类型的指针
struct NODE
{
    char string[100];
    struct NODE *next_node;
};
</code></pre>
<p>如果两个结构体互相包含，则需要对其中一个结构体进行不完整声明，如下所示：</p>
<pre><code class="language-c editable">struct B;    //对结构体B进行不完整声明
 
//结构体A中包含指向结构体B的指针
struct A
{
    struct B *partner;
    //other members;
};
 
//结构体B中包含指向结构体A的指针，在A声明完后，B也随之进行声明
struct B
{
    struct A *partner;
    //other members;
};
</code></pre>
<ul>
<li>结构体变量的初始化</li>
</ul>
<pre><code class="language-c editable">#include &lt;stdio.h&gt;
 
struct Books
{
   char  title[50];
   char  author[50];
   char  subject[100];
   int   book_id;
} book = {&quot;C 语言&quot;, &quot;RUNOOB&quot;, &quot;编程语言&quot;, 123456};
 
int main()
{
    printf(&quot;title : %s\nauthor: %s\nsubject: %s\nbook_id: %d\n&quot;, book.title, book.author, book.subject, book.book_id);
}

// title : C 语言
// author: RUNOOB
// subject: 编程语言
// book_id: 123456
</code></pre>
<ul>
<li>访问结构体成员</li>
</ul>
<pre><code class="language-c editable">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
 
struct Books
{
   char  title[50];
   char  author[50];
   char  subject[100];
   int   book_id;
};
 
int main( )
{
   struct Books Book1;        /* 声明 Book1，类型为 Books */
   struct Books Book2;        /* 声明 Book2，类型为 Books */
 
   /* Book1 详述 */
   strcpy( Book1.title, &quot;C Programming&quot;);
   strcpy( Book1.author, &quot;Nuha Ali&quot;); 
   strcpy( Book1.subject, &quot;C Programming Tutorial&quot;);
   Book1.book_id = 6495407;
 
   /* Book2 详述 */
   strcpy( Book2.title, &quot;Telecom Billing&quot;);
   strcpy( Book2.author, &quot;Zara Ali&quot;);
   strcpy( Book2.subject, &quot;Telecom Billing Tutorial&quot;);
   Book2.book_id = 6495700;
 
   /* 输出 Book1 信息 */
   printf( &quot;Book 1 title : %s\n&quot;, Book1.title); // Book 1 title : C Programming
   printf( &quot;Book 1 author : %s\n&quot;, Book1.author); // Book 1 author : Nuha Ali
   printf( &quot;Book 1 subject : %s\n&quot;, Book1.subject); // Book 1 subject : C Programming Tutorial
   printf( &quot;Book 1 book_id : %d\n&quot;, Book1.book_id); // Book 1 book_id : 6495407
 
   /* 输出 Book2 信息 */
   printf( &quot;Book 2 title : %s\n&quot;, Book2.title); // Book 2 title : Telecom Billing
   printf( &quot;Book 2 author : %s\n&quot;, Book2.author); // Book 2 author : Zara Ali
   printf( &quot;Book 2 subject : %s\n&quot;, Book2.subject); // Book 2 subject : Telecom Billing Tutorial
   printf( &quot;Book 2 book_id : %d\n&quot;, Book2.book_id); // Book 2 book_id : 6495700
 
   return 0;
}
</code></pre>
<ul>
<li>结构体作为函数参数</li>
</ul>
<pre><code class="language-c editable">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
 
struct Books
{
   char  title[50];
   char  author[50];
   char  subject[100];
   int   book_id;
};
 
/* 函数声明 */
void printBook( struct Books book );
int main( )
{
   struct Books Book1;        /* 声明 Book1，类型为 Books */
   struct Books Book2;        /* 声明 Book2，类型为 Books */
 
   /* Book1 详述 */
   strcpy( Book1.title, &quot;C Programming&quot;);
   strcpy( Book1.author, &quot;Nuha Ali&quot;); 
   strcpy( Book1.subject, &quot;C Programming Tutorial&quot;);
   Book1.book_id = 6495407;
 
   /* Book2 详述 */
   strcpy( Book2.title, &quot;Telecom Billing&quot;);
   strcpy( Book2.author, &quot;Zara Ali&quot;);
   strcpy( Book2.subject, &quot;Telecom Billing Tutorial&quot;);
   Book2.book_id = 6495700;
 
   /* 输出 Book1 信息 */
   printBook( Book1 );
 
   /* 输出 Book2 信息 */
   printBook( Book2 );
 
   return 0;
}
void printBook( struct Books book )
{
   printf( &quot;Book title : %s\n&quot;, book.title);
   printf( &quot;Book author : %s\n&quot;, book.author);
   printf( &quot;Book subject : %s\n&quot;, book.subject);
   printf( &quot;Book book_id : %d\n&quot;, book.book_id);
}

// Book title : C Programming
// Book author : Nuha Ali
// Book subject : C Programming Tutorial
// Book book_id : 6495407
// Book title : Telecom Billing
// Book author : Zara Ali
// Book subject : Telecom Billing Tutorial
// Book book_id : 6495700
</code></pre>
<ul>
<li>指向结构的指针</li>
</ul>
<pre><code class="language-c editable">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
 
struct Books
{
   char  title[50];
   char  author[50];
   char  subject[100];
   int   book_id;
};
 
/* 函数声明 */
void printBook( struct Books *book );
int main( )
{
   struct Books Book1;        /* 声明 Book1，类型为 Books */
   struct Books Book2;        /* 声明 Book2，类型为 Books */
 
   /* Book1 详述 */
   strcpy( Book1.title, &quot;C Programming&quot;);
   strcpy( Book1.author, &quot;Nuha Ali&quot;); 
   strcpy( Book1.subject, &quot;C Programming Tutorial&quot;);
   Book1.book_id = 6495407;
 
   /* Book2 详述 */
   strcpy( Book2.title, &quot;Telecom Billing&quot;);
   strcpy( Book2.author, &quot;Zara Ali&quot;);
   strcpy( Book2.subject, &quot;Telecom Billing Tutorial&quot;);
   Book2.book_id = 6495700;
 
   /* 通过传 Book1 的地址来输出 Book1 信息 */
   printBook( &amp;Book1 );
 
   /* 通过传 Book2 的地址来输出 Book2 信息 */
   printBook( &amp;Book2 );
 
   return 0;
}
void printBook( struct Books *book )
{
   printf( &quot;Book title : %s\n&quot;, book-&gt;title);
   printf( &quot;Book author : %s\n&quot;, book-&gt;author);
   printf( &quot;Book subject : %s\n&quot;, book-&gt;subject);
   printf( &quot;Book book_id : %d\n&quot;, book-&gt;book_id);
}

// Book title : C Programming
// Book author : Nuha Ali
// Book subject : C Programming Tutorial
// Book book_id : 6495407
// Book title : Telecom Billing
// Book author : Zara Ali
// Book subject : Telecom Billing Tutorial
// Book book_id : 6495700
</code></pre>
<h4 id="共用体"><a class="header" href="#共用体">共用体</a></h4>
<p>共用体是一种特殊的数据类型，允许您在相同的内存位置存储不同的数据类型。您可以定义一个带有多成员的共用体，但是任何时候只能有一个成员带有值。共用体提供了一种使用相同的内存位置的有效方式。</p>
<pre><code class="language-c editable">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
 
union Data
{
   int i;
   float f;
   char  str[20];
};
 
int main( )
{
   union Data data;        
 
   printf( &quot;Memory size occupied by data : %d\n&quot;, sizeof(data)); // Memory size occupied by data : 20
 
   return 0;
}
</code></pre>
<ul>
<li>访问共用体成员</li>
</ul>
<pre><code class="language-c editable">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
 
union Data
{
   int i;
   float f;
   char  str[20];
};
 
int main( )
{
   union Data data;        
 
   data.i = 10;
   data.f = 220.5;
   strcpy( data.str, &quot;C Programming&quot;);
 
   printf( &quot;data.i : %d\n&quot;, data.i); // data.i : 1917853763
   printf( &quot;data.f : %f\n&quot;, data.f); // data.f : 4122360580327794860452759994368.000000
   printf( &quot;data.str : %s\n&quot;, data.str); // data.str : C Programming
 
   return 0;
}
</code></pre>
<p>在这里，我们可以看到共用体的 i 和 f 成员的值有损坏，因为最后赋给变量的值占用了内存位置，这也是 str 成员能够完好输出的原因。现在让我们再来看一个相同的实例，这次我们在同一时间只使用一个变量，这也演示了使用共用体的主要目的：</p>
<pre><code class="language-c editable">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
 
union Data
{
   int i;
   float f;
   char  str[20];
};
 
int main( )
{
   union Data data;        
 
   data.i = 10;
   printf( &quot;data.i : %d\n&quot;, data.i); // data.i : 10
   
   data.f = 220.5;
   printf( &quot;data.f : %f\n&quot;, data.f); // data.f : 220.500000
   
   strcpy( data.str, &quot;C Programming&quot;);
   printf( &quot;data.str : %s\n&quot;, data.str); // data.str : C Programming
 
   return 0;
}
</code></pre>
<h4 id="位域"><a class="header" href="#位域">位域</a></h4>
<p>有些信息在存储时，并不需要占用一个完整的字节，而只需占几个或一个二进制位。例如在存放一个开关量时，只有 0 和 1 两种状态，用 1 位二进位即可。为了节省存储空间，并使处理简便，C 语言又提供了一种数据结构，称为&quot;位域&quot;或&quot;位段&quot;。</p>
<p>所谓&quot;位域&quot;是把一个字节中的二进位划分为几个不同的区域，并说明每个区域的位数。每个域有一个域名，允许在程序中按域名进行操作。这样就可以把几个不同的对象用一个字节的二进制位域来表示。</p>
<p>典型的实例：</p>
<ol>
<li>用 1 位二进位存放一个开关量时，只有 0 和 1 两种状态。</li>
<li>读取外部文件格式——可以读取非标准的文件格式。例如：9 位的整数。</li>
</ol>
<p><code>type [member_name] : width ;</code>
下面是有关位域中变量元素的描述：</p>
<div class="table-wrapper"><table><thead><tr><th>元素</th><th>描述</th></tr></thead><tbody>
<tr><td>type</td><td>只能为 int(整型)，unsigned int(无符号整型)，signed int(有符号整型) 三种类型，决定了如何解释位域的值。</td></tr>
<tr><td>member_name</td><td>位域的名称。</td></tr>
<tr><td>width</td><td>位域中位的数量。宽度必须小于或等于指定类型的位宽度。</td></tr>
</tbody></table>
</div>
<pre><code class="language-c editable">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
 
struct
{
  unsigned int age : 3;
} Age;
 
int main( )
{
   Age.age = 4;
   printf( &quot;Sizeof( Age ) : %d\n&quot;, sizeof(Age) );
   printf( &quot;Age.age : %d\n&quot;, Age.age );
 
   Age.age = 7;
   printf( &quot;Age.age : %d\n&quot;, Age.age );
 
   Age.age = 8; // 二进制表示为 1000 有四位，超出
   printf( &quot;Age.age : %d\n&quot;, Age.age );
 
   return 0;
}
</code></pre>
<p>当上面的代码被编译时，它会带有警告，当上面的代码被执行时，它会产生下列结果：</p>
<pre><code class="language-c editable">// Sizeof( Age ) : 4
// Age.age : 4
// Age.age : 7
// Age.age : 0
</code></pre>
<pre><code class="language-c editable">#include &lt;stdio.h&gt;
 
int main(){
    struct bs{
        unsigned a:1;
        unsigned b:3;
        unsigned c:4;
    } bit,*pbit;
    bit.a=1;    /* 给位域赋值（应注意赋值不能超过该位域的允许范围） */
    bit.b=7;    /* 给位域赋值（应注意赋值不能超过该位域的允许范围） */
    bit.c=15;    /* 给位域赋值（应注意赋值不能超过该位域的允许范围） */
    printf(&quot;%d,%d,%d\n&quot;,bit.a,bit.b,bit.c);    /* 以整型量格式输出三个域的内容 */
    pbit=&amp;bit;    /* 把位域变量 bit 的地址送给指针变量 pbit */
    pbit-&gt;a=0;    /* 用指针方式给位域 a 重新赋值，赋为 0 */
    pbit-&gt;b&amp;=3;    /* 使用了复合的位运算符 &quot;&amp;=&quot;，相当于：pbit-&gt;b=pbit-&gt;b&amp;3，位域 b 中原有值为 7，与 3 作按位与运算的结果为 3（111&amp;011=011，十进制值为 3） */
    pbit-&gt;c|=1;    /* 使用了复合位运算符&quot;|=&quot;，相当于：pbit-&gt;c=pbit-&gt;c|1，其结果为 15 */
    printf(&quot;%d,%d,%d\n&quot;,pbit-&gt;a,pbit-&gt;b,pbit-&gt;c);    /* 用指针方式输出了这三个域的值 */
}
</code></pre>
<p>上例程序中定义了位域结构 bs，三个位域为 a、b、c。说明了 bs 类型的变量 bit 和指向 bs 类型的指针变量 pbit。这表示位域也是可以使用指针的。</p>
<h4 id="typedef"><a class="header" href="#typedef">typedef</a></h4>
<p>C 语言提供了 typedef 关键字，您可以使用它来为类型取一个新的名字。下面的实例为单字节数字定义了一个术语 BYTE：
<code>typedef unsigned char BYTE;</code>
在这个类型定义之后，标识符 BYTE 可作为类型 unsigned char 的缩写，例如：
<code>BYTE  b1, b2;</code>
您也可以使用 typedef 来为用户自定义的数据类型取一个新的名字。例如，您可以对结构体使用 typedef 来定义一个新的数据类型名字，然后使用这个新的数据类型来直接定义结构变量，如下：</p>
<pre><code class="language-c editable">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
 
typedef struct Books
{
   char  title[50];
   char  author[50];
   char  subject[100];
   int   book_id;
} Book;
 
int main( )
{
   Book book;
 
   strcpy( book.title, &quot;C 教程&quot;);
   strcpy( book.author, &quot;Runoob&quot;); 
   strcpy( book.subject, &quot;编程语言&quot;);
   book.book_id = 12345;
 
   printf( &quot;书标题 : %s\n&quot;, book.title); // 书标题 : C 教程
   printf( &quot;书作者 : %s\n&quot;, book.author); // 书作者 : Runoob
   printf( &quot;书类目 : %s\n&quot;, book.subject); // 书类目 : 编程语言
   printf( &quot;书 ID : %d\n&quot;, book.book_id); // 书 ID : 12345
 
   return 0;
}
</code></pre>
<ul>
<li>typedef vs #define</li>
</ul>
<p>#define 是 C 指令，用于为各种数据类型定义别名，与 typedef 类似，但是它们有以下几点不同：</p>
<ol>
<li>typedef 仅限于为类型定义符号名称，#define 不仅可以为类型定义别名，也能为数值定义别名，比如您可以定义 1 为 ONE。</li>
<li>typedef 是由编译器执行解释的，#define 语句是由预编译器进行处理的。</li>
</ol>
<pre><code class="language-c editable">#include &lt;stdio.h&gt;
 
#define TRUE  1
#define FALSE 0
 
int main( )
{
   printf( &quot;TRUE 的值: %d\n&quot;, TRUE); // TRUE 的值: 1
   printf( &quot;FALSE 的值: %d\n&quot;, FALSE); // FALSE 的值: 0
 
   return 0;
}
</code></pre>
<h4 id=""><a class="header" href="#"></a></h4>
<pre><code class="language-c editable">
</code></pre>
<h4 id="-1"><a class="header" href="#-1"></a></h4>
<pre><code class="language-c editable">
</code></pre>
<h4 id="-2"><a class="header" href="#-2"></a></h4>
<pre><code class="language-c editable">
</code></pre>
<h4 id="-3"><a class="header" href="#-3"></a></h4>
<pre><code class="language-c editable">
</code></pre>
<h4 id="-4"><a class="header" href="#-4"></a></h4>
<pre><code class="language-c editable">
</code></pre>
<h4 id="-5"><a class="header" href="#-5"></a></h4>
<pre><code class="language-c editable">
</code></pre>
<h4 id="-6"><a class="header" href="#-6"></a></h4>
<pre><code class="language-c editable">
</code></pre>
<h4 id="-7"><a class="header" href="#-7"></a></h4>
<pre><code class="language-c editable">
</code></pre>
<h4 id="-8"><a class="header" href="#-8"></a></h4>
<pre><code class="language-c editable">
</code></pre>
<h4 id="-9"><a class="header" href="#-9"></a></h4>
<pre><code class="language-c editable">
</code></pre>
<h4 id="-10"><a class="header" href="#-10"></a></h4>
<pre><code class="language-c editable">
</code></pre>
<h4 id="-11"><a class="header" href="#-11"></a></h4>
<pre><code class="language-c editable">
</code></pre>
<h4 id="-12"><a class="header" href="#-12"></a></h4>
<pre><code class="language-c editable">
</code></pre>
<h4 id="-13"><a class="header" href="#-13"></a></h4>
<pre><code class="language-c editable">
</code></pre>
<h4 id="-14"><a class="header" href="#-14"></a></h4>
<pre><code class="language-c editable">
</code></pre>
<h4 id="-15"><a class="header" href="#-15"></a></h4>
<pre><code class="language-c editable">
</code></pre>
<h4 id="-16"><a class="header" href="#-16"></a></h4>
<pre><code class="language-c editable">
</code></pre>
<h4 id="-17"><a class="header" href="#-17"></a></h4>
<pre><code class="language-c editable">
</code></pre>
<h4 id="-18"><a class="header" href="#-18"></a></h4>
<pre><code class="language-c editable">
</code></pre>
<h4 id="-19"><a class="header" href="#-19"></a></h4>
<pre><code class="language-c editable">
</code></pre>
<h4 id="-20"><a class="header" href="#-20"></a></h4>
<pre><code class="language-c editable">
</code></pre>
<h4 id="-21"><a class="header" href="#-21"></a></h4>
<pre><code class="language-c editable">
</code></pre>
<h4 id="-22"><a class="header" href="#-22"></a></h4>
<pre><code class="language-c editable">
</code></pre>
<h4 id="-23"><a class="header" href="#-23"></a></h4>
<pre><code class="language-c editable">
</code></pre>
<h4 id="-24"><a class="header" href="#-24"></a></h4>
<pre><code class="language-c editable">
</code></pre>
<h4 id="-25"><a class="header" href="#-25"></a></h4>
<pre><code class="language-c editable">
</code></pre>
<h4 id="-26"><a class="header" href="#-26"></a></h4>
<pre><code class="language-c editable">
</code></pre>
<h4 id="-27"><a class="header" href="#-27"></a></h4>
<pre><code class="language-c editable">
</code></pre>
<h4 id="-28"><a class="header" href="#-28"></a></h4>
<pre><code class="language-c editable">
</code></pre>
<h4 id="-29"><a class="header" href="#-29"></a></h4>
<pre><code class="language-c editable">
</code></pre>
<h4 id="-30"><a class="header" href="#-30"></a></h4>
<pre><code class="language-c editable">
</code></pre>
<h4 id="-31"><a class="header" href="#-31"></a></h4>
<pre><code class="language-c editable">
</code></pre>
<h4 id="-32"><a class="header" href="#-32"></a></h4>
<pre><code class="language-c editable">
</code></pre>
<h4 id="-33"><a class="header" href="#-33"></a></h4>
<pre><code class="language-c editable">
</code></pre>
<h4 id="-34"><a class="header" href="#-34"></a></h4>
<pre><code class="language-c editable">
</code></pre>
<h4 id="-35"><a class="header" href="#-35"></a></h4>
<pre><code class="language-c editable">
</code></pre>
<h4 id="-36"><a class="header" href="#-36"></a></h4>
<pre><code class="language-c editable">
</code></pre>
<h4 id="-37"><a class="header" href="#-37"></a></h4>
<pre><code class="language-c editable">
</code></pre>
<h4 id="-38"><a class="header" href="#-38"></a></h4>
<pre><code class="language-c editable">
</code></pre>
<h4 id="-39"><a class="header" href="#-39"></a></h4>
<pre><code class="language-c editable">
</code></pre>
<h4 id="-40"><a class="header" href="#-40"></a></h4>
<pre><code class="language-c editable">
</code></pre>
<h4 id="-41"><a class="header" href="#-41"></a></h4>
<pre><code class="language-c editable">
</code></pre>
<h4 id="-42"><a class="header" href="#-42"></a></h4>
<pre><code class="language-c editable">
</code></pre>
<h4 id="-43"><a class="header" href="#-43"></a></h4>
<pre><code class="language-c editable">
</code></pre>
<h4 id="-44"><a class="header" href="#-44"></a></h4>
<pre><code class="language-c editable">
</code></pre>
<h4 id="-45"><a class="header" href="#-45"></a></h4>
<pre><code class="language-c editable">
</code></pre>
<h4 id="-46"><a class="header" href="#-46"></a></h4>
<pre><code class="language-c editable">
</code></pre>
<h4 id="-47"><a class="header" href="#-47"></a></h4>
<pre><code class="language-c editable">
</code></pre>
<h4 id="-48"><a class="header" href="#-48"></a></h4>
<pre><code class="language-c editable">
</code></pre>
<h4 id="-49"><a class="header" href="#-49"></a></h4>
<pre><code class="language-c editable">
</code></pre>
<h4 id="-50"><a class="header" href="#-50"></a></h4>
<pre><code class="language-c editable">
</code></pre>
<h4 id="-51"><a class="header" href="#-51"></a></h4>
<pre><code class="language-c editable">
</code></pre>
<h4 id="-52"><a class="header" href="#-52"></a></h4>
<pre><code class="language-c editable">
</code></pre>
<h4 id="-53"><a class="header" href="#-53"></a></h4>
<pre><code class="language-c editable">
</code></pre>
<h4 id="-54"><a class="header" href="#-54"></a></h4>
<pre><code class="language-c editable">
</code></pre>
<h4 id="-55"><a class="header" href="#-55"></a></h4>
<pre><code class="language-c editable">
</code></pre>
<h4 id="-56"><a class="header" href="#-56"></a></h4>
<pre><code class="language-c editable">
</code></pre>
<h4 id="-57"><a class="header" href="#-57"></a></h4>
<pre><code class="language-c editable">
</code></pre>
<h4 id="-58"><a class="header" href="#-58"></a></h4>
<pre><code class="language-c editable">
</code></pre>
<h4 id="-59"><a class="header" href="#-59"></a></h4>
<pre><code class="language-c editable">
</code></pre>
<h4 id="-60"><a class="header" href="#-60"></a></h4>
<pre><code class="language-c editable">
</code></pre>
<h4 id="-61"><a class="header" href="#-61"></a></h4>
<pre><code class="language-c editable">
</code></pre>
<h4 id="-62"><a class="header" href="#-62"></a></h4>
<pre><code class="language-c editable">
</code></pre>
<h2 id="c语法"><a class="header" href="#c语法">C++语法</a></h2>
<h4 id="hello-c-1"><a class="header" href="#hello-c-1">Hello, C++!</a></h4>
<pre><code class="language-c++ editable">#include &lt;stdio.h&gt;
int main()
{
    puts(&quot;Hello, AwesomeProgram!&quot;);
    return 0;
}
</code></pre>
<p><code>gcc main.cpp -lstdc++</code> 或者 <code>g++ main.cpp</code></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../c-cpp/chapter_1.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../c-cpp/chapter_1_2.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../c-cpp/chapter_1.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../c-cpp/chapter_1_2.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>


        <!-- Google Analytics Tag -->
        <script>
            var localAddrs = ["localhost", "127.0.0.1", ""];

            // make sure we don't activate google analytics if the developer is
            // inspecting the book locally...
            if (localAddrs.indexOf(document.location.hostname) === -1) {
                (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
                m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
                })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

                ga('create', 'G-ZHWPPT6ESV', 'auto');
                ga('send', 'pageview');
            }
        </script>


        <script>
            window.playground_copyable = true;
        </script>

        <script src="../ace.js"></script>
        <script src="../editor.js"></script>
        <script src="../mode-rust.js"></script>
        <script src="../theme-dawn.js"></script>
        <script src="../theme-tomorrow_night.js"></script>

        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
