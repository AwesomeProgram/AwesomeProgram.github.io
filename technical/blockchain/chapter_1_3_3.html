<!DOCTYPE HTML>
<html lang="zh-CN" class="sidebar-visible no-js navy">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Hardhat - 信息技术 | AwesomeProgram</title>


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="所思即所见，所见即所得，所得皆所想，技术从未停歇，也未曾缺乏">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "navy";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('navy')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../PrefixChapter.html">前言</a></li><li class="chapter-item expanded "><a href="../rust/chapter_1.html"><strong aria-hidden="true">1.</strong> Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../rust/chapter_1_1.html"><strong aria-hidden="true">1.1.</strong> Rust 语法结构</a></li><li class="chapter-item expanded "><a href="../rust/chapter_1_4.html"><strong aria-hidden="true">1.2.</strong> Rust 标准库</a></li><li class="chapter-item expanded "><a href="../rust/chapter_1_5.html"><strong aria-hidden="true">1.3.</strong> Rust 工具链</a></li><li class="chapter-item expanded "><a href="../rust/chapter_1_6.html"><strong aria-hidden="true">1.4.</strong> Rust 类型操作</a></li><li class="chapter-item expanded "><a href="../rust/chapter_1_7.html"><strong aria-hidden="true">1.5.</strong> Rust 编码范式</a></li></ol></li><li class="chapter-item expanded "><a href="../go/chapter_1.html"><strong aria-hidden="true">2.</strong> Go</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../go/chapter_1_1.html"><strong aria-hidden="true">2.1.</strong> Go 语法结构</a></li><li class="chapter-item expanded "><a href="../go/chapter_1_2.html"><strong aria-hidden="true">2.2.</strong> Go 标准库</a></li></ol></li><li class="chapter-item expanded "><a href="../chapter_3.html"><strong aria-hidden="true">3.</strong> 各语言对比</a></li><li class="chapter-item expanded "><a href="../blockchain/chapter_1.html"><strong aria-hidden="true">4.</strong> 区块链</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../blockchain/chapter_1_1.html"><strong aria-hidden="true">4.1.</strong> 区块链简史</a></li><li class="chapter-item expanded "><a href="../blockchain/chapter_1_2.html"><strong aria-hidden="true">4.2.</strong> 区块链框架</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../blockchain/chapter_1_2_1.html"><strong aria-hidden="true">4.2.1.</strong> substrate</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../blockchain/chapter_1_2_1_1.html"><strong aria-hidden="true">4.2.1.1.</strong> 基本原理</a></li><li class="chapter-item expanded "><a href="../blockchain/chapter_1_2_1_2.html"><strong aria-hidden="true">4.2.1.2.</strong> 构建与编码</a></li><li class="chapter-item expanded "><a href="../blockchain/chapter_1_2_1_3.html"><strong aria-hidden="true">4.2.1.3.</strong> 启动区块链网络</a></li><li class="chapter-item expanded "><a href="../blockchain/chapter_1_2_1_4.html"><strong aria-hidden="true">4.2.1.4.</strong> 自定义pallet</a></li><li class="chapter-item expanded "><a href="../blockchain/chapter_1_2_1_5.html"><strong aria-hidden="true">4.2.1.5.</strong> 开发智能合约</a></li><li class="chapter-item expanded "><a href="../blockchain/chapter_1_2_1_6.html"><strong aria-hidden="true">4.2.1.6.</strong> 桥接其它链</a></li><li class="chapter-item expanded "><a href="../blockchain/chapter_1_2_1_7.html"><strong aria-hidden="true">4.2.1.7.</strong> 工具集成</a></li><li class="chapter-item expanded "><a href="../blockchain/chapter_1_2_1_8.html"><strong aria-hidden="true">4.2.1.8.</strong> 测试</a></li></ol></li><li class="chapter-item expanded "><a href="../blockchain/chapter_1_2_2.html"><strong aria-hidden="true">4.2.2.</strong> fabric</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../blockchain/chapter_1_2_2_1.html"><strong aria-hidden="true">4.2.2.1.</strong> 基本原理</a></li><li class="chapter-item expanded "><a href="../blockchain/chapter_1_2_2_2.html"><strong aria-hidden="true">4.2.2.2.</strong> 构建与开发</a></li></ol></li><li class="chapter-item expanded "><a href="../blockchain/chapter_1_2_3.html"><strong aria-hidden="true">4.2.3.</strong> EOSIO</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../blockchain/chapter_1_2_3_1.html"><strong aria-hidden="true">4.2.3.1.</strong> 基本原理</a></li><li class="chapter-item expanded "><a href="../blockchain/chapter_1_2_3_2.html"><strong aria-hidden="true">4.2.3.2.</strong> 构建与开发</a></li></ol></li><li class="chapter-item expanded "><a href="../blockchain/chapter_1_3.html"><strong aria-hidden="true">4.2.4.</strong> 智能合约与DApp</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../blockchain/chapter_1_3_1.html"><strong aria-hidden="true">4.2.4.1.</strong> Move</a></li><li class="chapter-item expanded "><a href="../blockchain/chapter_1_3_2.html"><strong aria-hidden="true">4.2.4.2.</strong> Solidity</a></li><li class="chapter-item expanded "><a href="../blockchain/chapter_1_3_3.html" class="active"><strong aria-hidden="true">4.2.4.3.</strong> Hardhat</a></li></ol></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../cloud/chapter_1.html"><strong aria-hidden="true">5.</strong> 云计算</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../cloud/chapter_1_1.html"><strong aria-hidden="true">5.1.</strong> 云计算简史</a></li><li class="chapter-item expanded "><a href="../cloud/chapter_1_2.html"><strong aria-hidden="true">5.2.</strong> 资源编排框架</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../cloud/chapter_1_2_1.html"><strong aria-hidden="true">5.2.1.</strong> kubernetes</a></li><li class="chapter-item expanded "><a href="../cloud/chapter_1_2_2.html"><strong aria-hidden="true">5.2.2.</strong> openstack</a></li></ol></li><li class="chapter-item expanded "><a href="../cloud/chapter_1_3.html"><strong aria-hidden="true">5.3.</strong> 虚拟化</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../cloud/chapter_1_3_1.html"><strong aria-hidden="true">5.3.1.</strong> 计算</a></li><li class="chapter-item expanded "><a href="../cloud/chapter_1_3_2.html"><strong aria-hidden="true">5.3.2.</strong> 网络</a></li><li class="chapter-item expanded "><a href="../cloud/chapter_1_3_3.html"><strong aria-hidden="true">5.3.3.</strong> 存储</a></li></ol></li><li class="chapter-item expanded "><a href="../cloud/chapter_1_4.html"><strong aria-hidden="true">5.4.</strong> 容器</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../cloud/chapter_1_4_1.html"><strong aria-hidden="true">5.4.1.</strong> docker</a></li><li class="chapter-item expanded "><a href="../cloud/chapter_1_4_2.html"><strong aria-hidden="true">5.4.2.</strong> containerd</a></li><li class="chapter-item expanded "><a href="../cloud/chapter_1_4_3.html"><strong aria-hidden="true">5.4.3.</strong> podman</a></li></ol></li><li class="chapter-item expanded "><a href="../cloud/chapter_1_5.html"><strong aria-hidden="true">5.5.</strong> 高级语言虚拟机</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../cloud/chapter_1_5_1.html"><strong aria-hidden="true">5.5.1.</strong> wasm</a></li><li class="chapter-item expanded "><a href="../cloud/chapter_1_5_2.html"><strong aria-hidden="true">5.5.2.</strong> jvm</a></li><li class="chapter-item expanded "><a href="../cloud/chapter_1_5_3.html"><strong aria-hidden="true">5.5.3.</strong> evm</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../privacy/chapter_1.html"><strong aria-hidden="true">6.</strong> 隐私计算</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../privacy/chapter_1_1.html"><strong aria-hidden="true">6.1.</strong> 密码学相关</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../privacy/chapter_1_1_1.html"><strong aria-hidden="true">6.1.1.</strong> 零知识证明</a></li><li class="chapter-item expanded "><a href="../privacy/chapter_1_1_2.html"><strong aria-hidden="true">6.1.2.</strong> MPC</a></li><li class="chapter-item expanded "><a href="../privacy/chapter_1_1_3.html"><strong aria-hidden="true">6.1.3.</strong> 差分隐私</a></li><li class="chapter-item expanded "><a href="../privacy/chapter_1_1_4.html"><strong aria-hidden="true">6.1.4.</strong> 秘密共享</a></li><li class="chapter-item expanded "><a href="../privacy/chapter_1_1_5.html"><strong aria-hidden="true">6.1.5.</strong> 同态加密</a></li></ol></li><li class="chapter-item expanded "><a href="../privacy/chapter_1_2.html"><strong aria-hidden="true">6.2.</strong> 可信执行环境</a></li><li class="chapter-item expanded "><a href="../privacy/chapter_1_3.html"><strong aria-hidden="true">6.3.</strong> 联邦学习</a></li></ol></li><li class="chapter-item expanded "><a href="../quantum/chapter_1.html"><strong aria-hidden="true">7.</strong> 量子计算</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../quantum/chapter_1_1.html"><strong aria-hidden="true">7.1.</strong> 经典计算与量子计算</a></li><li class="chapter-item expanded "><a href="../quantum/chapter_1_2.html"><strong aria-hidden="true">7.2.</strong> 量子计算中的概念</a></li><li class="chapter-item expanded "><a href="../quantum/chapter_1_3.html"><strong aria-hidden="true">7.3.</strong> 量子计算中的算法</a></li></ol></li><li class="chapter-item expanded "><a href="../chapter_8.html"><strong aria-hidden="true">8.</strong> 软考记录</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">信息技术 | AwesomeProgram</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="hardhat教程"><a class="header" href="#hardhat教程">Hardhat教程</a></h1>
<h2 id="1-hardhat概述"><a class="header" href="#1-hardhat概述">1. Hardhat概述</a></h2>
<p>欢迎来到我们的以太坊合约和 dApp 开发初学者指南。本教程旨在快速让您从头开始构建一些东西。</p>
<p>为了协调这个过程，我们将使用 Hardhat，这是一种有助于在以太坊上构建的开发环境。它可以帮助开发人员管理和自动化构建智能合约和 dApp 过程中固有的重复性任务，并且它允许你围绕此工作流程轻松引入更多功能。这意味着 hardhat 在最核心的地方进行编译和测试。</p>
<p>Hardhat 还内置了 Hardhat 网络，这是一个专为开发而设计的本地以太坊网络。它允许你部署合约、运行测试和调试代码。</p>
<p>在本教程中，我们将引导您完成：</p>
<ul>
<li>为以太坊开发设置 Node.js 环境</li>
<li>创建和配置 Hardhat 项目</li>
<li>实现 Solidity 智能合约代币</li>
<li>使用 Hardhat 为你的合约编写自动化测试</li>
<li>使用Hardhat EVM的 <code>console.log()</code> 调试 Solidity</li>
<li>将您的合约部署到 Hardhat EVM 和以太坊测试网</li>
</ul>
<p>要遵循本教程，你应该能够：</p>
<ul>
<li>用 [JavaScript] 编写代码(https://developer.mozilla.org/en-US/docs/Learn/Getting_started_with_the_web/JavaScript_basics)</li>
<li>操作 <a href="https://en.wikipedia.org/wiki/Terminal_emulator">terminal</a></li>
<li>使用 <a href="https://git-scm.com/doc">git</a></li>
<li>了解 <a href="https://ethereum.org/learn/#smart-contracts">智能合约</a> 如何工作的基础知识</li>
<li>设置 <a href="https://metamask.io/">Metamask</a> 钱包</li>
</ul>
<p>如果你无法执行上述任何操作，请点击链接并花一些时间学习基础知识。</p>
<h2 id="2-搭建环境"><a class="header" href="#2-搭建环境">2. 搭建环境</a></h2>
<p>大多数以太坊库和工具都是用 JavaScript 编写的，Hardhat 也是如此。如果你不熟悉 Node.js，它是基于 Chrome 的 V8 JavaScript 引擎构建的 JavaScript 运行时。它是在 Web 浏览器之外运行 JavaScript 的最流行的解决方案，而 Hardhat 就是在它之上构建的。</p>
<p>:::提示</p>
<p><a href="https://marketplace.visualstudio.com/items?itemName=NomicFoundation.hardhat-solidity">Hardhat for Visual Studio Code</a> 是官方的 Hardhat 扩展，它为 VSCode 添加了对 Solidity 的高级支持。如果你使用 Visual Studio Code，可尝试一下！</p>
<p>:::</p>
<h3 id="安装nodejs"><a class="header" href="#安装nodejs">安装Node.js</a></h3>
<p>如果你已经安装了的 Node.js <code>&gt;=16.0</code>，则可以<a href="#3-%E5%88%9B%E5%BB%BA%E6%96%B0%E7%9A%84hardhat%E9%A1%B9%E7%9B%AE">跳到下一节</a>。如果没有，请按照以下步骤在 Ubuntu，MacOS 和 Windows 上安装它。</p>
<h4 id="linux"><a class="header" href="#linux">Linux</a></h4>
<h5 id="ubuntu"><a class="header" href="#ubuntu">Ubuntu</a></h5>
<p>将以下命令复制并粘贴到终端中：</p>
<pre><code>sudo apt update
sudo apt install curl git
curl -fsSL https://deb.nodesource.com/setup_18.x | sudo -E bash -
sudo apt-get install -y nodejs
</code></pre>
<h4 id="macos"><a class="header" href="#macos">MacOS</a></h4>
<p>确保你已安装 <code>git</code>。否则，请遵循<a href="https://www.atlassian.com/git/tutorials/install-git">这些说明</a>安装.</p>
<p>在 MacOS 上有多种安装 Node.js 的方法。我们将使用 Node 版本管理器（nvm）。将以下命令复制并粘贴到终端中：</p>
<pre><code>curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.1/install.sh | bash
nvm install 18
nvm use 18
nvm alias default 18
npm install npm --global # Upgrade npm to the latest version
</code></pre>
<h4 id="windows"><a class="header" href="#windows">Windows</a></h4>
<p>如果你使用 Windows，我们强烈推荐你使用用于 Linux 的 Windows 子系统（也就是 WSL2）。你可以不用它来使用 Hardhat，但如果你使用它，效果会更好。</p>
<p>要使用 WSL2 来安装 Node.js，可参考<a href="https://docs.microsoft.com/en-us/windows/dev-environment/javascript/nodejs-on-wsl">这篇手册</a>.</p>
<p>还要确保你已经<a href="https://docs.microsoft.com/en-us/windows/wsl/tutorials/wsl-git">在 WSL2 上安装了 git</a>.</p>
<h3 id="升级nodejs"><a class="header" href="#升级nodejs">升级Node.js</a></h3>
<p>如果你的 Node.js 版本很老的并且<a href="https://hardhat.org/hardhat-runner/docs/reference/stability-guarantees#node.js-versions-support">不被 Hardhat 支持</a>，则需要通过以下指引升级。</p>
<h4 id="linux-1"><a class="header" href="#linux-1">Linux</a></h4>
<h5 id="ubuntu-1"><a class="header" href="#ubuntu-1">Ubuntu</a></h5>
<ol>
<li>在终端运行 <code>sudo apt remove nodejs</code> 命令来删除 Node.js。</li>
<li>在<a href="https://github.com/nodesource/distributions#debinstall">这里</a>查找你希望安装的 Node.js 版本并且按照指令来安装。</li>
<li>在终端运行 <code>sudo apt update &amp;&amp; sudo apt install nodejs</code> 命令来再次安装 Node.js。</li>
</ol>
<h4 id="macos-1"><a class="header" href="#macos-1">MacOS</a></h4>
<p>你可以使用 <a href="http://github.com/creationix/nvm">nvm</a>来切换你的 Node.js 版本。在终端运行以下命令升级到 Node.js <code>18.x</code>：</p>
<pre><code>nvm install 18
nvm use 18
nvm alias default 18
npm install npm --global # 升级 npm 到最新的版本
</code></pre>
<h4 id="windows-1"><a class="header" href="#windows-1">Windows</a></h4>
<p>你需要遵循与之前<a href="#windows">相同的安装说明</a>，但选择不同的版本。你可以<a href="https://nodejs.org/en/download/releases/">在此处</a>查看所有可用版本的列表。</p>
<h2 id="3-创建新的hardhat项目"><a class="header" href="#3-创建新的hardhat项目">3. 创建新的Hardhat项目</a></h2>
<p>我们将使用 Node.js 的包管理器（<code>npm</code>）来安装 Hardhat，NPM 是一个 Node.js 软件包管理器和一个 JavaScript 代码库。</p>
<p>你可以使用 Node.js 的其它包管理器，但是我们建议你按照这个手册使用 npm 7 或者更高的版本。如果你遵循了之前的章节步骤，那么应该已经安装了它。</p>
<p>打开一个新终端，运行以下命令来创建一个新的目录：</p>
<pre><code>mkdir hardhat-tutorial
cd hardhat-tutorial
</code></pre>
<p>然后初始化一个 npm 项目，如下所示。系统将提示你回答一些问题。</p>
<p>::::提示</p>
<p>使用代码段中的选项卡选择首选的包管理器。我们建议使用 npm7 或更高版本，因为它使安装 Hardhat 的依赖关系变得更容易。</p>
<p>::::</p>
<p>::::tabsgroup{options=&quot;npm 7+,npm 6,yarn&quot;}</p>
<p>:::tab{value=&quot;npm 7+&quot;}</p>
<pre><code>npm init
</code></pre>
<p>:::</p>
<p>:::tab{value=&quot;npm 6&quot;}</p>
<pre><code>npm init
</code></pre>
<p>:::</p>
<p>:::tab{value=yarn}</p>
<pre><code>yarn init
</code></pre>
<p>:::</p>
<p>::::</p>
<p>现在我们可以安装 Hardhat：</p>
<p>::::tabsgroup{options=&quot;npm 7+,npm 6,yarn&quot;}</p>
<p>:::tab{value=&quot;npm 7+&quot;}</p>
<pre><code>npm install --save-dev hardhat
</code></pre>
<p>:::</p>
<p>:::tab{value=&quot;npm 6&quot;}</p>
<pre><code>npm install --save-dev hardhat
</code></pre>
<p>:::</p>
<p>:::tab{value=yarn}</p>
<pre><code>yarn add --dev hardhat
</code></pre>
<p>:::</p>
<p>::::</p>
<p>在安装 Hardhat 的同一目录中运行以下命令：</p>
<pre><code>npx hardhat
</code></pre>
<p>使用你的键盘选择 <code>Create an empty hardhat.config.js</code> 并且按下回车键。</p>
<pre><code class="language-markup{16}">$ npx hardhat
888    888                      888 888               888
888    888                      888 888               888
888    888                      888 888               888
8888888888  8888b.  888d888 .d88888 88888b.   8888b.  888888
888    888     &quot;88b 888P&quot;  d88&quot; 888 888 &quot;88b     &quot;88b 888
888    888 .d888888 888    888  888 888  888 .d888888 888
888    888 888  888 888    Y88b 888 888  888 888  888 Y88b.
888    888 &quot;Y888888 888     &quot;Y88888 888  888 &quot;Y888888  &quot;Y888

👷 Welcome to Hardhat v2.9.9 👷‍

? What do you want to do? …
  Create a JavaScript project
  Create a TypeScript project
❯ Create an empty hardhat.config.js
  Quit
</code></pre>
<p>当 Hardhat 在运行时，它从当前工作目录开始搜索最近的 <code>hardhat.config.js</code> 文件。这个文件通常存在你项目的根目录下，而且一个空的 <code>hardhat.config.js</code> 文件已经足够可以让 Hardhat 去工作了。你的整个配置都包含在这个文件中。</p>
<h3 id="hardhat的架构"><a class="header" href="#hardhat的架构">Hardhat的架构</a></h3>
<p>Hardhat 是围绕任务和插件的概念设计的。Hardhat 的大部分功能来自插件，你可以自由选择想要使用的<a href="https://hardhat.org/hardhat-runner/plugins">插件</a>。</p>
<h4 id="任务"><a class="header" href="#任务">任务</a></h4>
<p>每次从命令行运行 Hardhat 时，都在运行一个任务。例如，<code>npx hardhat compile</code> 正在运行 <code>compile</code> 任务。要查看项目中当前可用的任务，运行 <code>npx hardhat</code>。你可以通过运行 <code>npx hardhat help [task]</code> 来探索任何任务。</p>
<p>:::提示</p>
<p>你可以创建你自己的任务，可参阅<a href="https://hardhat.org/hardhat-runner/docs/advanced/create-task">创建任务指南</a>。</p>
<p>:::</p>
<h4 id="插件"><a class="header" href="#插件">插件</a></h4>
<p>就最终使用的工具而言，Hardhat 是独立的，但它确实有一些内置的默认值。所有这些都可以被覆盖。大多数情况下，使用给定工具的方法是使用将其集成到 Hardhat 中的插件。</p>
<p>在本教程中，我们将使用我们推荐的插件，<a href="https://hardhat.org/hardhat-runner/plugins/nomicfoundation-hardhat-toolbox"><code>@nomicfoundation/hardhat-toolbox</code></a>，它提供了开发智能合约所需的一切。</p>
<p>要安装它，请在项目目录中运行此命令：</p>
<p>::::tabsgroup{options=&quot;npm 7+,npm 6,yarn&quot;}</p>
<p>:::tab{value=&quot;npm 7+&quot;}</p>
<pre><code>npm install --save-dev @nomicfoundation/hardhat-toolbox
</code></pre>
<p>:::</p>
<p>:::tab{value=&quot;npm 6&quot;}</p>
<pre><code>npm install --save-dev @nomicfoundation/hardhat-toolbox @nomicfoundation/hardhat-network-helpers @nomicfoundation/hardhat-chai-matchers @nomiclabs/hardhat-ethers @nomiclabs/hardhat-etherscan chai ethers hardhat-gas-reporter solidity-coverage @typechain/hardhat typechain @typechain/ethers-v5 @ethersproject/abi @ethersproject/providers
</code></pre>
<p>:::</p>
<p>:::tab{value=yarn}</p>
<pre><code>yarn add --dev @nomicfoundation/hardhat-toolbox @nomicfoundation/hardhat-network-helpers @nomicfoundation/hardhat-chai-matchers @nomiclabs/hardhat-ethers @nomiclabs/hardhat-etherscan chai ethers hardhat-gas-reporter solidity-coverage @typechain/hardhat typechain @typechain/ethers-v5 @ethersproject/abi @ethersproject/providers
</code></pre>
<p>:::</p>
<p>::::</p>
<p>将高亮显示的行添加到 <code>hardhat.config.js</code> 中，使其看起来像这样：</p>
<pre><code class="language-js{1}">require(&quot;@nomicfoundation/hardhat-toolbox&quot;);

/** @type import('hardhat/config').HardhatUserConfig */
module.exports = {
  solidity: &quot;0.8.9&quot;,
};
</code></pre>
<h2 id="4-编写和编译合约"><a class="header" href="#4-编写和编译合约">4. 编写和编译合约</a></h2>
<p>我们将创建一个简单的智能合约，它会实现一个可以交易的 token。Token 合约最常用于交换和存储价值。在本教程中，我们不会深入研究合约的 Solidity 代码，但你应该知道我们实现的一些逻辑：</p>
<ul>
<li>Token 的总供应量是固定的，不能更改。</li>
<li>Token 的整个供应量分配给部署合约的账户地址。</li>
<li>任何人都可以收到 Token。</li>
<li>任何拥有至少一个 Token 的人都可以转移 Token。</li>
<li>Token 是不可分割的。你可以转移1、2、3或37个 Token，但不能转移2.5个。</li>
</ul>
<p>:::提示</p>
<p>你可能听说过 ERC-20，这是以太坊的一个 token 标准。token 如 DAI 和 USDC 实现了 ERC-20 标准，这使得它们都可以与任何可以处理 ERC-20 token 的软件兼容。为了简单起见，我们将要构建的 token 不实现 ERC-20 标准。</p>
<p>:::</p>
<h3 id="编写智能合约"><a class="header" href="#编写智能合约">编写智能合约</a></h3>
<p>开始创建一个名为 <code>contracts</code> 的新文件夹，并且在文件中创建一个名为 <code>Token.sol</code> 的文件。</p>
<p>粘贴下面的的代码到文件中，并且花一分钟通读以下这段代码。它很简单，而且充满了解释 Solidity 基本原理的注释。</p>
<p>:::提示</p>
<p>要在 Visual Studio Code 中为 solididity 获得语法高亮显示和编辑帮助，请尝试在<a href="https://marketplace.visualstudio.com/items?itemName=NomicFoundation.hardhat-solidity">Hardhat for Visual Studio Code</a>。</p>
<p>:::</p>
<pre><code class="language-solidity">//SPDX-License-Identifier: UNLICENSED

// Solidity文件必须以这个pragma开头。
// 它将被Solidity编译器用来验证它的版本。
pragma solidity ^0.8.9;


// 这是智能合约的主要构建模块。
contract Token {
    // 一些用于标识token的字符串类型变量。
    string public name = &quot;My Hardhat Token&quot;;
    string public symbol = &quot;MHT&quot;;

    // 固定数量的tokens，存储在无符号整数类型变量中。
    uint256 public totalSupply = 1000000;

    // 一个地址类型变量被用作存储以太坊账户。
    address public owner;

    // 一个key/value键值对map映射。我们在这里存储每个账户的余额。
    mapping(address =&gt; uint256) balances;

    // 这个转让事件帮助链下应用理解在你的合约中发生的什么。
    event Transfer(address indexed _from, address indexed _to, uint256 _value);

    /**
     * 合约初始化。
     */
    constructor() {
        // 这个总供应量被分配给交易发送者，它是部署这个合约的账户。
        balances[msg.sender] = totalSupply;
        owner = msg.sender;
    }

    /**
     * 转移tokens的函数。
     *
     * 这个 `external` 修饰符会使一个函数仅可以在这个合约外部被调用。
     */
    function transfer(address to, uint256 amount) external {
        // 检查这个交易发送者是否有足够的tokens。
        // 如果 `require` 的第一个参数等价于 `false` 那么这个交易将会恢复。
        require(balances[msg.sender] &gt;= amount, &quot;Not enough tokens&quot;);

        // 转移金额。
        balances[msg.sender] -= amount;
        balances[to] += amount;

        // 将转移通知链下应用程序。
        emit Transfer(msg.sender, to, amount);
    }

    /**
     * 只读函数，用于检索给定账户的token余额。
     * 这个 `view` 修饰符表明它不能修改合约的状态，它允许我们不需要执行一个交易而调用它。
     */
    function balanceOf(address account) external view returns (uint256) {
        return balances[account];
    }
}
</code></pre>
<p>:::提示</p>
<p><code>*.sol</code> 是Solidity合约文件的后缀。我们建议将文件名与其包含的合约名保持一致，这是一种常见的做法。</p>
<p>:::</p>
<h3 id="编译智能合约"><a class="header" href="#编译智能合约">编译智能合约</a></h3>
<p>要编译合约，可在你的终端中运行 <code>npx hardhat compile</code>。<code>compile</code> 任务是内置任务之一。</p>
<pre><code>$ npx hardhat compile
Compiling 1 file with 0.8.9
Compilation finished successfully
</code></pre>
<p>这个合约已经成功编译了，它可以准备被使用了。</p>
<h2 id="5-测试合约"><a class="header" href="#5-测试合约">5. 测试合约</a></h2>
<p>在构建智能合约时编写自动化测试是至关重要的，因为这关系到用户的钱。</p>
<p>为了测试我们的合约，我们将使用 Hardhat Network，这是一个为开发而设计的本地以太坊网络。它内置在 Hardhat 中，被用作默认网络。使用它不需要设置任何东西。</p>
<p>在我们的测试中，我将使用 <a href="https://docs.ethers.io/v5/">ethers.js</a> 与我们在上一节中构建的以太坊合约进行交互，并且我们将使用 <a href="https://mochajs.org/">Mocha</a> 作为我们的测试运行者。</p>
<h3 id="编写测试"><a class="header" href="#编写测试">编写测试</a></h3>
<p>在项目根目录中创建一个名为 <code>test</code> 的新目录，并在其中创建一个名为 <code>Token.js</code> 的新文件。</p>
<p>让我们从下面的代码开始。接下来我们将解释它，但现在将其粘贴到 <code>Token.js</code> 中：</p>
<pre><code class="language-js">const { expect } = require(&quot;chai&quot;);

describe(&quot;Token contract&quot;, function () {
  it(&quot;Deployment should assign the total supply of tokens to the owner&quot;, async function () {
    const [owner] = await ethers.getSigners();

    const Token = await ethers.getContractFactory(&quot;Token&quot;);

    const hardhatToken = await Token.deploy();

    const ownerBalance = await hardhatToken.balanceOf(owner.address);
    expect(await hardhatToken.totalSupply()).to.equal(ownerBalance);
  });
});
</code></pre>
<p>在你的终端中运行 <code>npx hardhat test</code>。你应该会看到如下的输出：</p>
<pre><code>$ npx hardhat test

  Token contract
    ✓ Deployment should assign the total supply of tokens to the owner (654ms)


  1 passing (663ms)
</code></pre>
<p>这意味着测试通过了。现在让我们解释每一行代码：</p>
<pre><code class="language-js">const [owner] = await ethers.getSigners();
</code></pre>
<p>ethers.js 中的 <code>Signer</code> 是代表以太坊帐户的对象。它被用于向合约和其他账户发送交易。这里我们得到连接到了节点上的账户列表，在本例中是 Hardhat Network，我们只保留第一个。</p>
<p><code>ethers</code> 变量在全局作用域中可用。如果你希望你的代码总是显式的，你可以在顶部添加这一行：</p>
<pre><code class="language-js">const { ethers } = require(&quot;hardhat&quot;);
</code></pre>
<p>:::提示</p>
<p>要学习更多关于 <code>Signer</code> 的内容，你可以查看 <a href="https://docs.ethers.io/v5/api/signer/">Signers 文档</a>。</p>
<p>:::</p>
<pre><code class="language-js">const Token = await ethers.getContractFactory(&quot;Token&quot;);
</code></pre>
<p>ethers.js 中的 <code>ContractFactory</code> 是一个用于部署新智能合约的抽象，因此这里的 <code>Token</code> 是 token 合约实例的工厂。</p>
<pre><code class="language-js">const hardhatToken = await Token.deploy();
</code></pre>
<p>在 <code>ContractFactory</code> 上调用 <code>deploy()</code> 将启动部署，并且返回一个解决为 <code>Contract</code> 的 <code>Promise</code>。这个对象为每个智能合约函数都提供了一个方法。</p>
<pre><code class="language-js">const ownerBalance = await hardhatToken.balanceOf(owner.address);
</code></pre>
<p>一旦这个合约被部署后，我们可以在 <code>hardhatToken</code> 上调用我们的合约方法。这里我们通过调用合约的 <code>balanceOf()</code> 方法，获得所有者账户的余额。</p>
<p>重新调用将会获得部署 token 的帐户的全部供应总量。默认情况下，<code>ContractFactory</code> 和 <code>Contract</code> 实例连接到第一个签名者。这意味着 <code>owner</code> 变量中的帐户执行了部署，并且 <code>balanceOf()</code> 应该返回整个供应总额。</p>
<pre><code class="language-js">expect(await hardhatToken.totalSupply()).to.equal(ownerBalance);
</code></pre>
<p>这里在我们的 Solidity 代码中，我们再次使用 <code>Contract</code> 实例去调用一个智能合约函数。<code>totalSupply()</code> 返回这个 token 供应总额，并且我们将检查它是否等价于 <code>ownerBalance</code>，正如它应该的那样。</p>
<p>为此，我们使用了 <a href="https://www.chaijs.com/">Chai</a>，这是一个流行的 JavaScript 断言库。这些断言函数被叫做 &quot;matchers&quot;，我们在这里使用的是来自 <a href="https://hardhat.org/hardhat-runner/plugins/nomicfoundation-hardhat-chai-matchers"><code>@nomicfoundation/hardhat-chai-matchers</code></a> 插件，它扩展了 Chai，提供了许多用于测试智能合约的匹配器。</p>
<h4 id="使用不同的账户"><a class="header" href="#使用不同的账户">使用不同的账户</a></h4>
<p>如果你需要从默认帐户以外的其他帐户（或 ethers.js 中的 <code>Signer</code>）发送交易来测试代码，则可以在 ethers.js 的 <code>Contract</code> 中使用 <code>connect()</code> 方法来将其连接到其他帐户，像这样：</p>
<pre><code class="language-js{18}">const { expect } = require(&quot;chai&quot;);

describe(&quot;Token contract&quot;, function () {
  // ...previous test...

  it(&quot;Should transfer tokens between accounts&quot;, async function() {
    const [owner, addr1, addr2] = await ethers.getSigners();

    const Token = await ethers.getContractFactory(&quot;Token&quot;);

    const hardhatToken = await Token.deploy();

    // Transfer 50 tokens from owner to addr1
    await hardhatToken.transfer(addr1.address, 50);
    expect(await hardhatToken.balanceOf(addr1.address)).to.equal(50);

    // Transfer 50 tokens from addr1 to addr2
    await hardhatToken.connect(addr1).transfer(addr2.address, 50);
    expect(await hardhatToken.balanceOf(addr2.address)).to.equal(50);
  });
});
</code></pre>
<h4 id="使用fixtures复用常见的测试配置"><a class="header" href="#使用fixtures复用常见的测试配置">使用fixtures复用常见的测试配置</a></h4>
<p>我们编写的两个测试从它们的设置开始，在本例中这意味着部署 token 合约。在更复杂的项目中，此设置可能涉及多个部署和其他事务。在每个测试中都这样做意味着大量的重复代码。另外，在每个测试开始时执行许多事务会使测试套件变得更慢。</p>
<p>通过使用 <strong>fixtures</strong>，你可以避免代码重复并提高测试套件的性能。fixture 是只在第一次调用时运行的设置函数。在随后的调用中，Hardhat 不会重新运行它，而是将网络的状态重置为 fixture 最初执行后的状态。</p>
<pre><code class="language-js">const { loadFixture } = require(&quot;@nomicfoundation/hardhat-network-helpers&quot;);
const { expect } = require(&quot;chai&quot;);

describe(&quot;Token contract&quot;, function () {
  async function deployTokenFixture() {
    const Token = await ethers.getContractFactory(&quot;Token&quot;);
    const [owner, addr1, addr2] = await ethers.getSigners();

    const hardhatToken = await Token.deploy();

    await hardhatToken.deployed();

    // Fixtures can return anything you consider useful for your tests
    return { Token, hardhatToken, owner, addr1, addr2 };
  }

  it(&quot;Should assign the total supply of tokens to the owner&quot;, async function () {
    const { hardhatToken, owner } = await loadFixture(deployTokenFixture);

    const ownerBalance = await hardhatToken.balanceOf(owner.address);
    expect(await hardhatToken.totalSupply()).to.equal(ownerBalance);
  });

  it(&quot;Should transfer tokens between accounts&quot;, async function () {
    const { hardhatToken, owner, addr1, addr2 } = await loadFixture(
      deployTokenFixture
    );

    // Transfer 50 tokens from owner to addr1
    await expect(
      hardhatToken.transfer(addr1.address, 50)
    ).to.changeTokenBalances(hardhatToken, [owner, addr1], [-50, 50]);

    // Transfer 50 tokens from addr1 to addr2
    // We use .connect(signer) to send a transaction from another account
    await expect(
      hardhatToken.connect(addr1).transfer(addr2.address, 50)
    ).to.changeTokenBalances(hardhatToken, [addr1, addr2], [-50, 50]);
  });
});
</code></pre>
<p>在这里，我们编写了一个 <code>deployTokenFixture</code> 函数，该函数执行必要的设置并返回稍后在测试中使用的每个值。然后在每个测试中，我们使用 <code>loadFixture</code> 来运行 fixture 并获取这些值。<code>loadFixture</code> 将在第一次运行设置，并在其他测试中迅速返回到该状态。</p>
<h4 id="完整的测试覆盖"><a class="header" href="#完整的测试覆盖">完整的测试覆盖</a></h4>
<p>现在我们已经介绍了测试合约所需的基本知识，下面是 token 的完整测试套件，其中包含大量关于 Mocha 以及如何组织测试的附加信息。我们建议你仔细阅读。</p>
<pre><code class="language-js">// This is an example test file. Hardhat will run every *.js file in `test/`,
// so feel free to add new ones.

// Hardhat tests are normally written with Mocha and Chai.

// We import Chai to use its asserting functions here.
const { expect } = require(&quot;chai&quot;);

// We use `loadFixture` to share common setups (or fixtures) between tests.
// Using this simplifies your tests and makes them run faster, by taking
// advantage of Hardhat Network's snapshot functionality.
const { loadFixture } = require(&quot;@nomicfoundation/hardhat-network-helpers&quot;);

// `describe` is a Mocha function that allows you to organize your tests.
// Having your tests organized makes debugging them easier. All Mocha
// functions are available in the global scope.
//
// `describe` receives the name of a section of your test suite, and a
// callback. The callback must define the tests of that section. This callback
// can't be an async function.
describe(&quot;Token contract&quot;, function () {
  // We define a fixture to reuse the same setup in every test. We use
  // loadFixture to run this setup once, snapshot that state, and reset Hardhat
  // Network to that snapshot in every test.
  async function deployTokenFixture() {
    // Get the ContractFactory and Signers here.
    const Token = await ethers.getContractFactory(&quot;Token&quot;);
    const [owner, addr1, addr2] = await ethers.getSigners();

    // To deploy our contract, we just have to call Token.deploy() and await
    // its deployed() method, which happens once its transaction has been
    // mined.
    const hardhatToken = await Token.deploy();

    await hardhatToken.deployed();

    // Fixtures can return anything you consider useful for your tests
    return { Token, hardhatToken, owner, addr1, addr2 };
  }

  // You can nest describe calls to create subsections.
  describe(&quot;Deployment&quot;, function () {
    // `it` is another Mocha function. This is the one you use to define each
    // of your tests. It receives the test name, and a callback function.
    //
    // If the callback function is async, Mocha will `await` it.
    it(&quot;Should set the right owner&quot;, async function () {
      // We use loadFixture to setup our environment, and then assert that
      // things went well
      const { hardhatToken, owner } = await loadFixture(deployTokenFixture);

      // `expect` receives a value and wraps it in an assertion object. These
      // objects have a lot of utility methods to assert values.

      // This test expects the owner variable stored in the contract to be
      // equal to our Signer's owner.
      expect(await hardhatToken.owner()).to.equal(owner.address);
    });

    it(&quot;Should assign the total supply of tokens to the owner&quot;, async function () {
      const { hardhatToken, owner } = await loadFixture(deployTokenFixture);
      const ownerBalance = await hardhatToken.balanceOf(owner.address);
      expect(await hardhatToken.totalSupply()).to.equal(ownerBalance);
    });
  });

  describe(&quot;Transactions&quot;, function () {
    it(&quot;Should transfer tokens between accounts&quot;, async function () {
      const { hardhatToken, owner, addr1, addr2 } = await loadFixture(
        deployTokenFixture
      );
      // Transfer 50 tokens from owner to addr1
      await expect(
        hardhatToken.transfer(addr1.address, 50)
      ).to.changeTokenBalances(hardhatToken, [owner, addr1], [-50, 50]);

      // Transfer 50 tokens from addr1 to addr2
      // We use .connect(signer) to send a transaction from another account
      await expect(
        hardhatToken.connect(addr1).transfer(addr2.address, 50)
      ).to.changeTokenBalances(hardhatToken, [addr1, addr2], [-50, 50]);
    });

    it(&quot;should emit Transfer events&quot;, async function () {
      const { hardhatToken, owner, addr1, addr2 } = await loadFixture(
        deployTokenFixture
      );

      // Transfer 50 tokens from owner to addr1
      await expect(hardhatToken.transfer(addr1.address, 50))
        .to.emit(hardhatToken, &quot;Transfer&quot;)
        .withArgs(owner.address, addr1.address, 50);

      // Transfer 50 tokens from addr1 to addr2
      // We use .connect(signer) to send a transaction from another account
      await expect(hardhatToken.connect(addr1).transfer(addr2.address, 50))
        .to.emit(hardhatToken, &quot;Transfer&quot;)
        .withArgs(addr1.address, addr2.address, 50);
    });

    it(&quot;Should fail if sender doesn't have enough tokens&quot;, async function () {
      const { hardhatToken, owner, addr1 } = await loadFixture(
        deployTokenFixture
      );
      const initialOwnerBalance = await hardhatToken.balanceOf(owner.address);

      // Try to send 1 token from addr1 (0 tokens) to owner.
      // `require` will evaluate false and revert the transaction.
      await expect(
        hardhatToken.connect(addr1).transfer(owner.address, 1)
      ).to.be.revertedWith(&quot;Not enough tokens&quot;);

      // Owner balance shouldn't have changed.
      expect(await hardhatToken.balanceOf(owner.address)).to.equal(
        initialOwnerBalance
      );
    });
  });
});
</code></pre>
<p>这是针对完整测试套件的 <code>npx hardhat test</code> 的输出：</p>
<pre><code>$ npx hardhat test

  Token contract
    Deployment
      ✓ Should set the right owner
      ✓ Should assign the total supply of tokens to the owner
    Transactions
      ✓ Should transfer tokens between accounts (199ms)
      ✓ Should fail if sender doesn’t have enough tokens
      ✓ Should update balances after transfers (111ms)


  5 passing (1s)
</code></pre>
<p>请记住，当你运行 <code>npx hardhat test</code> 时，如果自上次运行测试以来合约发生了更改，则会自动编译它们。</p>
<h2 id="6-使用hardhat网络进行调试"><a class="header" href="#6-使用hardhat网络进行调试">6. 使用Hardhat网络进行调试</a></h2>
<p>Hardhat 内置了 Hardhat 网络，这是一个专为开发设计的以太坊网络。它允许你部署合约，运行测试和调试代码，所有这些都在本地机器的范围内。它是 Hardhat 所连接的默认网络，因此你无需任何设置即可工作。你只需运行测试就好。</p>
<h2 id="solidity-consolelog"><a class="header" href="#solidity-consolelog">Solidity <code>console.log</code></a></h2>
<p>在 Hardhat 网络上运行合约和测试时，你可以在 Solidity 代码中调用 <code>console.log()</code> 打印日志信息和合约变量。你必须先从合约代码中导入 <code>hardhat/console.sol</code> 再使用它。</p>
<p>就像这样：</p>
<pre><code class="language-solidity{3}">pragma solidity ^0.8.9;

import &quot;hardhat/console.sol&quot;;

contract Token {
  //...
}
</code></pre>
<p>就像在 JavaScript 中使用一样，然后你只需在 <code>transfer()</code> 函数中添加一些 <code>console.log</code> 调用：</p>
<pre><code class="language-solidity{4-9}">function transfer(address to, uint256 amount) external {
    require(balances[msg.sender] &gt;= amount, &quot;Not enough tokens&quot;);

    console.log(
        &quot;Transferring from %s to %s %s tokens&quot;,
        msg.sender,
        to,
        amount
    );

    balances[msg.sender] -= amount;
    balances[to] += amount;

    emit Transfer(msg.sender, to, amount);
}
</code></pre>
<p>运行测试时将显示日志输出：</p>
<pre><code class="language-markup{8-11 14-17}">$ npx hardhat test

  Token contract
    Deployment
      ✓ Should set the right owner
      ✓ Should assign the total supply of tokens to the owner
    Transactions
Transferring from 0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266 to 0x70997970c51812dc3a010c7d01b50e0d17dc79c8 50 tokens
Transferring from 0x70997970c51812dc3a010c7d01b50e0d17dc79c8 to 0x3c44cdddb6a900fa2b585dd299e03d12fa4293bc 50 tokens
      ✓ Should transfer tokens between accounts (373ms)
      ✓ Should fail if sender doesn’t have enough tokens
Transferring from 0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266 to 0x70997970c51812dc3a010c7d01b50e0d17dc79c8 50 tokens
Transferring from 0x70997970c51812dc3a010c7d01b50e0d17dc79c8 to 0x3c44cdddb6a900fa2b585dd299e03d12fa4293bc 50 tokens
      ✓ Should update balances after transfers (187ms)


  5 passing (2s)
</code></pre>
<p>查看<a href="https://hardhat.org/hardhat-network/docs/overview#console.log">文档</a>以了解更多关于该特性的信息。</p>
<h2 id="7-部署到真实网络"><a class="header" href="#7-部署到真实网络">7. 部署到真实网络</a></h2>
<p>一旦你准备好与其他人分享 dApp 后，你可能要做的就是将其部署到一个真实的以太坊网络中。这样，其他人就可以访问不在本地系统上运行的实例了。</p>
<p>具有处理真实金钱的以太坊网络被称为“主网”，然后还有一些独立的“测试网”可以使用。这些测试网提供了共享的登录环境，可以很好地模拟真实世界的场景，而不需要投入真正的金钱，这里有几个<a href="https://ethereum.org/zh/developers/docs/networks/#ethereum-testnets">以太坊测试网</a>，像 <em>Goerli</em> 和 <em>Sepolia</em>。我们推荐你部署你的合约到 <em>Goerli</em> 测试网。</p>
<p>在软件级别，部署到测试网与部署到主网相同。唯一的区别是你连接到的哪个网络。让我们看看使用 ether.js 部署合约的代码是什么样的。</p>
<p>使用的主要概念是 <code>Signer</code>、<code>ContractFactory</code> 和 <code>Contract</code>，我们在<a href="#5-%E6%B5%8B%E8%AF%95%E5%90%88%E7%BA%A6">测试</a>部分中对此进行了解释。与测试相比，没有什么新东西需要做，因为当你测试合约时，实际上是在向开发网络进行部署。这使得代码非常相似，甚至完全相同。</p>
<p>让我们在项目根目录中创建一个新的目录 <code>scripts</code>，并将以下内容粘贴到该目录中的 <code>deploy.js</code> 文件中：</p>
<pre><code class="language-js">async function main() {
  const [deployer] = await ethers.getSigners();

  console.log(&quot;Deploying contracts with the account:&quot;, deployer.address);

  console.log(&quot;Account balance:&quot;, (await deployer.getBalance()).toString());

  const Token = await ethers.getContractFactory(&quot;Token&quot;);
  const token = await Token.deploy();

  console.log(&quot;Token address:&quot;, token.address);
}

main()
  .then(() =&gt; process.exit(0))
  .catch((error) =&gt; {
    console.error(error);
    process.exit(1);
  });
</code></pre>
<p>要告诉 Hardhat 连接到特定的以太坊网络，可以在运行任何任务时使用 <code>--network</code> 参数，如下所示</p>
<pre><code>npx hardhat run scripts/deploy.js --network &lt;network-name&gt;
</code></pre>
<p>对于我们当前的配置，在没有 <code>--network</code> 参数的情况下运行它将导致代码针对 Hardhat 网络的嵌入式实例运行。在这种情况下，当 Hardhat 完成运行时，部署实际上会丢失，但测试我们的部署代码是否有效仍然很有用：</p>
<pre><code>$ npx hardhat run scripts/deploy.js
Deploying contracts with the account: 0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266
Account balance: 10000000000000000000000
Token address: 0x5FbDB2315678afecb367f032d93F642f64180aa3
</code></pre>
<h2 id="部署到远程网络"><a class="header" href="#部署到远程网络">部署到远程网络</a></h2>
<p>要部署到诸如主网或任何测试网之类的远程网络，你需要添加一个 <code>network</code> 入口到你的 <code>hardhat.config.js</code> 文件中。在这个例子中，我们将使用 Goerli，但是你也可以添加任何类似的网络：</p>
<pre><code class="language-js{5 11 15-20}">require(&quot;@nomicfoundation/hardhat-toolbox&quot;);

// Go to https://www.alchemyapi.io, sign up, create
// a new App in its dashboard, and replace &quot;KEY&quot; with its key
const ALCHEMY_API_KEY = &quot;KEY&quot;;

// Replace this private key with your Goerli account private key
// To export your private key from Metamask, open Metamask and
// go to Account Details &gt; Export Private Key
// Beware: NEVER put real Ether into testing accounts
const GOERLI_PRIVATE_KEY = &quot;YOUR GOERLI PRIVATE KEY&quot;;

module.exports = {
  solidity: &quot;0.8.9&quot;,
  networks: {
    goerli: {
      url: `https://eth-goerli.alchemyapi.io/v2/${ALCHEMY_API_KEY}`,
      accounts: [GOERLI_PRIVATE_KEY]
    }
  }
};
</code></pre>
<p>我们使用了 <a href="https://www.alchemyapi.io">Alchemy</a>, 但是你将 <code>url</code> 指向其他任何以太坊节点或网关都是可以的。请填入你自己的 <code>ALCHEMY_API_KEY</code>。</p>
<p>要在 Goerli 上进行部署，你需要发送一些 Goerli ether 给将要进行部署的地址。你可以从水龙头获得测试网以太，这是一项免费分发测试 ETH 的服务。下面这些是给 Goerli 的：</p>
<ul>
<li><a href="https://faucets.chain.link/">Chainlink faucet</a></li>
<li><a href="https://goerlifaucet.com/">Alchemy Goerli Faucet</a></li>
</ul>
<p>你必须在交易前将 Metamask 的网络更改为 Goerli。</p>
<p>:::提示</p>
<p>你可以在 <a href="https://ethereum.org/zh/developers/docs/networks/#ethereum-testnets">ethereum.org</a> 网站上了解更多关于其他测试网的信息，并找到它们的水龙头链接。</p>
<p>:::</p>
<p>最终，运行：</p>
<pre><code>npx hardhat run scripts/deploy.js --network goerli
</code></pre>
<p>如果一切正常，你应该会看到部署的合约地址。</p>
<h2 id="8-前端模板项目"><a class="header" href="#8-前端模板项目">8. 前端模板项目</a></h2>
<p>如果你想要快速开始使用 dApp 或使用前端查看整个项目，可以使用我们的 <a href="https://github.com/NomicFoundation/hardhat-boilerplate">boilerplate 库</a>。</p>
<h2 id="包含哪些内容"><a class="header" href="#包含哪些内容">包含哪些内容</a></h2>
<ul>
<li>本次教程中我们使用的 Solidity 合约</li>
<li>测试合约的整个功能</li>
<li>使用 ethers.js 与合约进行交互的最小 React 前端</li>
</ul>
<h3 id="solidity合约与测试"><a class="header" href="#solidity合约与测试">Solidity合约与测试</a></h3>
<p>在代码库的根目录中，你将找到我们通过本教程与 <code>Token</code> 合约组合在一起的 Hardhat 项目。</p>
<ul>
<li>token 的总供应量是固定的，不能更改。</li>
<li>整个供应被分配给部署合约的地址。</li>
<li>任何人都可以接收 token。</li>
<li>任何人至少有一个 token 都可以转让 token。</li>
<li>这个 token 是不可以分割的。你可以转让1、2、3或37个代币，但不能转让2.5个。</li>
</ul>
<h3 id="前端app"><a class="header" href="#前端app">前端app</a></h3>
<p>在 <code>frontend</code> 你会发现一个简单的 app，允许用户做两件事：</p>
<ul>
<li>检查连接钱包的余额</li>
<li>发送 token 到一个地址</li>
</ul>
<p>它是一个独立的 npm 项目，它是用 <code>create-react-app</code> 创建的，这意味着它使用了 webpack 和 babel。</p>
<h3 id="前端文件目录结构"><a class="header" href="#前端文件目录结构">前端文件目录结构</a></h3>
<ul>
<li><code>src/</code> 包含了所有代码
<ul>
<li><code>src/components</code> 包含了 react 组件
<ul>
<li><code>Dapp.js</code> 是唯一具有业务逻辑的文件。如果你把它用作为模板，可在此处用自己的代码替换它。</li>
<li>其他组件仅渲染HTML，没有逻辑。</li>
<li><code>src/contracts</code> 具有合约的 ABI 和地址，这些由部署脚本自动生成。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="如何使用它"><a class="header" href="#如何使用它">如何使用它</a></h2>
<p>首先克隆代码库，然后准备部署合约：</p>
<pre><code>cd hardhat-boilerplate
npm install
npx hardhat node
</code></pre>
<p>在这里，我们仅需要安装 npm 项目的依赖项，然后运行 <code>npx hardhat node</code> 启动一个可以供 MetaMask 连接的 Hardhat 网络。在同一目录下的另一个终端中运行如下命令：</p>
<pre><code>npx hardhat --network localhost run scripts/deploy.js
</code></pre>
<p>这会将合约部署到 Hardhat 网络。完成后，启动 react web app：</p>
<pre><code>cd frontend
npm install
npm run start
</code></pre>
<p>然后在你的浏览器中打开 <a href="http://127.0.0.1:3000/">http://127.0.0.1:3000/</a>，你应该会看到如下所示：
<img src="https://awesomeprogram.gitee.io/imgdata/tech_bc_hardfront-5.png" alt="" /></p>
<p>将 MetaMask 中的网络设置为 <code>127.0.0.1:8545</code>。</p>
<p>现在点击 web app 的按钮。你应该会看到如下所示：
<img src="https://awesomeprogram.gitee.io/imgdata/tech_bc_hardfront-2.png" alt="" /></p>
<p>这里发生的情况是，显示当前钱包余额，前端代码检测到余额为 <code>0</code>，因此你无法尝试转账功能。通过运行如下命令：</p>
<pre><code>npx hardhat --network localhost faucet &lt;your address&gt;
</code></pre>
<p>你将运行我们包含的自定义 Hardhat 任务，该任务使用部署帐户的余额向你的地址发送100个MHT和1个ETH。这将允许你向另一个地址发送 token。</p>
<p>你可以在 <a href="https://github.com/NomicFoundation/hardhat-boilerplate/blob/master/tasks/faucet.js"><code>/tasks/faucet.js</code></a> 查看该任务的代码，这是从 <code>hardhat.config.js</code> 中需要的。</p>
<pre><code>$ npx hardhat --network localhost faucet 0x0987a41e73e69f60c5071ce3c8f7e730f9a60f90
Transferred 1 ETH and 100 tokens to 0x0987a41e73e69f60c5071ce3c8f7e730f9a60f90
</code></pre>
<p>在运行 <code>npx hardhat node</code> 的终端中，你还应该看到：</p>
<pre><code class="language-markup{10-11}">eth_sendTransaction
  Contract call:       Token#transfer
  Transaction:         0x460526d98b86f7886cd0f218d6618c96d27de7c745462ff8141973253e89b7d4
  From:                0xc783df8a850f42e7f7e57013759c285caa701eb6
  To:                  0x7c2c195cd6d34b8f845992d380aadb2730bb9c6f
  Value:               0 ETH
  Gas used:            37098 of 185490
  Block #8:            0x6b6cd29029b31f30158bfbd12faf2c4ac4263068fd12b6130f5655e70d1bc257

  console.log:
    Transferring from 0xc783df8a850f42e7f7e57013759c285caa701eb6 to 0x0987a41e73e69f60c5071ce3c8f7e730f9a60f90 100 tokens
</code></pre>
<p>在我们的合约中显示 <code>transfer()</code> 函数的 <code>console.log</code> 输出，这就是运行水龙头任务后 web app 的样子：
<img src="https://awesomeprogram.gitee.io/imgdata/tech_bc_hardfront-6.png" alt="" /></p>
<p>尝试使用它并阅读代码。它充满了注释，解释了发生了什么，并清楚地指出什么是以太坊 boilerplate 代码，什么是 dApp 逻辑。这将使代码库易于为你的项目复用。</p>
<h2 id="9-最后的想法"><a class="header" href="#9-最后的想法">9. 最后的想法</a></h2>
<p>恭喜你完成本教程！</p>
<p>这里有一些链接，你可能会发现在你的 dApp 开发旅程中有用：</p>
<ul>
<li><a href="https://github.com/NomicFoundation/hardhat-boilerplate">Hardhat's Boilerplate</a></li>
<li><a href="https://hardhat.org/docs">Hardhat's documentation site</a></li>
<li><a href="https://hardhat.org/hardhat-runner/plugins/nomicfoundation-hardhat-toolbox">Hardhat Toolbox's documenation</a></li>
<li><a href="https://discord.com/invite/TETZs2KK4k">Hardhat Support Discord server</a></li>
<li><a href="https://docs.ethers.io/">Ethers.js Documentation</a></li>
<li><a href="https://mochajs.org/">Mocha Documentation</a></li>
<li><a href="https://www.chaijs.com/">Chai Documentation</a></li>
</ul>
<p>Happy hacking!</p>
<p><img src="https://awesomeprogram.gitee.io/imgdata/tech_bc_hardcool.svg" alt="" /></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../blockchain/chapter_1_3_2.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../cloud/chapter_1.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../blockchain/chapter_1_3_2.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../cloud/chapter_1.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>


        <!-- Google Analytics Tag -->
        <script type="text/javascript">
            var localAddrs = ["localhost", "127.0.0.1", ""];

            // make sure we don't activate google analytics if the developer is
            // inspecting the book locally...
            if (localAddrs.indexOf(document.location.hostname) === -1) {
                (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
                m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
                })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

                ga('create', 'G-ZHWPPT6ESV', 'auto');
                ga('send', 'pageview');
            }
        </script>


        <script type="text/javascript">
            window.playground_copyable = true;
        </script>

        <script src="../ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="../editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="../theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="../theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>

        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
