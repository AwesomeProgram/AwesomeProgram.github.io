<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>类型 &mdash; Solidity 0.8.13 documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="_static/a4_railroad_diagram.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/custom.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/toggle.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/sphinx_highlight.js"></script>
        <script src="_static/js/toggle.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="单位和全局变量" href="units-and-global-variables.html" />
    <link rel="prev" title="合约结构" href="structure-of-a-contract.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #65afff" >
            <a href="index.html">
            <img src="_static/logo.svg" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                0.8.13
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
    
              <p class="caption" role="heading"><span class="caption-text">Basics</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="introduction-to-smart-contracts.html">智能合约概述</a></li>
<li class="toctree-l1"><a class="reference internal" href="installing-solidity.html">安装 Solidity 编译器</a></li>
<li class="toctree-l1"><a class="reference internal" href="solidity-by-example.html">Solidity 合约示例</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Language Description</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="layout-of-source-files.html">Solidity 源文件结构</a></li>
<li class="toctree-l1"><a class="reference internal" href="structure-of-a-contract.html">合约结构</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">类型</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#value-types">值类型</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#index-2">布尔类型</a></li>
<li class="toctree-l3"><a class="reference internal" href="#integers">整型</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id5">比较运算</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id6">位运算</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id7">移位运算</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id8">加法、减法和乘法</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id9">除法</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id10">取余</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id11">幂运算</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#index-4">定长浮点型</a></li>
<li class="toctree-l3"><a class="reference internal" href="#address">地址类型</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#members-of-addresses">地址类型成员变量</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#contract-types">合约类型</a></li>
<li class="toctree-l3"><a class="reference internal" href="#index-7">定长字节数组</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id17">变长字节数组</a></li>
<li class="toctree-l3"><a class="reference internal" href="#address-literals">地址字面常数（Address Literals）</a></li>
<li class="toctree-l3"><a class="reference internal" href="#rational-literals">有理数和整数字面常数</a></li>
<li class="toctree-l3"><a class="reference internal" href="#string-literals">字符串字面常数和类型</a></li>
<li class="toctree-l3"><a class="reference internal" href="#unicode">Unicode 字面常数</a></li>
<li class="toctree-l3"><a class="reference internal" href="#index-11">十六进制字面常数</a></li>
<li class="toctree-l3"><a class="reference internal" href="#enums">枚举类型</a></li>
<li class="toctree-l3"><a class="reference internal" href="#user-defined-value-types">用户定义的值类型</a></li>
<li class="toctree-l3"><a class="reference internal" href="#function-types">函数类型</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#reference-types">引用类型</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#data-location">数据位置</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#data-location-assignment">数据位置和分配行为</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#arrays">数组</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#bytes-string"><code class="docutils literal notranslate"><span class="pre">bytes</span></code> 和 <code class="docutils literal notranslate"><span class="pre">string</span></code> 类型的数组</a></li>
<li class="toctree-l4"><a class="reference internal" href="#bytes-concat-string-concat">函数 <code class="docutils literal notranslate"><span class="pre">bytes.concat</span></code> 和 <code class="docutils literal notranslate"><span class="pre">string.concat</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#index-19">创建内存数组</a></li>
<li class="toctree-l4"><a class="reference internal" href="#index-20">数组字面常数</a></li>
<li class="toctree-l4"><a class="reference internal" href="#array-members">数组成员</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#array-slices">数组切片</a></li>
<li class="toctree-l3"><a class="reference internal" href="#structs">结构体</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#mapping-types">映射类型</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#iterable-mappings">递归映射</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#index-26">运算符</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#index-27">复数和增量/减量运算符</a></li>
<li class="toctree-l3"><a class="reference internal" href="#delete">删除</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#types-conversion-elementary-types">基本类型之间的转换</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id41">隐式转换</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id42">显式转换</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#types-conversion-literals">字面常数和基本类型之间的转换</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id44">整数类型</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id45">固定大小的字节数组</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id46">地址类型</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="units-and-global-variables.html">单位和全局变量</a></li>
<li class="toctree-l1"><a class="reference internal" href="control-structures.html">表达式和控制结构</a></li>
<li class="toctree-l1"><a class="reference internal" href="contracts.html">合约</a></li>
<li class="toctree-l1"><a class="reference internal" href="assembly.html">内联汇编</a></li>
<li class="toctree-l1"><a class="reference internal" href="cheatsheet.html">速查表</a></li>
<li class="toctree-l1"><a class="reference internal" href="grammar.html">语法</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Compiler</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="using-the-compiler.html">使用编译器</a></li>
<li class="toctree-l1"><a class="reference internal" href="analysing-compilation-output.html">分析编译器的输出结果</a></li>
<li class="toctree-l1"><a class="reference internal" href="ir-breaking-changes.html">基于Solidity中间表征的Codegen变化</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Internals</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="internals/layout_in_storage.html">存储中的状态变量储存结构</a></li>
<li class="toctree-l1"><a class="reference internal" href="internals/layout_in_memory.html">内存中的存储结构</a></li>
<li class="toctree-l1"><a class="reference internal" href="internals/layout_in_calldata.html">调用数据的存储结构</a></li>
<li class="toctree-l1"><a class="reference internal" href="internals/variable_cleanup.html">清理变量</a></li>
<li class="toctree-l1"><a class="reference internal" href="internals/source_mappings.html">源代码映射</a></li>
<li class="toctree-l1"><a class="reference internal" href="internals/optimizer.html">优化器</a></li>
<li class="toctree-l1"><a class="reference internal" href="metadata.html">合约的元数据</a></li>
<li class="toctree-l1"><a class="reference internal" href="abi-spec.html">合约ABI规范</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Additional Material</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="050-breaking-changes.html">Solidity v0.5.0 突破性变化</a></li>
<li class="toctree-l1"><a class="reference internal" href="060-breaking-changes.html">Solidity 0.6.0 版本突破性变化</a></li>
<li class="toctree-l1"><a class="reference internal" href="070-breaking-changes.html">Solidity v0.7.0 突破性变化</a></li>
<li class="toctree-l1"><a class="reference internal" href="080-breaking-changes.html">Solidity v0.8.0 突破性变化</a></li>
<li class="toctree-l1"><a class="reference internal" href="natspec-format.html">风格指南</a></li>
<li class="toctree-l1"><a class="reference internal" href="security-considerations.html">安全考虑</a></li>
<li class="toctree-l1"><a class="reference internal" href="smtchecker.html">SMT检查器和形式化验证</a></li>
<li class="toctree-l1"><a class="reference internal" href="resources.html">资源</a></li>
<li class="toctree-l1"><a class="reference internal" href="path-resolution.html">Import Path Resolution</a></li>
<li class="toctree-l1"><a class="reference internal" href="yul.html">Yul</a></li>
<li class="toctree-l1"><a class="reference internal" href="style-guide.html">风格指南</a></li>
<li class="toctree-l1"><a class="reference internal" href="common-patterns.html">通用模式</a></li>
<li class="toctree-l1"><a class="reference internal" href="bugs.html">已知bug列表</a></li>
<li class="toctree-l1"><a class="reference internal" href="contributing.html">贡献方式</a></li>
<li class="toctree-l1"><a class="reference internal" href="brand-guide.html">Solidity 品牌指南</a></li>
<li class="toctree-l1"><a class="reference internal" href="language-influences.html">Language Influences</a></li>
</ul>

    <ul>
        <li>
            <a href="genindex.html">Keyword Index</a>
        </li>
    </ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: #65afff" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Solidity</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
      <li>类型</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/types.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="types">
<span id="index-0"></span><span id="id1"></span><h1>类型<a class="headerlink" href="#types" title="Permalink to this heading"></a></h1>
<p>Solidity 是一种静态类型语言，这意味着每个变量（状态变量和局部变量）都需要被指定。
Solidity 提供了几种基本类型，可以用来组合出复杂类型。</p>
<p>除此之外，各个类型之间可以在包含运算符号的表达式中进行交互。
关于各种运算符的快速参考，可以参考 <a class="reference internal" href="cheatsheet.html#order"><span class="std std-ref">操作符的优先顺序</span></a>。</p>
<p>Solidity中不存在”未定义”或”空”值的概念，
但新声明的变量总是有一个取决于其类型的 <a class="reference internal" href="control-structures.html#default-value"><span class="std std-ref">默认值</span></a>。
为了处理任何意外的值，您应该使用 <a class="reference internal" href="control-structures.html#assert-and-require"><span class="std std-ref">revert 函数</span></a> 来恢复整个事务，
或者返回一个带有第二个 <code class="docutils literal notranslate"><span class="pre">bool</span></code> 值的元组来表示成功。</p>
<section id="value-types">
<span id="index-1"></span><span id="id2"></span><h2>值类型<a class="headerlink" href="#value-types" title="Permalink to this heading"></a></h2>
<p>以下类型也称为值类型，因为这些类型的变量将始终按值来传递。
也就是说，当这些变量被用作函数参数或者用在赋值语句中时，总会进行值拷贝。</p>
<section id="index-2">
<span id="id3"></span><h3>布尔类型<a class="headerlink" href="#index-2" title="Permalink to this heading"></a></h3>
<p><code class="docutils literal notranslate"><span class="pre">bool</span></code> ：可能的取值为常数值 <code class="docutils literal notranslate"><span class="pre">true</span></code> 和 <code class="docutils literal notranslate"><span class="pre">false</span></code>。</p>
<p>运算符：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">!</span></code> (逻辑非)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&amp;&amp;</span></code> (逻辑与, “and”)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">||</span></code> (逻辑或, “or”)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">==</span></code> (等于)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">!=</span></code> (不等于)</p></li>
</ul>
<p>运算符 <code class="docutils literal notranslate"><span class="pre">||</span></code> 和 <code class="docutils literal notranslate"><span class="pre">&amp;&amp;</span></code> 都遵循同样的短路（ short-circuiting ）规则。
就是说在表达式 <code class="docutils literal notranslate"><span class="pre">f(x)</span> <span class="pre">||</span> <span class="pre">g(y)</span></code> 中， 如果 <code class="docutils literal notranslate"><span class="pre">f(x)</span></code> 的值为 <code class="docutils literal notranslate"><span class="pre">true</span></code> ，
那么 <code class="docutils literal notranslate"><span class="pre">g(y)</span></code> 就不会被执行，即使会出现一些副作用。</p>
</section>
<section id="integers">
<span id="index-3"></span><span id="id4"></span><h3>整型<a class="headerlink" href="#integers" title="Permalink to this heading"></a></h3>
<p><code class="docutils literal notranslate"><span class="pre">int</span></code> / <code class="docutils literal notranslate"><span class="pre">uint</span></code>: 分别表示有符号和无符号的不同位数的整型变量。
关键字 <code class="docutils literal notranslate"><span class="pre">uint8</span></code> 到 <code class="docutils literal notranslate"><span class="pre">uint256</span></code> （无符号整型，从 8 位到 256 位）以及 <code class="docutils literal notranslate"><span class="pre">int8</span></code> 到 <code class="docutils literal notranslate"><span class="pre">int256</span></code>，
以 8 位为步长递增。 <code class="docutils literal notranslate"><span class="pre">uint</span></code> 和 <code class="docutils literal notranslate"><span class="pre">int</span></code> 分别是 <code class="docutils literal notranslate"><span class="pre">uint256</span></code> 和 <code class="docutils literal notranslate"><span class="pre">int256</span></code> 的别名。</p>
<p>运算符：</p>
<ul class="simple">
<li><p>比较运算符： <code class="docutils literal notranslate"><span class="pre">&lt;=</span></code>， <code class="docutils literal notranslate"><span class="pre">&lt;</span></code>， <code class="docutils literal notranslate"><span class="pre">==</span></code>， <code class="docutils literal notranslate"><span class="pre">!=</span></code>， <code class="docutils literal notranslate"><span class="pre">&gt;=</span></code>， <code class="docutils literal notranslate"><span class="pre">&gt;</span></code> （返回布尔值）</p></li>
<li><p>位运算符： <code class="docutils literal notranslate"><span class="pre">&amp;</span></code>， <code class="docutils literal notranslate"><span class="pre">|</span></code>， <code class="docutils literal notranslate"><span class="pre">^</span></code> (异或)， <code class="docutils literal notranslate"><span class="pre">~</span></code> (位取反)</p></li>
<li><p>移位运算符： <code class="docutils literal notranslate"><span class="pre">&lt;&lt;</span></code> （左移）， <code class="docutils literal notranslate"><span class="pre">&gt;&gt;</span></code> （右移）</p></li>
<li><p>算数运算符： <code class="docutils literal notranslate"><span class="pre">+</span></code>， <code class="docutils literal notranslate"><span class="pre">-</span></code>， 一元运算 <code class="docutils literal notranslate"><span class="pre">-</span></code> （只适用于有符号的整数）， <code class="docutils literal notranslate"><span class="pre">*</span></code>， <code class="docutils literal notranslate"><span class="pre">/</span></code>， <code class="docutils literal notranslate"><span class="pre">%</span></code> (取余)， <code class="docutils literal notranslate"><span class="pre">**</span></code> (幂)</p></li>
</ul>
<p>对于一个整数类型 <code class="docutils literal notranslate"><span class="pre">X</span></code>，您可以使用 <code class="docutils literal notranslate"><span class="pre">type(X).min</span></code> 和 <code class="docutils literal notranslate"><span class="pre">type(X).max</span></code> 来访问该类型代表的最小值和最大值。</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Solidity中的整数被限制在一个特定的范围内。例如，对于 <code class="docutils literal notranslate"><span class="pre">uint32</span></code>，这是 <code class="docutils literal notranslate"><span class="pre">0</span></code> 到 <code class="docutils literal notranslate"><span class="pre">2**32</span> <span class="pre">-</span> <span class="pre">1</span></code>。
有两种模式在这些类型上进行算术。”包装” 或 “未检查” 模式和 “检查” 模式。
默认情况下，算术总是 “检查” 模式的，这意味着如果一个操作的结果超出了该类型的值范围，
调用将通过一个 <a class="reference internal" href="control-structures.html#assert-and-require"><span class="std std-ref">失败的断言</span></a> 而被恢复。
您可以用 <code class="docutils literal notranslate"><span class="pre">unchecked</span> <span class="pre">{</span> <span class="pre">...</span> <span class="pre">}</span></code>。 更多的细节可以在关于 <a class="reference internal" href="control-structures.html#unchecked"><span class="std std-ref">未检查</span></a> 的章节中找到。</p>
</div>
<section id="id5">
<h4>比较运算<a class="headerlink" href="#id5" title="Permalink to this heading"></a></h4>
<p>比较的值是通过比较整数值得到的值。</p>
</section>
<section id="id6">
<h4>位运算<a class="headerlink" href="#id6" title="Permalink to this heading"></a></h4>
<p>位操作是在数字的二进制补码表示上进行的。
这意味着，例如 <code class="docutils literal notranslate"><span class="pre">~int256(0)</span> <span class="pre">==</span> <span class="pre">int256(-1)</span></code>。</p>
</section>
<section id="id7">
<h4>移位运算<a class="headerlink" href="#id7" title="Permalink to this heading"></a></h4>
<p>移位操作的结果具有左操作数的类型，将结果截断以符合类型。
右操作数必须是无符号类型，试图对有符号类型进行移位会产生一个编译错误。</p>
<p>移位可以通过以下方式用2的幂的乘法来 “模拟”。
请注意，对左边操作数类型的截断总是在最后进行，但没有明确提及。</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;&lt;</span> <span class="pre">y</span></code> 等同于数学表达式 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">*</span> <span class="pre">2**y</span></code>。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&gt;&gt;</span> <span class="pre">y</span></code> 等同于数学表达式 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">/</span> <span class="pre">2**y</span></code>，向负无穷远的方向取整。</p></li>
</ul>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>在 <code class="docutils literal notranslate"><span class="pre">0.5.0</span></code> 版本之前，负数 <code class="docutils literal notranslate"><span class="pre">x</span></code> 的右移 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&gt;&gt;</span> <span class="pre">y</span></code> 相当于数学表达式 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">/</span> <span class="pre">2**y</span></code> 向零舍入，
即右移使用向上舍入（向零舍入）而不是向下舍入（向负无穷大）。</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>就像对算术操作那样，对移位操作从不进行溢出检查。相反，结果总是被截断的。</p>
</div>
</section>
<section id="id8">
<h4>加法、减法和乘法<a class="headerlink" href="#id8" title="Permalink to this heading"></a></h4>
<p>加法、减法和乘法具有通常的语义，在上溢和下溢方面有两种不同的模式：</p>
<p>默认情况下，所有的算术都会被检查是否有下溢或上溢，但这可以用 <a class="reference internal" href="control-structures.html#unchecked"><span class="std std-ref">未检查限制</span></a> 来禁用。
这会导致包装的算术。更多细节可以在那一节中找到。</p>
<p>表达式 <code class="docutils literal notranslate"><span class="pre">-x</span></code> 等同于 <code class="docutils literal notranslate"><span class="pre">(T(0)</span> <span class="pre">-</span> <span class="pre">x)</span></code>，其中
<code class="docutils literal notranslate"><span class="pre">T</span></code> 是 <code class="docutils literal notranslate"><span class="pre">x</span></code> 的类型。它只能用于有符号的类型。
如果 <code class="docutils literal notranslate"><span class="pre">x</span></code> 是负的， <code class="docutils literal notranslate"><span class="pre">-x</span></code> 的值就是正的。
还有一个注意事项也是由二进制补码表示产生的：</p>
<p>如果您有（这样的表达式） <code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">type(int).min;</span></code>，那么 <code class="docutils literal notranslate"><span class="pre">-x</span></code> 就不符合正数范围。
这意味着 <code class="docutils literal notranslate"><span class="pre">unchecked</span> <span class="pre">{</span> <span class="pre">assert(-x</span> <span class="pre">==</span> <span class="pre">x);</span> <span class="pre">}</span></code> 可以工作，
而表达式 <code class="docutils literal notranslate"><span class="pre">-x</span></code> 在检查模式下使用时将导致断言失败。</p>
</section>
<section id="id9">
<h4>除法<a class="headerlink" href="#id9" title="Permalink to this heading"></a></h4>
<p>由于运算结果的类型总是操作数之一的类型，整数除法的结果总是一个整数。
在Solidity中，除法是向零进位的。这意味着 <code class="docutils literal notranslate"><span class="pre">int256(-5)</span> <span class="pre">/</span> <span class="pre">int256(2)</span> <span class="pre">==</span> <span class="pre">int256(-2)</span></code>。</p>
<p>请注意，与此相反，在 <a class="reference internal" href="#rational-literals"><span class="std std-ref">字面上</span></a> 的除法会产生任意精度的分数值。</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>除以0会导致 <a class="reference internal" href="control-structures.html#assert-and-require"><span class="std std-ref">异常</span></a>。这个检查 <strong>不能</strong> 通过 <code class="docutils literal notranslate"><span class="pre">unchecked</span> <span class="pre">{</span> <span class="pre">...</span> <span class="pre">}</span></code> 禁用。</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>表达式 <code class="docutils literal notranslate"><span class="pre">type(int).min</span> <span class="pre">/</span> <span class="pre">(-1)</span></code> 是除法导致溢出的唯一情况。
在检查算术模式下，这将导致一个失败的断言，
而在包装模式下，值将是 <code class="docutils literal notranslate"><span class="pre">type(int).min</span></code>。</p>
</div>
</section>
<section id="id10">
<h4>取余<a class="headerlink" href="#id10" title="Permalink to this heading"></a></h4>
<p>模数运算 <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">%</span> <span class="pre">n</span></code> 是操作数 <code class="docutils literal notranslate"><span class="pre">a</span></code> 除以操作数 <code class="docutils literal notranslate"><span class="pre">n</span></code> 后产生余数 <code class="docutils literal notranslate"><span class="pre">r</span></code>，
其中 <code class="docutils literal notranslate"><span class="pre">q</span> <span class="pre">=</span> <span class="pre">int(a</span> <span class="pre">/</span> <span class="pre">n)</span></code> 和 <code class="docutils literal notranslate"><span class="pre">r</span> <span class="pre">=</span> <span class="pre">a</span> <span class="pre">-</span> <span class="pre">(n</span> <span class="pre">*</span> <span class="pre">q)</span></code>。
这意味着模数运算的结果与它的左边操作数（或零）相同，
<code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">%</span> <span class="pre">n</span> <span class="pre">==</span> <span class="pre">-(-a</span> <span class="pre">%</span> <span class="pre">n)</span></code> 对负的 <code class="docutils literal notranslate"><span class="pre">a</span></code> 来说成立。</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">int256(5)</span> <span class="pre">%</span> <span class="pre">int256(2)</span> <span class="pre">==</span> <span class="pre">int256(1)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">int256(5)</span> <span class="pre">%</span> <span class="pre">int256(-2)</span> <span class="pre">==</span> <span class="pre">int256(1)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">int256(-5)</span> <span class="pre">%</span> <span class="pre">int256(2)</span> <span class="pre">==</span> <span class="pre">int256(-1)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">int256(-5)</span> <span class="pre">%</span> <span class="pre">int256(-2)</span> <span class="pre">==</span> <span class="pre">int256(-1)</span></code></p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>对0取余会导致 <a class="reference internal" href="control-structures.html#assert-and-require"><span class="std std-ref">异常</span></a>。这个检查 <strong>不能</strong> 通过 <code class="docutils literal notranslate"><span class="pre">unchecked</span> <span class="pre">{</span> <span class="pre">...</span> <span class="pre">}</span></code> 禁用。</p>
</div>
</section>
<section id="id11">
<h4>幂运算<a class="headerlink" href="#id11" title="Permalink to this heading"></a></h4>
<p>幂运算只适用于指数中的无符号类型。幂运算的结果类型总是等于基数的类型。
请注意，它要足够大以容纳结果，并为潜在的断言失败或包装行为做好准备。</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>在检查模式下，幂运算只对小基数使用相对便宜的 <code class="docutils literal notranslate"><span class="pre">exp</span></code> 操作码。
对于 <code class="docutils literal notranslate"><span class="pre">x**3</span></code> 的情况，表达式 <code class="docutils literal notranslate"><span class="pre">x*x*x</span></code> 可能更便宜。
在任何情况下，气体成本测试和使用优化器都是可取的。</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>请注意，<code class="docutils literal notranslate"><span class="pre">0**0</span></code> 被EVM定义为 <code class="docutils literal notranslate"><span class="pre">1</span></code>。</p>
</div>
</section>
</section>
<section id="index-4">
<span id="id12"></span><h3>定长浮点型<a class="headerlink" href="#index-4" title="Permalink to this heading"></a></h3>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Solidity 还没有完全支持定长浮点型。可以声明定长浮点型的变量，
但不能给它们赋值或把它们赋值给其他变量。</p>
</div>
<p><code class="docutils literal notranslate"><span class="pre">fixed</span></code> / <code class="docutils literal notranslate"><span class="pre">ufixed</span></code>：表示各种大小的有符号和无符号的定长浮点型。
在关键字 <code class="docutils literal notranslate"><span class="pre">ufixedMxN</span></code> 和 <code class="docutils literal notranslate"><span class="pre">fixedMxN</span></code> 中， <code class="docutils literal notranslate"><span class="pre">M</span></code> 表示该类型占用的位数，
<code class="docutils literal notranslate"><span class="pre">N</span></code> 表示可用的小数位数。 <code class="docutils literal notranslate"><span class="pre">M</span></code> 必须能整除 8，即 8 到 256 位。
<code class="docutils literal notranslate"><span class="pre">N</span></code> 则可以是从 0 到 80 之间的任意数。 <code class="docutils literal notranslate"><span class="pre">ufixed</span></code> 和 <code class="docutils literal notranslate"><span class="pre">fixed</span></code> 分别是 <code class="docutils literal notranslate"><span class="pre">ufixed128x18</span></code> 和 <code class="docutils literal notranslate"><span class="pre">fixed128x18</span></code> 的别名。</p>
<p>运算符：</p>
<ul class="simple">
<li><p>比较运算符： <code class="docutils literal notranslate"><span class="pre">&lt;=</span></code>， <code class="docutils literal notranslate"><span class="pre">&lt;</span></code>， <code class="docutils literal notranslate"><span class="pre">==</span></code>， <code class="docutils literal notranslate"><span class="pre">!=</span></code>， <code class="docutils literal notranslate"><span class="pre">&gt;=</span></code>， <code class="docutils literal notranslate"><span class="pre">&gt;</span></code> （返回值是布尔型）</p></li>
<li><p>算术运算符： <code class="docutils literal notranslate"><span class="pre">+</span></code>， <code class="docutils literal notranslate"><span class="pre">-</span></code>， 一元运算 <code class="docutils literal notranslate"><span class="pre">-</span></code>， <code class="docutils literal notranslate"><span class="pre">*</span></code>， <code class="docutils literal notranslate"><span class="pre">/</span></code>， <code class="docutils literal notranslate"><span class="pre">%</span></code> (取余数)</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>浮点型（在许多语言中的 <code class="docutils literal notranslate"><span class="pre">float</span></code> 和 <code class="docutils literal notranslate"><span class="pre">double</span></code> ，更准确地说是 IEEE 754 类型）和定长浮点型之间最大的不同点是，
在前者中整数部分和小数部分（小数点后的部分）需要的位数是灵活可变的，而后者中这两部分的长度受到严格的规定。
一般来说，在浮点型中，几乎整个空间都用来表示数字，但只有少数的位来表示小数点的位置。</p>
</div>
</section>
<section id="address">
<span id="index-5"></span><span id="id13"></span><h3>地址类型<a class="headerlink" href="#address" title="Permalink to this heading"></a></h3>
<p>地址类型有两种，大体上是相同的：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">address</span></code>: 保存一个20字节的值（一个以太坊地址的大小）。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">address</span> <span class="pre">payable</span></code>: 与 <code class="docutils literal notranslate"><span class="pre">address</span></code> 类型相同，但有额外的方法 <code class="docutils literal notranslate"><span class="pre">transfer</span></code> 和 <code class="docutils literal notranslate"><span class="pre">send</span></code>。</p></li>
</ul>
<p>这种区别背后的想法是， <code class="docutils literal notranslate"><span class="pre">address</span> <span class="pre">payable</span></code> 是一个您可以发送以太币的地址，
而您不应该发送以太币给一个普通的 <code class="docutils literal notranslate"><span class="pre">address</span></code>，例如，因为它可能是一个智能合约，
而这个合约不是为接受以太币而建立的。</p>
<p>类型转换：</p>
<p>允许从 <code class="docutils literal notranslate"><span class="pre">address</span> <span class="pre">payable</span></code> 到 <code class="docutils literal notranslate"><span class="pre">address</span></code> 的隐式转换，
而从 <code class="docutils literal notranslate"><span class="pre">address</span></code> 到 <code class="docutils literal notranslate"><span class="pre">address</span> <span class="pre">payable</span></code> 的转换必须通过 <code class="docutils literal notranslate"><span class="pre">payable(&lt;address&gt;)</span></code> 来明确。</p>
<p>对于 <code class="docutils literal notranslate"><span class="pre">uint160</span></code>、整数、 <code class="docutils literal notranslate"><span class="pre">bytes20</span></code> 和合约类型，允许对 <code class="docutils literal notranslate"><span class="pre">address</span></code> 进行明确的转换和输出。</p>
<p>只有 <code class="docutils literal notranslate"><span class="pre">address</span></code> 类型和合约类型的表达式可以通过 <code class="docutils literal notranslate"><span class="pre">payable(...)</span></code> 显式转换为 <code class="docutils literal notranslate"><span class="pre">address</span> <span class="pre">payable</span></code> 类型。
对于合约类型，只有在合约可以接收以太的情况下才允许这种转换，也就是说，
合约要么有一个 <a class="reference internal" href="contracts.html#receive-ether-function"><span class="std std-ref">receive</span></a> 函数，要么有一个 payable 类型的 fallback 的函数。
请注意， <code class="docutils literal notranslate"><span class="pre">payable(0)</span></code> 是有效的，是这个规则的例外。</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>如果您需要一个 <code class="docutils literal notranslate"><span class="pre">address</span></code> 类型的变量，并计划向其发送以太，那么就将其类型声明为 <code class="docutils literal notranslate"><span class="pre">address</span> <span class="pre">payable</span></code>，
以使这一要求可行。另外，尽量尽早地进行这种区分或转换。</p>
</div>
<p>运算符：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">&lt;=</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;</span></code>, <code class="docutils literal notranslate"><span class="pre">==</span></code>, <code class="docutils literal notranslate"><span class="pre">!=</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;=</span></code> 和 <code class="docutils literal notranslate"><span class="pre">&gt;</span></code></p></li>
</ul>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>如果您使用较大字节的类型转换为 <code class="docutils literal notranslate"><span class="pre">address</span></code>，例如 <code class="docutils literal notranslate"><span class="pre">bytes32</span></code>，那么 <code class="docutils literal notranslate"><span class="pre">address</span></code> 就被截断了。
为了减少转换的模糊性，0.4.24及以上版本的编译器强迫你在转换中明确截断。以32字节的值
<code class="docutils literal notranslate"><span class="pre">0x111122333344556677888899AAAABBBBCCCCDDDDEEFFFFCCCC</span></code> 为例。</p>
<p>您可以使用 <code class="docutils literal notranslate"><span class="pre">address(uint160(bytes20(b)))</span></code>，结果是 <code class="docutils literal notranslate"><span class="pre">0x111122223333444455556666777788889999aAaa</span></code>，
或者您可以使用 <code class="docutils literal notranslate"><span class="pre">address(uint160(uint256(b)))</span></code>，结果是 <code class="docutils literal notranslate"><span class="pre">0x777788889999AaAAbBbbCcccddDdeeeEfFFfCcCc</span></code>。</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="docutils literal notranslate"><span class="pre">address</span></code> 和 <code class="docutils literal notranslate"><span class="pre">address</span> <span class="pre">payable</span></code> 之间的区别是在0.5.0版本中引入的。
同样从该版本开始，合约不从地址类型派生，但仍然可以明确转换为 <code class="docutils literal notranslate"><span class="pre">address</span></code> 或 <code class="docutils literal notranslate"><span class="pre">address</span> <span class="pre">payable</span></code>，
如果它们有一个 receive 或 payable 类型的 fallback 函数。</p>
</div>
<section id="members-of-addresses">
<span id="id14"></span><h4>地址类型成员变量<a class="headerlink" href="#members-of-addresses" title="Permalink to this heading"></a></h4>
<p>快速参考，请见 <a class="reference internal" href="units-and-global-variables.html#address-related"><span class="std std-ref">地址类型的成员</span></a>。</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">balance</span></code> 和 <code class="docutils literal notranslate"><span class="pre">transfer</span></code></p></li>
</ul>
<p>可以使用 <code class="docutils literal notranslate"><span class="pre">balance</span></code> 属性来查询一个地址的以太币余额，
也可以使用 <code class="docutils literal notranslate"><span class="pre">transfer</span></code> 函数向一个地址发送以太币（以 wei 为单位）：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.13&amp;code=YWRkcmVzcyBwYXlhYmxlIHggPSBwYXlhYmxlKDB4MTIzKTsKYWRkcmVzcyBteUFkZHJlc3MgPSBhZGRyZXNzKHRoaXMpOwppZiAoeC5iYWxhbmNlIDwgMTAgJiYgbXlBZGRyZXNzLmJhbGFuY2UgPj0gMTApIHgudHJhbnNmZXIoMTApOw=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="kt">address</span><span class="w"> </span><span class="nv">payable</span><span class="w"> </span>x<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">payable</span><span class="p">(</span><span class="mh">0x123</span><span class="p">);</span><span class="w"></span>
<span class="kt">address</span><span class="w"> </span><span class="nv">myAddress</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">address</span><span class="p">(</span><span class="kt">this</span><span class="p">);</span><span class="w"></span>
<span class="kt">if</span><span class="w"> </span><span class="p">(</span>x<span class="p">.</span>balance<span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="m m-Decimal">10</span><span class="w"> </span><span class="err">&amp;&amp;</span><span class="w"> </span>myAddress<span class="p">.</span>balance<span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="m m-Decimal">10</span><span class="p">)</span><span class="w"> </span>x<span class="p">.</span>transfer<span class="p">(</span><span class="m m-Decimal">10</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>如果当前合约的余额不足，或者以太币转账被接收账户拒绝，那么 <code class="docutils literal notranslate"><span class="pre">transfer</span></code> 功能就会失败。
<code class="docutils literal notranslate"><span class="pre">transfer</span></code> 功能在失败后会被还原。</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>如果 <code class="docutils literal notranslate"><span class="pre">x</span></code> 是一个合约地址，它的代码（更具体地说：它的 <a class="reference internal" href="contracts.html#receive-ether-function"><span class="std std-ref">接收以太的函数</span></a>，如果有的话，
或者它的 <a class="reference internal" href="contracts.html#fallback-function"><span class="std std-ref">Fallback 函数</span></a>，如果有的话）将与 <code class="docutils literal notranslate"><span class="pre">transfer</span></code> 调用一起执行（这是EVM的一个特性，无法阻止）。
如果执行过程中耗尽了气体或出现了任何故障，以太币的转移将被还原，当前的合约将以异常的方式停止。</p>
</div>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">send</span></code></p></li>
</ul>
<p>Send是 <code class="docutils literal notranslate"><span class="pre">transfer</span></code> 的低级对应部分。如果执行失败，当前的合约不会因异常而停止，但 <code class="docutils literal notranslate"><span class="pre">send</span></code> 会返回 <code class="docutils literal notranslate"><span class="pre">false</span></code>。</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>使用 <code class="docutils literal notranslate"><span class="pre">send</span></code> 有一些危险：如果调用堆栈深度为1024，传输就会失败（这可以由调用者强制执行），
如果接收者的气体耗尽，也会失败。因此，为了安全地进行以太币转账，
一定要检查 <code class="docutils literal notranslate"><span class="pre">send</span></code> 的返回值，或者使用 <code class="docutils literal notranslate"><span class="pre">transfer</span></code>，甚至使用更好的方式：
使用收款人提款的模式。</p>
</div>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">call</span></code>, <code class="docutils literal notranslate"><span class="pre">delegatecall</span></code> 和 <code class="docutils literal notranslate"><span class="pre">staticcall</span></code></p></li>
</ul>
<p>为了与不遵守ABI的合约对接，或者为了更直接地控制编码，
我们提供了 <code class="docutils literal notranslate"><span class="pre">call</span></code>, <code class="docutils literal notranslate"><span class="pre">delegatecall</span></code> 和 <code class="docutils literal notranslate"><span class="pre">staticcall</span></code> 函数。
它们都接受一个 <code class="docutils literal notranslate"><span class="pre">bytes</span> <span class="pre">memory</span></code> 参数，并返回成功条件（作为一个 <code class="docutils literal notranslate"><span class="pre">bool</span></code>）
和返回的数据（ <code class="docutils literal notranslate"><span class="pre">bytes</span> <span class="pre">memory</span></code>）。
函数 <code class="docutils literal notranslate"><span class="pre">abi.encode</span></code>, <code class="docutils literal notranslate"><span class="pre">abi.encodePacked</span></code>, <code class="docutils literal notranslate"><span class="pre">abi.encodeWithSelector</span></code>
和 <code class="docutils literal notranslate"><span class="pre">abi.encodeWithSignature</span></code> 可以用来编码结构化的数据。</p>
<p>示例：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.13&amp;code=Ynl0ZXMgbWVtb3J5IHBheWxvYWQgPSBhYmkuZW5jb2RlV2l0aFNpZ25hdHVyZSgicmVnaXN0ZXIoc3RyaW5nKSIsICJNeU5hbWUiKTsKKGJvb2wgc3VjY2VzcywgYnl0ZXMgbWVtb3J5IHJldHVybkRhdGEpID0gYWRkcmVzcyhuYW1lUmVnKS5jYWxsKHBheWxvYWQpOwpyZXF1aXJlKHN1Y2Nlc3MpOw=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="kt">bytes</span><span class="w"> </span><span class="nv">memory</span><span class="w"> </span>payload<span class="w"> </span><span class="o">=</span><span class="w"> </span>abi<span class="p">.</span>encodeWithSignature<span class="p">(</span><span class="s2">&quot;register(string)&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;MyName&quot;</span><span class="p">);</span><span class="w"></span>
<span class="p">(</span><span class="kt">bool</span><span class="w"> </span><span class="nv">success</span><span class="p">,</span><span class="w"> </span><span class="kt">bytes</span><span class="w"> </span><span class="nv">memory</span><span class="w"> </span>returnData<span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">address</span><span class="p">(</span>nameReg<span class="p">).</span>call<span class="p">(</span>payload<span class="p">);</span><span class="w"></span>
<span class="kt">require</span><span class="p">(</span>success<span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>所有这些函数都是低级别的函数，应该谨慎使用。
具体来说，任何未知的合约都可能是恶意的，如果您调用它，
您就把控制权交给了该合约，而该合约又可能回调到您的合约中，
所以要准备好在调用返回时改变您合约的状态变量。
与其他合约互动的常规方法是在合约对象上调用一个函数（ <code class="docutils literal notranslate"><span class="pre">x.f()</span></code>）。</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>以前的 Solidity 版本允许这些函数接收任意的参数，
并且也会以不同的方式处理 <code class="docutils literal notranslate"><span class="pre">bytes4</span></code> 类型的第一个参数。
这些边缘情况在0.5.0版本中被移除。</p>
</div>
<p>可以用 <code class="docutils literal notranslate"><span class="pre">gas</span></code> 修饰器来调整所提供的气体：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.13&amp;code=YWRkcmVzcyhuYW1lUmVnKS5jYWxse2dhczogMTAwMDAwMH0oYWJpLmVuY29kZVdpdGhTaWduYXR1cmUoInJlZ2lzdGVyKHN0cmluZykiLCAiTXlOYW1lIikpOw=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="kt">address</span><span class="p">(</span>nameReg<span class="p">).</span>call<span class="p">{</span>gas<span class="p">:</span><span class="w"> </span><span class="m m-Decimal">1000000</span><span class="p">}(</span>abi<span class="p">.</span>encodeWithSignature<span class="p">(</span><span class="s2">&quot;register(string)&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;MyName&quot;</span><span class="p">));</span><span class="w"></span>
</pre></div>
</div>
<p>同样，所提供的以太值也可以被控制：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.13&amp;code=YWRkcmVzcyhuYW1lUmVnKS5jYWxse3ZhbHVlOiAxIGV0aGVyfShhYmkuZW5jb2RlV2l0aFNpZ25hdHVyZSgicmVnaXN0ZXIoc3RyaW5nKSIsICJNeU5hbWUiKSk7"><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="kt">address</span><span class="p">(</span>nameReg<span class="p">).</span>call<span class="p">{</span>value<span class="p">:</span><span class="w"> </span><span class="m m-Decimal">1</span><span class="w"> </span>ether<span class="p">}(</span>abi<span class="p">.</span>encodeWithSignature<span class="p">(</span><span class="s2">&quot;register(string)&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;MyName&quot;</span><span class="p">));</span><span class="w"></span>
</pre></div>
</div>
<p>最后，这些修饰器可以合并。它们的顺序并不重要：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.13&amp;code=YWRkcmVzcyhuYW1lUmVnKS5jYWxse2dhczogMTAwMDAwMCwgdmFsdWU6IDEgZXRoZXJ9KGFiaS5lbmNvZGVXaXRoU2lnbmF0dXJlKCJyZWdpc3RlcihzdHJpbmcpIiwgIk15TmFtZSIpKTs="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="kt">address</span><span class="p">(</span>nameReg<span class="p">).</span>call<span class="p">{</span>gas<span class="p">:</span><span class="w"> </span><span class="m m-Decimal">1000000</span><span class="p">,</span><span class="w"> </span>value<span class="p">:</span><span class="w"> </span><span class="m m-Decimal">1</span><span class="w"> </span>ether<span class="p">}(</span>abi<span class="p">.</span>encodeWithSignature<span class="p">(</span><span class="s2">&quot;register(string)&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;MyName&quot;</span><span class="p">));</span><span class="w"></span>
</pre></div>
</div>
<p>以类似的方式，可以使用函数 <code class="docutils literal notranslate"><span class="pre">delegatecall</span></code>：不同的是，它只使用给定地址的代码，
所有其他方面（存储，余额，…）都取自当前的合约。
<code class="docutils literal notranslate"><span class="pre">delegatecall</span></code> 的目的是为了使用存储在另一个合约中的库代码。
用户必须确保两个合约中的存储结构都适合使用delegatecall。</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>在 homestead 版本之前，只有一个功能类似但作用有限的 <code class="docutils literal notranslate"><span class="pre">callcode</span></code> 的函数可用，
但它不能获取委托方的 <code class="docutils literal notranslate"><span class="pre">msg.sender</span></code> 和 <code class="docutils literal notranslate"><span class="pre">msg.value</span></code>。这个功能在0.5.0版本中被移除。</p>
</div>
<p>从byzantium开始，也可以使用 <code class="docutils literal notranslate"><span class="pre">staticcall</span></code>。这基本上与 <code class="docutils literal notranslate"><span class="pre">call</span></code> 相同，
但如果被调用的函数以任何方式修改了状态，则会恢复。</p>
<p>这三个函数 <code class="docutils literal notranslate"><span class="pre">call</span></code>， <code class="docutils literal notranslate"><span class="pre">delegatecall</span></code> 和 <code class="docutils literal notranslate"><span class="pre">staticcall</span></code> 都是非常低级的函数，
只应该作为 <em>最后的手段</em> 来使用，因为它们破坏了Solidity的类型安全。</p>
<p><code class="docutils literal notranslate"><span class="pre">gas</span></code> 选项在所有三种方法中都可用，而 <code class="docutils literal notranslate"><span class="pre">value</span></code> 选项只在 <code class="docutils literal notranslate"><span class="pre">call</span></code> 中可用。</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>最好避免在您的智能合约代码中依赖硬编码的气体值，无论状态是读出还是写入，
因为这可能有很多隐患。另外，对气体的访问在未来可能会改变。</p>
</div>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">code</span></code> 和 <code class="docutils literal notranslate"><span class="pre">codehash</span></code></p></li>
</ul>
<p>您可以查询任何智能合约的部署代码。使用 <code class="docutils literal notranslate"><span class="pre">.code</span></code> 获得作为 <code class="docutils literal notranslate"><span class="pre">bytes</span> <span class="pre">memory</span></code> 的EVM字节码，
这可能是空的。使用 <code class="docutils literal notranslate"><span class="pre">.codehash</span></code> 获得该代码的Keccak-256哈希值（作为 <code class="docutils literal notranslate"><span class="pre">bytes32</span></code>）。
注意，使用 <code class="docutils literal notranslate"><span class="pre">addr.codehash</span></code> 比 <code class="docutils literal notranslate"><span class="pre">keccak256(addr.code)</span></code> 更便宜。</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>所有的合约都可以转换为 <code class="docutils literal notranslate"><span class="pre">address</span></code> 类型，所以可以用 <code class="docutils literal notranslate"><span class="pre">address(this).balance</span></code> 查询当前合约的余额。</p>
</div>
</section>
</section>
<section id="contract-types">
<span id="index-6"></span><span id="id15"></span><h3>合约类型<a class="headerlink" href="#contract-types" title="Permalink to this heading"></a></h3>
<p>每个 <a class="reference internal" href="contracts.html#contracts"><span class="std std-ref">合约</span></a> 都定义了自己的类型。
您可以隐式地将一个合约转换为它们所继承的另一个合约。
合约可以显式地转换为 <code class="docutils literal notranslate"><span class="pre">address</span></code> 类型，也可以从 <code class="docutils literal notranslate"><span class="pre">address</span></code> 类型中转换。</p>
<p>只有在合约类型具有receive或 payable 类型的 fallback 函数的情况下，
才有可能明确转换为 <code class="docutils literal notranslate"><span class="pre">address</span> <span class="pre">payable</span></code> 类型和从该类型转换。
这种转换仍然使用 <code class="docutils literal notranslate"><span class="pre">address(x)</span></code> 进行转换。如果合约类型没有一个 receive 或 payable 类型的 fallback 函数，
可以使用 <code class="docutils literal notranslate"><span class="pre">payable(address(x))</span></code> 来转换为 <code class="docutils literal notranslate"><span class="pre">address</span> <span class="pre">payable</span></code> 。
您可以在 <a class="reference internal" href="#address"><span class="std std-ref">地址类型</span></a> 一节中找到更多信息。</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>在0.5.0版本之前，合约直接从地址类型派生出来，
并且在 <code class="docutils literal notranslate"><span class="pre">address</span></code> 和 <code class="docutils literal notranslate"><span class="pre">address</span> <span class="pre">payable</span></code> 之间没有区别。</p>
</div>
<p>如果您声明了一个本地类型的变量（ <code class="docutils literal notranslate"><span class="pre">MyContract</span> <span class="pre">c</span></code> ），您可以调用该合约上的函数。
注意要从相同合约类型的地方将其赋值。</p>
<p>您也可以实例化合约（这意味着它们是新创建的）。
您可以在 <a class="reference internal" href="control-structures.html#creating-contracts"><span class="std std-ref">‘通过关键字new创建合约’</span></a> 部分找到更多细节。</p>
<p>合约的数据表示与 <code class="docutils literal notranslate"><span class="pre">address</span></code> 类型相同，该类型也用于 <a class="reference internal" href="abi-spec.html#abi"><span class="std std-ref">ABI</span></a>。</p>
<p>合约不支持任何运算符。</p>
<p>合约类型的成员是合约的外部函数，包括任何标记为 <code class="docutils literal notranslate"><span class="pre">public</span></code> 的状态变量。</p>
<p>对于一个合约 <code class="docutils literal notranslate"><span class="pre">C</span></code>，您可以使用 <code class="docutils literal notranslate"><span class="pre">type(C)</span></code> 来访问
关于该合约的 <a class="reference internal" href="units-and-global-variables.html#meta-type"><span class="std std-ref">类型信息</span></a> 。</p>
</section>
<section id="index-7">
<span id="id16"></span><h3>定长字节数组<a class="headerlink" href="#index-7" title="Permalink to this heading"></a></h3>
<p>值类型 <code class="docutils literal notranslate"><span class="pre">bytes1</span></code>, <code class="docutils literal notranslate"><span class="pre">bytes2</span></code>, <code class="docutils literal notranslate"><span class="pre">bytes3</span></code>, …, <code class="docutils literal notranslate"><span class="pre">bytes32</span></code> 代表从1到32的字节序列。</p>
<p>运算符：</p>
<p>比较运算符：&lt;=， &lt;， ==， !=， &gt;=， &gt; （返回布尔型）</p>
<ul class="simple">
<li><p>比较运算符： <code class="docutils literal notranslate"><span class="pre">&lt;=</span></code>， <code class="docutils literal notranslate"><span class="pre">&lt;</span></code>， <code class="docutils literal notranslate"><span class="pre">==</span></code>， <code class="docutils literal notranslate"><span class="pre">!=</span></code>， <code class="docutils literal notranslate"><span class="pre">&gt;=</span></code>， <code class="docutils literal notranslate"><span class="pre">&gt;</span></code> (返回 <code class="docutils literal notranslate"><span class="pre">bool</span></code>)</p></li>
<li><p>位运算符： <code class="docutils literal notranslate"><span class="pre">&amp;</span></code>， <code class="docutils literal notranslate"><span class="pre">|</span></code>， <code class="docutils literal notranslate"><span class="pre">^</span></code> （按位异或）， <code class="docutils literal notranslate"><span class="pre">~</span></code> （按位取反）</p></li>
<li><p>移位运算符： <code class="docutils literal notranslate"><span class="pre">&lt;&lt;</span></code> （左移位）， <code class="docutils literal notranslate"><span class="pre">&gt;&gt;</span></code> （右移位）</p></li>
<li><p>索引访问： 如果 <code class="docutils literal notranslate"><span class="pre">x</span></code> 是 <code class="docutils literal notranslate"><span class="pre">bytesI</span></code> 类型，那么当 <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">k</span> <span class="pre">&lt;</span> <span class="pre">I</span></code> 时， <code class="docutils literal notranslate"><span class="pre">x[k]</span></code> 返回第 <code class="docutils literal notranslate"><span class="pre">k</span></code> 个字节（只读）。</p></li>
</ul>
<p>移位运算符以无符号的整数类型作为右操作数（但返回左操作数的类型），
它表示要移位的位数。有符号类型的移位将产生一个编译错误。</p>
<p>成员变量：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">.length</span></code> 表示这个字节数组的长度（只读）.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>类型 <code class="docutils literal notranslate"><span class="pre">bytes1[]</span></code> 是一个字节数组，但是由于填充规则，它为每个元素浪费了31个字节的空间（在存储中除外）。
因此最好使用 <code class="docutils literal notranslate"><span class="pre">bytes</span></code> 类型来代替。</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>在0.8.0版本之前， <code class="docutils literal notranslate"><span class="pre">byte</span></code> 曾经是 <code class="docutils literal notranslate"><span class="pre">bytes1</span></code> 的别名。</p>
</div>
</section>
<section id="id17">
<h3>变长字节数组<a class="headerlink" href="#id17" title="Permalink to this heading"></a></h3>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">bytes</span></code>:</dt><dd><p>变长字节数组，参见 <a class="reference internal" href="#arrays"><span class="std std-ref">数组</span></a>。它并不是值类型！</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">string</span></code>:</dt><dd><p>变长 UTF-8 编码字符串类型，参见 <a class="reference internal" href="#arrays"><span class="std std-ref">数组</span></a>。并不是值类型！</p>
</dd>
</dl>
</section>
<section id="address-literals">
<span id="index-8"></span><span id="id18"></span><h3>地址字面常数（Address Literals）<a class="headerlink" href="#address-literals" title="Permalink to this heading"></a></h3>
<p>比如像 <code class="docutils literal notranslate"><span class="pre">0xdCad3a6d3569DF655070DEd06cb7A1b2Ccd1D3AF</span></code> 这样的
通过了地址校验测试的十六进制字属于 <code class="docutils literal notranslate"><span class="pre">address</span></code> 类型。
十六进制字数在39到41位之间，并且没有通过校验测试，会产生一个错误。
您可以预加（对于整数类型）或附加（对于bytesNN类型）零来消除该错误。</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>混合大小写的地址校验和格式定义在 <a class="reference external" href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-55.md">EIP-55</a>。</p>
</div>
</section>
<section id="rational-literals">
<span id="index-9"></span><span id="id19"></span><h3>有理数和整数字面常数<a class="headerlink" href="#rational-literals" title="Permalink to this heading"></a></h3>
<p>整数字面常数由范围在 0-9 的一串数字组成，表现成十进制。
例如， <code class="docutils literal notranslate"><span class="pre">69</span></code> 表示十进制数字 69。 Solidity 中是没有八进制的，因此前置 0 是无效的。</p>
<p>十进制小数字面常数带有一个 <code class="docutils literal notranslate"><span class="pre">.</span></code>，至少在其一边会有一个数字。 比如： <code class="docutils literal notranslate"><span class="pre">1.</span></code>, <code class="docutils literal notranslate"><span class="pre">.1</span></code> 和 <code class="docutils literal notranslate"><span class="pre">1.3</span></code>。</p>
<p>也支持 <code class="docutils literal notranslate"><span class="pre">2e10</span></code> 形式的科学符号，其中尾数可以是小数，但指数必须是一个整数。
字面的 <code class="docutils literal notranslate"><span class="pre">MeE</span></code> 相当于 <code class="docutils literal notranslate"><span class="pre">M</span> <span class="pre">*</span> <span class="pre">10**E</span></code>。
例子包括 <code class="docutils literal notranslate"><span class="pre">2e10</span></code>, <code class="docutils literal notranslate"><span class="pre">-2e10</span></code>, <code class="docutils literal notranslate"><span class="pre">2e-10</span></code>, <code class="docutils literal notranslate"><span class="pre">2.5e1</span></code>。</p>
<p>下划线可以用来分隔数字字面的数字，以帮助阅读。
例如，十进制 <code class="docutils literal notranslate"><span class="pre">123_000</span></code>，十六进制 <code class="docutils literal notranslate"><span class="pre">0x2eff_abde</span></code>，科学十进制 <code class="docutils literal notranslate"><span class="pre">1_2e345_678</span></code> 都是有效的。
下划线只允许在两个数字之间，并且只允许一个连续的下划线。
含有下划线的数字字面没有额外的语义，下划线被忽略。</p>
<p>数值字面常数表达式保留任意精度，直到它们被转换为非字面常数类型
（即通过与非字面常数类型一起使用或通过显式转换）。
这意味着在数值常量表达式中，计算不会溢出，除法不会截断。</p>
<p>例如， <code class="docutils literal notranslate"><span class="pre">(2**800</span> <span class="pre">+</span> <span class="pre">1)</span> <span class="pre">-</span> <span class="pre">2**800</span></code> 的结果是常数 <code class="docutils literal notranslate"><span class="pre">1</span></code> （类型 <code class="docutils literal notranslate"><span class="pre">uint8</span></code>），
尽管中间的结果甚至不符合机器字的大小。此外， <code class="docutils literal notranslate"><span class="pre">.5</span> <span class="pre">*</span> <span class="pre">8</span></code> 的结果是整数 <code class="docutils literal notranslate"><span class="pre">4</span></code> （尽管中间使用了非整数）。</p>
<p>只要操作数是整数，任何可以应用于整数的操作数也可以应用于数值字面常数表达式。
如果两者中的任何一个是小数，则不允许进行位操作，
如果指数是小数，则不允许进行幂运算（因为这可能导致无理数）。</p>
<p>以数值字面常数表达式为左（或基数）操作数，以整数类型为右（指数）操作数的移位和幂运算，
总是在 <code class="docutils literal notranslate"><span class="pre">uint256</span></code> （非负数数值字面常数）或 <code class="docutils literal notranslate"><span class="pre">int256</span></code> （负数数值字面常数）类型中进行。
无论右（指数）操作数的类型如何。</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>在0.4.0版本之前，Solidity中整数字的除法会被截断，但现在它转换为一个有理数，即 <code class="docutils literal notranslate"><span class="pre">5</span> <span class="pre">/</span> <span class="pre">2</span></code> 不等于 <code class="docutils literal notranslate"><span class="pre">2</span></code>，而是 <code class="docutils literal notranslate"><span class="pre">2.5</span></code>。</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Solidity 对每个有理数都有对应的数值字面常数类型。
整数字面常数和有理数字面常数都属于数值字面常数类型。
除此之外，所有的数值字面常数表达式（即只包含数值字面常数和运算符的表达式）都属于数值字面常数类型。
因此数值字面常数表达式 <code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">+</span> <span class="pre">2</span></code> 和 <code class="docutils literal notranslate"><span class="pre">2</span> <span class="pre">+</span> <span class="pre">1</span></code> 的结果跟有理数3的数值字面常数类型相同。</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>数字字面表达式一旦与非字面表达式一起使用，就会被转换为非字面类型。
不考虑类型，下面分配给 <code class="docutils literal notranslate"><span class="pre">b</span></code> 的表达式的值被评估为一个整数。
因为 <code class="docutils literal notranslate"><span class="pre">a</span></code> 的类型是 <code class="docutils literal notranslate"><span class="pre">uint128</span></code>，所以表达式 <code class="docutils literal notranslate"><span class="pre">2.5</span> <span class="pre">+</span> <span class="pre">a</span></code> 必须有一个合适的类型。
由于 <code class="docutils literal notranslate"><span class="pre">2.5</span></code> 和 <code class="docutils literal notranslate"><span class="pre">uint128</span></code> 的类型没有共同的类型，Solidity编译器不接受这段代码。</p>
</div>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.13&amp;code=dWludDEyOCBhID0gMTsKdWludDEyOCBiID0gMi41ICsgYSArIDAuNTs="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="kt">uint128</span><span class="w"> </span><span class="nv">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m m-Decimal">1</span><span class="p">;</span><span class="w"></span>
<span class="kt">uint128</span><span class="w"> </span><span class="nv">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m m-Decimal">2</span><span class="p">.</span><span class="m m-Decimal">5</span><span class="w"> </span><span class="o">+</span><span class="w"> </span>a<span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="m m-Decimal">0</span><span class="p">.</span><span class="m m-Decimal">5</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="string-literals">
<span id="index-10"></span><span id="id20"></span><h3>字符串字面常数和类型<a class="headerlink" href="#string-literals" title="Permalink to this heading"></a></h3>
<p>字符串字面常数是指由双引号或单引号引起来的字符串（ <code class="docutils literal notranslate"><span class="pre">&quot;foo&quot;</span></code> 或者 <code class="docutils literal notranslate"><span class="pre">'bar'</span></code>）。
它们也可以分成多个连续部分（ <code class="docutils literal notranslate"><span class="pre">&quot;foo&quot;</span> <span class="pre">&quot;bar&quot;</span></code> 相当于 <code class="docutils literal notranslate"><span class="pre">&quot;foobar&quot;</span></code> ），这在处理长字符串时很有帮助。
它们不像在 C 语言中那样带有结束符； <code class="docutils literal notranslate"><span class="pre">&quot;foo&quot;</span></code> 相当于3个字节而不是4个。
和整数字面常数一样，字符串字面常数的类型也可以发生改变，
但它们可以隐式地转换成 <code class="docutils literal notranslate"><span class="pre">bytes1</span></code>，……， <code class="docutils literal notranslate"><span class="pre">bytes32</span></code>，如果合适的话，还可以转换成 <code class="docutils literal notranslate"><span class="pre">bytes</span></code> 以及 <code class="docutils literal notranslate"><span class="pre">string</span></code>。</p>
<p>例如，使用 <code class="docutils literal notranslate"><span class="pre">bytes32</span> <span class="pre">samevar</span> <span class="pre">=</span> <span class="pre">&quot;stringliteral&quot;</span></code>，
当分配给 <code class="docutils literal notranslate"><span class="pre">bytes32</span></code> 类型时，字符串字面常数被解释成原始字节形式。</p>
<p>字符串字面常数只能包含可打印的ASCII字符，也就是0x20 … 0x7E之间的字符。</p>
<p>此外，字符串字元还支持以下转义字符：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">\&lt;newline&gt;</span></code> （转义一个实际的换行）</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">\\</span></code> （反斜杠）</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">\'</span></code> （单引号）</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">\&quot;</span></code> （双引号）</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">\n</span></code> （换行）</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">\r</span></code> （回车键）</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">\t</span></code> （制表）</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">\xNN</span></code> （十六进制转义，见下文）</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">\uNNNN</span></code> （unicode转义，见下文）</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">\xNN</span></code> 接收一个十六进制值并插入相应的字节，而 <code class="docutils literal notranslate"><span class="pre">\uNNNN</span></code> 接收一个Unicode编码点并插入一个UTF-8序列。</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>在0.8.0版本之前，有三个额外的转义序列。 <code class="docutils literal notranslate"><span class="pre">\b</span></code>， <code class="docutils literal notranslate"><span class="pre">\f</span></code> 和 <code class="docutils literal notranslate"><span class="pre">v</span></code>。
它们在其他语言中通常是可用的，但在实践中很少需要。
如果您确实需要它们，仍然可以通过十六进制转义插入，
即分别为 <code class="docutils literal notranslate"><span class="pre">\x08</span></code>， <code class="docutils literal notranslate"><span class="pre">x0c</span></code> 和 <code class="docutils literal notranslate"><span class="pre">\x0b</span></code>，就像其他ASCII字符一样。</p>
</div>
<p>下面例子中的字符串的长度为10个字节。
它以一个换行字节开始，接着是一个双引号，一个单引号，一个反斜杠字符，
然后（没有分隔符）是字符序列 <code class="docutils literal notranslate"><span class="pre">abcdef</span></code>。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.13&amp;code=IlxuXCJcJ1xcYWJjXApkZWYi"><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="s2">&quot;\n\&quot;</span><span class="err">\&#39;\\</span>abc<span class="err">\</span><span class="w"></span>
def<span class="err">&quot;</span><span class="w"></span>
</pre></div>
</div>
<p>任何非换行的Unicode行结束符（即LF, VF, FF, CR, NEL, LS, PS）都被认为是字符串字面的结束。
换行只在字符串字面内容前面没有 <code class="docutils literal notranslate"><span class="pre">\</span></code> 的情况下终止。</p>
</section>
<section id="unicode">
<h3>Unicode 字面常数<a class="headerlink" href="#unicode" title="Permalink to this heading"></a></h3>
<p>普通字符串字面常数只能包含ASCII码，而Unicode字面常数–以关键字 <code class="docutils literal notranslate"><span class="pre">unicode</span></code> 为前缀–可以包含任何有效的UTF-8序列。
它们也支持与普通字符串字面意义相同的转义序列。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.13&amp;code=c3RyaW5nIG1lbW9yeSBhID0gdW5pY29kZSJIZWxsbyDwn5iDIjs="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="kt">string</span><span class="w"> </span><span class="nv">memory</span><span class="w"> </span>a<span class="w"> </span><span class="o">=</span><span class="w"> </span>unicode<span class="s2">&quot;Hello 😃&quot;</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="index-11">
<span id="id21"></span><h3>十六进制字面常数<a class="headerlink" href="#index-11" title="Permalink to this heading"></a></h3>
<p>十六进制字面常数以关键字 <code class="docutils literal notranslate"><span class="pre">hex</span></code> 打头，
后面紧跟着用单引号或双引号引起来的字符串（ <code class="docutils literal notranslate"><span class="pre">hex&quot;001122FF&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">hex'0011_22_FF'</span></code>）。
它们的内容必须是十六进制的数字，可以选择使用一个下划线作为字节边界之间的分隔符。
字面的值将是十六进制序列的二进制表示。</p>
<p>由空格分隔的多个十六进制字面常数被串联成一个字面常数：
<code class="docutils literal notranslate"><span class="pre">hex&quot;00112233&quot;</span> <span class="pre">hex&quot;44556677&quot;</span></code> 相当于 <code class="docutils literal notranslate"><span class="pre">hex&quot;0011223344556677&quot;</span></code>。</p>
<p>十六进制字面常数的行为与 <a class="reference internal" href="#string-literals"><span class="std std-ref">字符串字面常数</span></a> 类似，并有相同的可转换性限制。</p>
</section>
<section id="enums">
<span id="index-12"></span><span id="id22"></span><h3>枚举类型<a class="headerlink" href="#enums" title="Permalink to this heading"></a></h3>
<p>枚举是在 Solidity 中创建用户定义类型的一种方式。
它们可以显式地转换为所有整数类型，和从整数类型来转换，但不允许隐式转换。
从整数的显式转换在运行时检查该值是否在枚举的范围内，否则会导致 <a class="reference internal" href="control-structures.html#assert-and-require"><span class="std std-ref">异常</span></a>。
枚举要求至少有一个成员，其声明时的默认值是第一个成员。
枚举不能有超过256个成员。</p>
<p>数据表示与C语言中的枚举相同。选项由后续的从 <code class="docutils literal notranslate"><span class="pre">0</span></code> 开始无符号整数值表示。</p>
<p>使用 <code class="docutils literal notranslate"><span class="pre">type(NameOfEnum).min</span></code> 和 <code class="docutils literal notranslate"><span class="pre">type(NameOfEnum).max</span></code>
您可以得到给定枚举的最小值和最大值。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.13&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguODsKCmNvbnRyYWN0IHRlc3QgewogICAgZW51bSBBY3Rpb25DaG9pY2VzIHsgR29MZWZ0LCBHb1JpZ2h0LCBHb1N0cmFpZ2h0LCBTaXRTdGlsbCB9CiAgICBBY3Rpb25DaG9pY2VzIGNob2ljZTsKICAgIEFjdGlvbkNob2ljZXMgY29uc3RhbnQgZGVmYXVsdENob2ljZSA9IEFjdGlvbkNob2ljZXMuR29TdHJhaWdodDsKCiAgICBmdW5jdGlvbiBzZXRHb1N0cmFpZ2h0KCkgcHVibGljIHsKICAgICAgICBjaG9pY2UgPSBBY3Rpb25DaG9pY2VzLkdvU3RyYWlnaHQ7CiAgICB9CgogICAgLy8g55Sx5LqO5p6a5Li+57G75Z6L5LiN5bGe5LqOQUJJ55qE5LiA6YOo5YiG77yM5Zug5q2k5a+55LqO5omA5pyJ5p2l6IeqIFNvbGlkaXR5IOWklumDqOeahOiwg+eUqO+8jAogICAgLy8gImdldENob2ljZSIg55qE562+5ZCN5Lya6Ieq5Yqo6KKr5pS55oiQICJnZXRDaG9pY2UoKSByZXR1cm5zICh1aW50OCki44CCCiAgICBmdW5jdGlvbiBnZXRDaG9pY2UoKSBwdWJsaWMgdmlldyByZXR1cm5zIChBY3Rpb25DaG9pY2VzKSB7CiAgICAgICAgcmV0dXJuIGNob2ljZTsKICAgIH0KCiAgICBmdW5jdGlvbiBnZXREZWZhdWx0Q2hvaWNlKCkgcHVibGljIHB1cmUgcmV0dXJucyAodWludCkgewogICAgICAgIHJldHVybiB1aW50KGRlZmF1bHRDaG9pY2UpOwogICAgfQoKICAgIGZ1bmN0aW9uIGdldExhcmdlc3RWYWx1ZSgpIHB1YmxpYyBwdXJlIHJldHVybnMgKEFjdGlvbkNob2ljZXMpIHsKICAgICAgICByZXR1cm4gdHlwZShBY3Rpb25DaG9pY2VzKS5tYXg7CiAgICB9CgogICAgZnVuY3Rpb24gZ2V0U21hbGxlc3RWYWx1ZSgpIHB1YmxpYyBwdXJlIHJldHVybnMgKEFjdGlvbkNob2ljZXMpIHsKICAgICAgICByZXR1cm4gdHlwZShBY3Rpb25DaG9pY2VzKS5taW47CiAgICB9Cn0="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">^</span><span class="k">0.8.8</span><span class="p">;</span><span class="w"></span>

<span class="k">contract</span><span class="w"> </span><span class="ni">test</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">enum</span><span class="w"> </span><span class="nv">ActionChoices</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>GoLeft<span class="p">,</span><span class="w"> </span>GoRight<span class="p">,</span><span class="w"> </span>GoStraight<span class="p">,</span><span class="w"> </span>SitStill<span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span>ActionChoices<span class="w"> </span>choice<span class="p">;</span><span class="w"></span>
<span class="w">    </span>ActionChoices<span class="w"> </span><span class="kt">constant</span><span class="w"> </span>defaultChoice<span class="w"> </span><span class="o">=</span><span class="w"> </span>ActionChoices<span class="p">.</span>GoStraight<span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">setGoStraight</span><span class="p">()</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span>choice<span class="w"> </span><span class="o">=</span><span class="w"> </span>ActionChoices<span class="p">.</span>GoStraight<span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="c1">// 由于枚举类型不属于ABI的一部分，因此对于所有来自 Solidity 外部的调用，</span>
<span class="w">    </span><span class="c1">// &quot;getChoice&quot; 的签名会自动被改成 &quot;getChoice() returns (uint8)&quot;。</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">getChoice</span><span class="p">()</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>view<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span>ActionChoices<span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">return</span><span class="w"> </span>choice<span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">getDefaultChoice</span><span class="p">()</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>pure<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">return</span><span class="w"> </span><span class="kt">uint</span><span class="p">(</span>defaultChoice<span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">getLargestValue</span><span class="p">()</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>pure<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span>ActionChoices<span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">return</span><span class="w"> </span>type<span class="p">(</span>ActionChoices<span class="p">).</span>max<span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">getSmallestValue</span><span class="p">()</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>pure<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span>ActionChoices<span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">return</span><span class="w"> </span>type<span class="p">(</span>ActionChoices<span class="p">).</span>min<span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>枚举也可以在文件级别上声明，在合约或库定义之外。</p>
</div>
</section>
<section id="user-defined-value-types">
<span id="index-13"></span><span id="id23"></span><h3>用户定义的值类型<a class="headerlink" href="#user-defined-value-types" title="Permalink to this heading"></a></h3>
<p>一个用户定义的值类型允许在一个基本的值类型上创建一个零成本的抽象。
这类似于一个别名，但有更严格的类型要求。</p>
<p>一个用户定义的值类型是用 <code class="docutils literal notranslate"><span class="pre">type</span> <span class="pre">C</span> <span class="pre">is</span> <span class="pre">V</span></code> 定义的，其中 <code class="docutils literal notranslate"><span class="pre">C</span></code> 是新引入的类型的名称，
<code class="docutils literal notranslate"><span class="pre">V</span></code> 必须是一个内置的值类型（”底层类型”）。
函数 <code class="docutils literal notranslate"><span class="pre">C.wrap</span></code> 被用来从底层类型转换到自定义类型。同样地，
函数 <code class="docutils literal notranslate"><span class="pre">C.unwrap</span></code> 用于从自定义类型转换到底层类型。</p>
<p>类型 <code class="docutils literal notranslate"><span class="pre">C</span></code> 没有任何运算符或约束成员函数。特别的是，甚至运算符 <code class="docutils literal notranslate"><span class="pre">==</span></code> 也没有定义。
也不允许与其他类型进行显式和隐式转换。</p>
<p>这种类型的值的数据表示是从底层类型中继承的，底层类型也被用于ABI中。</p>
<p>下面的例子说明了一个自定义类型 <code class="docutils literal notranslate"><span class="pre">UFixed256x18</span></code>，
代表一个有18位小数的十进制定点类型和一个最小的库来对该类型做算术运算。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.13&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguODsKCi8vIOS9v+eUqOeUqOaIt+WumuS5ieeahOWAvOexu+Wei+ihqOekuuS4gOS4qjE45L2N5bCP5pWw77yMMjU25L2N5a6955qE5a6a54K557G75Z6L44CCCnR5cGUgVUZpeGVkMjU2eDE4IGlzIHVpbnQyNTY7CgovLy8g5LiA5Liq5ZyoVUZpeGVkMjU2eDE45LiK6L+b6KGM5a6a54K55pON5L2c55qE5pyA5bCP5bqT44CCCmxpYnJhcnkgRml4ZWRNYXRoIHsKICAgIHVpbnQgY29uc3RhbnQgbXVsdGlwbGllciA9IDEwKioxODsKCiAgICAvLy8g5bCG5Lik5LiqVUZpeGVkMjU2eDE455qE5pWw5a2X55u45Yqg44CC5rqi5Ye65pe25bCG6L+U5Zue77yM5L6d6Z2gdWludDI1NueahOeul+acr+ajgOafpeOAggogICAgZnVuY3Rpb24gYWRkKFVGaXhlZDI1NngxOCBhLCBVRml4ZWQyNTZ4MTggYikgaW50ZXJuYWwgcHVyZSByZXR1cm5zIChVRml4ZWQyNTZ4MTgpIHsKICAgICAgICByZXR1cm4gVUZpeGVkMjU2eDE4LndyYXAoVUZpeGVkMjU2eDE4LnVud3JhcChhKSArIFVGaXhlZDI1NngxOC51bndyYXAoYikpOwogICAgfQogICAgLy8vIOWwhlVGaXhlZDI1NngxOOWSjHVpbnQyNTbnm7jkuZjjgILmuqLlh7rml7blsIbov5Tlm57vvIzkvp3pnaB1aW50MjU255qE566X5pyv5qOA5p+l44CCCiAgICBmdW5jdGlvbiBtdWwoVUZpeGVkMjU2eDE4IGEsIHVpbnQyNTYgYikgaW50ZXJuYWwgcHVyZSByZXR1cm5zIChVRml4ZWQyNTZ4MTgpIHsKICAgICAgICByZXR1cm4gVUZpeGVkMjU2eDE4LndyYXAoVUZpeGVkMjU2eDE4LnVud3JhcChhKSAqIGIpOwogICAgfQogICAgLy8vIOWvueS4gOS4qlVGaXhlZDI1NngxOOexu+Wei+eahOaVsOWtl+ebuOS4i+WPluaVtOOAggogICAgLy8vIEByZXR1cm4g5LiN6LaF6L+HIGBhYCDnmoTmnIDlpKfmlbTmlbDjgIIKICAgIGZ1bmN0aW9uIGZsb29yKFVGaXhlZDI1NngxOCBhKSBpbnRlcm5hbCBwdXJlIHJldHVybnMgKHVpbnQyNTYpIHsKICAgICAgICByZXR1cm4gVUZpeGVkMjU2eDE4LnVud3JhcChhKSAvIG11bHRpcGxpZXI7CiAgICB9CiAgICAvLy8g5bCG5LiA5LiqdWludDI1Nui9rOWMluS4uuebuOWQjOWAvOeahFVGaXhlZDI1NngxOOOAggogICAgLy8vIOWmguaenOaVtOaVsOWkquWkp++8jOWImeaBouWkjeOAggogICAgZnVuY3Rpb24gdG9VRml4ZWQyNTZ4MTgodWludDI1NiBhKSBpbnRlcm5hbCBwdXJlIHJldHVybnMgKFVGaXhlZDI1NngxOCkgewogICAgICAgIHJldHVybiBVRml4ZWQyNTZ4MTgud3JhcChhICogbXVsdGlwbGllcik7CiAgICB9Cn0="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">^</span><span class="k">0.8.8</span><span class="p">;</span><span class="w"></span>

<span class="c1">// 使用用户定义的值类型表示一个18位小数，256位宽的定点类型。</span>
type<span class="w"> </span>UFixed256x18<span class="w"> </span><span class="kt">is</span><span class="w"> </span><span class="kt">uint256</span><span class="p">;</span><span class="w"></span>

<span class="c1">/// 一个在UFixed256x18上进行定点操作的最小库。</span>
<span class="kt">library</span><span class="w"> </span>FixedMath<span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">uint</span><span class="w"> </span><span class="nv">constant</span><span class="w"> </span>multiplier<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m m-Decimal">10</span><span class="o">**</span><span class="m m-Decimal">18</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="c1">/// 将两个UFixed256x18的数字相加。溢出时将返回，依靠uint256的算术检查。</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">add</span><span class="p">(</span>UFixed256x18<span class="w"> </span>a<span class="p">,</span><span class="w"> </span>UFixed256x18<span class="w"> </span>b<span class="p">)</span><span class="w"> </span><span class="kt">internal</span><span class="w"> </span>pure<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span>UFixed256x18<span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">return</span><span class="w"> </span>UFixed256x18<span class="p">.</span>wrap<span class="p">(</span>UFixed256x18<span class="p">.</span>unwrap<span class="p">(</span>a<span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span>UFixed256x18<span class="p">.</span>unwrap<span class="p">(</span>b<span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="c1">/// 将UFixed256x18和uint256相乘。溢出时将返回，依靠uint256的算术检查。</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">mul</span><span class="p">(</span>UFixed256x18<span class="w"> </span>a<span class="p">,</span><span class="w"> </span><span class="kt">uint256</span><span class="w"> </span><span class="nv">b</span><span class="p">)</span><span class="w"> </span><span class="kt">internal</span><span class="w"> </span>pure<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span>UFixed256x18<span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">return</span><span class="w"> </span>UFixed256x18<span class="p">.</span>wrap<span class="p">(</span>UFixed256x18<span class="p">.</span>unwrap<span class="p">(</span>a<span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span>b<span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="c1">/// 对一个UFixed256x18类型的数字相下取整。</span>
<span class="w">    </span><span class="c1">/// @return 不超过 `a` 的最大整数。</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">floor</span><span class="p">(</span>UFixed256x18<span class="w"> </span>a<span class="p">)</span><span class="w"> </span><span class="kt">internal</span><span class="w"> </span>pure<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint256</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">return</span><span class="w"> </span>UFixed256x18<span class="p">.</span>unwrap<span class="p">(</span>a<span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span>multiplier<span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="c1">/// 将一个uint256转化为相同值的UFixed256x18。</span>
<span class="w">    </span><span class="c1">/// 如果整数太大，则恢复。</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">toUFixed256x18</span><span class="p">(</span><span class="kt">uint256</span><span class="w"> </span><span class="nv">a</span><span class="p">)</span><span class="w"> </span><span class="kt">internal</span><span class="w"> </span>pure<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span>UFixed256x18<span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">return</span><span class="w"> </span>UFixed256x18<span class="p">.</span>wrap<span class="p">(</span>a<span class="w"> </span><span class="o">*</span><span class="w"> </span>multiplier<span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>注意 <code class="docutils literal notranslate"><span class="pre">UFixed256x18.wrap</span></code> 和 <code class="docutils literal notranslate"><span class="pre">FixedMath.toUFixed256x18</span></code> 有相同的签名，
但执行两个非常不同的操作。 <code class="docutils literal notranslate"><span class="pre">UFixed256x18.wrap</span></code> 函数返回一个与输入的数据表示相同的 <code class="docutils literal notranslate"><span class="pre">UFixed256x18</span></code>，
而 <code class="docutils literal notranslate"><span class="pre">toUFixed256x18</span></code> 则返回一个具有相同数值的 <code class="docutils literal notranslate"><span class="pre">UFixed256x18</span></code>。</p>
</section>
<section id="function-types">
<span id="index-14"></span><span id="id24"></span><h3>函数类型<a class="headerlink" href="#function-types" title="Permalink to this heading"></a></h3>
<p>函数类型是一种表示函数的类型。可以将一个函数赋值给另一个函数类型的变量，
也可以将一个函数作为参数进行传递，还能在函数调用中返回函数类型变量。
函数类型有两类：- <em>内部（internal）</em> 函数和 <em>外部（external）</em> 函数：</p>
<p>内部函数只能在当前合约内被调用（更具体来说，
在当前代码块内，包括内部库函数和继承的函数中），
因为它们不能在当前合约上下文的外部被执行。
调用一个内部函数是通过跳转到它的入口标签来实现的，
就像在当前合约的内部调用一个函数。</p>
<p>外部函数由一个地址和一个函数签名组成，可以通过外部函数调用传递或者返回。</p>
<p>函数类型表示成如下的形式：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.13&amp;code=ZnVuY3Rpb24gKDxwYXJhbWV0ZXIgdHlwZXM+KSB7aW50ZXJuYWx8ZXh0ZXJuYWx9IFtwdXJlfHZpZXd8cGF5YWJsZV0gW3JldHVybnMgKDxyZXR1cm4gdHlwZXM+KV0="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="kt">function</span><span class="w"> </span><span class="p">(</span><span class="o">&lt;</span>parameter<span class="w"> </span>types<span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="kt">internal</span><span class="err">|</span><span class="kt">external</span><span class="p">}</span><span class="w"> </span><span class="p">[</span>pure<span class="err">|</span>view<span class="err">|</span><span class="kt">payable</span><span class="p">]</span><span class="w"> </span><span class="p">[</span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="o">&lt;</span><span class="kt">return</span><span class="w"> </span>types<span class="o">&gt;</span><span class="p">)]</span><span class="w"></span>
</pre></div>
</div>
<p>与参数类型相反，返回类型不能为空 —— 如果函数类型不需要返回，
则需要删除整个 <code class="docutils literal notranslate"><span class="pre">returns</span> <span class="pre">(&lt;return</span> <span class="pre">types&gt;)</span></code> 部分。</p>
<p>默认情况下，函数类型是内部函数，所以可以省略 <code class="docutils literal notranslate"><span class="pre">internal</span></code> 关键字。
注意，这只适用于函数类型。对于合约中定义的函数，
必须明确指定其可见性，它们没有默认类型。</p>
<p>转换：</p>
<p>当且仅当它们的参数类型相同，它们的返回类型相同，它们的内部/外部属性相同，
并且 <code class="docutils literal notranslate"><span class="pre">A</span></code> 的状态可变性比 <code class="docutils literal notranslate"><span class="pre">B</span></code> 的状态可变性更具限制性时，
一个函数类型 <code class="docutils literal notranslate"><span class="pre">A</span></code> 就可以隐式转换为一个函数类型 <code class="docutils literal notranslate"><span class="pre">B</span></code>。特别是：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pure</span></code> 函数可以转换为 <code class="docutils literal notranslate"><span class="pre">view</span></code> 和 <code class="docutils literal notranslate"><span class="pre">non-payable</span></code> 函数</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">view</span></code> 函数可以转换为 <code class="docutils literal notranslate"><span class="pre">non-payable</span></code> 函数</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">payable</span></code> 函数可以转换为 <code class="docutils literal notranslate"><span class="pre">non-payable</span></code> 函数</p></li>
</ul>
<p>其他函数类型之间的转换是不可能的。</p>
<p>关于 <code class="docutils literal notranslate"><span class="pre">payable</span></code> 和 <code class="docutils literal notranslate"><span class="pre">non-payable</span></code> 的规则可能有点混乱，
但实质上，如果一个函数是 <code class="docutils literal notranslate"><span class="pre">payable</span></code>，这意味着
它也接受零以太的支付，所以它也是 <code class="docutils literal notranslate"><span class="pre">non-payable</span></code>。
另一方面，一个 <code class="docutils literal notranslate"><span class="pre">non-payable</span></code> 的函数将拒绝发送给它的以太，
所以 <code class="docutils literal notranslate"><span class="pre">non-payable</span></code> 的函数不能被转换为 <code class="docutils literal notranslate"><span class="pre">payable</span></code> 的函数。</p>
<p>如果一个函数类型的变量没有被初始化，调用它将导致
会出现 <a class="reference internal" href="control-structures.html#assert-and-require"><span class="std std-ref">异常</span></a>。如果你在一个函数上使用了 <code class="docutils literal notranslate"><span class="pre">delete</span></code> 之后再调用它，
也会发生同样的情况。</p>
<p>如果外部函数类型在Solidity的上下文中被使用，
它们将被视为 <code class="docutils literal notranslate"><span class="pre">function</span></code> 类型，它将地址和函数标识符一起编码为一个 <code class="docutils literal notranslate"><span class="pre">bytes24</span></code> 类型。</p>
<p>请注意，当前合约的公开函数既可以被当作内部函数也可以被当作外部函数使用。
如果想将一个函数当作内部函数使用，就用 <code class="docutils literal notranslate"><span class="pre">f</span></code> 调用，
如果想将其当作外部函数，使用 <code class="docutils literal notranslate"><span class="pre">this.f</span></code> 。</p>
<p>一个内部类型的函数可以被分配给一个内部函数类型的变量，而不管它在哪里被定义。
这包括合约和库合约的隐私、内部和公共函数，以及自由函数。
另一方面，外部函数类型只与公共和外部合约函数兼容。
库合约被排除在外，因为它们需要一个 <code class="docutils literal notranslate"><span class="pre">delegatecall</span></code>，
并且 <a class="reference internal" href="contracts.html#library-selectors"><span class="std std-ref">对它们的选择器使用不同的ABI约定</span></a>。
在接口中声明的函数没有定义，所以指向它们也没有意义。</p>
<p>成员：
外部（或公共）函数有以下成员：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">.address</span></code> 返回该函数的合约地址。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">.selector</span></code> 返回 <a class="reference internal" href="abi-spec.html#abi-function-selector"><span class="std std-ref">ABI 函数选择器</span></a></p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>外部（或公共）函数曾经有额外的成员 <code class="docutils literal notranslate"><span class="pre">.gas(uint)</span></code> 和 <code class="docutils literal notranslate"><span class="pre">.value(uint)</span></code>。
这些在Solidity 0.6.2中被废弃，并在Solidity 0.7.0中被移除。取而代之的是
使用 <code class="docutils literal notranslate"><span class="pre">{gas:</span> <span class="pre">...}</span></code> 和 <code class="docutils literal notranslate"><span class="pre">{value:</span> <span class="pre">...}</span></code> 来分别指定发送到函数的气体量或以太（wei为单位）量。
参见 <a class="reference internal" href="control-structures.html#external-function-calls"><span class="std std-ref">外部函数调用</span></a> 以获得更多信息。</p>
</div>
<p>以下例子展示如何使用这些成员：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.13&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjQgPDAuOS4wOwoKY29udHJhY3QgRXhhbXBsZSB7CiAgICBmdW5jdGlvbiBmKCkgcHVibGljIHBheWFibGUgcmV0dXJucyAoYnl0ZXM0KSB7CiAgICAgICAgYXNzZXJ0KHRoaXMuZi5hZGRyZXNzID09IGFkZHJlc3ModGhpcykpOwogICAgICAgIHJldHVybiB0aGlzLmYuc2VsZWN0b3I7CiAgICB9CgogICAgZnVuY3Rpb24gZygpIHB1YmxpYyB7CiAgICAgICAgdGhpcy5me2dhczogMTAsIHZhbHVlOiA4MDB9KCk7CiAgICB9Cn0="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.6.4</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span><span class="w"></span>

<span class="k">contract</span><span class="w"> </span><span class="ni">Example</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">f</span><span class="p">()</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="kt">payable</span><span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span>bytes4<span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span>assert<span class="p">(</span><span class="kt">this</span><span class="p">.</span>f<span class="p">.</span><span class="kt">address</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kt">address</span><span class="p">(</span><span class="kt">this</span><span class="p">));</span><span class="w"></span>
<span class="w">        </span><span class="kt">return</span><span class="w"> </span><span class="kt">this</span><span class="p">.</span>f<span class="p">.</span>selector<span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">g</span><span class="p">()</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">this</span><span class="p">.</span>f<span class="p">{</span>gas<span class="p">:</span><span class="w"> </span><span class="m m-Decimal">10</span><span class="p">,</span><span class="w"> </span>value<span class="p">:</span><span class="w"> </span><span class="m m-Decimal">800</span><span class="p">}();</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>以下例子展示如何使用内部函数类型：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.13&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCmxpYnJhcnkgQXJyYXlVdGlscyB7CiAgICAvLyDlhoXpg6jlh73mlbDlj6/ku6XlnKjlhoXpg6jlupPlh73mlbDkuK3kvb/nlKjvvIzlm6DkuLrlroPku6zlsIbmmK/lkIzkuIDku6PnoIHkuIrkuIvmlofnmoTkuIDpg6jliIYKICAgIGZ1bmN0aW9uIG1hcCh1aW50W10gbWVtb3J5IHNlbGYsIGZ1bmN0aW9uICh1aW50KSBwdXJlIHJldHVybnMgKHVpbnQpIGYpCiAgICAgICAgaW50ZXJuYWwKICAgICAgICBwdXJlCiAgICAgICAgcmV0dXJucyAodWludFtdIG1lbW9yeSByKQogICAgewogICAgICAgIHIgPSBuZXcgdWludFtdKHNlbGYubGVuZ3RoKTsKICAgICAgICBmb3IgKHVpbnQgaSA9IDA7IGkgPCBzZWxmLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgICAgIHJbaV0gPSBmKHNlbGZbaV0pOwogICAgICAgIH0KICAgIH0KCiAgICBmdW5jdGlvbiByZWR1Y2UoCiAgICAgICAgdWludFtdIG1lbW9yeSBzZWxmLAogICAgICAgIGZ1bmN0aW9uICh1aW50LCB1aW50KSBwdXJlIHJldHVybnMgKHVpbnQpIGYKICAgICkKICAgICAgICBpbnRlcm5hbAogICAgICAgIHB1cmUKICAgICAgICByZXR1cm5zICh1aW50IHIpCiAgICB7CiAgICAgICAgciA9IHNlbGZbMF07CiAgICAgICAgZm9yICh1aW50IGkgPSAxOyBpIDwgc2VsZi5sZW5ndGg7IGkrKykgewogICAgICAgICAgICByID0gZihyLCBzZWxmW2ldKTsKICAgICAgICB9CiAgICB9CgogICAgZnVuY3Rpb24gcmFuZ2UodWludCBsZW5ndGgpIGludGVybmFsIHB1cmUgcmV0dXJucyAodWludFtdIG1lbW9yeSByKSB7CiAgICAgICAgciA9IG5ldyB1aW50W10obGVuZ3RoKTsKICAgICAgICBmb3IgKHVpbnQgaSA9IDA7IGkgPCByLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgICAgIHJbaV0gPSBpOwogICAgICAgIH0KICAgIH0KfQoKCmNvbnRyYWN0IFB5cmFtaWQgewogICAgdXNpbmcgQXJyYXlVdGlscyBmb3IgKjsKCiAgICBmdW5jdGlvbiBweXJhbWlkKHVpbnQgbCkgcHVibGljIHB1cmUgcmV0dXJucyAodWludCkgewogICAgICAgIHJldHVybiBBcnJheVV0aWxzLnJhbmdlKGwpLm1hcChzcXVhcmUpLnJlZHVjZShzdW0pOwogICAgfQoKICAgIGZ1bmN0aW9uIHNxdWFyZSh1aW50IHgpIGludGVybmFsIHB1cmUgcmV0dXJucyAodWludCkgewogICAgICAgIHJldHVybiB4ICogeDsKICAgIH0KCiAgICBmdW5jdGlvbiBzdW0odWludCB4LCB1aW50IHkpIGludGVybmFsIHB1cmUgcmV0dXJucyAodWludCkgewogICAgICAgIHJldHVybiB4ICsgeTsKICAgIH0KfQ=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.4.16</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span><span class="w"></span>

<span class="kt">library</span><span class="w"> </span>ArrayUtils<span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// 内部函数可以在内部库函数中使用，因为它们将是同一代码上下文的一部分</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">map</span><span class="p">(</span><span class="kt">uint</span><span class="p">[]</span><span class="w"> </span><span class="kt">memory</span><span class="w"> </span>self<span class="p">,</span><span class="w"> </span><span class="kt">function</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="p">)</span><span class="w"> </span>pure<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="p">)</span><span class="w"> </span>f<span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="kt">internal</span><span class="w"></span>
<span class="w">        </span>pure<span class="w"></span>
<span class="w">        </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="p">[]</span><span class="w"> </span><span class="kt">memory</span><span class="w"> </span>r<span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span>r<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">new</span><span class="w"> </span><span class="kt">uint</span><span class="p">[](</span>self<span class="p">.</span>length<span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kt">for</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m m-Decimal">0</span><span class="p">;</span><span class="w"> </span>i<span class="w"> </span><span class="o">&lt;</span><span class="w"> </span>self<span class="p">.</span>length<span class="p">;</span><span class="w"> </span>i<span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span>r<span class="p">[</span>i<span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>f<span class="p">(</span>self<span class="p">[</span>i<span class="p">]);</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">reduce</span><span class="p">(</span><span class="w"></span>
<span class="w">        </span><span class="kt">uint</span><span class="p">[]</span><span class="w"> </span><span class="kt">memory</span><span class="w"> </span>self<span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="kt">function</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="p">)</span><span class="w"> </span>pure<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="p">)</span><span class="w"> </span>f<span class="w"></span>
<span class="w">    </span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="kt">internal</span><span class="w"></span>
<span class="w">        </span>pure<span class="w"></span>
<span class="w">        </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">r</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span>r<span class="w"> </span><span class="o">=</span><span class="w"> </span>self<span class="p">[</span><span class="m m-Decimal">0</span><span class="p">];</span><span class="w"></span>
<span class="w">        </span><span class="kt">for</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m m-Decimal">1</span><span class="p">;</span><span class="w"> </span>i<span class="w"> </span><span class="o">&lt;</span><span class="w"> </span>self<span class="p">.</span>length<span class="p">;</span><span class="w"> </span>i<span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span>r<span class="w"> </span><span class="o">=</span><span class="w"> </span>f<span class="p">(</span>r<span class="p">,</span><span class="w"> </span>self<span class="p">[</span>i<span class="p">]);</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">range</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">length</span><span class="p">)</span><span class="w"> </span><span class="kt">internal</span><span class="w"> </span>pure<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="p">[]</span><span class="w"> </span><span class="kt">memory</span><span class="w"> </span>r<span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span>r<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">new</span><span class="w"> </span><span class="kt">uint</span><span class="p">[](</span>length<span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kt">for</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m m-Decimal">0</span><span class="p">;</span><span class="w"> </span>i<span class="w"> </span><span class="o">&lt;</span><span class="w"> </span>r<span class="p">.</span>length<span class="p">;</span><span class="w"> </span>i<span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span>r<span class="p">[</span>i<span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>i<span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>


<span class="k">contract</span><span class="w"> </span><span class="ni">Pyramid</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span>using<span class="w"> </span>ArrayUtils<span class="w"> </span><span class="kt">for</span><span class="w"> </span><span class="o">*</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">pyramid</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">l</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>pure<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">return</span><span class="w"> </span>ArrayUtils<span class="p">.</span>range<span class="p">(</span>l<span class="p">).</span>map<span class="p">(</span>square<span class="p">).</span>reduce<span class="p">(</span>sum<span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">square</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">x</span><span class="p">)</span><span class="w"> </span><span class="kt">internal</span><span class="w"> </span>pure<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">return</span><span class="w"> </span>x<span class="w"> </span><span class="o">*</span><span class="w"> </span>x<span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">sum</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">x</span><span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="nv">y</span><span class="p">)</span><span class="w"> </span><span class="kt">internal</span><span class="w"> </span>pure<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">return</span><span class="w"> </span>x<span class="w"> </span><span class="o">+</span><span class="w"> </span>y<span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>另一个使用外部函数类型的例子：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.13&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjIyIDwwLjkuMDsKCgpjb250cmFjdCBPcmFjbGUgewogICAgc3RydWN0IFJlcXVlc3QgewogICAgICAgIGJ5dGVzIGRhdGE7CiAgICAgICAgZnVuY3Rpb24odWludCkgZXh0ZXJuYWwgY2FsbGJhY2s7CiAgICB9CgogICAgUmVxdWVzdFtdIHByaXZhdGUgcmVxdWVzdHM7CiAgICBldmVudCBOZXdSZXF1ZXN0KHVpbnQpOwoKICAgIGZ1bmN0aW9uIHF1ZXJ5KGJ5dGVzIG1lbW9yeSBkYXRhLCBmdW5jdGlvbih1aW50KSBleHRlcm5hbCBjYWxsYmFjaykgcHVibGljIHsKICAgICAgICByZXF1ZXN0cy5wdXNoKFJlcXVlc3QoZGF0YSwgY2FsbGJhY2spKTsKICAgICAgICBlbWl0IE5ld1JlcXVlc3QocmVxdWVzdHMubGVuZ3RoIC0gMSk7CiAgICB9CgogICAgZnVuY3Rpb24gcmVwbHkodWludCByZXF1ZXN0SUQsIHVpbnQgcmVzcG9uc2UpIHB1YmxpYyB7CiAgICAgICAgLy8g6L+Z6YeM6KaB5qOA5p+l55qE5piv6LCD55So6L+U5Zue5piv5ZCm5p2l6Ieq5Y+v5L+h55qE5p2l5rqQCiAgICAgICAgcmVxdWVzdHNbcmVxdWVzdElEXS5jYWxsYmFjayhyZXNwb25zZSk7CiAgICB9Cn0KCgpjb250cmFjdCBPcmFjbGVVc2VyIHsKICAgIE9yYWNsZSBjb25zdGFudCBwcml2YXRlIE9SQUNMRV9DT05TVCA9IE9yYWNsZShhZGRyZXNzKDB4MDAwMDAwMDAyMTlhYjU0MDM1NmNCQjgzOUNiZTA1MzAzZDc3MDVGYSkpOyAvLyDlt7Lnn6XnmoTlkIjnuqYKICAgIHVpbnQgcHJpdmF0ZSBleGNoYW5nZVJhdGU7CgogICAgZnVuY3Rpb24gYnV5U29tZXRoaW5nKCkgcHVibGljIHsKICAgICAgICBPUkFDTEVfQ09OU1QucXVlcnkoIlVTRCIsIHRoaXMub3JhY2xlUmVzcG9uc2UpOwogICAgfQoKICAgIGZ1bmN0aW9uIG9yYWNsZVJlc3BvbnNlKHVpbnQgcmVzcG9uc2UpIHB1YmxpYyB7CiAgICAgICAgcmVxdWlyZSgKICAgICAgICAgICAgbXNnLnNlbmRlciA9PSBhZGRyZXNzKE9SQUNMRV9DT05TVCksCiAgICAgICAgICAgICJPbmx5IG9yYWNsZSBjYW4gY2FsbCB0aGlzLiIKICAgICAgICApOwogICAgICAgIGV4Y2hhbmdlUmF0ZSA9IHJlc3BvbnNlOwogICAgfQp9"><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.4.22</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span><span class="w"></span>


<span class="k">contract</span><span class="w"> </span><span class="ni">Oracle</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">struct</span><span class="w"> </span><span class="nv">Request</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">bytes</span><span class="w"> </span><span class="nv">data</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="kt">function</span><span class="p">(</span><span class="kt">uint</span><span class="p">)</span><span class="w"> </span><span class="kt">external</span><span class="w"> </span>callback<span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span>Request<span class="p">[]</span><span class="w"> </span><span class="kt">private</span><span class="w"> </span>requests<span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">event</span><span class="w"> </span><span class="nv">NewRequest</span><span class="p">(</span><span class="kt">uint</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">query</span><span class="p">(</span><span class="kt">bytes</span><span class="w"> </span><span class="nv">memory</span><span class="w"> </span>data<span class="p">,</span><span class="w"> </span><span class="kt">function</span><span class="p">(</span><span class="kt">uint</span><span class="p">)</span><span class="w"> </span><span class="kt">external</span><span class="w"> </span>callback<span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span>requests<span class="p">.</span>push<span class="p">(</span>Request<span class="p">(</span>data<span class="p">,</span><span class="w"> </span>callback<span class="p">));</span><span class="w"></span>
<span class="w">        </span>emit<span class="w"> </span>NewRequest<span class="p">(</span>requests<span class="p">.</span>length<span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="m m-Decimal">1</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">reply</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">requestID</span><span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="nv">response</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// 这里要检查的是调用返回是否来自可信的来源</span>
<span class="w">        </span>requests<span class="p">[</span>requestID<span class="p">].</span>callback<span class="p">(</span>response<span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>


<span class="k">contract</span><span class="w"> </span><span class="ni">OracleUser</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span>Oracle<span class="w"> </span><span class="kt">constant</span><span class="w"> </span><span class="kt">private</span><span class="w"> </span>ORACLE_CONST<span class="w"> </span><span class="o">=</span><span class="w"> </span>Oracle<span class="p">(</span><span class="kt">address</span><span class="p">(</span><span class="mh">0x00000000219ab540356cBB839Cbe05303d7705Fa</span><span class="p">));</span><span class="w"> </span><span class="c1">// 已知的合约</span>
<span class="w">    </span><span class="kt">uint</span><span class="w"> </span><span class="k">private </span><span class="nv">exchangeRate</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">buySomething</span><span class="p">()</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span>ORACLE_CONST<span class="p">.</span>query<span class="p">(</span><span class="s2">&quot;USD&quot;</span><span class="p">,</span><span class="w"> </span><span class="kt">this</span><span class="p">.</span>oracleResponse<span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">oracleResponse</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">response</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">require</span><span class="p">(</span><span class="w"></span>
<span class="w">            </span><span class="k">msg.sender</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kt">address</span><span class="p">(</span>ORACLE_CONST<span class="p">),</span><span class="w"></span>
<span class="w">            </span><span class="s2">&quot;Only oracle can call this.&quot;</span><span class="w"></span>
<span class="w">        </span><span class="p">);</span><span class="w"></span>
<span class="w">        </span>exchangeRate<span class="w"> </span><span class="o">=</span><span class="w"> </span>response<span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Lambda或内联函数是计划中的，但还不支持。</p>
</div>
</section>
</section>
<section id="reference-types">
<span id="index-15"></span><span id="id25"></span><h2>引用类型<a class="headerlink" href="#reference-types" title="Permalink to this heading"></a></h2>
<p>引用类型的值可以通过多个不同的名称进行修改。
这与值类型形成鲜明对比，在值类型的变量被使用时，您会得到一个独立的副本。
正因为如此，对引用类型的处理要比对值类型的处理更加谨慎。目前，
引用类型包括结构、数组和映射。如果您使用一个引用类型，
您必须明确地提供存储该类型的数据区域。 <code class="docutils literal notranslate"><span class="pre">memory</span></code> （其寿命限于外部函数调用），
<code class="docutils literal notranslate"><span class="pre">storage</span></code> （存储状态变量的位置，其寿命限于合约的寿命）
或 <code class="docutils literal notranslate"><span class="pre">calldata</span></code> （包含函数参数的特殊数据位置）。</p>
<p>改变数据位置的赋值或类型转换将总是导致自动复制操作，
而同一数据位置内的赋值只在某些情况下对存储类型进行复制。</p>
<section id="data-location">
<span id="id26"></span><h3>数据位置<a class="headerlink" href="#data-location" title="Permalink to this heading"></a></h3>
<p>每个引用类型都有一个额外的属性，即 “数据位置”，
关于它的存储位置。有三个数据位置。 <code class="docutils literal notranslate"><span class="pre">memory</span></code>, <code class="docutils literal notranslate"><span class="pre">storage</span></code> 和 <code class="docutils literal notranslate"><span class="pre">calldata</span></code>。
Calldata是一个不可修改的、非持久性的区域，用于存储函数参数，其行为主要类似于memory。</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>如果可以的话，尽量使用 <code class="docutils literal notranslate"><span class="pre">calldata</span></code> 作为数据位置，因为这样可以避免复制，
也可以确保数据不能被修改。使用 <code class="docutils literal notranslate"><span class="pre">calldata</span></code> 数据位置的数组和结构也可以从函数中返回，
但不可能分配这种类型。</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>在0.6.9版本之前，引用型参数的数据位置被限制在外部函数中的 <code class="docutils literal notranslate"><span class="pre">calldata</span></code>，
公开函数中的 <code class="docutils literal notranslate"><span class="pre">memory</span></code>，以及内部和私有函数中的 <code class="docutils literal notranslate"><span class="pre">memory</span></code> 或 <code class="docutils literal notranslate"><span class="pre">storage</span></code>。
现在 <code class="docutils literal notranslate"><span class="pre">memory</span></code> 和 <code class="docutils literal notranslate"><span class="pre">calldata</span></code> 在所有函数中都被允许使用，无论其可见性如何。</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>在0.5.0版本之前，数据位置可以省略，并且会根据变量的种类、函数类型等默认为不同的位置，
但现在所有的复杂类型都必须给出一个明确的数据位置。</p>
</div>
<section id="data-location-assignment">
<span id="id27"></span><h4>数据位置和分配行为<a class="headerlink" href="#data-location-assignment" title="Permalink to this heading"></a></h4>
<p>数据位置不仅与数据的持久性有关，而且也与分配的语义有关：</p>
<ul class="simple">
<li><p>在 <code class="docutils literal notranslate"><span class="pre">storage</span></code> 和 <code class="docutils literal notranslate"><span class="pre">memory</span></code> 之间的分配（或从 <code class="docutils literal notranslate"><span class="pre">calldata</span></code> 中分配） 总是创建一个独立的拷贝。</p></li>
<li><p>从 <code class="docutils literal notranslate"><span class="pre">memory</span></code> 到 <code class="docutils literal notranslate"><span class="pre">memory</span></code> 的赋值只创建引用。
这意味着对一个内存变量的改变在所有其他引用相同数据的内存变量中也是可见的。</p></li>
<li><p>从  <code class="docutils literal notranslate"><span class="pre">storage</span></code> 到 <strong>local</strong> 存储变量的赋值也只赋值一个引用。</p></li>
<li><p>所有其他对 <code class="docutils literal notranslate"><span class="pre">storage</span></code> 的赋值总是拷贝的。
这种情况的例子是对状态变量或存储结构类型的局部变量成员的赋值，
即使局部变量本身只是一个引用。</p></li>
</ul>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.13&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC41LjAgPDAuOS4wOwoKY29udHJhY3QgQyB7CiAgICAvLyB4IOeahOaVsOaNruWtmOWCqOS9jee9ruaYryBzdG9yYWdl44CCCiAgICAvLyDov5nmmK/llK/kuIDlj6/ku6XnnIHnlaXmlbDmja7kvY3nva7nmoTlnLDmlrnjgIIKICAgIHVpbnRbXSB4OwoKICAgIC8vIG1lbW9yeUFycmF5IOeahOaVsOaNruWtmOWCqOS9jee9ruaYryBtZW1vcnnjgIIKICAgIGZ1bmN0aW9uIGYodWludFtdIG1lbW9yeSBtZW1vcnlBcnJheSkgcHVibGljIHsKICAgICAgICB4ID0gbWVtb3J5QXJyYXk7IC8vIOWwhuaVtOS4quaVsOe7hOaLt+i0neWIsCBzdG9yYWdlIOS4re+8jOWPr+ihjAogICAgICAgIHVpbnRbXSBzdG9yYWdlIHkgPSB4OyAvLyDliIbphY3kuIDkuKrmjIfpkojvvIzlhbbkuK0geSDnmoTmlbDmja7lrZjlgqjkvY3nva7mmK8gc3RvcmFnZe+8jOWPr+ihjAogICAgICAgIHlbN107IC8vIOi/lOWbnuesrCA4IOS4quWFg+e0oO+8jOWPr+ihjAogICAgICAgIHkucG9wKCk7IC8vIOmAmui/h3nkv67mlLl477yM5Y+v6KGMCiAgICAgICAgZGVsZXRlIHg7IC8vIOa4hemZpOaVsOe7hO+8jOWQjOaXtuS/ruaUuSB577yM5Y+v6KGMCiAgICAgICAgLy8g5LiL6Z2i55qE5bCx5LiN5Y+v6KGM5LqG77yb6ZyA6KaB5ZyoIHN0b3JhZ2Ug5Lit5Yib5bu65paw55qE5pyq5ZG95ZCN55qE5Li05pe25pWw57uE77yMLwogICAgICAgIC8vIOS9hiBzdG9yYWdlIOaYr+KAnOmdmeaAgeKAneWIhumFjeeahO+8mgogICAgICAgIC8vIHkgPSBtZW1vcnlBcnJheTsKICAgICAgICAvLyDkuIvpnaLov5nkuIDooYzkuZ/kuI3lj6/ooYzvvIzlm6DkuLrov5nkvJrigJzph43nva7igJ3mjIfpkojvvIwKICAgICAgICAvLyDkvYblubbmsqHmnInlj6/ku6XorqnlroPmjIflkJHnmoTlkIjpgILnmoTlrZjlgqjkvY3nva7jgIIKICAgICAgICAvLyBkZWxldGUgeTsKICAgICAgICBnKHgpOyAvLyDosIPnlKggZyDlh73mlbDvvIzlkIzml7bnp7vkuqTlr7kgeCDnmoTlvJXnlKgKICAgICAgICBoKHgpOyAvLyDosIPnlKggaCDlh73mlbDvvIzlkIzml7blnKggbWVtb3J5IOS4reWIm+W7uuS4gOS4queLrOeri+eahOS4tOaXtuaLt+i0nQogICAgfQoKICAgIGZ1bmN0aW9uIGcodWludFtdIHN0b3JhZ2UpIGludGVybmFsIHB1cmUge30KICAgIGZ1bmN0aW9uIGgodWludFtdIG1lbW9yeSkgcHVibGljIHB1cmUge30KfQ=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.5.0</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span><span class="w"></span>

<span class="k">contract</span><span class="w"> </span><span class="ni">C</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// x 的数据存储位置是 storage。</span>
<span class="w">    </span><span class="c1">// 这是唯一可以省略数据位置的地方。</span>
<span class="w">    </span><span class="kt">uint</span><span class="p">[]</span><span class="w"> </span>x<span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="c1">// memoryArray 的数据存储位置是 memory。</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">f</span><span class="p">(</span><span class="kt">uint</span><span class="p">[]</span><span class="w"> </span><span class="kt">memory</span><span class="w"> </span>memoryArray<span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span>x<span class="w"> </span><span class="o">=</span><span class="w"> </span>memoryArray<span class="p">;</span><span class="w"> </span><span class="c1">// 将整个数组拷贝到 storage 中，可行</span>
<span class="w">        </span><span class="kt">uint</span><span class="p">[]</span><span class="w"> </span>storage<span class="w"> </span>y<span class="w"> </span><span class="o">=</span><span class="w"> </span>x<span class="p">;</span><span class="w"> </span><span class="c1">// 分配一个指针，其中 y 的数据存储位置是 storage，可行</span>
<span class="w">        </span>y<span class="p">[</span><span class="m m-Decimal">7</span><span class="p">];</span><span class="w"> </span><span class="c1">// 返回第 8 个元素，可行</span>
<span class="w">        </span>y<span class="p">.</span>pop<span class="p">();</span><span class="w"> </span><span class="c1">// 通过y修改x，可行</span>
<span class="w">        </span>delete<span class="w"> </span>x<span class="p">;</span><span class="w"> </span><span class="c1">// 清除数组，同时修改 y，可行</span>
<span class="w">        </span><span class="c1">// 下面的就不可行了；需要在 storage 中创建新的未命名的临时数组，/</span>
<span class="w">        </span><span class="c1">// 但 storage 是“静态”分配的：</span>
<span class="w">        </span><span class="c1">// y = memoryArray;</span>
<span class="w">        </span><span class="c1">// 下面这一行也不可行，因为这会“重置”指针，</span>
<span class="w">        </span><span class="c1">// 但并没有可以让它指向的合适的存储位置。</span>
<span class="w">        </span><span class="c1">// delete y;</span>
<span class="w">        </span>g<span class="p">(</span>x<span class="p">);</span><span class="w"> </span><span class="c1">// 调用 g 函数，同时移交对 x 的引用</span>
<span class="w">        </span>h<span class="p">(</span>x<span class="p">);</span><span class="w"> </span><span class="c1">// 调用 h 函数，同时在 memory 中创建一个独立的临时拷贝</span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">g</span><span class="p">(</span><span class="kt">uint</span><span class="p">[]</span><span class="w"> </span>storage<span class="p">)</span><span class="w"> </span><span class="kt">internal</span><span class="w"> </span>pure<span class="w"> </span><span class="p">{}</span><span class="w"></span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">h</span><span class="p">(</span><span class="kt">uint</span><span class="p">[]</span><span class="w"> </span><span class="kt">memory</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>pure<span class="w"> </span><span class="p">{}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
</section>
<section id="arrays">
<span id="index-16"></span><span id="id28"></span><h3>数组<a class="headerlink" href="#arrays" title="Permalink to this heading"></a></h3>
<p>数组可以在声明时指定长度，也可以动态调整大小。</p>
<p>一个元素类型为 <code class="docutils literal notranslate"><span class="pre">T</span></code>，固定长度为 <code class="docutils literal notranslate"><span class="pre">k</span></code> 的数组可以声明为 <code class="docutils literal notranslate"><span class="pre">T[k]</span></code>，
而动态数组声明为 <code class="docutils literal notranslate"><span class="pre">T[]</span></code>。</p>
<p>例如，一个由5个 <code class="docutils literal notranslate"><span class="pre">uint</span></code> 的动态数组组成的数组被写成 <code class="docutils literal notranslate"><span class="pre">uint[][5]</span></code>。
与其他一些语言相比, 这种记法是相反的。
在Solidity中, <code class="docutils literal notranslate"><span class="pre">X[3]</span></code> 总是一个包含三个 <code class="docutils literal notranslate"><span class="pre">X</span></code> 类型元素的数组，
即使 <code class="docutils literal notranslate"><span class="pre">X</span></code> 本身是一个数组。 这在其他语言中是不存在的，如C语言。</p>
<p>索引是基于零的，访问方向与声明相反。</p>
<p>例如，如果您有一个变量 <code class="docutils literal notranslate"><span class="pre">uint[][5]</span> <span class="pre">memory</span> <span class="pre">x</span></code>，您用 <code class="docutils literal notranslate"><span class="pre">x[2][6]</span></code> 访问第三个动态数组中的第七个 <code class="docutils literal notranslate"><span class="pre">uint</span></code>，
要访问第三个动态数组，用 <code class="docutils literal notranslate"><span class="pre">x[2]</span></code>。同样，如果您有一个数组 <code class="docutils literal notranslate"><span class="pre">T[5]</span> <span class="pre">a</span></code> 的类型 <code class="docutils literal notranslate"><span class="pre">T</span></code>，
也可以是一个数组，那么 <code class="docutils literal notranslate"><span class="pre">a[2]</span></code> 总是有类型 <code class="docutils literal notranslate"><span class="pre">T</span></code>。</p>
<p>数组元素可以是任何类型，包括映射或结构体。
并适用于类型的一般限制，映射只能存储在 <code class="docutils literal notranslate"><span class="pre">storage</span></code> 数据位置，
公开可见的函数需要参数是 <a class="reference internal" href="abi-spec.html#abi"><span class="std std-ref">ABI类型</span></a>。</p>
<p>可以将状态变量数组标记为 <code class="docutils literal notranslate"><span class="pre">public</span></code>，
并让Solidity创建一个 <a class="reference internal" href="contracts.html#visibility-and-getters"><span class="std std-ref">getter</span></a> 函数。数字索引成为该函数的一个必要参数。</p>
<p>访问一个超过它的末端的数组会导致一个失败的断言。
方法 <code class="docutils literal notranslate"><span class="pre">.push()</span></code> 和 <code class="docutils literal notranslate"><span class="pre">.push(value)</span></code> 可以用来在数组的末端追加一个新的元素，
其中 <code class="docutils literal notranslate"><span class="pre">.push()</span></code> 追加一个零初始化的元素并返回它的引用。</p>
<section id="bytes-string">
<span id="bytes"></span><span id="strings"></span><span id="index-17"></span><h4><code class="docutils literal notranslate"><span class="pre">bytes</span></code> 和 <code class="docutils literal notranslate"><span class="pre">string</span></code> 类型的数组<a class="headerlink" href="#bytes-string" title="Permalink to this heading"></a></h4>
<p><code class="docutils literal notranslate"><span class="pre">bytes</span></code> 和 <code class="docutils literal notranslate"><span class="pre">string</span></code> 类型的变量是特殊的数组。 <code class="docutils literal notranslate"><span class="pre">bytes</span></code> 类似于 <code class="docutils literal notranslate"><span class="pre">bytes1[]</span></code>，
但它在 calldata 中会被“紧打包”（译者注：将元素连续地存在一起，不会按每 32 字节一单元的方式来存放）。
<code class="docutils literal notranslate"><span class="pre">string</span></code> 与 <code class="docutils literal notranslate"><span class="pre">bytes</span></code> 相同，但不允许用长度或索引来访问。</p>
<p>Solidity没有字符串操作函数，但有第三方的字符串库。
您也可以用 <code class="docutils literal notranslate"><span class="pre">keccak256(abi.encodePacked(s1))</span> <span class="pre">==</span> <span class="pre">keccak256(abi.encodePacked(s2))</span></code>
来比较两个字符串的keccak256-hash，用 <code class="docutils literal notranslate"><span class="pre">string.concat(s1,</span> <span class="pre">s2)</span></code> 来连接两个字符串。</p>
<p>您应该使用 <code class="docutils literal notranslate"><span class="pre">bytes</span></code> 而不是 <code class="docutils literal notranslate"><span class="pre">bytes1[]</span></code>，因为它更便宜，
因为在 <code class="docutils literal notranslate"><span class="pre">memory</span></code> 中使用 <code class="docutils literal notranslate"><span class="pre">bytes1[]</span></code> 会在元素之间增加31个填充字节。
请注意，在 <code class="docutils literal notranslate"><span class="pre">storage</span></code> 中，由于紧打包，没有填充，参见 <a class="reference internal" href="internals/layout_in_storage.html#bytes-and-string"><span class="std std-ref">字节和字符串</span></a>。
一般来说，对于任意长度的原始字节数据使用 <code class="docutils literal notranslate"><span class="pre">bytes</span></code>，对于任意长度的字符串（UTF-8）数据使用 <code class="docutils literal notranslate"><span class="pre">string</span></code>。
如果您能将长度限制在一定的字节数，总是使用 <code class="docutils literal notranslate"><span class="pre">bytes1</span></code> 到 <code class="docutils literal notranslate"><span class="pre">bytes32</span></code> 中的一种值类型，因为它们更便宜。</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>如果想要访问以字节表示的字符串 <code class="docutils literal notranslate"><span class="pre">s</span></code>，
请使用 <code class="docutils literal notranslate"><span class="pre">bytes(s).length</span></code> / <code class="docutils literal notranslate"><span class="pre">bytes(s)[7]</span> <span class="pre">=</span> <span class="pre">'x';</span></code>。
注意这时您访问的是 UTF-8 形式的低级 bytes 类型，而不是单个的字符。</p>
</div>
</section>
<section id="bytes-concat-string-concat">
<span id="string-concat"></span><span id="bytes-concat"></span><span id="index-18"></span><h4>函数 <code class="docutils literal notranslate"><span class="pre">bytes.concat</span></code> 和 <code class="docutils literal notranslate"><span class="pre">string.concat</span></code><a class="headerlink" href="#bytes-concat-string-concat" title="Permalink to this heading"></a></h4>
<p>您可以使用 <code class="docutils literal notranslate"><span class="pre">string.concat</span></code> 连接任意数量的 <code class="docutils literal notranslate"><span class="pre">string</span></code> 值。
该函数返回一个单一的 <code class="docutils literal notranslate"><span class="pre">string</span> <span class="pre">memory</span></code> 数组，其中包含没有填充的参数内容。
如果您想使用不能隐式转换为 <code class="docutils literal notranslate"><span class="pre">string</span></code> 的其他类型的参数，您需要先将它们转换为 <code class="docutils literal notranslate"><span class="pre">string</span></code>。</p>
<p>同样， <code class="docutils literal notranslate"><span class="pre">bytes.concat</span></code> 函数可以连接任意数量的 <code class="docutils literal notranslate"><span class="pre">bytes</span></code> 或 <code class="docutils literal notranslate"><span class="pre">bytes1</span> <span class="pre">...</span> <span class="pre">bytes32</span></code> 值。
该函数返回一个单一的 <code class="docutils literal notranslate"><span class="pre">bytes</span> <span class="pre">memory</span></code> 数组，其中包含没有填充的参数内容。
如果您想使用字符串参数或其他不能隐式转换为 <code class="docutils literal notranslate"><span class="pre">bytes</span></code> 的类型，
您需要先将它们转换为 <code class="docutils literal notranslate"><span class="pre">bytes</span></code> 或 <code class="docutils literal notranslate"><span class="pre">bytes1</span></code> /…/ <code class="docutils literal notranslate"><span class="pre">bytes32</span></code>。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.13&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguMTI7Cgpjb250cmFjdCBDIHsKICAgIHN0cmluZyBzID0gIlN0b3JhZ2UiOwogICAgZnVuY3Rpb24gZihieXRlcyBjYWxsZGF0YSBiYywgc3RyaW5nIG1lbW9yeSBzbSwgYnl0ZXMxNiBiKSBwdWJsaWMgdmlldyB7CiAgICAgICAgc3RyaW5nIG1lbW9yeSBjb25jYXRTdHJpbmcgPSBzdHJpbmcuY29uY2F0KHMsIHN0cmluZyhiYyksICJMaXRlcmFsIiwgc20pOwogICAgICAgIGFzc2VydCgoYnl0ZXMocykubGVuZ3RoICsgYmMubGVuZ3RoICsgNyArIGJ5dGVzKHNtKS5sZW5ndGgpID09IGJ5dGVzKGNvbmNhdFN0cmluZykubGVuZ3RoKTsKCiAgICAgICAgYnl0ZXMgbWVtb3J5IGNvbmNhdEJ5dGVzID0gYnl0ZXMuY29uY2F0KGJ5dGVzKHMpLCBiYywgYmNbOjJdLCAiTGl0ZXJhbCIsIGJ5dGVzKHNtKSwgYik7CiAgICAgICAgYXNzZXJ0KChieXRlcyhzKS5sZW5ndGggKyBiYy5sZW5ndGggKyAyICsgNyArIGJ5dGVzKHNtKS5sZW5ndGggKyBiLmxlbmd0aCkgPT0gY29uY2F0Qnl0ZXMubGVuZ3RoKTsKICAgIH0KfQ=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">^</span><span class="k">0.8.12</span><span class="p">;</span><span class="w"></span>

<span class="k">contract</span><span class="w"> </span><span class="ni">C</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">string</span><span class="w"> </span><span class="nv">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">&quot;Storage&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">f</span><span class="p">(</span><span class="kt">bytes</span><span class="w"> </span><span class="nv">calldata</span><span class="w"> </span>bc<span class="p">,</span><span class="w"> </span><span class="kt">string</span><span class="w"> </span><span class="nv">memory</span><span class="w"> </span>sm<span class="p">,</span><span class="w"> </span><span class="kt">bytes16</span><span class="w"> </span><span class="nv">b</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>view<span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">string</span><span class="w"> </span><span class="nv">memory</span><span class="w"> </span>concatString<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">string</span><span class="p">.</span>concat<span class="p">(</span>s<span class="p">,</span><span class="w"> </span><span class="kt">string</span><span class="p">(</span>bc<span class="p">),</span><span class="w"> </span><span class="s2">&quot;Literal&quot;</span><span class="p">,</span><span class="w"> </span>sm<span class="p">);</span><span class="w"></span>
<span class="w">        </span>assert<span class="p">((</span><span class="kt">bytes</span><span class="p">(</span>s<span class="p">).</span>length<span class="w"> </span><span class="o">+</span><span class="w"> </span>bc<span class="p">.</span>length<span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="m m-Decimal">7</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="kt">bytes</span><span class="p">(</span>sm<span class="p">).</span>length<span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kt">bytes</span><span class="p">(</span>concatString<span class="p">).</span>length<span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="kt">bytes</span><span class="w"> </span><span class="nv">memory</span><span class="w"> </span>concatBytes<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">bytes</span><span class="p">.</span>concat<span class="p">(</span><span class="kt">bytes</span><span class="p">(</span>s<span class="p">),</span><span class="w"> </span>bc<span class="p">,</span><span class="w"> </span>bc<span class="p">[:</span><span class="m m-Decimal">2</span><span class="p">],</span><span class="w"> </span><span class="s2">&quot;Literal&quot;</span><span class="p">,</span><span class="w"> </span><span class="kt">bytes</span><span class="p">(</span>sm<span class="p">),</span><span class="w"> </span>b<span class="p">);</span><span class="w"></span>
<span class="w">        </span>assert<span class="p">((</span><span class="kt">bytes</span><span class="p">(</span>s<span class="p">).</span>length<span class="w"> </span><span class="o">+</span><span class="w"> </span>bc<span class="p">.</span>length<span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="m m-Decimal">2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="m m-Decimal">7</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="kt">bytes</span><span class="p">(</span>sm<span class="p">).</span>length<span class="w"> </span><span class="o">+</span><span class="w"> </span>b<span class="p">.</span>length<span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span>concatBytes<span class="p">.</span>length<span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>如果您不带参数调用 <code class="docutils literal notranslate"><span class="pre">string.concat</span></code> 或 <code class="docutils literal notranslate"><span class="pre">bytes.concat</span></code>，它们会返回一个空数组。</p>
</section>
<section id="index-19">
<span id="id29"></span><h4>创建内存数组<a class="headerlink" href="#index-19" title="Permalink to this heading"></a></h4>
<p>具有动态长度的内存数组可以使用 <code class="docutils literal notranslate"><span class="pre">new</span></code> 操作符创建。
与存储数组不同的是，<strong>不可能</strong> 调整内存数组的大小（例如， <code class="docutils literal notranslate"><span class="pre">.push</span></code> 成员函数不可用）。
您必须事先计算出所需的大小，或者创建一个新的内存数组并复制每个元素。</p>
<p>正如Solidity中的所有变量一样，新分配的数组元素总是以 <a class="reference internal" href="control-structures.html#default-value"><span class="std std-ref">默认值</span></a> 进行初始化。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.13&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCmNvbnRyYWN0IEMgewogICAgZnVuY3Rpb24gZih1aW50IGxlbikgcHVibGljIHB1cmUgewogICAgICAgIHVpbnRbXSBtZW1vcnkgYSA9IG5ldyB1aW50W10oNyk7CiAgICAgICAgYnl0ZXMgbWVtb3J5IGIgPSBuZXcgYnl0ZXMobGVuKTsKICAgICAgICBhc3NlcnQoYS5sZW5ndGggPT0gNyk7CiAgICAgICAgYXNzZXJ0KGIubGVuZ3RoID09IGxlbik7CiAgICAgICAgYVs2XSA9IDg7CiAgICB9Cn0="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.4.16</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span><span class="w"></span>

<span class="k">contract</span><span class="w"> </span><span class="ni">C</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">f</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">len</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>pure<span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">uint</span><span class="p">[]</span><span class="w"> </span><span class="kt">memory</span><span class="w"> </span>a<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">new</span><span class="w"> </span><span class="kt">uint</span><span class="p">[](</span><span class="m m-Decimal">7</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kt">bytes</span><span class="w"> </span><span class="nv">memory</span><span class="w"> </span>b<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">new</span><span class="w"> </span><span class="kt">bytes</span><span class="p">(</span>len<span class="p">);</span><span class="w"></span>
<span class="w">        </span>assert<span class="p">(</span>a<span class="p">.</span>length<span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="m m-Decimal">7</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span>assert<span class="p">(</span>b<span class="p">.</span>length<span class="w"> </span><span class="o">==</span><span class="w"> </span>len<span class="p">);</span><span class="w"></span>
<span class="w">        </span>a<span class="p">[</span><span class="m m-Decimal">6</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m m-Decimal">8</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="index-20">
<span id="id30"></span><h4>数组字面常数<a class="headerlink" href="#index-20" title="Permalink to this heading"></a></h4>
<p>数组字面常数表达式是一个逗号分隔的一个或多个表达式的列表，用方括号（ <code class="docutils literal notranslate"><span class="pre">[...]</span></code> ）括起来。
例如， <code class="docutils literal notranslate"><span class="pre">[1,</span> <span class="pre">a,</span> <span class="pre">f(3)]</span></code>。数组字面常数的类型确定如下：</p>
<p>它总是一个静态大小的内存数组，其长度是表达式的数量。</p>
<p>数组的基本类型是列表上第一个表达式的类型，这样所有其他表达式都可以隐含地转换为它。
如果不能做到这一点，则会有一个类型错误。</p>
<p>仅仅存在一个所有元素都可以转换的类型是不够的。其中一个元素必须是该类型的。</p>
<p>在下面的例子中， <code class="docutils literal notranslate"><span class="pre">[1,</span> <span class="pre">2,</span> <span class="pre">3]</span></code> 的类型是 <code class="docutils literal notranslate"><span class="pre">uint8[3]</span> <span class="pre">memory</span></code>，
因为这些常量的类型都是 <code class="docutils literal notranslate"><span class="pre">uint8</span></code>。如果您想让结果是 <code class="docutils literal notranslate"><span class="pre">uint[3]</span> <span class="pre">memory</span></code> 类型，
您需要把第一个元素转换为 <code class="docutils literal notranslate"><span class="pre">uint</span></code>。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.13&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCmNvbnRyYWN0IEMgewogICAgZnVuY3Rpb24gZigpIHB1YmxpYyBwdXJlIHsKICAgICAgICBnKFt1aW50KDEpLCAyLCAzXSk7CiAgICB9CiAgICBmdW5jdGlvbiBnKHVpbnRbM10gbWVtb3J5KSBwdWJsaWMgcHVyZSB7CiAgICAgICAgLy8gLi4uCiAgICB9Cn0="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.4.16</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span><span class="w"></span>

<span class="k">contract</span><span class="w"> </span><span class="ni">C</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">f</span><span class="p">()</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>pure<span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span>g<span class="p">([</span><span class="kt">uint</span><span class="p">(</span><span class="m m-Decimal">1</span><span class="p">),</span><span class="w"> </span><span class="m m-Decimal">2</span><span class="p">,</span><span class="w"> </span><span class="m m-Decimal">3</span><span class="p">]);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">g</span><span class="p">(</span><span class="kt">uint</span><span class="p">[</span><span class="m m-Decimal">3</span><span class="p">]</span><span class="w"> </span><span class="kt">memory</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>pure<span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// ...</span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>数组表达式 <code class="docutils literal notranslate"><span class="pre">[1,</span> <span class="pre">-1]</span></code> 是无效的，因为第一个表达式的类型是 <code class="docutils literal notranslate"><span class="pre">uint8</span></code>，
而第二个表达式的类型是 <code class="docutils literal notranslate"><span class="pre">int8</span></code>，它们不能相互隐式转换。为了使其有效，
例如，您可以使用 <code class="docutils literal notranslate"><span class="pre">[int8(1),</span> <span class="pre">-1]</span></code>。</p>
<p>由于不同类型的固定大小的内存数组不能相互转换（即使基类可以），
如果您想使用二维数组字面常数，您必须总是明确指定一个共同的基类：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.13&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCmNvbnRyYWN0IEMgewogICAgZnVuY3Rpb24gZigpIHB1YmxpYyBwdXJlIHJldHVybnMgKHVpbnQyNFsyXVs0XSBtZW1vcnkpIHsKICAgICAgICB1aW50MjRbMl1bNF0gbWVtb3J5IHggPSBbW3VpbnQyNCgweDEpLCAxXSwgWzB4ZmZmZmZmLCAyXSwgW3VpbnQyNCgweGZmKSwgM10sIFt1aW50MjQoMHhmZmZmKSwgNF1dOwogICAgICAgIC8vIOS4i+mdoueahOaWueazleS4jeS8mui1t+S9nOeUqO+8jOWboOS4uuS4gOS6m+WGhemDqOaVsOe7hOeahOexu+Wei+S4jeWvueOAggogICAgICAgIC8vIHVpbnRbMl1bNF0gbWVtb3J5IHggPSBbWzB4MSwgMV0sIFsweGZmZmZmZiwgMl0sIFsweGZmLCAzXSwgWzB4ZmZmZiwgNF1dOwogICAgICAgIHJldHVybiB4OwogICAgfQp9"><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.4.16</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span><span class="w"></span>

<span class="k">contract</span><span class="w"> </span><span class="ni">C</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">f</span><span class="p">()</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>pure<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint24</span><span class="p">[</span><span class="m m-Decimal">2</span><span class="p">][</span><span class="m m-Decimal">4</span><span class="p">]</span><span class="w"> </span><span class="kt">memory</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">uint24</span><span class="p">[</span><span class="m m-Decimal">2</span><span class="p">][</span><span class="m m-Decimal">4</span><span class="p">]</span><span class="w"> </span><span class="kt">memory</span><span class="w"> </span>x<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[[</span><span class="kt">uint24</span><span class="p">(</span><span class="mh">0x1</span><span class="p">),</span><span class="w"> </span><span class="m m-Decimal">1</span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="mh">0xffffff</span><span class="p">,</span><span class="w"> </span><span class="m m-Decimal">2</span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="kt">uint24</span><span class="p">(</span><span class="mh">0xff</span><span class="p">),</span><span class="w"> </span><span class="m m-Decimal">3</span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="kt">uint24</span><span class="p">(</span><span class="mh">0xffff</span><span class="p">),</span><span class="w"> </span><span class="m m-Decimal">4</span><span class="p">]];</span><span class="w"></span>
<span class="w">        </span><span class="c1">// 下面的方法不会起作用，因为一些内部数组的类型不对。</span>
<span class="w">        </span><span class="c1">// uint[2][4] memory x = [[0x1, 1], [0xffffff, 2], [0xff, 3], [0xffff, 4]];</span>
<span class="w">        </span><span class="kt">return</span><span class="w"> </span>x<span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>固定大小的内存数组不能分配给动态大小的内存数组，也就是说，以下情况是不可能的：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.13&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjAgPDAuOS4wOwoKLy8gVGhpcyB3aWxsIG5vdCBjb21waWxlLgpjb250cmFjdCBDIHsKICAgIGZ1bmN0aW9uIGYoKSBwdWJsaWMgewogICAgICAgIC8vIOS4i+S4gOihjOS8muS6p+eUn+S4gOS4quexu+Wei+mUmeivr++8jOWboOS4unVpbnRbM13lhoXlrZjkuI3og73ooqvovazmjaLkuLp1aW50W13lhoXlrZjjgIIKICAgICAgICB1aW50W10gbWVtb3J5IHggPSBbdWludCgxKSwgMywgNF07CiAgICB9Cn0="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.4.0</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span><span class="w"></span>

<span class="c1">// This will not compile.</span>
<span class="k">contract</span><span class="w"> </span><span class="ni">C</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">f</span><span class="p">()</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// 下一行会产生一个类型错误，因为uint[3]内存不能被转换为uint[]内存。</span>
<span class="w">        </span><span class="kt">uint</span><span class="p">[]</span><span class="w"> </span><span class="kt">memory</span><span class="w"> </span>x<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="kt">uint</span><span class="p">(</span><span class="m m-Decimal">1</span><span class="p">),</span><span class="w"> </span><span class="m m-Decimal">3</span><span class="p">,</span><span class="w"> </span><span class="m m-Decimal">4</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>计划在将来取消这一限制，但由于ABI中数组的传递方式，它产生了一些复杂的问题。</p>
<p>如果您想初始化动态大小的数组，您必须分配各个元素：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.13&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCmNvbnRyYWN0IEMgewogICAgZnVuY3Rpb24gZigpIHB1YmxpYyBwdXJlIHsKICAgICAgICB1aW50W10gbWVtb3J5IHggPSBuZXcgdWludFtdKDMpOwogICAgICAgIHhbMF0gPSAxOwogICAgICAgIHhbMV0gPSAzOwogICAgICAgIHhbMl0gPSA0OwogICAgfQp9"><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.4.16</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span><span class="w"></span>

<span class="k">contract</span><span class="w"> </span><span class="ni">C</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">f</span><span class="p">()</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>pure<span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">uint</span><span class="p">[]</span><span class="w"> </span><span class="kt">memory</span><span class="w"> </span>x<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">new</span><span class="w"> </span><span class="kt">uint</span><span class="p">[](</span><span class="m m-Decimal">3</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span>x<span class="p">[</span><span class="m m-Decimal">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m m-Decimal">1</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span>x<span class="p">[</span><span class="m m-Decimal">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m m-Decimal">3</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span>x<span class="p">[</span><span class="m m-Decimal">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m m-Decimal">4</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="array-members">
<span id="index-21"></span><span id="id31"></span><h4>数组成员<a class="headerlink" href="#array-members" title="Permalink to this heading"></a></h4>
<dl class="simple">
<dt><strong>length</strong>:</dt><dd><p>数组有 <code class="docutils literal notranslate"><span class="pre">length</span></code> 成员变量表示当前数组的长度。一经创建，
内存memory数组的大小就是固定的（但却是动态的，也就是说，它依赖于运行时的参数）。</p>
</dd>
<dt><strong>push()</strong>:</dt><dd><p>动态存储数组和 <code class="docutils literal notranslate"><span class="pre">bytes</span></code> （不是 <code class="docutils literal notranslate"><span class="pre">string</span></code> ）有一个叫 <code class="docutils literal notranslate"><span class="pre">push()</span></code> 的成员函数，
您可以用它在数组的末尾追加一个零初始化的元素。它返回一个元素的引用，
因此可以像 <code class="docutils literal notranslate"><span class="pre">x.push().t</span> <span class="pre">=</span> <span class="pre">2</span></code> 或 <code class="docutils literal notranslate"><span class="pre">x.push()</span> <span class="pre">=</span> <span class="pre">b</span></code> 那样使用。</p>
</dd>
<dt><strong>push(x)</strong>:</dt><dd><p>动态存储数组和 <code class="docutils literal notranslate"><span class="pre">bytes</span></code> （不是 <code class="docutils literal notranslate"><span class="pre">string</span></code> ）有一个叫 <code class="docutils literal notranslate"><span class="pre">push(x)</span></code> 的成员函数，
您可以用它在数组的末端追加一个指定的元素。该函数不返回任何东西。</p>
</dd>
<dt><strong>pop()</strong>:</dt><dd><p>动态存储数组和 <code class="docutils literal notranslate"><span class="pre">bytes</span></code> （不是 <code class="docutils literal notranslate"><span class="pre">string</span></code> ）有一个叫 <code class="docutils literal notranslate"><span class="pre">pop()</span></code> 的成员函数，
您可以用它来从数组的末端移除一个元素。这也隐含地在被删除的元素上调用 <a class="reference internal" href="#delete"><span class="std std-ref">delete</span></a>。</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>通过调用 <code class="docutils literal notranslate"><span class="pre">push()</span></code> 增加存储数组的长度有恒定的气体成本，因为存储是零初始化的，
而通过调用 <code class="docutils literal notranslate"><span class="pre">pop()</span></code> 减少长度的成本取决于被移除元素的 “大小”。
如果该元素是一个数组，它的成本可能非常高，
因为它包括明确地清除被移除的元素，类似于对它们调用 <a class="reference internal" href="#delete"><span class="std std-ref">delete</span></a>。</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>要在外部（而不是公开）函数中使用数组的数组，
您需要激活ABI coder v2。</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>在Byzantium之前的EVM版本中，不可能访问从函数调用返回的动态数组。
如果您调用返回动态数组的函数，请确保使用设置为Byzantium模式的EVM。</p>
</div>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.13&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjAgPDAuOS4wOwoKY29udHJhY3QgQXJyYXlDb250cmFjdCB7CiAgICB1aW50WzIqKjIwXSBhTG90T2ZJbnRlZ2VyczsKICAgIC8vIOazqOaEj+S4i+mdoueahOS7o+eggeW5tuS4jeaYr+S4gOWvueWKqOaAgeaVsOe7hO+8jAogICAgLy8g6ICM5piv5LiA5Liq5pWw57uE5YWD57Sg5Li65LiA5a+55Y+Y6YeP55qE5Yqo5oCB5pWw57uE77yI5Lmf5bCx5piv5pWw57uE5YWD57Sg5Li66ZW/5bqm5Li6IDIg55qE5a6a6ZW/5pWw57uE55qE5Yqo5oCB5pWw57uE77yJ44CCCiAgICAvLyDlm6DkuLrvvIxUW10g5oC75pivIFQg55qE5LiA5Liq5Yqo5oCB5pWw57uE77yM5Y2z5L2/IFQg5pys6Lqr5piv5LiA5Liq5pWw57uE44CCCiAgICAvLyDmiYDmnInnirbmgIHlj5jph4/nmoTmlbDmja7kvY3nva7mmK8gc3RvcmFnZeOAggogICAgYm9vbFsyXVtdIHBhaXJzT2ZGbGFnczsKCiAgICAvLyBuZXdQYWlyc+iiq+WtmOWCqOWcqG1lbW9yeeS4rS0t6L+Z5piv5YWs5byA5ZCI57qm5Ye95pWw5Y+C5pWw55qE5ZSv5LiA5Y+v6IO95oCn44CCCiAgICBmdW5jdGlvbiBzZXRBbGxGbGFnUGFpcnMoYm9vbFsyXVtdIG1lbW9yeSBuZXdQYWlycykgcHVibGljIHsKICAgICAgICAvLyDotYvlgLzliLDkuIDkuKrlrZjlgqjmlbDnu4TkvJrmiafooYwgYGBuZXdQYWlyc2BgIOeahOaLt+i0ne+8jAogICAgICAgIC8vIOW5tuabv+aNouWujOaVtOeahOmYteWIlyBgYHBhaXJzT2ZGbGFnc2Bg44CCCiAgICAgICAgcGFpcnNPZkZsYWdzID0gbmV3UGFpcnM7CiAgICB9CgogICAgc3RydWN0IFN0cnVjdFR5cGUgewogICAgICAgIHVpbnRbXSBjb250ZW50czsKICAgICAgICB1aW50IG1vcmVJbmZvOwogICAgfQogICAgU3RydWN0VHlwZSBzOwoKICAgIGZ1bmN0aW9uIGYodWludFtdIG1lbW9yeSBjKSBwdWJsaWMgewogICAgICAgIC8vIOWcqCBgYGdgYCDkuK3lrZjlgqjkuIDkuKrlr7kgYGBzYGAg55qE5byV55So44CCCiAgICAgICAgU3RydWN0VHlwZSBzdG9yYWdlIGcgPSBzOwogICAgICAgIC8vIOS5n+aUueWPmOS6hiBgYHMubW9yZUluZm9gYC4KICAgICAgICBnLm1vcmVJbmZvID0gMjsKICAgICAgICAvLyDmjIflrprkuIDkuKrmi7fotJ3vvIzlm6DkuLogYGBnLmNvbnRlbnRzYGAg5LiN5piv5LiA5Liq5bGA6YOo5Y+Y6YeP77yMCiAgICAgICAgLy8g6ICM5piv5LiA5Liq5bGA6YOo5Y+Y6YeP55qE5oiQ5ZGY44CCCiAgICAgICAgZy5jb250ZW50cyA9IGM7CiAgICB9CgogICAgZnVuY3Rpb24gc2V0RmxhZ1BhaXIodWludCBpbmRleCwgYm9vbCBmbGFnQSwgYm9vbCBmbGFnQikgcHVibGljIHsKICAgICAgICAvLyDorr/pl67kuIDkuKrkuI3lrZjlnKjnmoTmlbDnu4TntKLlvJXkvJrlvJXlj5HkuIDkuKrlvILluLgKICAgICAgICBwYWlyc09mRmxhZ3NbaW5kZXhdWzBdID0gZmxhZ0E7CiAgICAgICAgcGFpcnNPZkZsYWdzW2luZGV4XVsxXSA9IGZsYWdCOwogICAgfQoKICAgIGZ1bmN0aW9uIGNoYW5nZUZsYWdBcnJheVNpemUodWludCBuZXdTaXplKSBwdWJsaWMgewogICAgICAgIC8vIOS9v+eUqHB1c2jlkoxwb3DmmK/mlLnlj5jmlbDnu4Tplb/luqbnmoTllK/kuIDmlrnms5XjgIIKICAgICAgICBpZiAobmV3U2l6ZSA8IHBhaXJzT2ZGbGFncy5sZW5ndGgpIHsKICAgICAgICAgICAgd2hpbGUgKHBhaXJzT2ZGbGFncy5sZW5ndGggPiBuZXdTaXplKQogICAgICAgICAgICAgICAgcGFpcnNPZkZsYWdzLnBvcCgpOwogICAgICAgIH0gZWxzZSBpZiAobmV3U2l6ZSA+IHBhaXJzT2ZGbGFncy5sZW5ndGgpIHsKICAgICAgICAgICAgd2hpbGUgKHBhaXJzT2ZGbGFncy5sZW5ndGggPCBuZXdTaXplKQogICAgICAgICAgICAgICAgcGFpcnNPZkZsYWdzLnB1c2goKTsKICAgICAgICB9CiAgICB9CgogICAgZnVuY3Rpb24gY2xlYXIoKSBwdWJsaWMgewogICAgICAgIC8vIOi/meS6m+WujOWFqOa4hemZpOS6huaVsOe7hAogICAgICAgIGRlbGV0ZSBwYWlyc09mRmxhZ3M7CiAgICAgICAgZGVsZXRlIGFMb3RPZkludGVnZXJzOwogICAgICAgIC8vIOi/memHjOacieebuOWQjOeahOaViOaenAogICAgICAgIHBhaXJzT2ZGbGFncyA9IG5ldyBib29sWzJdW10oMCk7CiAgICB9CgogICAgYnl0ZXMgYnl0ZURhdGE7CgogICAgZnVuY3Rpb24gYnl0ZUFycmF5cyhieXRlcyBtZW1vcnkgZGF0YSkgcHVibGljIHsKICAgICAgICAvLyDlrZfoioLmlbDnu4TvvIgiYnl0ZSLvvInmmK/kuI3lkIznmoTvvIzlm6DkuLrlroPku6znmoTlrZjlgqjmsqHmnInloavlhYXvvIwKICAgICAgICAvLyDkvYblj6/ku6XkuI4gInVpbnQ4W10i55u45ZCM44CCCiAgICAgICAgYnl0ZURhdGEgPSBkYXRhOwogICAgICAgIGZvciAodWludCBpID0gMDsgaSA8IDc7IGkrKykKICAgICAgICAgICAgYnl0ZURhdGEucHVzaCgpOwogICAgICAgIGJ5dGVEYXRhWzNdID0gMHgwODsKICAgICAgICBkZWxldGUgYnl0ZURhdGFbMl07CiAgICB9CgogICAgZnVuY3Rpb24gYWRkRmxhZyhib29sWzJdIG1lbW9yeSBmbGFnKSBwdWJsaWMgcmV0dXJucyAodWludCkgewogICAgICAgIHBhaXJzT2ZGbGFncy5wdXNoKGZsYWcpOwogICAgICAgIHJldHVybiBwYWlyc09mRmxhZ3MubGVuZ3RoOwogICAgfQoKICAgIGZ1bmN0aW9uIGNyZWF0ZU1lbW9yeUFycmF5KHVpbnQgc2l6ZSkgcHVibGljIHB1cmUgcmV0dXJucyAoYnl0ZXMgbWVtb3J5KSB7CiAgICAgICAgLy8g5L2/55SoIGBuZXdgIOWIm+W7uuWKqOaAgSBtZW1vcnkg5pWw57uE77yaCiAgICAgICAgdWludFsyXVtdIG1lbW9yeSBhcnJheU9mUGFpcnMgPSBuZXcgdWludFsyXVtdKHNpemUpOwoKICAgICAgICAvLyDlhoXogZTmlbDnu4TmgLvmmK/pnZnmgIHlpKflsI/nmoTvvIzlpoLmnpzmgqjlj6rkvb/nlKjlrZfpnaLluLjmlbDooajovr7lvI/vvIzmgqjlv4Xpobvoh7PlsJHmj5DkvpvkuIDnp43nsbvlnovjgIIKICAgICAgICBhcnJheU9mUGFpcnNbMF0gPSBbdWludCgxKSwgMl07CgogICAgICAgIC8vIOWIm+W7uuS4gOS4quWKqOaAgeWtl+iKguaVsOe7hO+8mgogICAgICAgIGJ5dGVzIG1lbW9yeSBiID0gbmV3IGJ5dGVzKDIwMCk7CiAgICAgICAgZm9yICh1aW50IGkgPSAwOyBpIDwgYi5sZW5ndGg7IGkrKykKICAgICAgICAgICAgYltpXSA9IGJ5dGVzMSh1aW50OChpKSk7CiAgICAgICAgcmV0dXJuIGI7CiAgICB9Cn0="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.6.0</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span><span class="w"></span>

<span class="k">contract</span><span class="w"> </span><span class="ni">ArrayContract</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">uint</span><span class="p">[</span><span class="m m-Decimal">2</span><span class="o">**</span><span class="m m-Decimal">20</span><span class="p">]</span><span class="w"> </span>aLotOfIntegers<span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="c1">// 注意下面的代码并不是一对动态数组，</span>
<span class="w">    </span><span class="c1">// 而是一个数组元素为一对变量的动态数组（也就是数组元素为长度为 2 的定长数组的动态数组）。</span>
<span class="w">    </span><span class="c1">// 因为，T[] 总是 T 的一个动态数组，即使 T 本身是一个数组。</span>
<span class="w">    </span><span class="c1">// 所有状态变量的数据位置是 storage。</span>
<span class="w">    </span><span class="kt">bool</span><span class="p">[</span><span class="m m-Decimal">2</span><span class="p">][]</span><span class="w"> </span>pairsOfFlags<span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="c1">// newPairs被存储在memory中--这是公开合约函数参数的唯一可能性。</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">setAllFlagPairs</span><span class="p">(</span><span class="kt">bool</span><span class="p">[</span><span class="m m-Decimal">2</span><span class="p">][]</span><span class="w"> </span><span class="kt">memory</span><span class="w"> </span>newPairs<span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// 赋值到一个存储数组会执行 ``newPairs`` 的拷贝，</span>
<span class="w">        </span><span class="c1">// 并替换完整的阵列 ``pairsOfFlags``。</span>
<span class="w">        </span>pairsOfFlags<span class="w"> </span><span class="o">=</span><span class="w"> </span>newPairs<span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kt">struct</span><span class="w"> </span><span class="nv">StructType</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">uint</span><span class="p">[]</span><span class="w"> </span>contents<span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="kt">uint</span><span class="w"> </span><span class="nv">moreInfo</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span>StructType<span class="w"> </span>s<span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">f</span><span class="p">(</span><span class="kt">uint</span><span class="p">[]</span><span class="w"> </span><span class="kt">memory</span><span class="w"> </span>c<span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// 在 ``g`` 中存储一个对 ``s`` 的引用。</span>
<span class="w">        </span>StructType<span class="w"> </span>storage<span class="w"> </span>g<span class="w"> </span><span class="o">=</span><span class="w"> </span>s<span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="c1">// 也改变了 ``s.moreInfo``.</span>
<span class="w">        </span>g<span class="p">.</span>moreInfo<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m m-Decimal">2</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="c1">// 指定一个拷贝，因为 ``g.contents`` 不是一个局部变量，</span>
<span class="w">        </span><span class="c1">// 而是一个局部变量的成员。</span>
<span class="w">        </span>g<span class="p">.</span>contents<span class="w"> </span><span class="o">=</span><span class="w"> </span>c<span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">setFlagPair</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">index</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="nv">flagA</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="nv">flagB</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// 访问一个不存在的数组索引会引发一个异常</span>
<span class="w">        </span>pairsOfFlags<span class="p">[</span>index<span class="p">][</span><span class="m m-Decimal">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>flagA<span class="p">;</span><span class="w"></span>
<span class="w">        </span>pairsOfFlags<span class="p">[</span>index<span class="p">][</span><span class="m m-Decimal">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>flagB<span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">changeFlagArraySize</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">newSize</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// 使用push和pop是改变数组长度的唯一方法。</span>
<span class="w">        </span><span class="kt">if</span><span class="w"> </span><span class="p">(</span>newSize<span class="w"> </span><span class="o">&lt;</span><span class="w"> </span>pairsOfFlags<span class="p">.</span>length<span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="kt">while</span><span class="w"> </span><span class="p">(</span>pairsOfFlags<span class="p">.</span>length<span class="w"> </span><span class="o">&gt;</span><span class="w"> </span>newSize<span class="p">)</span><span class="w"></span>
<span class="w">                </span>pairsOfFlags<span class="p">.</span>pop<span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="kt">else</span><span class="w"> </span><span class="kt">if</span><span class="w"> </span><span class="p">(</span>newSize<span class="w"> </span><span class="o">&gt;</span><span class="w"> </span>pairsOfFlags<span class="p">.</span>length<span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="kt">while</span><span class="w"> </span><span class="p">(</span>pairsOfFlags<span class="p">.</span>length<span class="w"> </span><span class="o">&lt;</span><span class="w"> </span>newSize<span class="p">)</span><span class="w"></span>
<span class="w">                </span>pairsOfFlags<span class="p">.</span>push<span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">clear</span><span class="p">()</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// 这些完全清除了数组</span>
<span class="w">        </span>delete<span class="w"> </span>pairsOfFlags<span class="p">;</span><span class="w"></span>
<span class="w">        </span>delete<span class="w"> </span>aLotOfIntegers<span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="c1">// 这里有相同的效果</span>
<span class="w">        </span>pairsOfFlags<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">new</span><span class="w"> </span><span class="kt">bool</span><span class="p">[</span><span class="m m-Decimal">2</span><span class="p">][](</span><span class="m m-Decimal">0</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kt">bytes</span><span class="w"> </span><span class="nv">byteData</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">byteArrays</span><span class="p">(</span><span class="kt">bytes</span><span class="w"> </span><span class="nv">memory</span><span class="w"> </span>data<span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// 字节数组（&quot;byte&quot;）是不同的，因为它们的存储没有填充，</span>
<span class="w">        </span><span class="c1">// 但可以与 &quot;uint8[]&quot;相同。</span>
<span class="w">        </span>byteData<span class="w"> </span><span class="o">=</span><span class="w"> </span>data<span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="kt">for</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m m-Decimal">0</span><span class="p">;</span><span class="w"> </span>i<span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="m m-Decimal">7</span><span class="p">;</span><span class="w"> </span>i<span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span>byteData<span class="p">.</span>push<span class="p">();</span><span class="w"></span>
<span class="w">        </span>byteData<span class="p">[</span><span class="m m-Decimal">3</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x08</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span>delete<span class="w"> </span>byteData<span class="p">[</span><span class="m m-Decimal">2</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">addFlag</span><span class="p">(</span><span class="kt">bool</span><span class="p">[</span><span class="m m-Decimal">2</span><span class="p">]</span><span class="w"> </span><span class="kt">memory</span><span class="w"> </span>flag<span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span>pairsOfFlags<span class="p">.</span>push<span class="p">(</span>flag<span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kt">return</span><span class="w"> </span>pairsOfFlags<span class="p">.</span>length<span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">createMemoryArray</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">size</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>pure<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">bytes</span><span class="w"> </span><span class="nv">memory</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// 使用 `new` 创建动态 memory 数组：</span>
<span class="w">        </span><span class="kt">uint</span><span class="p">[</span><span class="m m-Decimal">2</span><span class="p">][]</span><span class="w"> </span><span class="kt">memory</span><span class="w"> </span>arrayOfPairs<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">new</span><span class="w"> </span><span class="kt">uint</span><span class="p">[</span><span class="m m-Decimal">2</span><span class="p">][](</span>size<span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="c1">// 内联数组总是静态大小的，如果您只使用字面常数表达式，您必须至少提供一种类型。</span>
<span class="w">        </span>arrayOfPairs<span class="p">[</span><span class="m m-Decimal">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="kt">uint</span><span class="p">(</span><span class="m m-Decimal">1</span><span class="p">),</span><span class="w"> </span><span class="m m-Decimal">2</span><span class="p">];</span><span class="w"></span>

<span class="w">        </span><span class="c1">// 创建一个动态字节数组：</span>
<span class="w">        </span><span class="kt">bytes</span><span class="w"> </span><span class="nv">memory</span><span class="w"> </span>b<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">new</span><span class="w"> </span><span class="kt">bytes</span><span class="p">(</span><span class="m m-Decimal">200</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kt">for</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m m-Decimal">0</span><span class="p">;</span><span class="w"> </span>i<span class="w"> </span><span class="o">&lt;</span><span class="w"> </span>b<span class="p">.</span>length<span class="p">;</span><span class="w"> </span>i<span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span>b<span class="p">[</span>i<span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>bytes1<span class="p">(</span><span class="kt">uint8</span><span class="p">(</span>i<span class="p">));</span><span class="w"></span>
<span class="w">        </span><span class="kt">return</span><span class="w"> </span>b<span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
</section>
<section id="array-slices">
<span id="index-22"></span><span id="id32"></span><h3>数组切片<a class="headerlink" href="#array-slices" title="Permalink to this heading"></a></h3>
<p>数组切片是对一个数组的连续部分的预览。
它们被写成 <code class="docutils literal notranslate"><span class="pre">x[start:end]</span></code>，其中 <code class="docutils literal notranslate"><span class="pre">start</span></code> 和 <code class="docutils literal notranslate"><span class="pre">end</span></code> 是表达式，
结果是uint256类型（或隐含的可转换类型）。分片的第一个元素是 <code class="docutils literal notranslate"><span class="pre">x[start]</span></code>，
最后一个元素是 <code class="docutils literal notranslate"><span class="pre">x[end</span> <span class="pre">-</span> <span class="pre">1]</span></code>。</p>
<p>如果 <code class="docutils literal notranslate"><span class="pre">start</span></code> 大于 <code class="docutils literal notranslate"><span class="pre">end</span></code>，或者 <code class="docutils literal notranslate"><span class="pre">end</span></code> 大于数组的长度，
就会出现异常。</p>
<p><code class="docutils literal notranslate"><span class="pre">start</span></code> 和 <code class="docutils literal notranslate"><span class="pre">end</span></code> 都是可选的： <code class="docutils literal notranslate"><span class="pre">start</span></code> 默认为 <code class="docutils literal notranslate"><span class="pre">0</span></code>，
<code class="docutils literal notranslate"><span class="pre">end</span></code> 默认为数组的长度。</p>
<p>数组切片没有任何成员。它们可以隐含地转换为其底层类型的数组并支持索引访问。
索引访问在底层数组中不是绝对的，而是相对于分片的开始。</p>
<p>数组切片没有类型名，这意味着任何变量都不能以数组切片为类型，
它们只存在于中间表达式中。</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>到现在为止，数组切片只有calldata数组可以实现。</p>
</div>
<p>数组切片对于ABI解码在函数参数中传递的二级数据很有用：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.13&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC44LjUgPDAuOS4wOwpjb250cmFjdCBQcm94eSB7CiAgICAvLy8gQGRldiDnlLHku6PnkIbnrqHnkIbnmoTlrqLmiLflkIjnuqbnmoTlnLDlnYDvvIzljbPmnKzlkIjnuqbnmoTlnLDlnYAKICAgIGFkZHJlc3MgY2xpZW50OwoKICAgIGNvbnN0cnVjdG9yKGFkZHJlc3MgX2NsaWVudCkgewogICAgICAgIGNsaWVudCA9IF9jbGllbnQ7CiAgICB9CgogICAgLy8vIOi9rOWPkeWvuSAic2V0T3duZXIoYWRkcmVzcykiIOeahOiwg+eUqO+8jAogICAgLy8vIOivpeiwg+eUqOWcqOWvueWcsOWdgOWPguaVsOi/m+ihjOWfuuacrOmqjOivgeWQjueUseWuouaIt+err+aJp+ihjOOAggogICAgZnVuY3Rpb24gZm9yd2FyZChieXRlcyBjYWxsZGF0YSBfcGF5bG9hZCkgZXh0ZXJuYWwgewogICAgICAgIGJ5dGVzNCBzaWcgPSBieXRlczQoX3BheWxvYWRbOjRdKTsKICAgICAgICAvLyDnlLHkuo7miKrmlq3ooYzkuLrvvIxieXRlczQoX3BheWxvYWQp55qE6KGo546w5piv55u45ZCM55qE44CCCiAgICAgICAgLy8gYnl0ZXM0IHNpZyA9IGJ5dGVzNChfcGF5bG9hZCk7CiAgICAgICAgaWYgKHNpZyA9PSBieXRlczQoa2VjY2FrMjU2KCJzZXRPd25lcihhZGRyZXNzKSIpKSkgewogICAgICAgICAgICBhZGRyZXNzIG93bmVyID0gYWJpLmRlY29kZShfcGF5bG9hZFs0Ol0sIChhZGRyZXNzKSk7CiAgICAgICAgICAgIHJlcXVpcmUob3duZXIgIT0gYWRkcmVzcygwKSwgIkFkZHJlc3Mgb2Ygb3duZXIgY2Fubm90IGJlIHplcm8uIik7CiAgICAgICAgfQogICAgICAgIChib29sIHN0YXR1cywpID0gY2xpZW50LmRlbGVnYXRlY2FsbChfcGF5bG9hZCk7CiAgICAgICAgcmVxdWlyZShzdGF0dXMsICJGb3J3YXJkZWQgY2FsbCBmYWlsZWQuIik7CiAgICB9Cn0="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.8.5</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span><span class="w"></span>
<span class="k">contract</span><span class="w"> </span><span class="ni">Proxy</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">/// @dev 由代理管理的客户合约的地址，即本合约的地址</span>
<span class="w">    </span><span class="kt">address</span><span class="w"> </span><span class="nv">client</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="kt">constructor</span><span class="p">(</span><span class="kt">address</span><span class="w"> </span><span class="nv">_client</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span>client<span class="w"> </span><span class="o">=</span><span class="w"> </span>_client<span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="c1">/// 转发对 &quot;setOwner(address)&quot; 的调用，</span>
<span class="w">    </span><span class="c1">/// 该调用在对地址参数进行基本验证后由客户端执行。</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">forward</span><span class="p">(</span><span class="kt">bytes</span><span class="w"> </span><span class="nv">calldata</span><span class="w"> </span>_payload<span class="p">)</span><span class="w"> </span><span class="kt">external</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span>bytes4<span class="w"> </span>sig<span class="w"> </span><span class="o">=</span><span class="w"> </span>bytes4<span class="p">(</span>_payload<span class="p">[:</span><span class="m m-Decimal">4</span><span class="p">]);</span><span class="w"></span>
<span class="w">        </span><span class="c1">// 由于截断行为，bytes4(_payload)的表现是相同的。</span>
<span class="w">        </span><span class="c1">// bytes4 sig = bytes4(_payload);</span>
<span class="w">        </span><span class="kt">if</span><span class="w"> </span><span class="p">(</span>sig<span class="w"> </span><span class="o">==</span><span class="w"> </span>bytes4<span class="p">(</span><span class="nb">keccak256</span><span class="p">(</span><span class="s2">&quot;setOwner(address)&quot;</span><span class="p">)))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="kt">address</span><span class="w"> </span><span class="nv">owner</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>abi<span class="p">.</span>decode<span class="p">(</span>_payload<span class="p">[</span><span class="m m-Decimal">4</span><span class="p">:],</span><span class="w"> </span><span class="p">(</span><span class="kt">address</span><span class="p">));</span><span class="w"></span>
<span class="w">            </span><span class="kt">require</span><span class="p">(</span>owner<span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kt">address</span><span class="p">(</span><span class="m m-Decimal">0</span><span class="p">),</span><span class="w"> </span><span class="s2">&quot;Address of owner cannot be zero.&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">(</span><span class="kt">bool</span><span class="w"> </span><span class="nv">status</span><span class="p">,)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>client<span class="p">.</span>delegatecall<span class="p">(</span>_payload<span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kt">require</span><span class="p">(</span>status<span class="p">,</span><span class="w"> </span><span class="s2">&quot;Forwarded call failed.&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="structs">
<span id="index-23"></span><span id="id33"></span><h3>结构体<a class="headerlink" href="#structs" title="Permalink to this heading"></a></h3>
<p>Solidity 提供了一种以结构形式定义新类型的方法，以下是一个结构体使用的示例：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.13&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjAgPDAuOS4wOwoKLy8g5a6a5LmJ5LiA5Liq5YyF5ZCr5Lik5Liq5bGe5oCn55qE5paw57G75Z6L44CCCi8vIOWcqOWQiOe6puS5i+WkluWjsOaYjuS4gOS4que7k+aehO+8jAovLyDlj6/ku6XorqnlroPooqvlpJrkuKrlkIjnuqbmiYDlhbHkuqvjgIIKLy8g5Zyo6L+Z6YeM77yM6L+Z5bm25LiN5piv55yf55qE6ZyA6KaB44CCCnN0cnVjdCBGdW5kZXIgewogICAgYWRkcmVzcyBhZGRyOwogICAgdWludCBhbW91bnQ7Cn0KCmNvbnRyYWN0IENyb3dkRnVuZGluZyB7CiAgICAvLyDnu5PmnoTkvZPkuZ/lj6/ku6XooqvlrprkuYnlnKjlkIjnuqblhoXpg6jvvIzov5nkvb/lvpflroPku6zlj6rlnKjmnKzlkIjnuqblkozmtL7nlJ/lkIjnuqbkuK3lj6/op4HjgIIKICAgIHN0cnVjdCBDYW1wYWlnbiB7CiAgICAgICAgYWRkcmVzcyBwYXlhYmxlIGJlbmVmaWNpYXJ5OwogICAgICAgIHVpbnQgZnVuZGluZ0dvYWw7CiAgICAgICAgdWludCBudW1GdW5kZXJzOwogICAgICAgIHVpbnQgYW1vdW50OwogICAgICAgIG1hcHBpbmcgKHVpbnQgPT4gRnVuZGVyKSBmdW5kZXJzOwogICAgfQoKICAgIHVpbnQgbnVtQ2FtcGFpZ25zOwogICAgbWFwcGluZyAodWludCA9PiBDYW1wYWlnbikgY2FtcGFpZ25zOwoKICAgIGZ1bmN0aW9uIG5ld0NhbXBhaWduKGFkZHJlc3MgcGF5YWJsZSBiZW5lZmljaWFyeSwgdWludCBnb2FsKSBwdWJsaWMgcmV0dXJucyAodWludCBjYW1wYWlnbklEKSB7CiAgICAgICAgY2FtcGFpZ25JRCA9IG51bUNhbXBhaWducysrOyAvLyBjYW1wYWlnbklEIOS9nOS4uuS4gOS4quWPmOmHj+i/lOWbngogICAgICAgIC8vIOaIkeS7rOS4jeiDveS9v+eUqCAiY2FtcGFpZ25zW2NhbXBhaWduSURdID0gQ2FtcGFpZ24oYmVuZWZpY2lhcnksIGdvYWwsIDAsIDApIgogICAgICAgIC8vIOWboOS4uuWPs+S+p+WIm+W7uuS6huS4gOS4quWGheWtmOe7k+aehCAiQ2FtcGFpZ24i77yM5YW25Lit5YyF5ZCr5LiA5Liq5pig5bCE44CCCiAgICAgICAgQ2FtcGFpZ24gc3RvcmFnZSBjID0gY2FtcGFpZ25zW2NhbXBhaWduSURdOwogICAgICAgIGMuYmVuZWZpY2lhcnkgPSBiZW5lZmljaWFyeTsKICAgICAgICBjLmZ1bmRpbmdHb2FsID0gZ29hbDsKICAgIH0KCiAgICBmdW5jdGlvbiBjb250cmlidXRlKHVpbnQgY2FtcGFpZ25JRCkgcHVibGljIHBheWFibGUgewogICAgICAgIENhbXBhaWduIHN0b3JhZ2UgYyA9IGNhbXBhaWduc1tjYW1wYWlnbklEXTsKICAgICAgICAvLyDku6Xnu5nlrprnmoTlgLzliJ3lp4vljJbvvIzliJvlu7rkuIDkuKrmlrDnmoTkuLTml7YgbWVtb3J5IOe7k+aehOS9k++8jAogICAgICAgIC8vIOW5tuWwhuWFtuaLt+i0neWIsCBzdG9yYWdlIOS4reOAggogICAgICAgIC8vIOazqOaEj+aCqOS5n+WPr+S7peS9v+eUqCBGdW5kZXIobXNnLnNlbmRlciwgbXNnLnZhbHVlKSDmnaXliJ3lp4vljJbjgIIKICAgICAgICBjLmZ1bmRlcnNbYy5udW1GdW5kZXJzKytdID0gRnVuZGVyKHthZGRyOiBtc2cuc2VuZGVyLCBhbW91bnQ6IG1zZy52YWx1ZX0pOwogICAgICAgIGMuYW1vdW50ICs9IG1zZy52YWx1ZTsKICAgIH0KCiAgICBmdW5jdGlvbiBjaGVja0dvYWxSZWFjaGVkKHVpbnQgY2FtcGFpZ25JRCkgcHVibGljIHJldHVybnMgKGJvb2wgcmVhY2hlZCkgewogICAgICAgIENhbXBhaWduIHN0b3JhZ2UgYyA9IGNhbXBhaWduc1tjYW1wYWlnbklEXTsKICAgICAgICBpZiAoYy5hbW91bnQgPCBjLmZ1bmRpbmdHb2FsKQogICAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgdWludCBhbW91bnQgPSBjLmFtb3VudDsKICAgICAgICBjLmFtb3VudCA9IDA7CiAgICAgICAgYy5iZW5lZmljaWFyeS50cmFuc2ZlcihhbW91bnQpOwogICAgICAgIHJldHVybiB0cnVlOwogICAgfQp9"><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.6.0</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span><span class="w"></span>

<span class="c1">// 定义一个包含两个属性的新类型。</span>
<span class="c1">// 在合约之外声明一个结构，</span>
<span class="c1">// 可以让它被多个合约所共享。</span>
<span class="c1">// 在这里，这并不是真的需要。</span>
<span class="kt">struct</span><span class="w"> </span><span class="nv">Funder</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">address</span><span class="w"> </span><span class="nv">addr</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">uint</span><span class="w"> </span><span class="nv">amount</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">contract</span><span class="w"> </span><span class="ni">CrowdFunding</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// 结构体也可以被定义在合约内部，这使得它们只在本合约和派生合约中可见。</span>
<span class="w">    </span><span class="kt">struct</span><span class="w"> </span><span class="nv">Campaign</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">address</span><span class="w"> </span><span class="nv">payable</span><span class="w"> </span>beneficiary<span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="kt">uint</span><span class="w"> </span><span class="nv">fundingGoal</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="kt">uint</span><span class="w"> </span><span class="nv">numFunders</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="kt">uint</span><span class="w"> </span><span class="nv">amount</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="kt">mapping</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span>Funder<span class="p">)</span><span class="w"> </span>funders<span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kt">uint</span><span class="w"> </span><span class="nv">numCampaigns</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">mapping</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span>Campaign<span class="p">)</span><span class="w"> </span>campaigns<span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">newCampaign</span><span class="p">(</span><span class="kt">address</span><span class="w"> </span><span class="nv">payable</span><span class="w"> </span>beneficiary<span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="nv">goal</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">campaignID</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span>campaignID<span class="w"> </span><span class="o">=</span><span class="w"> </span>numCampaigns<span class="o">++</span><span class="p">;</span><span class="w"> </span><span class="c1">// campaignID 作为一个变量返回</span>
<span class="w">        </span><span class="c1">// 我们不能使用 &quot;campaigns[campaignID] = Campaign(beneficiary, goal, 0, 0)&quot;</span>
<span class="w">        </span><span class="c1">// 因为右侧创建了一个内存结构 &quot;Campaign&quot;，其中包含一个映射。</span>
<span class="w">        </span>Campaign<span class="w"> </span>storage<span class="w"> </span>c<span class="w"> </span><span class="o">=</span><span class="w"> </span>campaigns<span class="p">[</span>campaignID<span class="p">];</span><span class="w"></span>
<span class="w">        </span>c<span class="p">.</span>beneficiary<span class="w"> </span><span class="o">=</span><span class="w"> </span>beneficiary<span class="p">;</span><span class="w"></span>
<span class="w">        </span>c<span class="p">.</span>fundingGoal<span class="w"> </span><span class="o">=</span><span class="w"> </span>goal<span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">contribute</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">campaignID</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="kt">payable</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span>Campaign<span class="w"> </span>storage<span class="w"> </span>c<span class="w"> </span><span class="o">=</span><span class="w"> </span>campaigns<span class="p">[</span>campaignID<span class="p">];</span><span class="w"></span>
<span class="w">        </span><span class="c1">// 以给定的值初始化，创建一个新的临时 memory 结构体，</span>
<span class="w">        </span><span class="c1">// 并将其拷贝到 storage 中。</span>
<span class="w">        </span><span class="c1">// 注意您也可以使用 Funder(msg.sender, msg.value) 来初始化。</span>
<span class="w">        </span>c<span class="p">.</span>funders<span class="p">[</span>c<span class="p">.</span>numFunders<span class="o">++</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>Funder<span class="p">({</span>addr<span class="p">:</span><span class="w"> </span><span class="k">msg.sender</span><span class="p">,</span><span class="w"> </span>amount<span class="p">:</span><span class="w"> </span><span class="k">msg.value</span><span class="p">});</span><span class="w"></span>
<span class="w">        </span>c<span class="p">.</span>amount<span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="k">msg.value</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">checkGoalReached</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">campaignID</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">bool</span><span class="w"> </span><span class="nv">reached</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span>Campaign<span class="w"> </span>storage<span class="w"> </span>c<span class="w"> </span><span class="o">=</span><span class="w"> </span>campaigns<span class="p">[</span>campaignID<span class="p">];</span><span class="w"></span>
<span class="w">        </span><span class="kt">if</span><span class="w"> </span><span class="p">(</span>c<span class="p">.</span>amount<span class="w"> </span><span class="o">&lt;</span><span class="w"> </span>c<span class="p">.</span>fundingGoal<span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="kt">return</span><span class="w"> </span><span class="kt">false</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="kt">uint</span><span class="w"> </span><span class="nv">amount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>c<span class="p">.</span>amount<span class="p">;</span><span class="w"></span>
<span class="w">        </span>c<span class="p">.</span>amount<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m m-Decimal">0</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span>c<span class="p">.</span>beneficiary<span class="p">.</span>transfer<span class="p">(</span>amount<span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kt">return</span><span class="w"> </span><span class="kt">true</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>上面的合约并没有提供众筹合约的全部功能，
但它包含了理解结构体所需的基本概念。
结构类型可以在映射和数组内使用，
它们本身可以包含映射和数组。</p>
<p>结构体不可能包含其自身类型的成员，尽管结构本身可以是映射成员的值类型，
或者它可以包含其类型的动态大小的数组。
这一限制是必要的，因为结构的大小必须是有限的。</p>
<p>注意在所有的函数中，结构类型被分配到数据位置为 <code class="docutils literal notranslate"><span class="pre">storage</span></code> 的局部变量。
这并不是拷贝结构体，而只是存储一个引用，
因此对本地变量成员的赋值实际上是写入状态。</p>
<p>当然，您也可以直接访问该结构的成员，
而不把它分配给本地变量，如 <code class="docutils literal notranslate"><span class="pre">campaigns[campaignID].amount</span> <span class="pre">=</span> <span class="pre">0</span></code>。</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>在 Solidity 0.7.0 之前，包含仅有存储类型（例如映射）的成员的内存结构是允许的，
像上面例子中的 <code class="docutils literal notranslate"><span class="pre">campaigns[campaignID]</span> <span class="pre">=</span> <span class="pre">Campaign(beneficiary,</span> <span class="pre">goal,</span> <span class="pre">0,</span> <span class="pre">0)</span></code> 这样的赋值是可以的，
只是会默默地跳过这些成员。</p>
</div>
</section>
</section>
<section id="mapping-types">
<span id="index-24"></span><span id="id34"></span><h2>映射类型<a class="headerlink" href="#mapping-types" title="Permalink to this heading"></a></h2>
<p>映射类型使用语法 <code class="docutils literal notranslate"><span class="pre">mapping(_KeyType</span> <span class="pre">=&gt;</span> <span class="pre">_ValueType)</span></code>，
映射类型的变量使用语法 <code class="docutils literal notranslate"><span class="pre">mapping(_KeyType</span> <span class="pre">=&gt;</span> <span class="pre">_ValueType)</span> <span class="pre">_VariableName</span></code> 声明。
<code class="docutils literal notranslate"><span class="pre">_KeyType</span></code> 可以是任何内置的值类型， <code class="docutils literal notranslate"><span class="pre">bytes</span></code>， <code class="docutils literal notranslate"><span class="pre">string</span></code>，或任何合约或枚举类型。
其他用户定义的或复杂的类型，如映射、结构体或数组类型是不允许的。
<code class="docutils literal notranslate"><span class="pre">_ValueType</span></code> 可以是任何类型，包括映射、数组和结构体。</p>
<p>您可以把映射想象成 <a class="reference external" href="https://en.wikipedia.org/wiki/Hash_table">哈希表</a>，
它实际上被初始化了，使每一个可能的键都存在，
并将其映射到字节形式全是零的值，一个类型的 <a class="reference internal" href="control-structures.html#default-value"><span class="std std-ref">默认值</span></a>。
相似性到此为止，键数据不存储在映射中，而是它的 <code class="docutils literal notranslate"><span class="pre">keccak256</span></code> 哈希值被用来查询。</p>
<p>正因为如此，映射没有长度，也没有被设置的键或值的概念，
因此，如果没有关于分配的键的额外信息，就不能被删除（见 <a class="reference internal" href="security-considerations.html#clearing-mappings"><span class="std std-ref">清除映射</span></a>）。</p>
<p>映射只能有一个 <code class="docutils literal notranslate"><span class="pre">storage</span></code> 的数据位置，因此允许用于状态变量，
可作为函数中的存储引用类型，或作为库函数的参数。
但它们不能被用作公开可见的合约函数的参数或返回参数。
这些限制对于包含映射的数组和结构也是如此。</p>
<p>您可以把映射类型的状态变量标记为 <code class="docutils literal notranslate"><span class="pre">public</span></code>，
Solidity会为您创建一个 <a class="reference internal" href="contracts.html#visibility-and-getters"><span class="std std-ref">getter</span></a> 函数。
<code class="docutils literal notranslate"><span class="pre">_KeyType</span></code> 将成为getter的参数。
如果 <code class="docutils literal notranslate"><span class="pre">_ValueType</span></code> 是一个值类型或一个结构，getter返回 <code class="docutils literal notranslate"><span class="pre">_ValueType</span></code>。
如果 <code class="docutils literal notranslate"><span class="pre">_ValueType</span></code> 是一个数组或映射，getter对每个 <code class="docutils literal notranslate"><span class="pre">_KeyType</span></code> 递归出一个参数。</p>
<p>在下面的例子中， <code class="docutils literal notranslate"><span class="pre">MappingExample</span></code> 合约定义了一个公共的 <code class="docutils literal notranslate"><span class="pre">balances</span></code> 映射，
键类型是 <code class="docutils literal notranslate"><span class="pre">address</span></code>，值类型是 <code class="docutils literal notranslate"><span class="pre">uint</span></code>，将一个Ethereum地址映射到一个无符号整数值。
由于 <code class="docutils literal notranslate"><span class="pre">uint</span></code> 是一个值类型，getter 返回一个与该类型相匹配的值，
您可以在 <code class="docutils literal notranslate"><span class="pre">MappingUser</span></code> 合约中看到它返回指定地址对应的值。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.13&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjAgPDAuOS4wOwoKY29udHJhY3QgTWFwcGluZ0V4YW1wbGUgewogICAgbWFwcGluZyhhZGRyZXNzID0+IHVpbnQpIHB1YmxpYyBiYWxhbmNlczsKCiAgICBmdW5jdGlvbiB1cGRhdGUodWludCBuZXdCYWxhbmNlKSBwdWJsaWMgewogICAgICAgIGJhbGFuY2VzW21zZy5zZW5kZXJdID0gbmV3QmFsYW5jZTsKICAgIH0KfQoKY29udHJhY3QgTWFwcGluZ1VzZXIgewogICAgZnVuY3Rpb24gZigpIHB1YmxpYyByZXR1cm5zICh1aW50KSB7CiAgICAgICAgTWFwcGluZ0V4YW1wbGUgbSA9IG5ldyBNYXBwaW5nRXhhbXBsZSgpOwogICAgICAgIG0udXBkYXRlKDEwMCk7CiAgICAgICAgcmV0dXJuIG0uYmFsYW5jZXMoYWRkcmVzcyh0aGlzKSk7CiAgICB9Cn0="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.4.0</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span><span class="w"></span>

<span class="k">contract</span><span class="w"> </span><span class="ni">MappingExample</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">mapping</span><span class="p">(</span><span class="kt">address</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="kt">uint</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>balances<span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">update</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">newBalance</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span>balances<span class="p">[</span><span class="k">msg.sender</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>newBalance<span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">contract</span><span class="w"> </span><span class="ni">MappingUser</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">f</span><span class="p">()</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span>MappingExample<span class="w"> </span>m<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">new</span><span class="w"> </span>MappingExample<span class="p">();</span><span class="w"></span>
<span class="w">        </span>m<span class="p">.</span>update<span class="p">(</span><span class="m m-Decimal">100</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kt">return</span><span class="w"> </span>m<span class="p">.</span>balances<span class="p">(</span><span class="kt">address</span><span class="p">(</span><span class="kt">this</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>下面的例子是一个简化版本的
<a class="reference external" href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol">ERC20 代币</a>。
<code class="docutils literal notranslate"><span class="pre">_allowances</span></code> 是一个映射类型在另一个映射类型中的例子。
下面的例子使用 <code class="docutils literal notranslate"><span class="pre">_allowances</span></code> 来记录别人允许从您的账户中提取的金额。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.13&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjIyIDwwLjkuMDsKCmNvbnRyYWN0IE1hcHBpbmdFeGFtcGxlIHsKCiAgICBtYXBwaW5nIChhZGRyZXNzID0+IHVpbnQyNTYpIHByaXZhdGUgX2JhbGFuY2VzOwogICAgbWFwcGluZyAoYWRkcmVzcyA9PiBtYXBwaW5nIChhZGRyZXNzID0+IHVpbnQyNTYpKSBwcml2YXRlIF9hbGxvd2FuY2VzOwoKICAgIGV2ZW50IFRyYW5zZmVyKGFkZHJlc3MgaW5kZXhlZCBmcm9tLCBhZGRyZXNzIGluZGV4ZWQgdG8sIHVpbnQyNTYgdmFsdWUpOwogICAgZXZlbnQgQXBwcm92YWwoYWRkcmVzcyBpbmRleGVkIG93bmVyLCBhZGRyZXNzIGluZGV4ZWQgc3BlbmRlciwgdWludDI1NiB2YWx1ZSk7CgogICAgZnVuY3Rpb24gYWxsb3dhbmNlKGFkZHJlc3Mgb3duZXIsIGFkZHJlc3Mgc3BlbmRlcikgcHVibGljIHZpZXcgcmV0dXJucyAodWludDI1NikgewogICAgICAgIHJldHVybiBfYWxsb3dhbmNlc1tvd25lcl1bc3BlbmRlcl07CiAgICB9CgogICAgZnVuY3Rpb24gdHJhbnNmZXJGcm9tKGFkZHJlc3Mgc2VuZGVyLCBhZGRyZXNzIHJlY2lwaWVudCwgdWludDI1NiBhbW91bnQpIHB1YmxpYyByZXR1cm5zIChib29sKSB7CiAgICAgICAgcmVxdWlyZShfYWxsb3dhbmNlc1tzZW5kZXJdW21zZy5zZW5kZXJdID49IGFtb3VudCwgIkVSQzIwOiBBbGxvd2FuY2Ugbm90IGhpZ2ggZW5vdWdoLiIpOwogICAgICAgIF9hbGxvd2FuY2VzW3NlbmRlcl1bbXNnLnNlbmRlcl0gLT0gYW1vdW50OwogICAgICAgIF90cmFuc2ZlcihzZW5kZXIsIHJlY2lwaWVudCwgYW1vdW50KTsKICAgICAgICByZXR1cm4gdHJ1ZTsKICAgIH0KCiAgICBmdW5jdGlvbiBhcHByb3ZlKGFkZHJlc3Mgc3BlbmRlciwgdWludDI1NiBhbW91bnQpIHB1YmxpYyByZXR1cm5zIChib29sKSB7CiAgICAgICAgcmVxdWlyZShzcGVuZGVyICE9IGFkZHJlc3MoMCksICJFUkMyMDogYXBwcm92ZSB0byB0aGUgemVybyBhZGRyZXNzIik7CgogICAgICAgIF9hbGxvd2FuY2VzW21zZy5zZW5kZXJdW3NwZW5kZXJdID0gYW1vdW50OwogICAgICAgIGVtaXQgQXBwcm92YWwobXNnLnNlbmRlciwgc3BlbmRlciwgYW1vdW50KTsKICAgICAgICByZXR1cm4gdHJ1ZTsKICAgIH0KCiAgICBmdW5jdGlvbiBfdHJhbnNmZXIoYWRkcmVzcyBzZW5kZXIsIGFkZHJlc3MgcmVjaXBpZW50LCB1aW50MjU2IGFtb3VudCkgaW50ZXJuYWwgewogICAgICAgIHJlcXVpcmUoc2VuZGVyICE9IGFkZHJlc3MoMCksICJFUkMyMDogdHJhbnNmZXIgZnJvbSB0aGUgemVybyBhZGRyZXNzIik7CiAgICAgICAgcmVxdWlyZShyZWNpcGllbnQgIT0gYWRkcmVzcygwKSwgIkVSQzIwOiB0cmFuc2ZlciB0byB0aGUgemVybyBhZGRyZXNzIik7CiAgICAgICAgcmVxdWlyZShfYmFsYW5jZXNbc2VuZGVyXSA+PSBhbW91bnQsICJFUkMyMDogTm90IGVub3VnaCBmdW5kcy4iKTsKCiAgICAgICAgX2JhbGFuY2VzW3NlbmRlcl0gLT0gYW1vdW50OwogICAgICAgIF9iYWxhbmNlc1tyZWNpcGllbnRdICs9IGFtb3VudDsKICAgICAgICBlbWl0IFRyYW5zZmVyKHNlbmRlciwgcmVjaXBpZW50LCBhbW91bnQpOwogICAgfQp9"><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.4.22</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span><span class="w"></span>

<span class="k">contract</span><span class="w"> </span><span class="ni">MappingExample</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">    </span><span class="kt">mapping</span><span class="w"> </span><span class="p">(</span><span class="kt">address</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="kt">uint256</span><span class="p">)</span><span class="w"> </span><span class="kt">private</span><span class="w"> </span>_balances<span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">mapping</span><span class="w"> </span><span class="p">(</span><span class="kt">address</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="kt">mapping</span><span class="w"> </span><span class="p">(</span><span class="kt">address</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="kt">uint256</span><span class="p">))</span><span class="w"> </span><span class="kt">private</span><span class="w"> </span>_allowances<span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="kt">event</span><span class="w"> </span><span class="nv">Transfer</span><span class="p">(</span><span class="kt">address</span><span class="w"> </span><span class="nv">indexed</span><span class="w"> </span>from<span class="p">,</span><span class="w"> </span><span class="kt">address</span><span class="w"> </span><span class="nv">indexed</span><span class="w"> </span>to<span class="p">,</span><span class="w"> </span><span class="kt">uint256</span><span class="w"> </span><span class="nv">value</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="kt">event</span><span class="w"> </span><span class="nv">Approval</span><span class="p">(</span><span class="kt">address</span><span class="w"> </span><span class="nv">indexed</span><span class="w"> </span>owner<span class="p">,</span><span class="w"> </span><span class="kt">address</span><span class="w"> </span><span class="nv">indexed</span><span class="w"> </span>spender<span class="p">,</span><span class="w"> </span><span class="kt">uint256</span><span class="w"> </span><span class="nv">value</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">allowance</span><span class="p">(</span><span class="kt">address</span><span class="w"> </span><span class="nv">owner</span><span class="p">,</span><span class="w"> </span><span class="kt">address</span><span class="w"> </span><span class="nv">spender</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>view<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint256</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">return</span><span class="w"> </span>_allowances<span class="p">[</span>owner<span class="p">][</span>spender<span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">transferFrom</span><span class="p">(</span><span class="kt">address</span><span class="w"> </span><span class="nv">sender</span><span class="p">,</span><span class="w"> </span><span class="kt">address</span><span class="w"> </span><span class="nv">recipient</span><span class="p">,</span><span class="w"> </span><span class="kt">uint256</span><span class="w"> </span><span class="nv">amount</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">bool</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">require</span><span class="p">(</span>_allowances<span class="p">[</span>sender<span class="p">][</span><span class="k">msg.sender</span><span class="p">]</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span>amount<span class="p">,</span><span class="w"> </span><span class="s2">&quot;ERC20: Allowance not high enough.&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span>_allowances<span class="p">[</span>sender<span class="p">][</span><span class="k">msg.sender</span><span class="p">]</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span>amount<span class="p">;</span><span class="w"></span>
<span class="w">        </span>_transfer<span class="p">(</span>sender<span class="p">,</span><span class="w"> </span>recipient<span class="p">,</span><span class="w"> </span>amount<span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kt">return</span><span class="w"> </span><span class="kt">true</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">approve</span><span class="p">(</span><span class="kt">address</span><span class="w"> </span><span class="nv">spender</span><span class="p">,</span><span class="w"> </span><span class="kt">uint256</span><span class="w"> </span><span class="nv">amount</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">bool</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">require</span><span class="p">(</span>spender<span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kt">address</span><span class="p">(</span><span class="m m-Decimal">0</span><span class="p">),</span><span class="w"> </span><span class="s2">&quot;ERC20: approve to the zero address&quot;</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span>_allowances<span class="p">[</span><span class="k">msg.sender</span><span class="p">][</span>spender<span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>amount<span class="p">;</span><span class="w"></span>
<span class="w">        </span>emit<span class="w"> </span>Approval<span class="p">(</span><span class="k">msg.sender</span><span class="p">,</span><span class="w"> </span>spender<span class="p">,</span><span class="w"> </span>amount<span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kt">return</span><span class="w"> </span><span class="kt">true</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">_transfer</span><span class="p">(</span><span class="kt">address</span><span class="w"> </span><span class="nv">sender</span><span class="p">,</span><span class="w"> </span><span class="kt">address</span><span class="w"> </span><span class="nv">recipient</span><span class="p">,</span><span class="w"> </span><span class="kt">uint256</span><span class="w"> </span><span class="nv">amount</span><span class="p">)</span><span class="w"> </span><span class="kt">internal</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">require</span><span class="p">(</span>sender<span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kt">address</span><span class="p">(</span><span class="m m-Decimal">0</span><span class="p">),</span><span class="w"> </span><span class="s2">&quot;ERC20: transfer from the zero address&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kt">require</span><span class="p">(</span>recipient<span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kt">address</span><span class="p">(</span><span class="m m-Decimal">0</span><span class="p">),</span><span class="w"> </span><span class="s2">&quot;ERC20: transfer to the zero address&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kt">require</span><span class="p">(</span>_balances<span class="p">[</span>sender<span class="p">]</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span>amount<span class="p">,</span><span class="w"> </span><span class="s2">&quot;ERC20: Not enough funds.&quot;</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span>_balances<span class="p">[</span>sender<span class="p">]</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span>amount<span class="p">;</span><span class="w"></span>
<span class="w">        </span>_balances<span class="p">[</span>recipient<span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span>amount<span class="p">;</span><span class="w"></span>
<span class="w">        </span>emit<span class="w"> </span>Transfer<span class="p">(</span>sender<span class="p">,</span><span class="w"> </span>recipient<span class="p">,</span><span class="w"> </span>amount<span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<section id="iterable-mappings">
<span id="index-25"></span><span id="id36"></span><h3>递归映射<a class="headerlink" href="#iterable-mappings" title="Permalink to this heading"></a></h3>
<p>您不能对映射进行递归调用，也就是说，您不能列举它们的键。
不过，可以在它们上层实现一个数据结构，并对其进行递归。例如，
下面的代码实现了一个 <code class="docutils literal notranslate"><span class="pre">IterableMapping</span></code> 库， <code class="docutils literal notranslate"><span class="pre">User</span></code> 合约也添加了数据，
<code class="docutils literal notranslate"><span class="pre">sum</span></code> 函数对所有的值进行递归调用去累加这些值。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.13&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjggPDAuOS4wOwoKc3RydWN0IEluZGV4VmFsdWUgeyB1aW50IGtleUluZGV4OyB1aW50IHZhbHVlOyB9CnN0cnVjdCBLZXlGbGFnIHsgdWludCBrZXk7IGJvb2wgZGVsZXRlZDsgfQoKc3RydWN0IGl0bWFwIHsKICAgIG1hcHBpbmcodWludCA9PiBJbmRleFZhbHVlKSBkYXRhOwogICAgS2V5RmxhZ1tdIGtleXM7CiAgICB1aW50IHNpemU7Cn0KCmxpYnJhcnkgSXRlcmFibGVNYXBwaW5nIHsKICAgIGZ1bmN0aW9uIGluc2VydChpdG1hcCBzdG9yYWdlIHNlbGYsIHVpbnQga2V5LCB1aW50IHZhbHVlKSBpbnRlcm5hbCByZXR1cm5zIChib29sIHJlcGxhY2VkKSB7CiAgICAgICAgdWludCBrZXlJbmRleCA9IHNlbGYuZGF0YVtrZXldLmtleUluZGV4OwogICAgICAgIHNlbGYuZGF0YVtrZXldLnZhbHVlID0gdmFsdWU7CiAgICAgICAgaWYgKGtleUluZGV4ID4gMCkKICAgICAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgICAgZWxzZSB7CiAgICAgICAgICAgIGtleUluZGV4ID0gc2VsZi5rZXlzLmxlbmd0aDsKICAgICAgICAgICAgc2VsZi5rZXlzLnB1c2goKTsKICAgICAgICAgICAgc2VsZi5kYXRhW2tleV0ua2V5SW5kZXggPSBrZXlJbmRleCArIDE7CiAgICAgICAgICAgIHNlbGYua2V5c1trZXlJbmRleF0ua2V5ID0ga2V5OwogICAgICAgICAgICBzZWxmLnNpemUrKzsKICAgICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgIH0KICAgIH0KCiAgICBmdW5jdGlvbiByZW1vdmUoaXRtYXAgc3RvcmFnZSBzZWxmLCB1aW50IGtleSkgaW50ZXJuYWwgcmV0dXJucyAoYm9vbCBzdWNjZXNzKSB7CiAgICAgICAgdWludCBrZXlJbmRleCA9IHNlbGYuZGF0YVtrZXldLmtleUluZGV4OwogICAgICAgIGlmIChrZXlJbmRleCA9PSAwKQogICAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgZGVsZXRlIHNlbGYuZGF0YVtrZXldOwogICAgICAgIHNlbGYua2V5c1trZXlJbmRleCAtIDFdLmRlbGV0ZWQgPSB0cnVlOwogICAgICAgIHNlbGYuc2l6ZSAtLTsKICAgIH0KCiAgICBmdW5jdGlvbiBjb250YWlucyhpdG1hcCBzdG9yYWdlIHNlbGYsIHVpbnQga2V5KSBpbnRlcm5hbCB2aWV3IHJldHVybnMgKGJvb2wpIHsKICAgICAgICByZXR1cm4gc2VsZi5kYXRhW2tleV0ua2V5SW5kZXggPiAwOwogICAgfQoKICAgIGZ1bmN0aW9uIGl0ZXJhdGVTdGFydChpdG1hcCBzdG9yYWdlIHNlbGYpIGludGVybmFsIHZpZXcgcmV0dXJucyAodWludCBrZXlJbmRleCkgewogICAgICAgIHJldHVybiBpdGVyYXRlTmV4dChzZWxmLCB0eXBlKHVpbnQpLm1heCk7CiAgICB9CgogICAgZnVuY3Rpb24gaXRlcmF0ZVZhbGlkKGl0bWFwIHN0b3JhZ2Ugc2VsZiwgdWludCBrZXlJbmRleCkgaW50ZXJuYWwgdmlldyByZXR1cm5zIChib29sKSB7CiAgICAgICAgcmV0dXJuIGtleUluZGV4IDwgc2VsZi5rZXlzLmxlbmd0aDsKICAgIH0KCiAgICBmdW5jdGlvbiBpdGVyYXRlTmV4dChpdG1hcCBzdG9yYWdlIHNlbGYsIHVpbnQga2V5SW5kZXgpIGludGVybmFsIHZpZXcgcmV0dXJucyAodWludCByX2tleUluZGV4KSB7CiAgICAgICAga2V5SW5kZXgrKzsKICAgICAgICB3aGlsZSAoa2V5SW5kZXggPCBzZWxmLmtleXMubGVuZ3RoICYmIHNlbGYua2V5c1trZXlJbmRleF0uZGVsZXRlZCkKICAgICAgICAgICAga2V5SW5kZXgrKzsKICAgICAgICByZXR1cm4ga2V5SW5kZXg7CiAgICB9CgogICAgZnVuY3Rpb24gaXRlcmF0ZUdldChpdG1hcCBzdG9yYWdlIHNlbGYsIHVpbnQga2V5SW5kZXgpIGludGVybmFsIHZpZXcgcmV0dXJucyAodWludCBrZXksIHVpbnQgdmFsdWUpIHsKICAgICAgICBrZXkgPSBzZWxmLmtleXNba2V5SW5kZXhdLmtleTsKICAgICAgICB2YWx1ZSA9IHNlbGYuZGF0YVtrZXldLnZhbHVlOwogICAgfQp9CgovLyDlpoLkvZXkvb/nlKgKY29udHJhY3QgVXNlciB7CiAgICAvLyDlj6rmmK/kuIDkuKrkv53lrZjmiJHku6zmlbDmja7nmoTnu5PmnoTkvZPjgIIKICAgIGl0bWFwIGRhdGE7CiAgICAvLyDlr7nmlbDmja7nsbvlnovlupTnlKjlupPlh73mlbDjgIIKICAgIHVzaW5nIEl0ZXJhYmxlTWFwcGluZyBmb3IgaXRtYXA7CgogICAgLy8g5o+S5YWl5LiA5Lqb5pWw5o2uCiAgICBmdW5jdGlvbiBpbnNlcnQodWludCBrLCB1aW50IHYpIHB1YmxpYyByZXR1cm5zICh1aW50IHNpemUpIHsKICAgICAgICAvLyDov5nlsIbosIPnlKggSXRlcmFibGVNYXBwaW5nLmluc2VydChkYXRhLCBrLCB2KQogICAgICAgIGRhdGEuaW5zZXJ0KGssIHYpOwogICAgICAgIC8vIOaIkeS7rOS7jeeEtuWPr+S7peiuv+mXrue7k+aehOS4reeahOaIkOWRmO+8jAogICAgICAgIC8vIOS9huaIkeS7rOW6lOivpeazqOaEj+S4jeimgeS5seWKqOS7luS7rOOAggogICAgICAgIHJldHVybiBkYXRhLnNpemU7CiAgICB9CgogICAgLy8g6K6h566X5omA5pyJ5a2Y5YKo5pWw5o2u55qE5oC75ZKM44CCCiAgICBmdW5jdGlvbiBzdW0oKSBwdWJsaWMgdmlldyByZXR1cm5zICh1aW50IHMpIHsKICAgICAgICBmb3IgKAogICAgICAgICAgICB1aW50IGkgPSBkYXRhLml0ZXJhdGVTdGFydCgpOwogICAgICAgICAgICBkYXRhLml0ZXJhdGVWYWxpZChpKTsKICAgICAgICAgICAgaSA9IGRhdGEuaXRlcmF0ZU5leHQoaSkKICAgICAgICApIHsKICAgICAgICAgICAgKCwgdWludCB2YWx1ZSkgPSBkYXRhLml0ZXJhdGVHZXQoaSk7CiAgICAgICAgICAgIHMgKz0gdmFsdWU7CiAgICAgICAgfQogICAgfQp9"><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.6.8</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span><span class="w"></span>

<span class="kt">struct</span><span class="w"> </span><span class="nv">IndexValue</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="nv">keyIndex</span><span class="p">;</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="nv">value</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="kt">struct</span><span class="w"> </span><span class="nv">KeyFlag</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="nv">key</span><span class="p">;</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="nv">deleted</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>

<span class="kt">struct</span><span class="w"> </span><span class="nv">itmap</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">mapping</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span>IndexValue<span class="p">)</span><span class="w"> </span>data<span class="p">;</span><span class="w"></span>
<span class="w">    </span>KeyFlag<span class="p">[]</span><span class="w"> </span>keys<span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">uint</span><span class="w"> </span><span class="nv">size</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">library</span><span class="w"> </span>IterableMapping<span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">insert</span><span class="p">(</span>itmap<span class="w"> </span>storage<span class="w"> </span>self<span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="nv">key</span><span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="nv">value</span><span class="p">)</span><span class="w"> </span><span class="kt">internal</span><span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">bool</span><span class="w"> </span><span class="nv">replaced</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">uint</span><span class="w"> </span><span class="nv">keyIndex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>self<span class="p">.</span>data<span class="p">[</span>key<span class="p">].</span>keyIndex<span class="p">;</span><span class="w"></span>
<span class="w">        </span>self<span class="p">.</span>data<span class="p">[</span>key<span class="p">].</span>value<span class="w"> </span><span class="o">=</span><span class="w"> </span>value<span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="kt">if</span><span class="w"> </span><span class="p">(</span>keyIndex<span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="m m-Decimal">0</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="kt">return</span><span class="w"> </span><span class="kt">true</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="kt">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span>keyIndex<span class="w"> </span><span class="o">=</span><span class="w"> </span>self<span class="p">.</span>keys<span class="p">.</span>length<span class="p">;</span><span class="w"></span>
<span class="w">            </span>self<span class="p">.</span>keys<span class="p">.</span>push<span class="p">();</span><span class="w"></span>
<span class="w">            </span>self<span class="p">.</span>data<span class="p">[</span>key<span class="p">].</span>keyIndex<span class="w"> </span><span class="o">=</span><span class="w"> </span>keyIndex<span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="m m-Decimal">1</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span>self<span class="p">.</span>keys<span class="p">[</span>keyIndex<span class="p">].</span>key<span class="w"> </span><span class="o">=</span><span class="w"> </span>key<span class="p">;</span><span class="w"></span>
<span class="w">            </span>self<span class="p">.</span>size<span class="o">++</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="kt">return</span><span class="w"> </span><span class="kt">false</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">remove</span><span class="p">(</span>itmap<span class="w"> </span>storage<span class="w"> </span>self<span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="nv">key</span><span class="p">)</span><span class="w"> </span><span class="kt">internal</span><span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">bool</span><span class="w"> </span><span class="nv">success</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">uint</span><span class="w"> </span><span class="nv">keyIndex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>self<span class="p">.</span>data<span class="p">[</span>key<span class="p">].</span>keyIndex<span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="kt">if</span><span class="w"> </span><span class="p">(</span>keyIndex<span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="m m-Decimal">0</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="kt">return</span><span class="w"> </span><span class="kt">false</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span>delete<span class="w"> </span>self<span class="p">.</span>data<span class="p">[</span>key<span class="p">];</span><span class="w"></span>
<span class="w">        </span>self<span class="p">.</span>keys<span class="p">[</span>keyIndex<span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="m m-Decimal">1</span><span class="p">].</span>deleted<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">true</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span>self<span class="p">.</span>size<span class="w"> </span><span class="o">--</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">contains</span><span class="p">(</span>itmap<span class="w"> </span>storage<span class="w"> </span>self<span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="nv">key</span><span class="p">)</span><span class="w"> </span><span class="kt">internal</span><span class="w"> </span>view<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">bool</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">return</span><span class="w"> </span>self<span class="p">.</span>data<span class="p">[</span>key<span class="p">].</span>keyIndex<span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="m m-Decimal">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">iterateStart</span><span class="p">(</span>itmap<span class="w"> </span>storage<span class="w"> </span>self<span class="p">)</span><span class="w"> </span><span class="kt">internal</span><span class="w"> </span>view<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">keyIndex</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">return</span><span class="w"> </span>iterateNext<span class="p">(</span>self<span class="p">,</span><span class="w"> </span>type<span class="p">(</span><span class="kt">uint</span><span class="p">).</span>max<span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">iterateValid</span><span class="p">(</span>itmap<span class="w"> </span>storage<span class="w"> </span>self<span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="nv">keyIndex</span><span class="p">)</span><span class="w"> </span><span class="kt">internal</span><span class="w"> </span>view<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">bool</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">return</span><span class="w"> </span>keyIndex<span class="w"> </span><span class="o">&lt;</span><span class="w"> </span>self<span class="p">.</span>keys<span class="p">.</span>length<span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">iterateNext</span><span class="p">(</span>itmap<span class="w"> </span>storage<span class="w"> </span>self<span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="nv">keyIndex</span><span class="p">)</span><span class="w"> </span><span class="kt">internal</span><span class="w"> </span>view<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">r_keyIndex</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span>keyIndex<span class="o">++</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="kt">while</span><span class="w"> </span><span class="p">(</span>keyIndex<span class="w"> </span><span class="o">&lt;</span><span class="w"> </span>self<span class="p">.</span>keys<span class="p">.</span>length<span class="w"> </span><span class="err">&amp;&amp;</span><span class="w"> </span>self<span class="p">.</span>keys<span class="p">[</span>keyIndex<span class="p">].</span>deleted<span class="p">)</span><span class="w"></span>
<span class="w">            </span>keyIndex<span class="o">++</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="kt">return</span><span class="w"> </span>keyIndex<span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">iterateGet</span><span class="p">(</span>itmap<span class="w"> </span>storage<span class="w"> </span>self<span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="nv">keyIndex</span><span class="p">)</span><span class="w"> </span><span class="kt">internal</span><span class="w"> </span>view<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">key</span><span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="nv">value</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span>key<span class="w"> </span><span class="o">=</span><span class="w"> </span>self<span class="p">.</span>keys<span class="p">[</span>keyIndex<span class="p">].</span>key<span class="p">;</span><span class="w"></span>
<span class="w">        </span>value<span class="w"> </span><span class="o">=</span><span class="w"> </span>self<span class="p">.</span>data<span class="p">[</span>key<span class="p">].</span>value<span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// 如何使用</span>
<span class="k">contract</span><span class="w"> </span><span class="ni">User</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// 只是一个保存我们数据的结构体。</span>
<span class="w">    </span>itmap<span class="w"> </span>data<span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="c1">// 对数据类型应用库函数。</span>
<span class="w">    </span>using<span class="w"> </span>IterableMapping<span class="w"> </span><span class="kt">for</span><span class="w"> </span>itmap<span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="c1">// 插入一些数据</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">insert</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">k</span><span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="nv">v</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">size</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// 这将调用 IterableMapping.insert(data, k, v)</span>
<span class="w">        </span>data<span class="p">.</span>insert<span class="p">(</span>k<span class="p">,</span><span class="w"> </span>v<span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="c1">// 我们仍然可以访问结构中的成员，</span>
<span class="w">        </span><span class="c1">// 但我们应该注意不要乱动他们。</span>
<span class="w">        </span><span class="kt">return</span><span class="w"> </span>data<span class="p">.</span>size<span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="c1">// 计算所有存储数据的总和。</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">sum</span><span class="p">()</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>view<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">s</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">for</span><span class="w"> </span><span class="p">(</span><span class="w"></span>
<span class="w">            </span><span class="kt">uint</span><span class="w"> </span><span class="nv">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>data<span class="p">.</span>iterateStart<span class="p">();</span><span class="w"></span>
<span class="w">            </span>data<span class="p">.</span>iterateValid<span class="p">(</span>i<span class="p">);</span><span class="w"></span>
<span class="w">            </span>i<span class="w"> </span><span class="o">=</span><span class="w"> </span>data<span class="p">.</span>iterateNext<span class="p">(</span>i<span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="p">(,</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="nv">value</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>data<span class="p">.</span>iterateGet<span class="p">(</span>i<span class="p">);</span><span class="w"></span>
<span class="w">            </span>s<span class="w"> </span><span class="o">+=</span><span class="w"> </span>value<span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
</section>
<section id="index-26">
<span id="id37"></span><h2>运算符<a class="headerlink" href="#index-26" title="Permalink to this heading"></a></h2>
<p>即使两个操作数的类型不一样，也可以应用算术和位操作数。
例如，您可以计算 <code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">=</span> <span class="pre">x</span> <span class="pre">+</span> <span class="pre">z</span></code>，其中 <code class="docutils literal notranslate"><span class="pre">x</span></code> 是 <code class="docutils literal notranslate"><span class="pre">uint8</span></code>， <code class="docutils literal notranslate"><span class="pre">z</span></code> 的类型为 <code class="docutils literal notranslate"><span class="pre">int32</span></code>。
在这种情况下，下面的机制将被用来确定计算操作的类型（这在溢出的情况下很重要）和操作结果的类型：</p>
<ol class="arabic simple">
<li><p>如果右操作数的类型可以隐式转换为左操作数的类型，则使用左操作数的类型，</p></li>
<li><p>如果左操作数的类型可以隐式转换为右操作数的类型，则使用右操作数的类型，</p></li>
<li><p>否则的话，该操作不被允许。</p></li>
</ol>
<p>如果其中一个操作数是 <a class="reference internal" href="#rational-literals"><span class="std std-ref">字面常数</span></a>，
它首先被转换为其 “移动类型（mobile type）”，也就是能容纳该值的最小类型
（相同位宽的无符号类型被认为比有符号类型 “小”）。
如果两者都是字面常数，则以任意的精度进行计算。</p>
<p>操作符的结果类型与操作的类型相同，除了比较操作符，其结果总是 <code class="docutils literal notranslate"><span class="pre">bool</span></code>。</p>
<p>运算符 <code class="docutils literal notranslate"><span class="pre">**</span></code> （幂运算）， <code class="docutils literal notranslate"><span class="pre">&lt;&lt;</span></code> 和 <code class="docutils literal notranslate"><span class="pre">&gt;&gt;</span></code> 使用左边操作数的类型进行运算和以其作为结果。</p>
<section id="index-27">
<span id="id38"></span><h3>复数和增量/减量运算符<a class="headerlink" href="#index-27" title="Permalink to this heading"></a></h3>
<p>如果 <code class="docutils literal notranslate"><span class="pre">a</span></code> 是一个LValue（即是一个变量或者是可以被分配的东西），
下列运算符可以作为速记：</p>
<p><code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">+=</span> <span class="pre">e</span></code> 相当于 <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">a</span> <span class="pre">+</span> <span class="pre">e</span></code>，运算符 <code class="docutils literal notranslate"><span class="pre">-=</span></code>， <code class="docutils literal notranslate"><span class="pre">*=</span></code>， <code class="docutils literal notranslate"><span class="pre">/=</span></code>， <code class="docutils literal notranslate"><span class="pre">%=</span></code>，
<code class="docutils literal notranslate"><span class="pre">|=</span></code>， <code class="docutils literal notranslate"><span class="pre">&amp;=</span></code>， <code class="docutils literal notranslate"><span class="pre">^=</span></code>， <code class="docutils literal notranslate"><span class="pre">&lt;&lt;=</span></code> 和 <code class="docutils literal notranslate"><span class="pre">&gt;&gt;=</span></code> 都有相应的定义。
<code class="docutils literal notranslate"><span class="pre">a++</span></code> 和 <code class="docutils literal notranslate"><span class="pre">a--</span></code> 相当于 <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">+=</span> <span class="pre">1</span></code> / <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">-=</span> <span class="pre">1</span></code> 但是表达式本身仍然是以前的值 <code class="docutils literal notranslate"><span class="pre">a</span></code>。
相比之下， <code class="docutils literal notranslate"><span class="pre">--a</span></code> 和 <code class="docutils literal notranslate"><span class="pre">++a</span></code> 对 <code class="docutils literal notranslate"><span class="pre">a</span></code> 有同样的作用，但返回改变后的值。</p>
</section>
<section id="delete">
<span id="index-28"></span><span id="id39"></span><h3>删除<a class="headerlink" href="#delete" title="Permalink to this heading"></a></h3>
<p><code class="docutils literal notranslate"><span class="pre">delete</span> <span class="pre">a</span></code> 为该类型分配初始值 <code class="docutils literal notranslate"><span class="pre">a</span></code>。例如，对于整数来说，它相当于 <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">0</span></code>，
但是它也可以用于数组，它指定一个长度为0的动态数组或者一个相同长度的静态数组，
所有元素都设置为初始值。 <code class="docutils literal notranslate"><span class="pre">delete</span> <span class="pre">a[x]</span></code> 删除数组中索引为 <code class="docutils literal notranslate"><span class="pre">x</span></code> 的元素，
并保留所有其他元素和数组的长度不动。这特别意味着它在数组中留下一个缺口。
如果您打算删除项目，一个 <a class="reference internal" href="#mapping-types"><span class="std std-ref">映射类型</span></a> 可能是一个更好的选择。</p>
<p>对于结构体，则将结构体中的所有属性重置。换句话说，在 <code class="docutils literal notranslate"><span class="pre">delete</span> <span class="pre">a</span></code> 之后，
<code class="docutils literal notranslate"><span class="pre">a</span></code> 的值与 <code class="docutils literal notranslate"><span class="pre">a</span></code> 在没有赋值的情况下被声明是一样的，但有以下注意事项：</p>
<p><code class="docutils literal notranslate"><span class="pre">delete</span></code> 对映射类型没有影响（因为映射的键可能是任意的，通常是未知的）。
因此，如果您删除一个结构体，它将重置所有不是映射类型的成员，
同时也会递归到这些成员，除非它们是映射。
然而，单个键和它们所映射的内容可以被删除。
如果 <code class="docutils literal notranslate"><span class="pre">a</span></code> 是一个映射，那么 <code class="docutils literal notranslate"><span class="pre">delete</span> <span class="pre">a[x]</span></code> 将删除存储在 <code class="docutils literal notranslate"><span class="pre">x</span></code> 的值。</p>
<p>值得注意的是， <code class="docutils literal notranslate"><span class="pre">delete</span> <span class="pre">a</span></code> 的行为实际上是对 <code class="docutils literal notranslate"><span class="pre">a</span></code> 的赋值，
也就是说，它在 <code class="docutils literal notranslate"><span class="pre">a</span></code> 中存储了一个新的对象。
当 <code class="docutils literal notranslate"><span class="pre">a</span></code> 是引用变量时，这种区别是明显的。
它只会重置 <code class="docutils literal notranslate"><span class="pre">a</span></code> 本身，而不是它之前引用的值。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.13&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjAgPDAuOS4wOwoKY29udHJhY3QgRGVsZXRlRXhhbXBsZSB7CiAgICB1aW50IGRhdGE7CiAgICB1aW50W10gZGF0YUFycmF5OwoKICAgIGZ1bmN0aW9uIGYoKSBwdWJsaWMgewogICAgICAgIHVpbnQgeCA9IGRhdGE7CiAgICAgICAgZGVsZXRlIHg7IC8vIOWwhiB4IOiuvuS4uiAw77yM5bm25LiN5b2x5ZONZGF0YeWPmOmHjwogICAgICAgIGRlbGV0ZSBkYXRhOyAvLyDlsIYgZGF0YSDorr7kuLogMO+8jOW5tuS4jeW9seWTjSB4CiAgICAgICAgdWludFtdIHN0b3JhZ2UgeSA9IGRhdGFBcnJheTsKICAgICAgICBkZWxldGUgZGF0YUFycmF5OyAvLyDlsIYgZGF0YUFycmF5Lmxlbmd0aCDorr7kuLogMO+8jOS9hueUseS6jiB1aW50W10g5piv5LiA5Liq5aSN5p2C55qE5a+56LGh77yMCiAgICAgICAgLy8geSDkuZ/lsIblj5fliLDlvbHlk43vvIzlroPmmK/kuIDkuKrlrZjlgqjkvY3nva7mmK8gc3RvcmFnZSDnmoTlr7nosaHnmoTliKvlkI3jgIIKICAgICAgICAvLyDlj6bkuIDmlrnpnaLvvJoiZGVsZXRlIHkiIOaYr+mdnuazleeahO+8jOW8leeUqOS6hiBzdG9yYWdlIOWvueixoeeahOWxgOmDqOWPmOmHj+WPquiDveeUseW3suacieeahCBzdG9yYWdlIOWvueixoei1i+WAvOOAggogICAgICAgIGFzc2VydCh5Lmxlbmd0aCA9PSAwKTsKICAgIH0KfQ=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.4.0</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span><span class="w"></span>

<span class="k">contract</span><span class="w"> </span><span class="ni">DeleteExample</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">uint</span><span class="w"> </span><span class="nv">data</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">uint</span><span class="p">[]</span><span class="w"> </span>dataArray<span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">f</span><span class="p">()</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">uint</span><span class="w"> </span><span class="nv">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>data<span class="p">;</span><span class="w"></span>
<span class="w">        </span>delete<span class="w"> </span>x<span class="p">;</span><span class="w"> </span><span class="c1">// 将 x 设为 0，并不影响data变量</span>
<span class="w">        </span>delete<span class="w"> </span>data<span class="p">;</span><span class="w"> </span><span class="c1">// 将 data 设为 0，并不影响 x</span>
<span class="w">        </span><span class="kt">uint</span><span class="p">[]</span><span class="w"> </span>storage<span class="w"> </span>y<span class="w"> </span><span class="o">=</span><span class="w"> </span>dataArray<span class="p">;</span><span class="w"></span>
<span class="w">        </span>delete<span class="w"> </span>dataArray<span class="p">;</span><span class="w"> </span><span class="c1">// 将 dataArray.length 设为 0，但由于 uint[] 是一个复杂的对象，</span>
<span class="w">        </span><span class="c1">// y 也将受到影响，它是一个存储位置是 storage 的对象的别名。</span>
<span class="w">        </span><span class="c1">// 另一方面：&quot;delete y&quot; 是非法的，引用了 storage 对象的局部变量只能由已有的 storage 对象赋值。</span>
<span class="w">        </span>assert<span class="p">(</span>y<span class="p">.</span>length<span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="m m-Decimal">0</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
</section>
<section id="types-conversion-elementary-types">
<span id="index-29"></span><span id="id40"></span><h2>基本类型之间的转换<a class="headerlink" href="#types-conversion-elementary-types" title="Permalink to this heading"></a></h2>
<section id="id41">
<h3>隐式转换<a class="headerlink" href="#id41" title="Permalink to this heading"></a></h3>
<p>在某些情况下，在赋值过程中，在向函数传递参数和应用运算符时，
编译器会自动应用隐式类型转换。一般来说，如果在语义上有意义，
并且不会丢失信息，那么值-类型之间的隐式转换是可能的。</p>
<p>例如， <code class="docutils literal notranslate"><span class="pre">uint8</span></code> 可以转换为 <code class="docutils literal notranslate"><span class="pre">uint16</span></code>， <code class="docutils literal notranslate"><span class="pre">int128</span></code> 可以转换为 <code class="docutils literal notranslate"><span class="pre">int256</span></code>，
但是 <code class="docutils literal notranslate"><span class="pre">int8</span></code> 不能转换为 <code class="docutils literal notranslate"><span class="pre">uint256</span></code>，因为 <code class="docutils literal notranslate"><span class="pre">uint256</span></code> 不能容纳 <code class="docutils literal notranslate"><span class="pre">-1</span></code> 这样的值。</p>
<p>如果一个运算符被应用于不同的类型，
编译器会尝试将其中一个操作数隐含地转换为另一个的类型（对于赋值也是如此）。
这意味着操作总是以其中一个操作数的类型进行。</p>
<p>关于哪些隐式转换是可能的，请参考关于类型本身的章节。</p>
<p>在下面的例子中， <code class="docutils literal notranslate"><span class="pre">y</span></code> 和 <code class="docutils literal notranslate"><span class="pre">z</span></code>，即加法的操作数，没有相同的类型，
但是 <code class="docutils literal notranslate"><span class="pre">uint8</span></code> 可以隐式转换为 <code class="docutils literal notranslate"><span class="pre">uint16</span></code>，反之则不行。正因为如此，
<code class="docutils literal notranslate"><span class="pre">y</span></code> 被转换为 <code class="docutils literal notranslate"><span class="pre">z</span></code> 的类型，然后在 <code class="docutils literal notranslate"><span class="pre">uint16</span></code> 类型中进行加法。
结果表达式 <code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">+</span> <span class="pre">z</span></code> 的类型是 <code class="docutils literal notranslate"><span class="pre">uint16</span></code>。
因为它被分配到一个 <code class="docutils literal notranslate"><span class="pre">uint32</span></code> 类型的变量中，所以在加法后又进行了一次隐式转换。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.13&amp;code=dWludDggeTsKdWludDE2IHo7CnVpbnQzMiB4ID0geSArIHo7"><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="kt">uint8</span><span class="w"> </span><span class="nv">y</span><span class="p">;</span><span class="w"></span>
<span class="kt">uint16</span><span class="w"> </span><span class="nv">z</span><span class="p">;</span><span class="w"></span>
<span class="kt">uint32</span><span class="w"> </span><span class="nv">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>y<span class="w"> </span><span class="o">+</span><span class="w"> </span>z<span class="p">;</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="id42">
<h3>显式转换<a class="headerlink" href="#id42" title="Permalink to this heading"></a></h3>
<p>如果编译器不允许隐式转换，但您确信转换会成功，
有时可以进行显式类型转换。
这可能会导致意想不到的行为，并使您绕过编译器的一些安全特性，
所以一定要测试结果是否是您想要的和期望的!</p>
<p>以下面的例子为例，将一个负的 <code class="docutils literal notranslate"><span class="pre">int</span></code> 转换为 <code class="docutils literal notranslate"><span class="pre">uint</span></code>：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.13&amp;code=aW50ICB5ID0gLTM7CnVpbnQgeCA9IHVpbnQoeSk7"><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w">  </span><span class="nv">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="m m-Decimal">3</span><span class="p">;</span><span class="w"></span>
<span class="kt">uint</span><span class="w"> </span><span class="nv">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">uint</span><span class="p">(</span>y<span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>在这个代码片断的最后， <code class="docutils literal notranslate"><span class="pre">x</span></code> 变成 <code class="docutils literal notranslate"><span class="pre">0xfffff..fd</span></code> 的值（64个十六进制字符），
这在256位的二进制补码中表示是-3。</p>
<p>如果一个整数被明确地转换为一个较小的类型，高阶位就会被切断：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.13&amp;code=dWludDMyIGEgPSAweDEyMzQ1Njc4Owp1aW50MTYgYiA9IHVpbnQxNihhKTsgLy8gYiDnjrDlnKjkvJrmmK8gMHg1Njc4"><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="kt">uint32</span><span class="w"> </span><span class="nv">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x12345678</span><span class="p">;</span><span class="w"></span>
<span class="kt">uint16</span><span class="w"> </span><span class="nv">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">uint16</span><span class="p">(</span>a<span class="p">);</span><span class="w"> </span><span class="c1">// b 现在会是 0x5678</span>
</pre></div>
</div>
<p>如果一个整数被明确地转换为一个更大的类型，它将在左边被填充（即在高阶的一端）。
转换的结果将与原整数比较相等：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.13&amp;code=dWludDE2IGEgPSAweDEyMzQ7CnVpbnQzMiBiID0gdWludDMyKGEpOyAvLyBiIOeOsOWcqOS8muaYryAweDAwMDAxMjM0CmFzc2VydChhID09IGIpOw=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="kt">uint16</span><span class="w"> </span><span class="nv">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x1234</span><span class="p">;</span><span class="w"></span>
<span class="kt">uint32</span><span class="w"> </span><span class="nv">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">uint32</span><span class="p">(</span>a<span class="p">);</span><span class="w"> </span><span class="c1">// b 现在会是 0x00001234</span>
assert<span class="p">(</span>a<span class="w"> </span><span class="o">==</span><span class="w"> </span>b<span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>固定大小的字节类型在转换过程中的行为是不同的。
它们可以被认为是单个字节的序列，转换到一个较小的类型将切断序列：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.13&amp;code=Ynl0ZXMyIGEgPSAweDEyMzQ7CmJ5dGVzMSBiID0gYnl0ZXMxKGEpOyAvLyBiIOeOsOWcqOS8muaYryAweDEy"><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span>bytes2<span class="w"> </span>a<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x1234</span><span class="p">;</span><span class="w"></span>
bytes1<span class="w"> </span>b<span class="w"> </span><span class="o">=</span><span class="w"> </span>bytes1<span class="p">(</span>a<span class="p">);</span><span class="w"> </span><span class="c1">// b 现在会是 0x12</span>
</pre></div>
</div>
<p>如果一个固定大小的字节类型被明确地转换为一个更大的类型，它将在右边被填充。
访问固定索引的字节将导致转换前后的数值相同（如果索引仍在范围内）：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.13&amp;code=Ynl0ZXMyIGEgPSAweDEyMzQ7CmJ5dGVzNCBiID0gYnl0ZXM0KGEpOyAvLyBiIOeOsOWcqOS8muaYryAweDEyMzQwMDAwCmFzc2VydChhWzBdID09IGJbMF0pOwphc3NlcnQoYVsxXSA9PSBiWzFdKTs="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span>bytes2<span class="w"> </span>a<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x1234</span><span class="p">;</span><span class="w"></span>
bytes4<span class="w"> </span>b<span class="w"> </span><span class="o">=</span><span class="w"> </span>bytes4<span class="p">(</span>a<span class="p">);</span><span class="w"> </span><span class="c1">// b 现在会是 0x12340000</span>
assert<span class="p">(</span>a<span class="p">[</span><span class="m m-Decimal">0</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span>b<span class="p">[</span><span class="m m-Decimal">0</span><span class="p">]);</span><span class="w"></span>
assert<span class="p">(</span>a<span class="p">[</span><span class="m m-Decimal">1</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span>b<span class="p">[</span><span class="m m-Decimal">1</span><span class="p">]);</span><span class="w"></span>
</pre></div>
</div>
<p>于整数和固定大小的字节数组在截断或填充时表现不同，
只有在整数和固定大小的字节数组具有相同大小的情况下，才允许在两者之间进行显式转换。
如果您想在不同大小的整数和固定大小的字节数组之间进行转换，您必须使用中间转换，
使所需的截断和填充规则明确：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.13&amp;code=Ynl0ZXMyIGEgPSAweDEyMzQ7CnVpbnQzMiBiID0gdWludDE2KGEpOyAvLyBiIOWwhuS8muaYryAweDAwMDAxMjM0CnVpbnQzMiBjID0gdWludDMyKGJ5dGVzNChhKSk7IC8vIGMg5bCG5Lya5pivIDB4MTIzNDAwMDAKdWludDggZCA9IHVpbnQ4KHVpbnQxNihhKSk7IC8vIGQg5bCG5Lya5pivIDB4MzQKdWludDggZSA9IHVpbnQ4KGJ5dGVzMShhKSk7IC8vIGUg5bCG5Lya5pivIDB4MTI="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span>bytes2<span class="w"> </span>a<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x1234</span><span class="p">;</span><span class="w"></span>
<span class="kt">uint32</span><span class="w"> </span><span class="nv">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">uint16</span><span class="p">(</span>a<span class="p">);</span><span class="w"> </span><span class="c1">// b 将会是 0x00001234</span>
<span class="kt">uint32</span><span class="w"> </span><span class="nv">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">uint32</span><span class="p">(</span>bytes4<span class="p">(</span>a<span class="p">));</span><span class="w"> </span><span class="c1">// c 将会是 0x12340000</span>
<span class="kt">uint8</span><span class="w"> </span><span class="nv">d</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">uint8</span><span class="p">(</span><span class="kt">uint16</span><span class="p">(</span>a<span class="p">));</span><span class="w"> </span><span class="c1">// d 将会是 0x34</span>
<span class="kt">uint8</span><span class="w"> </span><span class="nv">e</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">uint8</span><span class="p">(</span>bytes1<span class="p">(</span>a<span class="p">));</span><span class="w"> </span><span class="c1">// e 将会是 0x12</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">bytes</span></code> 数组和 <code class="docutils literal notranslate"><span class="pre">bytes</span></code> calldata 切片可以明确转换为固定字节类型（ <code class="docutils literal notranslate"><span class="pre">bytes1</span></code> /…/ <code class="docutils literal notranslate"><span class="pre">bytes32</span></code>）。
如果数组比目标的固定字节类型长，在末端会发生截断的情况。如果数组比目标类型短，它将在末尾被填充零。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.13&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguNTsKCmNvbnRyYWN0IEMgewogICAgYnl0ZXMgcyA9ICJhYmNkZWZnaCI7CiAgICBmdW5jdGlvbiBmKGJ5dGVzIGNhbGxkYXRhIGMsIGJ5dGVzIG1lbW9yeSBtKSBwdWJsaWMgdmlldyByZXR1cm5zIChieXRlczE2LCBieXRlczMpIHsKICAgICAgICByZXF1aXJlKGMubGVuZ3RoID09IDE2LCAiIik7CiAgICAgICAgYnl0ZXMxNiBiID0gYnl0ZXMxNihtKTsgIC8vIOWmguaenG3nmoTplb/luqblpKfkuo4xNu+8jOWwhuWPkeeUn+aIquaWreOAggogICAgICAgIGIgPSBieXRlczE2KHMpOyAgLy8g5Y+z6L656L+b6KGM5aGr5YWF77yM5omA5Lul57uT5p6c5pivICJhYmNkZWZnaFwwXDBcMFwwXDBcMFwwXDAiCiAgICAgICAgYnl0ZXMzIGIxID0gYnl0ZXMzKHMpOyAvLyDlj5HnlJ/miKrmlq0sIGIxIOebuOW9k+S6jiAiYWJjIgogICAgICAgIGIgPSBieXRlczE2KGNbOjhdKTsgIC8vIOWQjOagt+eUqDDov5vooYzloavlhYUKICAgICAgICByZXR1cm4gKGIsIGIxKTsKICAgIH0KfQ=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">^</span><span class="k">0.8.5</span><span class="p">;</span><span class="w"></span>

<span class="k">contract</span><span class="w"> </span><span class="ni">C</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">bytes</span><span class="w"> </span><span class="nv">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">&quot;abcdefgh&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">f</span><span class="p">(</span><span class="kt">bytes</span><span class="w"> </span><span class="nv">calldata</span><span class="w"> </span>c<span class="p">,</span><span class="w"> </span><span class="kt">bytes</span><span class="w"> </span><span class="nv">memory</span><span class="w"> </span>m<span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>view<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">bytes16</span><span class="p">,</span><span class="w"> </span>bytes3<span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">require</span><span class="p">(</span>c<span class="p">.</span>length<span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="m m-Decimal">16</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kt">bytes16</span><span class="w"> </span><span class="nv">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">bytes16</span><span class="p">(</span>m<span class="p">);</span><span class="w">  </span><span class="c1">// 如果m的长度大于16，将发生截断。</span>
<span class="w">        </span>b<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">bytes16</span><span class="p">(</span>s<span class="p">);</span><span class="w">  </span><span class="c1">// 右边进行填充，所以结果是 &quot;abcdefgh\0\0\0\0\0\0\0\0&quot;</span>
<span class="w">        </span>bytes3<span class="w"> </span>b1<span class="w"> </span><span class="o">=</span><span class="w"> </span>bytes3<span class="p">(</span>s<span class="p">);</span><span class="w"> </span><span class="c1">// 发生截断, b1 相当于 &quot;abc&quot;</span>
<span class="w">        </span>b<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">bytes16</span><span class="p">(</span>c<span class="p">[:</span><span class="m m-Decimal">8</span><span class="p">]);</span><span class="w">  </span><span class="c1">// 同样用0进行填充</span>
<span class="w">        </span><span class="kt">return</span><span class="w"> </span><span class="p">(</span>b<span class="p">,</span><span class="w"> </span>b1<span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
</section>
<section id="types-conversion-literals">
<span id="id43"></span><h2>字面常数和基本类型之间的转换<a class="headerlink" href="#types-conversion-literals" title="Permalink to this heading"></a></h2>
<section id="id44">
<h3>整数类型<a class="headerlink" href="#id44" title="Permalink to this heading"></a></h3>
<p>十进制和十六进制的数字字面常数可以隐含地转换为任何足够大的整数类型去表示它而不被截断：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.13&amp;code=dWludDggYSA9IDEyOyAvLyDlj6/ooYwKdWludDMyIGIgPSAxMjM0OyAvLyDlj6/ooYwKdWludDE2IGMgPSAweDEyMzQ1NjsgLy8g5oql6ZSZLCDlm6DkuLrov5nlsIbkvJrmiKrmlq3miJAgMHgzNDU2"><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="kt">uint8</span><span class="w"> </span><span class="nv">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m m-Decimal">12</span><span class="p">;</span><span class="w"> </span><span class="c1">// 可行</span>
<span class="kt">uint32</span><span class="w"> </span><span class="nv">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m m-Decimal">1234</span><span class="p">;</span><span class="w"> </span><span class="c1">// 可行</span>
<span class="kt">uint16</span><span class="w"> </span><span class="nv">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x123456</span><span class="p">;</span><span class="w"> </span><span class="c1">// 报错, 因为这将会截断成 0x3456</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>在0.8.0版本之前，任何十进制或十六进制的数字字面常数都可以显式转换为整数类型。
从0.8.0开始，这种显式转换和隐式转换一样严格，也就是说，只有当字面意义符合所产生的范围时，才允许转换。</p>
</div>
</section>
<section id="id45">
<h3>固定大小的字节数组<a class="headerlink" href="#id45" title="Permalink to this heading"></a></h3>
<p>十进制数字字面常数不能被隐含地转换为固定大小的字节数组。
十六进制数字字面常数是可以的，但只有当十六进制数字的数量正好符合字节类型的大小时才可以。
但是有一个例外，数值为0的十进制和十六进制数字字面常数都可以被转换为任何固定大小的字节类型：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.13&amp;code=Ynl0ZXMyIGEgPSA1NDMyMTsgLy8g5LiN5YWB6K64CmJ5dGVzMiBiID0gMHgxMjsgLy8g5LiN5YWB6K64CmJ5dGVzMiBjID0gMHgxMjM7IC8vIOS4jeWFgeiuuApieXRlczIgZCA9IDB4MTIzNDsgLy8g5Y+v6KGMCmJ5dGVzMiBlID0gMHgwMDEyOyAvLyDlj6/ooYwKYnl0ZXM0IGYgPSAwOyAvLyDlj6/ooYwKYnl0ZXM0IGcgPSAweDA7IC8vIOWPr+ihjA=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span>bytes2<span class="w"> </span>a<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m m-Decimal">54321</span><span class="p">;</span><span class="w"> </span><span class="c1">// 不允许</span>
bytes2<span class="w"> </span>b<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x12</span><span class="p">;</span><span class="w"> </span><span class="c1">// 不允许</span>
bytes2<span class="w"> </span>c<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x123</span><span class="p">;</span><span class="w"> </span><span class="c1">// 不允许</span>
bytes2<span class="w"> </span>d<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x1234</span><span class="p">;</span><span class="w"> </span><span class="c1">// 可行</span>
bytes2<span class="w"> </span>e<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x0012</span><span class="p">;</span><span class="w"> </span><span class="c1">// 可行</span>
bytes4<span class="w"> </span>f<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m m-Decimal">0</span><span class="p">;</span><span class="w"> </span><span class="c1">// 可行</span>
bytes4<span class="w"> </span>g<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x0</span><span class="p">;</span><span class="w"> </span><span class="c1">// 可行</span>
</pre></div>
</div>
<p>字符串和十六进制字符串字面常数可以被隐含地转换为固定大小的字节数组，
如果它们的字符数与字节类型的大小相匹配：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.13&amp;code=Ynl0ZXMyIGEgPSBoZXgiMTIzNCI7IC8vIOWPr+ihjApieXRlczIgYiA9ICJ4eSI7IC8vIOWPr+ihjApieXRlczIgYyA9IGhleCIxMiI7IC8vIOS4jeWFgeiuuApieXRlczIgZCA9IGhleCIxMjMiOyAvLyDkuI3lhYHorrgKYnl0ZXMyIGUgPSAieCI7IC8vIOS4jeWFgeiuuApieXRlczIgZiA9ICJ4eXoiOyAvLyDkuI3lhYHorrg="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span>bytes2<span class="w"> </span>a<span class="w"> </span><span class="o">=</span><span class="w"> </span>hex<span class="s2">&quot;1234&quot;</span><span class="p">;</span><span class="w"> </span><span class="c1">// 可行</span>
bytes2<span class="w"> </span>b<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">&quot;xy&quot;</span><span class="p">;</span><span class="w"> </span><span class="c1">// 可行</span>
bytes2<span class="w"> </span>c<span class="w"> </span><span class="o">=</span><span class="w"> </span>hex<span class="s2">&quot;12&quot;</span><span class="p">;</span><span class="w"> </span><span class="c1">// 不允许</span>
bytes2<span class="w"> </span>d<span class="w"> </span><span class="o">=</span><span class="w"> </span>hex<span class="s2">&quot;123&quot;</span><span class="p">;</span><span class="w"> </span><span class="c1">// 不允许</span>
bytes2<span class="w"> </span>e<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">&quot;x&quot;</span><span class="p">;</span><span class="w"> </span><span class="c1">// 不允许</span>
bytes2<span class="w"> </span>f<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">&quot;xyz&quot;</span><span class="p">;</span><span class="w"> </span><span class="c1">// 不允许</span>
</pre></div>
</div>
</section>
<section id="id46">
<h3>地址类型<a class="headerlink" href="#id46" title="Permalink to this heading"></a></h3>
<p>正如在 <a class="reference internal" href="#address-literals"><span class="std std-ref">地址字面常数（Address Literals）</span></a> 中所描述的那样，正确大小并通过校验测试的十六进制字是 <code class="docutils literal notranslate"><span class="pre">address</span></code> 类型。
其他字面常数不能隐含地转换为 <code class="docutils literal notranslate"><span class="pre">address</span></code> 类型。</p>
<p>从 <code class="docutils literal notranslate"><span class="pre">bytes20</span></code> 或任何整数类型转换到 <code class="docutils literal notranslate"><span class="pre">address</span></code> 的结果是 <code class="docutils literal notranslate"><span class="pre">address</span> <span class="pre">payable</span></code>。</p>
<p>一个 <code class="docutils literal notranslate"><span class="pre">address</span> <span class="pre">a</span></code> 可以通过 <code class="docutils literal notranslate"><span class="pre">payable(a)</span></code> 转换为 <code class="docutils literal notranslate"><span class="pre">address</span> <span class="pre">payable</span></code>。</p>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="structure-of-a-contract.html" class="btn btn-neutral float-left" title="合约结构" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="units-and-global-variables.html" class="btn btn-neutral float-right" title="单位和全局变量" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2016-2021, Ethereum.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
  
    <p>
        <a href="credits-and-attribution.html">Credits and attribution</a>.
    </p>


</footer>
        </div>
      </div>
    </section>
  </div>
  
<div class="rst-versions" data-toggle="rst-versions" role="note" aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
    <span class="fa fa-book fa-element"> RTD </span>

    <span class="fa fa-element">
    <input class="container_toggle" type="checkbox" id="switch" name="mode">
    <label for="switch"></label>
    </span>

    <span class="fa fa-v fa-element"> v:  <span class="fa fa-caret-down"></span></span>

    </span>
    <div class="rst-other-versions">
        <dl>
            <dt>Downloads</dt> 
        </dl>
        <dl>
            <dt>Versions</dt> 
        </dl>
        <dl>
            
            <dt>On Read the Docs</dt>
            <dd>
                <a href="///projects//?fromdocs=">Project Home</a>
            </dd>
            <dd>
                <a href="///builds//?fromdocs=">Builds</a>
            </dd>
        </dl>
    </div>
</div><script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>