<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>单位和全局变量 &mdash; Solidity 0.8.13 documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="_static/a4_railroad_diagram.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/custom.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/toggle.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/sphinx_highlight.js"></script>
        <script src="_static/js/toggle.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="表达式和控制结构" href="control-structures.html" />
    <link rel="prev" title="类型" href="types.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #65afff" >
            <a href="index.html">
            <img src="_static/logo.svg" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                0.8.13
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
    
              <p class="caption" role="heading"><span class="caption-text">Basics</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="introduction-to-smart-contracts.html">智能合约概述</a></li>
<li class="toctree-l1"><a class="reference internal" href="installing-solidity.html">安装 Solidity 编译器</a></li>
<li class="toctree-l1"><a class="reference internal" href="solidity-by-example.html">Solidity 合约示例</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Language Description</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="layout-of-source-files.html">Solidity 源文件结构</a></li>
<li class="toctree-l1"><a class="reference internal" href="structure-of-a-contract.html">合约结构</a></li>
<li class="toctree-l1"><a class="reference internal" href="types.html">类型</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">单位和全局变量</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#ether">以太Coin（Ether） 单位</a></li>
<li class="toctree-l2"><a class="reference internal" href="#index-1">时间单位</a></li>
<li class="toctree-l2"><a class="reference internal" href="#special-variables-functions">特殊变量和函数</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#index-2">区块和交易属性</a></li>
<li class="toctree-l3"><a class="reference internal" href="#abi">ABI编码和解码函数</a></li>
<li class="toctree-l3"><a class="reference internal" href="#index-4">字节类型的成员</a></li>
<li class="toctree-l3"><a class="reference internal" href="#index-5">字符串的成员</a></li>
<li class="toctree-l3"><a class="reference internal" href="#index-6">错误处理</a></li>
<li class="toctree-l3"><a class="reference internal" href="#mathematical-and-cryptographic-functions">数学和密码学函数</a></li>
<li class="toctree-l3"><a class="reference internal" href="#address-related">地址类型的成员</a></li>
<li class="toctree-l3"><a class="reference internal" href="#index-9">合约相关</a></li>
<li class="toctree-l3"><a class="reference internal" href="#meta-type">类型信息</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="control-structures.html">表达式和控制结构</a></li>
<li class="toctree-l1"><a class="reference internal" href="contracts.html">合约</a></li>
<li class="toctree-l1"><a class="reference internal" href="assembly.html">内联汇编</a></li>
<li class="toctree-l1"><a class="reference internal" href="cheatsheet.html">速查表</a></li>
<li class="toctree-l1"><a class="reference internal" href="grammar.html">语法</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Compiler</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="using-the-compiler.html">使用编译器</a></li>
<li class="toctree-l1"><a class="reference internal" href="analysing-compilation-output.html">分析编译器的输出结果</a></li>
<li class="toctree-l1"><a class="reference internal" href="ir-breaking-changes.html">基于Solidity中间表征的Codegen变化</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Internals</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="internals/layout_in_storage.html">存储中的状态变量储存结构</a></li>
<li class="toctree-l1"><a class="reference internal" href="internals/layout_in_memory.html">内存中的存储结构</a></li>
<li class="toctree-l1"><a class="reference internal" href="internals/layout_in_calldata.html">调用数据的存储结构</a></li>
<li class="toctree-l1"><a class="reference internal" href="internals/variable_cleanup.html">清理变量</a></li>
<li class="toctree-l1"><a class="reference internal" href="internals/source_mappings.html">源代码映射</a></li>
<li class="toctree-l1"><a class="reference internal" href="internals/optimizer.html">优化器</a></li>
<li class="toctree-l1"><a class="reference internal" href="metadata.html">合约的元数据</a></li>
<li class="toctree-l1"><a class="reference internal" href="abi-spec.html">合约ABI规范</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Additional Material</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="050-breaking-changes.html">Solidity v0.5.0 突破性变化</a></li>
<li class="toctree-l1"><a class="reference internal" href="060-breaking-changes.html">Solidity 0.6.0 版本突破性变化</a></li>
<li class="toctree-l1"><a class="reference internal" href="070-breaking-changes.html">Solidity v0.7.0 突破性变化</a></li>
<li class="toctree-l1"><a class="reference internal" href="080-breaking-changes.html">Solidity v0.8.0 突破性变化</a></li>
<li class="toctree-l1"><a class="reference internal" href="natspec-format.html">风格指南</a></li>
<li class="toctree-l1"><a class="reference internal" href="security-considerations.html">安全考虑</a></li>
<li class="toctree-l1"><a class="reference internal" href="smtchecker.html">SMT检查器和形式化验证</a></li>
<li class="toctree-l1"><a class="reference internal" href="resources.html">资源</a></li>
<li class="toctree-l1"><a class="reference internal" href="path-resolution.html">Import Path Resolution</a></li>
<li class="toctree-l1"><a class="reference internal" href="yul.html">Yul</a></li>
<li class="toctree-l1"><a class="reference internal" href="style-guide.html">风格指南</a></li>
<li class="toctree-l1"><a class="reference internal" href="common-patterns.html">通用模式</a></li>
<li class="toctree-l1"><a class="reference internal" href="bugs.html">已知bug列表</a></li>
<li class="toctree-l1"><a class="reference internal" href="contributing.html">贡献方式</a></li>
<li class="toctree-l1"><a class="reference internal" href="brand-guide.html">Solidity 品牌指南</a></li>
<li class="toctree-l1"><a class="reference internal" href="language-influences.html">Language Influences</a></li>
</ul>

    <ul>
        <li>
            <a href="genindex.html">Keyword Index</a>
        </li>
    </ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: #65afff" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Solidity</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
      <li>单位和全局变量</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/units-and-global-variables.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="id1">
<h1>单位和全局变量<a class="headerlink" href="#id1" title="Permalink to this heading"></a></h1>
<section id="ether">
<span id="index-0"></span><h2>以太Coin（Ether） 单位<a class="headerlink" href="#ether" title="Permalink to this heading"></a></h2>
<p>一个字面常数可以带一个后缀 <code class="docutils literal notranslate"><span class="pre">wei</span></code>， <code class="docutils literal notranslate"><span class="pre">gwei</span></code> 或 <code class="docutils literal notranslate"><span class="pre">ether</span></code> 来指定一个以太Coin的数量，
其中没有后缀的以太数字被认为单位是wei。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.13&amp;code=YXNzZXJ0KDEgd2VpID09IDEpOwphc3NlcnQoMSBnd2VpID09IDFlOSk7CmFzc2VydCgxIGV0aGVyID09IDFlMTgpOw=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span>assert<span class="p">(</span><span class="m m-Decimal">1</span><span class="w"> </span>wei<span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="m m-Decimal">1</span><span class="p">);</span><span class="w"></span>
assert<span class="p">(</span><span class="m m-Decimal">1</span><span class="w"> </span>gwei<span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="err">1</span>e9<span class="p">);</span><span class="w"></span>
assert<span class="p">(</span><span class="m m-Decimal">1</span><span class="w"> </span>ether<span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="err">1</span>e18<span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>单位后缀的唯一作用是乘以10的幂次方。</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>0.7.0版本中删除了 <code class="docutils literal notranslate"><span class="pre">finney</span></code> 和 <code class="docutils literal notranslate"><span class="pre">szabo</span></code> 这两个单位。</p>
</div>
</section>
<section id="index-1">
<span id="id2"></span><h2>时间单位<a class="headerlink" href="#index-1" title="Permalink to this heading"></a></h2>
<p>诸如 <code class="docutils literal notranslate"><span class="pre">seconds</span></code>， <code class="docutils literal notranslate"><span class="pre">minutes</span></code>， <code class="docutils literal notranslate"><span class="pre">hours</span></code>， <code class="docutils literal notranslate"><span class="pre">days</span></code> 和 <code class="docutils literal notranslate"><span class="pre">weeks</span></code> 等
后缀在字面常数后面，可以用来指定时间单位，其中秒是基本单位，单位的考虑方式很直白：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">==</span> <span class="pre">1</span> <span class="pre">seconds</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">minutes</span> <span class="pre">==</span> <span class="pre">60</span> <span class="pre">seconds</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">hours</span> <span class="pre">==</span> <span class="pre">60</span> <span class="pre">minutes</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">days</span> <span class="pre">==</span> <span class="pre">24</span> <span class="pre">hours</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">weeks</span> <span class="pre">==</span> <span class="pre">7</span> <span class="pre">days</span></code></p></li>
</ul>
<p>如果您使用这些单位进行日历计算，请注意，由于 <a class="reference external" href="https://en.wikipedia.org/wiki/Leap_second">闰秒</a>
会造成不是每一年都等于365天，甚至不是每一天都有24小时，而且因为闰秒是无法预测的，
所以需要借助外部的预言机（oracle，是一种链外数据服务，译者注）来对一个确定的日期代码库进行时间矫正。</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>由于上述原因，在0.5.0版本中删除了后缀 <code class="docutils literal notranslate"><span class="pre">years</span></code>。</p>
</div>
<p>这些后缀单位不能应用于变量。例如，
如果您想用时间单位（例如 days）来将输入变量换算为时间，您可以用以下方式：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.13&amp;code=ZnVuY3Rpb24gZih1aW50IHN0YXJ0LCB1aW50IGRheXNBZnRlcikgcHVibGljIHsKICAgIGlmIChibG9jay50aW1lc3RhbXAgPj0gc3RhcnQgKyBkYXlzQWZ0ZXIgKiAxIGRheXMpIHsKICAgICAgLy8gLi4uCiAgICB9Cn0="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="kt">function</span><span class="w"> </span><span class="nv">f</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">start</span><span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="nv">daysAfter</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">if</span><span class="w"> </span><span class="p">(</span><span class="k">block.timestamp</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span>start<span class="w"> </span><span class="o">+</span><span class="w"> </span>daysAfter<span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="m m-Decimal">1</span><span class="w"> </span>days<span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="c1">// ...</span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="special-variables-functions">
<span id="id4"></span><h2>特殊变量和函数<a class="headerlink" href="#special-variables-functions" title="Permalink to this heading"></a></h2>
<p>有一些特殊的变量和函数总是存在于全局命名空间，主要用于提供区块链的信息，或者是通用的工具函数。</p>
<section id="index-2">
<span id="id5"></span><h3>区块和交易属性<a class="headerlink" href="#index-2" title="Permalink to this heading"></a></h3>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">blockhash(uint</span> <span class="pre">blockNumber)</span> <span class="pre">returns</span> <span class="pre">(bytes32)</span></code>: 当 <code class="docutils literal notranslate"><span class="pre">blocknumber</span></code> 是最近的256个区块之一时，给定区块的哈希值；否则返回0。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">block.basefee</span></code> （ <code class="docutils literal notranslate"><span class="pre">uint</span></code>）： 当前区块的基本费用 （ <a class="reference external" href="https://eips.ethereum.org/EIPS/eip-3198">EIP-3198</a> 和 <a class="reference external" href="https://eips.ethereum.org/EIPS/eip-1559">EIP-1559</a>）</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">block.chainid</span></code> （ <code class="docutils literal notranslate"><span class="pre">uint</span></code>）： 当前链的ID</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">block.coinbase</span></code> （ <code class="docutils literal notranslate"><span class="pre">address</span> <span class="pre">payable</span></code>）： 挖出当前区块的矿工地址</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">block.difficulty</span></code> （ <code class="docutils literal notranslate"><span class="pre">uint</span></code>）： 挖出当前区块的矿工地址</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">block.gaslimit</span></code> （ <code class="docutils literal notranslate"><span class="pre">uint</span></code>）： 当前区块 gas 限额</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">block.number</span></code> （ <code class="docutils literal notranslate"><span class="pre">uint</span></code>）： 当前区块号</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">block.timestamp</span></code> （ <code class="docutils literal notranslate"><span class="pre">uint</span></code>）： 自 unix epoch 起始到当前区块以秒计的时间戳</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">gasleft()</span> <span class="pre">returns</span> <span class="pre">(uint256)</span></code>： 剩余的 gas</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">msg.data</span></code> （ <code class="docutils literal notranslate"><span class="pre">bytes</span> <span class="pre">calldata</span></code>）： 完整的  calldata</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">msg.sender</span></code> （ <code class="docutils literal notranslate"><span class="pre">address</span></code>）： 消息发送者（当前调用）</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">msg.sig</span></code> （ <code class="docutils literal notranslate"><span class="pre">bytes4</span></code>）： calldata 的前 4 字节（也就是函数标识符）</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">msg.value</span></code> （ <code class="docutils literal notranslate"><span class="pre">uint</span></code>）： 随消息发送的 wei 的数量</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tx.gasprice</span></code> （ <code class="docutils literal notranslate"><span class="pre">uint</span></code>）： 随消息发送的 wei 的数量</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tx.origin</span></code> （ <code class="docutils literal notranslate"><span class="pre">address</span></code>）： 交易发起者（完全的调用链）</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>对于每一个 <strong>外部（external）</strong> 函数调用，
包括 <code class="docutils literal notranslate"><span class="pre">msg.sender</span></code> 和 <code class="docutils literal notranslate"><span class="pre">msg.value</span></code> 在内所有 <code class="docutils literal notranslate"><span class="pre">msg</span></code> 成员的值都会变化。
这里包括对库函数的调用。</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>当合约在链下而不是在区块中包含的交易的背景下计算时，
您不应该认为 <code class="docutils literal notranslate"><span class="pre">block.*</span></code> 和 <code class="docutils literal notranslate"><span class="pre">tx.*</span></code> 是指任何特定区块或交易的值。
这些值是由执行合约的EVM实现提供的，可以是任意的。</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>不要依赖 <code class="docutils literal notranslate"><span class="pre">block.timestamp</span></code> 和 <code class="docutils literal notranslate"><span class="pre">blockhash</span></code> 产生随机数，除非您知道自己在做什么。</p>
<p>时间戳和区块哈希在一定程度上都可能受到挖矿矿工影响。
例如，挖矿社区中的恶意矿工可以用某个给定的哈希来运行赌场合约的 payout 函数，
而如果他们没收到钱，还可以用一个不同的哈希重新尝试。</p>
<p>当前区块的时间戳必须严格大于最后一个区块的时间戳，
但这里唯一能确保的只是它会是在权威链上的两个连续区块的时间戳之间的数值。</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>基于可扩展因素，区块哈希不是对所有区块都有效。
您仅仅可以访问最近 256 个区块的哈希，其余的哈希均为零。</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>函数 <code class="docutils literal notranslate"><span class="pre">blockhash</span></code> 以前被称为 <code class="docutils literal notranslate"><span class="pre">block.blockhash</span></code>，
在0.4.22版本中被废弃，在0.5.0版本中被删除。</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>函数 <code class="docutils literal notranslate"><span class="pre">gasleft</span></code> 的前身是 <code class="docutils literal notranslate"><span class="pre">msg.gas</span></code>，
在0.4.21版本中被弃用，在0.5.0版本中被删除。</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>在0.7.0版本中，删除了别名 <code class="docutils literal notranslate"><span class="pre">now``（用于</span> <span class="pre">``block.timestamp</span></code>）。</p>
</div>
</section>
<section id="abi">
<span id="index-3"></span><h3>ABI编码和解码函数<a class="headerlink" href="#abi" title="Permalink to this heading"></a></h3>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">abi.decode(bytes</span> <span class="pre">memory</span> <span class="pre">encodedData,</span> <span class="pre">(...))</span> <span class="pre">returns</span> <span class="pre">(...)</span></code>: ABI-解码给定的数据，而类型在括号中作为第二个参数给出。例如： <code class="docutils literal notranslate"><span class="pre">(uint</span> <span class="pre">a,</span> <span class="pre">uint[2]</span> <span class="pre">memory</span> <span class="pre">b,</span> <span class="pre">bytes</span> <span class="pre">memory</span> <span class="pre">c)</span> <span class="pre">=</span> <span class="pre">abi.decode(data,</span> <span class="pre">(uint,</span> <span class="pre">uint[2],</span> <span class="pre">bytes))</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">abi.encode(...)</span> <span class="pre">returns</span> <span class="pre">(bytes</span> <span class="pre">memory)</span></code>： 对给定的参数进行ABI编码</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">abi.encodePacked(...)</span> <span class="pre">returns</span> <span class="pre">(bytes</span> <span class="pre">memory)</span></code>： 对给定参数执行 <a class="reference internal" href="abi-spec.html#abi-packed-mode"><span class="std std-ref">紧打包编码</span></a>。 请注意，打包编码可能会有歧义!</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">abi.encodeWithSelector(bytes4</span> <span class="pre">selector,</span> <span class="pre">...)</span> <span class="pre">returns</span> <span class="pre">(bytes</span> <span class="pre">memory)</span></code>： ABI-对给定参数进行编码，并以给定的函数选择器作为起始的4字节数据一起返回</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">abi.encodeWithSignature(string</span> <span class="pre">memory</span> <span class="pre">signature,</span> <span class="pre">...)</span> <span class="pre">returns</span> <span class="pre">(bytes</span> <span class="pre">memory)</span></code>： 相当于 <code class="docutils literal notranslate"><span class="pre">abi.encodeWithSelector(bytes4(keccak256(bytes(signature))),</span> <span class="pre">...)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">abi.encodeCall(function</span> <span class="pre">functionPointer,</span> <span class="pre">(...))</span> <span class="pre">returns</span> <span class="pre">(bytes</span> <span class="pre">memory)</span></code>： 对 <code class="docutils literal notranslate"><span class="pre">函数指针</span></code> 的调用进行ABI编码，参数在元组中找到。执行全面的类型检查，确保类型与函数签名相符。结果相当于 <code class="docutils literal notranslate"><span class="pre">abi.encodeWithSelector(functionPointer.selector,</span> <span class="pre">(...))</span></code>。</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>这些编码函数可用于制作外部函数调用的数据，而无需实际调用外部函数。
此外， <code class="docutils literal notranslate"><span class="pre">keccak256(abi.encodePacked(a,</span> <span class="pre">b))</span></code> 是一种计算结构化数据的哈希值的方法
（但是要注意有可能使用不同的函数参数类型会制作出一个 “哈希碰撞”）。</p>
</div>
<p>更多详情请参考 <a class="reference internal" href="abi-spec.html#abi"><span class="std std-ref">ABI</span></a> 和 <a class="reference internal" href="abi-spec.html#abi-packed-mode"><span class="std std-ref">紧打包编码</span></a>。</p>
</section>
<section id="index-4">
<span id="id6"></span><h3>字节类型的成员<a class="headerlink" href="#index-4" title="Permalink to this heading"></a></h3>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">bytes.concat(...)</span> <span class="pre">returns</span> <span class="pre">(bytes</span> <span class="pre">memory)</span></code>: <a class="reference internal" href="types.html#bytes-concat"><span class="std std-ref">将可变数量的字节和byte1, …, byte32参数串联成一个字节数组</span></a></p></li>
</ul>
</section>
<section id="index-5">
<span id="id7"></span><h3>字符串的成员<a class="headerlink" href="#index-5" title="Permalink to this heading"></a></h3>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">string.concat(...)</span> <span class="pre">returns</span> <span class="pre">(string</span> <span class="pre">memory)</span></code>: <a class="reference internal" href="types.html#string-concat"><span class="std std-ref">将可变数量的字符串参数串联成一个字符串数组</span></a></p></li>
</ul>
</section>
<section id="index-6">
<span id="id8"></span><h3>错误处理<a class="headerlink" href="#index-6" title="Permalink to this heading"></a></h3>
<p>关于错误处理和何时使用哪个函数的更多细节，
请参见 <a class="reference internal" href="control-structures.html#assert-and-require"><span class="std std-ref">assert 和 require</span></a> 的专门章节。</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">assert(bool</span> <span class="pre">condition)</span></code></dt><dd><p>如果条件不满足，会导致异常，因此，状态变化会被恢复 - 用于内部错误。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">require(bool</span> <span class="pre">condition)</span></code></dt><dd><p>如果条件不满足，则恢复状态更改 - 用于输入或外部组件的错误。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">require(bool</span> <span class="pre">condition,</span> <span class="pre">string</span> <span class="pre">memory</span> <span class="pre">message)</span></code></dt><dd><p>如果条件不满足，则恢复状态更改 - 用于输入或外部组件的错误，可以同时提供一个错误消息。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">revert()</span></code></dt><dd><p>终止运行并恢复状态更改。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">revert(string</span> <span class="pre">memory</span> <span class="pre">reason)</span></code></dt><dd><p>终止运行并恢复状态更改，可以同时提供一个解释性的字符串。</p>
</dd>
</dl>
</section>
<section id="mathematical-and-cryptographic-functions">
<span id="index-7"></span><span id="id9"></span><h3>数学和密码学函数<a class="headerlink" href="#mathematical-and-cryptographic-functions" title="Permalink to this heading"></a></h3>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">addmod(uint</span> <span class="pre">x,</span> <span class="pre">uint</span> <span class="pre">y,</span> <span class="pre">uint</span> <span class="pre">k)</span> <span class="pre">returns</span> <span class="pre">(uint)</span></code></dt><dd><p>计算 <code class="docutils literal notranslate"><span class="pre">(x</span> <span class="pre">+</span> <span class="pre">y)</span> <span class="pre">%</span> <span class="pre">k</span></code>，加法会在任意精度下执行，并且加法的结果即使超过 <code class="docutils literal notranslate"><span class="pre">2**256</span></code> 也不会被截取。从 0.5.0 版本的编译器开始会加入对 <code class="docutils literal notranslate"><span class="pre">k</span> <span class="pre">!=</span> <span class="pre">0</span></code> 的校验（assert）。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mulmod(uint</span> <span class="pre">x,</span> <span class="pre">uint</span> <span class="pre">y,</span> <span class="pre">uint</span> <span class="pre">k)</span> <span class="pre">returns</span> <span class="pre">(uint)</span></code></dt><dd><p>计算 <code class="docutils literal notranslate"><span class="pre">(x</span> <span class="pre">*</span> <span class="pre">y)</span> <span class="pre">%</span> <span class="pre">k</span></code>，乘法会在任意精度下执行，并且乘法的结果即使超过 <code class="docutils literal notranslate"><span class="pre">2**256</span></code> 也不会被截取。从 0.5.0 版本的编译器开始会加入对 <code class="docutils literal notranslate"><span class="pre">k</span> <span class="pre">!=</span> <span class="pre">0</span></code> 的校验（assert）。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">keccak256(bytes</span> <span class="pre">memory)</span> <span class="pre">returns</span> <span class="pre">(bytes32)</span></code></dt><dd><p>计算输入的 Keccak-256 哈希值。</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>以前 <code class="docutils literal notranslate"><span class="pre">keccak256</span></code> 的别名叫 <code class="docutils literal notranslate"><span class="pre">sha3</span></code> ，在0.5.0版本中被删除。</p>
</div>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">sha256(bytes</span> <span class="pre">memory)</span> <span class="pre">returns</span> <span class="pre">(bytes32)</span></code></dt><dd><p>计算输入的 SHA-256 哈希值。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ripemd160(bytes</span> <span class="pre">memory)</span> <span class="pre">returns</span> <span class="pre">(bytes20)</span></code></dt><dd><p>计算输入的 RIPEMD-160 哈希值。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ecrecover(bytes32</span> <span class="pre">hash,</span> <span class="pre">uint8</span> <span class="pre">v,</span> <span class="pre">bytes32</span> <span class="pre">r,</span> <span class="pre">bytes32</span> <span class="pre">s)</span> <span class="pre">returns</span> <span class="pre">(address)</span></code></dt><dd><p>利用椭圆曲线签名恢复与公钥相关的地址，错误返回零值。
函数参数对应于签名的ECDSA值：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">r</span></code> = 签名的前32字节</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">s</span></code> = 签名的第二个32字节</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">v</span></code> = 签名的最后1个字节</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">ecrecover</span></code> 返回一个 <code class="docutils literal notranslate"><span class="pre">address</span></code>，而不是 <code class="docutils literal notranslate"><span class="pre">address</span> <span class="pre">payable</span></code>。
参见 <a class="reference internal" href="types.html#address"><span class="std std-ref">地址类型</span></a> 进行转换，以备您需要向恢复的地址转移资金。</p>
<p>更多细节，请阅读 <a class="reference external" href="https://ethereum.stackexchange.com/questions/1777/workflow-on-signing-a-string-with-private-key-followed-by-signature-verificatio">使用示例</a>.</p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>如果您使用 <code class="docutils literal notranslate"><span class="pre">ecrecover</span></code>，请注意，一个有效的签名可以变成另一个有效的签名，而不需要知道相应的私钥。
在Homestead硬分叉中，这个问题对 _transaction_ 签名进行了修复
（见 <a class="reference external" href="https://eips.ethereum.org/EIPS/eip-2#specification">EIP-2</a>），
但ecrecover函数仍然没有改变。</p>
<p>这通常不是一个问题，除非您要求签名是唯一的，或者用它们来识别个体。
OpenZeppelin有一个 <a class="reference external" href="https://docs.openzeppelin.com/contracts/2.x/api/cryptography#ECDSA">ECDSA辅助库</a>，
您可以用它作为 <code class="docutils literal notranslate"><span class="pre">ecrecover</span></code> 的包装，那样就没有这个问题。</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>当在 <em>私有区块链</em> 上运行 <code class="docutils literal notranslate"><span class="pre">sha256</span></code>， <code class="docutils literal notranslate"><span class="pre">ripemd160</span></code> 或 <code class="docutils literal notranslate"><span class="pre">ecrecover</span></code> 时，您可能会遇到超出gas（Out-of-Gas）的错误。这是因为这些功能是作为 “预编译合约” 实现的，只有在它们收到第一个消息后才真正存在（尽管它们的合约代码是硬编码的）。向不存在的合约发送消息的成本较高，因此执行时可能会遇到Out-of-Gas错误。这个问题的一个变通方法是，在您的实际合约中使用它们之前，先向每个合约发送Wei（例如1）。这在主网和测试网上都没有问题。</p>
</div>
</section>
<section id="address-related">
<span id="index-8"></span><span id="id11"></span><h3>地址类型的成员<a class="headerlink" href="#address-related" title="Permalink to this heading"></a></h3>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">&lt;address&gt;.balance</span></code> （ <code class="docutils literal notranslate"><span class="pre">uint256</span></code> ）</dt><dd><p>以 Wei 为单位的 <a class="reference internal" href="types.html#address"><span class="std std-ref">地址类型</span></a> 的余额。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">&lt;address&gt;.code</span></code> （ <code class="docutils literal notranslate"><span class="pre">bytes</span> <span class="pre">memory</span></code> ）</dt><dd><p>在 <a class="reference internal" href="types.html#address"><span class="std std-ref">地址类型</span></a> 的代码（可以是空的）。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">&lt;address&gt;.codehash</span></code> （ <code class="docutils literal notranslate"><span class="pre">bytes32</span></code> ）</dt><dd><p><a class="reference internal" href="types.html#address"><span class="std std-ref">地址类型</span></a> 的代码哈希值</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">&lt;address</span> <span class="pre">payable&gt;.transfer(uint256</span> <span class="pre">amount)</span></code></dt><dd><p>向 <a class="reference internal" href="types.html#address"><span class="std std-ref">地址类型</span></a> 发送数量为 amount 的 Wei，失败时抛出异常，发送 2300 gas 的矿工费，不可调节。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">&lt;address</span> <span class="pre">payable&gt;.send(uint256</span> <span class="pre">amount)</span> <span class="pre">returns</span> <span class="pre">(bool)</span></code></dt><dd><p>向 <a class="reference internal" href="types.html#address"><span class="std std-ref">地址类型</span></a> 发送数量为 amount 的 Wei，失败时返回 <code class="docutils literal notranslate"><span class="pre">false</span></code> 2300 gas 的矿工费用，不可调节。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">&lt;address&gt;.call(bytes</span> <span class="pre">memory)</span> <span class="pre">returns</span> <span class="pre">(bool,</span> <span class="pre">bytes</span> <span class="pre">memory)</span></code></dt><dd><p>用给定的数据发出低级别的 <code class="docutils literal notranslate"><span class="pre">CALL</span></code>，返回是否成功的结果和数据，发送所有可用 gas，可调节。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">&lt;address&gt;.delegatecall(bytes</span> <span class="pre">memory)</span> <span class="pre">returns</span> <span class="pre">(bool,</span> <span class="pre">bytes</span> <span class="pre">memory)</span></code></dt><dd><p>用给定的数据发出低级别的 <code class="docutils literal notranslate"><span class="pre">DELEGATECALL</span></code>，返回是否成功的结果和数据，发送所有可用 gas，可调节。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">&lt;address&gt;.staticcall(bytes</span> <span class="pre">memory)</span> <span class="pre">returns</span> <span class="pre">(bool,</span> <span class="pre">bytes</span> <span class="pre">memory)</span></code></dt><dd><p>用给定的数据发出低级别的 <code class="docutils literal notranslate"><span class="pre">STATICCALL</span></code>，返回是否成功的结果和数据，发送所有可用 gas，可调节。</p>
</dd>
</dl>
<p>更多信息，请参见 <a class="reference internal" href="types.html#address"><span class="std std-ref">地址类型</span></a> 一节。</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>您应该尽可能避免在执行另一个合约函数时使用 <code class="docutils literal notranslate"><span class="pre">.call()</span></code>，因为它绕过了类型检查、函数存在性检查和参数打包。</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>使用 <code class="docutils literal notranslate"><span class="pre">send</span></code> 有很多危险：如果调用栈深度已经达到 1024（这总是可以由调用者所强制指定），
转账会失败；并且如果接收者用光了 gas，转账同样会失败。为了保证以太Coin转账安全，
总是检查 <code class="docutils literal notranslate"><span class="pre">send</span></code> 的返回值，使用 <code class="docutils literal notranslate"><span class="pre">transfer</span></code> 或者下面更好的方式： 用接收者提款的模式。</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>由于EVM认为对一个不存在的合约的调用总是成功的，
Solidity在执行外部调用时使用 <code class="docutils literal notranslate"><span class="pre">extcodesize</span></code> 操作码进行额外的检查。
这确保了即将被调用的合约要么实际存在（它包含代码），要么就会产生一个异常。</p>
<p>对地址而不是合约实例进行低级调用
（即 <code class="docutils literal notranslate"><span class="pre">.call()</span></code>, <code class="docutils literal notranslate"><span class="pre">.delegatecall()</span></code>, <code class="docutils literal notranslate"><span class="pre">.staticcall()</span></code>, <code class="docutils literal notranslate"><span class="pre">.send()</span></code> 和 <code class="docutils literal notranslate"><span class="pre">.transfer()</span></code>）
<strong>不包括</strong> 这种检查，这使得它们在gas方面更便宜，但也更不安全。</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>在0.5.0版本之前，Solidity允许地址成员被合约实例访问，例如 <code class="docutils literal notranslate"><span class="pre">this.balance</span></code>。
现在这被禁止了，必须做一个明确的地址转换。 <code class="docutils literal notranslate"><span class="pre">address(this).balance</span></code>。</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>如果状态变量是通过低级别的委托调用来访问的，那么两个合约的存储布局必须一致，
以便被调用的合约能够正确地通过名称来访问调用合约的存储变量。
当然，如果存储指针作为函数参数被传递的话，情况就不是这样了，就像高层库的情况一样。</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>在0.5.0版本之前， <code class="docutils literal notranslate"><span class="pre">.call</span></code>, <code class="docutils literal notranslate"><span class="pre">.delegatecall</span></code> 和 <code class="docutils literal notranslate"><span class="pre">.staticcall</span></code> 只返回成功状况，
不返回数据。</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>在0.5.0版本之前，有一个名为 <code class="docutils literal notranslate"><span class="pre">callcode</span></code> 的成员，其语义与 <code class="docutils literal notranslate"><span class="pre">delegatecall</span></code> 相似但略有不同。</p>
</div>
</section>
<section id="index-9">
<span id="id12"></span><h3>合约相关<a class="headerlink" href="#index-9" title="Permalink to this heading"></a></h3>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">this</span></code> （当前合约类型）</dt><dd><p>当前合约，可以明确转换为 <a class="reference internal" href="types.html#address"><span class="std std-ref">地址类型</span></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">selfdestruct(address</span> <span class="pre">payable</span> <span class="pre">recipient)</span></code></dt><dd><p>销毁当前合约，将其资金发送到给定的 <a class="reference internal" href="types.html#address"><span class="std std-ref">地址类型</span></a> 并结束执行。
注意， <code class="docutils literal notranslate"><span class="pre">selfdestruct</span></code> 有一些从EVM继承的特殊性：</p>
<ul class="simple">
<li><p>接收合约的接收函数不会被执行。</p></li>
<li><p>合约只有在交易结束时才真正被销毁， 任何一个 <code class="docutils literal notranslate"><span class="pre">revert</span></code> 可能会 “恢复” 销毁。</p></li>
</ul>
</dd>
</dl>
<p>此外，当前合约的所有函数都可以直接调用，包括当前函数。</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>在0.5.0版本之前，有一个叫做 <code class="docutils literal notranslate"><span class="pre">suicide</span></code> 的函数，其语义与 <code class="docutils literal notranslate"><span class="pre">selfdestruct</span></code> 相同。</p>
</div>
</section>
<section id="meta-type">
<span id="index-10"></span><span id="id13"></span><h3>类型信息<a class="headerlink" href="#meta-type" title="Permalink to this heading"></a></h3>
<p>表达式 <code class="docutils literal notranslate"><span class="pre">type(X)</span></code> 可以用来检索关于 <code class="docutils literal notranslate"><span class="pre">X</span></code> 类型的信息。
目前，对这一功能的支持是有限的（ <code class="docutils literal notranslate"><span class="pre">X</span></code> 可以是合约类型或整数型），但在未来可能会扩展。</p>
<p>以下是合约类型 <code class="docutils literal notranslate"><span class="pre">C</span></code> 的可用属性：</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">type(C).name</span></code></dt><dd><p>合约的名称。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">type(C).creationCode</span></code></dt><dd><p>内存字节数组，包含合约的创建字节码。
可以在内联程序中用来建立自定义的创建程序，
特别是通过使用 <code class="docutils literal notranslate"><span class="pre">create2</span></code> 操作码。
这个属性 <strong>不能</strong> 在合约本身或任何派生合约中被访问。
它会导致字节码被包含在调用站点的字节码中，因此像这样的循环引用是不可能的。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">type(C).runtimeCode</span></code></dt><dd><p>内存字节数组，包含合约运行时的字节码。
通常是由 <code class="docutils literal notranslate"><span class="pre">C</span></code> 的构造函数部署的代码。
如果 <code class="docutils literal notranslate"><span class="pre">C</span></code> 有一个使用内联汇编的构造函数，这可能与实际部署的字节码不同。
还要注意的是，库合约在部署时修改其运行时字节码，以防止常规调用。
与 <code class="docutils literal notranslate"><span class="pre">.creationCode</span></code> 相同的限制也适用于这个属性。</p>
</dd>
</dl>
<p>除了上述属性外，以下属性对接口类型 <code class="docutils literal notranslate"><span class="pre">I</span></code> 可用：</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">type(I).interfaceId</span></code>:</dt><dd><p>一个 <code class="docutils literal notranslate"><span class="pre">bytes4</span></code> 值，是包含给定接口 <code class="docutils literal notranslate"><span class="pre">I</span></code> 的 <a class="reference external" href="https://eips.ethereum.org/EIPS/eip-165">EIP-165</a> 接口标识符。
这个标识符被定义为接口本身定义的所有函数选择器的 <code class="docutils literal notranslate"><span class="pre">XOR</span></code>，不包括所有继承的函数。</p>
</dd>
</dl>
<p>以下属性可用于整数类型 <code class="docutils literal notranslate"><span class="pre">T</span></code>：</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">type(T).min</span></code></dt><dd><p>类型 <code class="docutils literal notranslate"><span class="pre">T</span></code> 所能代表的最小值。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">type(T).max</span></code></dt><dd><p>类型 <code class="docutils literal notranslate"><span class="pre">T</span></code> 所能代表的最大值。</p>
</dd>
</dl>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="types.html" class="btn btn-neutral float-left" title="类型" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="control-structures.html" class="btn btn-neutral float-right" title="表达式和控制结构" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2016-2021, Ethereum.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
  
    <p>
        <a href="credits-and-attribution.html">Credits and attribution</a>.
    </p>


</footer>
        </div>
      </div>
    </section>
  </div>
  
<div class="rst-versions" data-toggle="rst-versions" role="note" aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
    <span class="fa fa-book fa-element"> RTD </span>

    <span class="fa fa-element">
    <input class="container_toggle" type="checkbox" id="switch" name="mode">
    <label for="switch"></label>
    </span>

    <span class="fa fa-v fa-element"> v:  <span class="fa fa-caret-down"></span></span>

    </span>
    <div class="rst-other-versions">
        <dl>
            <dt>Downloads</dt> 
        </dl>
        <dl>
            <dt>Versions</dt> 
        </dl>
        <dl>
            
            <dt>On Read the Docs</dt>
            <dd>
                <a href="///projects//?fromdocs=">Project Home</a>
            </dd>
            <dd>
                <a href="///builds//?fromdocs=">Builds</a>
            </dd>
        </dl>
    </div>
</div><script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>