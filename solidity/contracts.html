<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>合约 &mdash; Solidity 0.8.13 documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="_static/a4_railroad_diagram.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/custom.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/toggle.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/sphinx_highlight.js"></script>
        <script src="_static/js/toggle.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="内联汇编" href="assembly.html" />
    <link rel="prev" title="表达式和控制结构" href="control-structures.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #65afff" >
            <a href="index.html">
            <img src="_static/logo.svg" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                0.8.13
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
    
              <p class="caption" role="heading"><span class="caption-text">Basics</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="introduction-to-smart-contracts.html">智能合约概述</a></li>
<li class="toctree-l1"><a class="reference internal" href="installing-solidity.html">安装 Solidity 编译器</a></li>
<li class="toctree-l1"><a class="reference internal" href="solidity-by-example.html">Solidity 合约示例</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Language Description</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="layout-of-source-files.html">Solidity 源文件结构</a></li>
<li class="toctree-l1"><a class="reference internal" href="structure-of-a-contract.html">合约结构</a></li>
<li class="toctree-l1"><a class="reference internal" href="types.html">类型</a></li>
<li class="toctree-l1"><a class="reference internal" href="units-and-global-variables.html">单位和全局变量</a></li>
<li class="toctree-l1"><a class="reference internal" href="control-structures.html">表达式和控制结构</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">合约</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#index-1">创建合约</a></li>
<li class="toctree-l2"><a class="reference internal" href="#getter">可见性和 getter 函数</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id3">状态变量的可见性</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id4">函数的可见性</a></li>
<li class="toctree-l3"><a class="reference internal" href="#getter-functions">Getter 函数</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#modifiers">函数修饰器</a></li>
<li class="toctree-l2"><a class="reference internal" href="#constant-immutable">Constant 和 Immutable 状态变量</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#constant">Constant</a></li>
<li class="toctree-l3"><a class="reference internal" href="#immutable">Immutable</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#functions">函数</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#function-parameters-return-variables">函数参数和返回变量</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id9">函数参数</a></li>
<li class="toctree-l4"><a class="reference internal" href="#index-8">返回的变量</a></li>
<li class="toctree-l4"><a class="reference internal" href="#multi-return">返回多个值</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#state-mutability">状态可变性</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#view">View 函数</a></li>
<li class="toctree-l4"><a class="reference internal" href="#pure">Pure 函数</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#special-functions">特殊的函数</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#receive-ether-function">接收以太的函数</a></li>
<li class="toctree-l4"><a class="reference internal" href="#fallback">Fallback 函数</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#overload-function">函数重载</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id16">重载解析和参数匹配</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#events">事件</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id19">了解事件的其他资源</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#errors">错误和恢复语句</a></li>
<li class="toctree-l2"><a class="reference internal" href="#index-16">继承</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#function-overriding">函数重载</a></li>
<li class="toctree-l3"><a class="reference internal" href="#modifier-overriding">修饰器重载</a></li>
<li class="toctree-l3"><a class="reference internal" href="#constructor">构造函数</a></li>
<li class="toctree-l3"><a class="reference internal" href="#index-20">基本构造函数的参数</a></li>
<li class="toctree-l3"><a class="reference internal" href="#multi-inheritance">多重继承与线性化</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id29">继承有相同名字的不同类型成员</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#abstract-contract">抽象合约</a></li>
<li class="toctree-l2"><a class="reference internal" href="#interfaces">接口</a></li>
<li class="toctree-l2"><a class="reference internal" href="#libraries">库合约</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#index-26">库合约中的函数签名和选择器</a></li>
<li class="toctree-l3"><a class="reference internal" href="#call-protection">库的调用保护</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#using-for">Using For</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="assembly.html">内联汇编</a></li>
<li class="toctree-l1"><a class="reference internal" href="cheatsheet.html">速查表</a></li>
<li class="toctree-l1"><a class="reference internal" href="grammar.html">语法</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Compiler</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="using-the-compiler.html">使用编译器</a></li>
<li class="toctree-l1"><a class="reference internal" href="analysing-compilation-output.html">分析编译器的输出结果</a></li>
<li class="toctree-l1"><a class="reference internal" href="ir-breaking-changes.html">基于Solidity中间表征的Codegen变化</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Internals</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="internals/layout_in_storage.html">存储中的状态变量储存结构</a></li>
<li class="toctree-l1"><a class="reference internal" href="internals/layout_in_memory.html">内存中的存储结构</a></li>
<li class="toctree-l1"><a class="reference internal" href="internals/layout_in_calldata.html">调用数据的存储结构</a></li>
<li class="toctree-l1"><a class="reference internal" href="internals/variable_cleanup.html">清理变量</a></li>
<li class="toctree-l1"><a class="reference internal" href="internals/source_mappings.html">源代码映射</a></li>
<li class="toctree-l1"><a class="reference internal" href="internals/optimizer.html">优化器</a></li>
<li class="toctree-l1"><a class="reference internal" href="metadata.html">合约的元数据</a></li>
<li class="toctree-l1"><a class="reference internal" href="abi-spec.html">合约ABI规范</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Additional Material</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="050-breaking-changes.html">Solidity v0.5.0 突破性变化</a></li>
<li class="toctree-l1"><a class="reference internal" href="060-breaking-changes.html">Solidity 0.6.0 版本突破性变化</a></li>
<li class="toctree-l1"><a class="reference internal" href="070-breaking-changes.html">Solidity v0.7.0 突破性变化</a></li>
<li class="toctree-l1"><a class="reference internal" href="080-breaking-changes.html">Solidity v0.8.0 突破性变化</a></li>
<li class="toctree-l1"><a class="reference internal" href="natspec-format.html">风格指南</a></li>
<li class="toctree-l1"><a class="reference internal" href="security-considerations.html">安全考虑</a></li>
<li class="toctree-l1"><a class="reference internal" href="smtchecker.html">SMT检查器和形式化验证</a></li>
<li class="toctree-l1"><a class="reference internal" href="resources.html">资源</a></li>
<li class="toctree-l1"><a class="reference internal" href="path-resolution.html">Import Path Resolution</a></li>
<li class="toctree-l1"><a class="reference internal" href="yul.html">Yul</a></li>
<li class="toctree-l1"><a class="reference internal" href="style-guide.html">风格指南</a></li>
<li class="toctree-l1"><a class="reference internal" href="common-patterns.html">通用模式</a></li>
<li class="toctree-l1"><a class="reference internal" href="bugs.html">已知bug列表</a></li>
<li class="toctree-l1"><a class="reference internal" href="contributing.html">贡献方式</a></li>
<li class="toctree-l1"><a class="reference internal" href="brand-guide.html">Solidity 品牌指南</a></li>
<li class="toctree-l1"><a class="reference internal" href="language-influences.html">Language Influences</a></li>
</ul>

    <ul>
        <li>
            <a href="genindex.html">Keyword Index</a>
        </li>
    </ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: #65afff" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Solidity</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
      <li>合约</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/contracts.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="contracts">
<span id="index-0"></span><span id="id1"></span><h1>合约<a class="headerlink" href="#contracts" title="Permalink to this heading"></a></h1>
<p>Solidity中的合约类似于面向对象语言中的类。
它们在状态变量中包含持久的数据，以及可以修改这些变量的函数。
在不同的合约（实例）上调用一个函数将执行一个EVM函数调用，
从而切换上下文，使调用合约中的状态变量无法访问。
一个合约和它的函数需要被调用才会发生。
在以太坊中没有 “cron” 的概念，在特定的事件中自动调用一个函数。</p>
<section id="index-1">
<span id="id2"></span><h2>创建合约<a class="headerlink" href="#index-1" title="Permalink to this heading"></a></h2>
<p>可以通过以太坊交易 “从外部” 或从 Solidity 合约内部创建合约。</p>
<p>集成开发环境，如 <a class="reference external" href="https://remix.ethereum.org/">Remix</a>，使用UI元素使创建过程无缝化。</p>
<p>在以太坊上以编程方式创建合约的一种方法是通过JavaScript API <a class="reference external" href="https://github.com/ethereum/web3.js">web3.js</a>。
它有一个名为 <a class="reference external" href="https://web3js.readthedocs.io/en/1.0/web3-eth-contract.html#new-contract">web3.eth.Contract</a> 的函数，
以方便创建合约。</p>
<p>当一个合约被创建时，它的 <a class="reference internal" href="#constructor"><span class="std std-ref">构造函数（constructor）</span></a>
（一个用 <code class="docutils literal notranslate"><span class="pre">constructor</span></code> 关键字声明的函数）被执行一次。</p>
<p>构造函数是可选的。但是只允许有一个构造函数，这意味着不支持重载。</p>
<p>构造函数执行完毕后，合约的最终代码被存储在区块链上。
这段代码包括所有公开和外部函数，以及所有通过函数调用可从那里到达的函数。
部署的代码不包括构造函数代码或只从构造函数调用的内部函数。</p>
<p id="index-2">在内部，构造函数参数在合约代码之后通过 <a class="reference internal" href="abi-spec.html#abi"><span class="std std-ref">ABI编码</span></a> 传递，
但是如果您使用 <code class="docutils literal notranslate"><span class="pre">web3.js</span></code> 则不必关心这个问题。</p>
<p>如果一个合约想创建另一个合约，创建者必须知道所创建合约的源代码（和二进制）。
这意味着，循环的创建依赖是不可能的。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.13&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjIyIDwwLjkuMDsKCgpjb250cmFjdCBPd25lZFRva2VuIHsKICAgIC8vIGBUb2tlbkNyZWF0b3JgIOaYr+WmguS4i+WumuS5ieeahOWQiOe6puexu+Wei+OAggogICAgLy8g5LiN5Yib5bu65paw5ZCI57qm55qE6K+d77yM5Lmf5Y+v5Lul5byV55So5a6D44CCCiAgICBUb2tlbkNyZWF0b3IgY3JlYXRvcjsKICAgIGFkZHJlc3Mgb3duZXI7CiAgICBieXRlczMyIG5hbWU7CgogICAgLy8g6L+Z5piv5rOo5YaMIGNyZWF0b3Ig5ZKM6K6+572u5ZCN56ew55qE5p6E6YCg5Ye95pWw44CCCiAgICBjb25zdHJ1Y3RvcihieXRlczMyIF9uYW1lKSB7CiAgICAgICAgLy8g54q25oCB5Y+Y6YeP6YCa6L+H5YW25ZCN56ew6K6/6Zeu77yMCiAgICAgICAgLy8g6ICM5LiN5piv6YCa6L+H5L6L5aaCIGB0aGlzLm93bmVyYCDnmoTmlrnlvI/orr/pl67jgIIKICAgICAgICAvLyDlh73mlbDlj6/ku6Xnm7TmjqXmiJbpgJrov4cgYHRoaXMuZmAg6K6/6Zeu44CCCiAgICAgICAgLy8g5L2G5ZCO6ICF5o+Q5L6b5LqG5LiA5Liq5a+55Ye95pWw55qE5aSW6YOo5Y+v6KeG5pa55rOV44CCCiAgICAgICAgLy8g54m55Yir5piv5Zyo5p6E6YCg5Ye95pWw5Lit77yM5oKo5LiN5bqU6K+l5LuO5aSW6YOo6K6/6Zeu5Ye95pWw77yMCiAgICAgICAgLy8g5Zug5Li66K+l5Ye95pWw6L+Y5LiN5a2Y5Zyo44CC6K+m6KeB5LiL5LiA6IqC44CCCiAgICAgICAgb3duZXIgPSBtc2cuc2VuZGVyOwoKICAgICAgICAvLyDmiJHku6zov5vooYzkuobku44gYGFkZHJlc3NgIOWIsCBgVG9rZW5DcmVhdG9yYCDnmoTmmL7lvI/nsbvlnovovazmjaLvvIwKICAgICAgICAvLyDlubblgYflrprosIPnlKjlkIjnuqbnmoTnsbvlnovmmK8gYFRva2VuQ3JlYXRvcmDvvIwKICAgICAgICAvLyDmsqHmnInnnJ/mraPnmoTmlrnms5XmnaXpqozor4HvvIwKICAgICAgICAvLyDov5nlubbmsqHmnInliJvlu7rkuIDkuKrmlrDnmoTlkIjnuqbjgIIKICAgICAgICBjcmVhdG9yID0gVG9rZW5DcmVhdG9yKG1zZy5zZW5kZXIpOwogICAgICAgIG5hbWUgPSBfbmFtZTsKICAgIH0KCiAgICBmdW5jdGlvbiBjaGFuZ2VOYW1lKGJ5dGVzMzIgbmV3TmFtZSkgcHVibGljIHsKICAgICAgICAvLyDlj6rmnInliJvlu7rogIXlj6/ku6XmlLnlj5jlkI3np7DjgIIKICAgICAgICAvLyDmiJHku6zmoLnmja7lkIjnuqbnmoTlnLDlnYDov5vooYzmr5TovoPvvIwKICAgICAgICAvLyDlroPlj6/ku6XpgJrov4fmmL7lvI/ovazmjaLkuLrlnLDlnYDmnaXmo4DntKLjgIIKICAgICAgICBpZiAobXNnLnNlbmRlciA9PSBhZGRyZXNzKGNyZWF0b3IpKQogICAgICAgICAgICBuYW1lID0gbmV3TmFtZTsKICAgIH0KCiAgICBmdW5jdGlvbiB0cmFuc2ZlcihhZGRyZXNzIG5ld093bmVyKSBwdWJsaWMgewogICAgICAgIC8vIOWPquacieW9k+WJjeaJgOacieiAheaJjeiDveWPkemAgSB0b2tlbuOAggogICAgICAgIGlmIChtc2cuc2VuZGVyICE9IG93bmVyKSByZXR1cm47CgogICAgICAgIC8vIOaIkeS7rOmAmui/h+S9v+eUqOS4i+mdouWumuS5ieeahCBgVG9rZW5DcmVhdG9yYCDlkIjnuqbnmoTkuIDkuKrlh73mlbAKICAgICAgICAvLyDmnaXor6Lpl67liJvlu7rogIXlkIjnuqbmmK/lkKblupTor6Xov5vooYzovaznp7vjgIIKICAgICAgICAvLyDlpoLmnpzosIPnlKjlpLHotKXvvIjkvovlpoLnlLHkuo7msJTkvZPlgLzogJflsL3vvInvvIwKICAgICAgICAvLyDov5nph4znmoTmiafooYzkuZ/kvJrlpLHotKXjgIIKICAgICAgICBpZiAoY3JlYXRvci5pc1Rva2VuVHJhbnNmZXJPSyhvd25lciwgbmV3T3duZXIpKQogICAgICAgICAgICBvd25lciA9IG5ld093bmVyOwogICAgfQp9CgoKY29udHJhY3QgVG9rZW5DcmVhdG9yIHsKICAgIGZ1bmN0aW9uIGNyZWF0ZVRva2VuKGJ5dGVzMzIgbmFtZSkKICAgICAgICBwdWJsaWMKICAgICAgICByZXR1cm5zIChPd25lZFRva2VuIHRva2VuQWRkcmVzcykKICAgIHsKICAgICAgICAvLyDliJvlu7rkuIDkuKrmlrDnmoQgYFRva2VuYCDlkIjnuqblubbov5Tlm57lhbblnLDlnYDjgIIKICAgICAgICAvLyDku45KYXZhU2NyaXB05pa56Z2i5p2l55yL77yMCiAgICAgICAgLy8g6L+Z5Liq5Ye95pWw55qE6L+U5Zue57G75Z6L5pivIGBhZGRyZXNzYO+8jAogICAgICAgIC8vIOWboOS4uui/meaYr0FCSeS4reacgOaOpei/keeahOexu+Wei+OAggogICAgICAgIHJldHVybiBuZXcgT3duZWRUb2tlbihuYW1lKTsKICAgIH0KCiAgICBmdW5jdGlvbiBjaGFuZ2VOYW1lKE93bmVkVG9rZW4gdG9rZW5BZGRyZXNzLCBieXRlczMyIG5hbWUpIHB1YmxpYyB7CiAgICAgICAgLy8g5ZCM5qC377yMYHRva2VuQWRkcmVzc2Ag55qE5aSW6YOo57G75Z6L5piv566A5Y2V55qEIGBhZGRyZXNzYOOAggogICAgICAgIHRva2VuQWRkcmVzcy5jaGFuZ2VOYW1lKG5hbWUpOwogICAgfQoKICAgIC8vIOaJp+ihjOajgOafpe+8jOS7peehruWumuaYr+WQpuW6lOivpeWwhuS7o+W4gei9rOenu+WIsCBgT3duZWRUb2tlbmAg5ZCI57qm5LiK44CCCiAgICBmdW5jdGlvbiBpc1Rva2VuVHJhbnNmZXJPSyhhZGRyZXNzIGN1cnJlbnRPd25lciwgYWRkcmVzcyBuZXdPd25lcikKICAgICAgICBwdWJsaWMKICAgICAgICBwdXJlCiAgICAgICAgcmV0dXJucyAoYm9vbCBvaykKICAgIHsKICAgICAgICAvLyDmo4Dmn6XkuIDkuKrku7vmhI/nmoTmnaHku7bvvIznnIvmmK/lkKblupTor6Xov5vooYzovaznp7vjgIIKICAgICAgICByZXR1cm4ga2VjY2FrMjU2KGFiaS5lbmNvZGVQYWNrZWQoY3VycmVudE93bmVyLCBuZXdPd25lcikpWzBdID09IDB4N2Y7CiAgICB9Cn0="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.4.22</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span><span class="w"></span>


<span class="k">contract</span><span class="w"> </span><span class="ni">OwnedToken</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// `TokenCreator` 是如下定义的合约类型。</span>
<span class="w">    </span><span class="c1">// 不创建新合约的话，也可以引用它。</span>
<span class="w">    </span>TokenCreator<span class="w"> </span>creator<span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">address</span><span class="w"> </span><span class="nv">owner</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">bytes32</span><span class="w"> </span><span class="nv">name</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="c1">// 这是注册 creator 和设置名称的构造函数。</span>
<span class="w">    </span><span class="kt">constructor</span><span class="p">(</span><span class="kt">bytes32</span><span class="w"> </span><span class="nv">_name</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// 状态变量通过其名称访问，</span>
<span class="w">        </span><span class="c1">// 而不是通过例如 `this.owner` 的方式访问。</span>
<span class="w">        </span><span class="c1">// 函数可以直接或通过 `this.f` 访问。</span>
<span class="w">        </span><span class="c1">// 但后者提供了一个对函数的外部可视方法。</span>
<span class="w">        </span><span class="c1">// 特别是在构造函数中，您不应该从外部访问函数，</span>
<span class="w">        </span><span class="c1">// 因为该函数还不存在。详见下一节。</span>
<span class="w">        </span>owner<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">msg.sender</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="c1">// 我们进行了从 `address` 到 `TokenCreator` 的显式类型转换，</span>
<span class="w">        </span><span class="c1">// 并假定调用合约的类型是 `TokenCreator`，</span>
<span class="w">        </span><span class="c1">// 没有真正的方法来验证，</span>
<span class="w">        </span><span class="c1">// 这并没有创建一个新的合约。</span>
<span class="w">        </span>creator<span class="w"> </span><span class="o">=</span><span class="w"> </span>TokenCreator<span class="p">(</span><span class="k">msg.sender</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span>name<span class="w"> </span><span class="o">=</span><span class="w"> </span>_name<span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">changeName</span><span class="p">(</span><span class="kt">bytes32</span><span class="w"> </span><span class="nv">newName</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// 只有创建者可以改变名称。</span>
<span class="w">        </span><span class="c1">// 我们根据合约的地址进行比较，</span>
<span class="w">        </span><span class="c1">// 它可以通过显式转换为地址来检索。</span>
<span class="w">        </span><span class="kt">if</span><span class="w"> </span><span class="p">(</span><span class="k">msg.sender</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kt">address</span><span class="p">(</span>creator<span class="p">))</span><span class="w"></span>
<span class="w">            </span>name<span class="w"> </span><span class="o">=</span><span class="w"> </span>newName<span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">transfer</span><span class="p">(</span><span class="kt">address</span><span class="w"> </span><span class="nv">newOwner</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// 只有当前所有者才能发送 token。</span>
<span class="w">        </span><span class="kt">if</span><span class="w"> </span><span class="p">(</span><span class="k">msg.sender</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span>owner<span class="p">)</span><span class="w"> </span><span class="kt">return</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="c1">// 我们通过使用下面定义的 `TokenCreator` 合约的一个函数</span>
<span class="w">        </span><span class="c1">// 来询问创建者合约是否应该进行转移。</span>
<span class="w">        </span><span class="c1">// 如果调用失败（例如由于气体值耗尽），</span>
<span class="w">        </span><span class="c1">// 这里的执行也会失败。</span>
<span class="w">        </span><span class="kt">if</span><span class="w"> </span><span class="p">(</span>creator<span class="p">.</span>isTokenTransferOK<span class="p">(</span>owner<span class="p">,</span><span class="w"> </span>newOwner<span class="p">))</span><span class="w"></span>
<span class="w">            </span>owner<span class="w"> </span><span class="o">=</span><span class="w"> </span>newOwner<span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>


<span class="k">contract</span><span class="w"> </span><span class="ni">TokenCreator</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">createToken</span><span class="p">(</span><span class="kt">bytes32</span><span class="w"> </span><span class="nv">name</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="kt">public</span><span class="w"></span>
<span class="w">        </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span>OwnedToken<span class="w"> </span>tokenAddress<span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// 创建一个新的 `Token` 合约并返回其地址。</span>
<span class="w">        </span><span class="c1">// 从JavaScript方面来看，</span>
<span class="w">        </span><span class="c1">// 这个函数的返回类型是 `address`，</span>
<span class="w">        </span><span class="c1">// 因为这是ABI中最接近的类型。</span>
<span class="w">        </span><span class="kt">return</span><span class="w"> </span><span class="kt">new</span><span class="w"> </span>OwnedToken<span class="p">(</span>name<span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">changeName</span><span class="p">(</span>OwnedToken<span class="w"> </span>tokenAddress<span class="p">,</span><span class="w"> </span><span class="kt">bytes32</span><span class="w"> </span><span class="nv">name</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// 同样，`tokenAddress` 的外部类型是简单的 `address`。</span>
<span class="w">        </span>tokenAddress<span class="p">.</span>changeName<span class="p">(</span>name<span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="c1">// 执行检查，以确定是否应该将代币转移到 `OwnedToken` 合约上。</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">isTokenTransferOK</span><span class="p">(</span><span class="kt">address</span><span class="w"> </span><span class="nv">currentOwner</span><span class="p">,</span><span class="w"> </span><span class="kt">address</span><span class="w"> </span><span class="nv">newOwner</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="kt">public</span><span class="w"></span>
<span class="w">        </span>pure<span class="w"></span>
<span class="w">        </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">bool</span><span class="w"> </span><span class="nv">ok</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// 检查一个任意的条件，看是否应该进行转移。</span>
<span class="w">        </span><span class="kt">return</span><span class="w"> </span><span class="nb">keccak256</span><span class="p">(</span>abi<span class="p">.</span>encodePacked<span class="p">(</span>currentOwner<span class="p">,</span><span class="w"> </span>newOwner<span class="p">))[</span><span class="m m-Decimal">0</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mh">0x7f</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<span class="target" id="index-3"></span></section>
<section id="getter">
<span id="visibility-and-getters"></span><h2>可见性和 getter 函数<a class="headerlink" href="#getter" title="Permalink to this heading"></a></h2>
<section id="id3">
<h3>状态变量的可见性<a class="headerlink" href="#id3" title="Permalink to this heading"></a></h3>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">public</span></code></dt><dd><p>公开状态变量与内部变量的不同之处在于，编译器会自动为它们生成 <a class="reference internal" href="#getter-functions"><span class="std std-ref">getter函数</span></a>，
从而允许其他合约读取它们的值。当在同一个合约中使用时，外部访问（例如 <code class="docutils literal notranslate"><span class="pre">this.x</span></code>）会调用getter，
而内部访问（例如 <code class="docutils literal notranslate"><span class="pre">x</span></code>）会直接从存储中获取变量值。
Setter函数没有被生成，所以其他合约不能直接修改其值。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">internal</span></code></dt><dd><p>内部状态变量只能从它们所定义的合约和派生合约中访问。
它们不能被外部访问。
这是状态变量的默认可见性。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">private</span></code></dt><dd><p>私有状态变量就像内部变量一样，但它们在派生合约中是不可见的。</p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>标记一些变量为 <code class="docutils literal notranslate"><span class="pre">private</span></code> 或 <code class="docutils literal notranslate"><span class="pre">internal</span></code>，只能防止其他合约读取或修改信息，但它仍然会被区块链之外的整个世界看到。</p>
</div>
</section>
<section id="id4">
<h3>函数的可见性<a class="headerlink" href="#id4" title="Permalink to this heading"></a></h3>
<p>Solidity 有两种函数调用：确实创建了实际 EVM 消息调用的外部函数和不创建 EVM 消息调用的内部函数。
此外，派生合约可能无法访问内部函数。
这就产生了四种类型的函数的可见性。</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">external</span></code></dt><dd><p>外部函数作为合约接口的一部分，意味着我们可以从其他合约和交易中调用。
一个外部函数 <code class="docutils literal notranslate"><span class="pre">f</span></code> 不能从内部调用
（即 <code class="docutils literal notranslate"><span class="pre">f()</span></code> 不起作用，但 <code class="docutils literal notranslate"><span class="pre">this.f()</span></code> 可以）。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">public</span></code></dt><dd><p>公开函数是合约接口的一部分，可以在内部或通过消息调用。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">internal</span></code></dt><dd><p>内部函数只能从当前的合约或从它派生出来的合约中访问。
它们不能被外部访问。
由于它们没有通过合约的ABI暴露在外部，它们可以接受内部类型的参数，如映射或存储引用。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">private</span></code></dt><dd><p>私有函数和内部函数一样，但它们在派生合约中是不可见的。</p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>标记一些变量为 <code class="docutils literal notranslate"><span class="pre">private</span></code> 或 <code class="docutils literal notranslate"><span class="pre">internal</span></code>，只能防止其他合约读取或修改信息，但它仍然会被区块链之外的整个世界看到。</p>
</div>
<p>在状态变量的类型之后，以及在函数的参数列表和返回参数列表之间，都会给出可见性指定符。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.13&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCmNvbnRyYWN0IEMgewogICAgZnVuY3Rpb24gZih1aW50IGEpIHByaXZhdGUgcHVyZSByZXR1cm5zICh1aW50IGIpIHsgcmV0dXJuIGEgKyAxOyB9CiAgICBmdW5jdGlvbiBzZXREYXRhKHVpbnQgYSkgaW50ZXJuYWwgeyBkYXRhID0gYTsgfQogICAgdWludCBwdWJsaWMgZGF0YTsKfQ=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.4.16</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span><span class="w"></span>

<span class="k">contract</span><span class="w"> </span><span class="ni">C</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">f</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">a</span><span class="p">)</span><span class="w"> </span><span class="kt">private</span><span class="w"> </span>pure<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="kt">return</span><span class="w"> </span>a<span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="m m-Decimal">1</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">setData</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">a</span><span class="p">)</span><span class="w"> </span><span class="kt">internal</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>data<span class="w"> </span><span class="o">=</span><span class="w"> </span>a<span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="kt">uint</span><span class="w"> </span><span class="k">public </span><span class="nv">data</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>在下面的例子中，合约 <code class="docutils literal notranslate"><span class="pre">D</span></code>, 可以调用 <code class="docutils literal notranslate"><span class="pre">c.getData()</span></code> 来检索状态存储中 <code class="docutils literal notranslate"><span class="pre">data</span></code> 的值，
但不能调用 <code class="docutils literal notranslate"><span class="pre">f</span></code>。 合约 <code class="docutils literal notranslate"><span class="pre">E</span></code> 是从合约 <code class="docutils literal notranslate"><span class="pre">C</span></code> 派生出来的，因此可以调用 <code class="docutils literal notranslate"><span class="pre">compute</span></code>。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.13&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCmNvbnRyYWN0IEMgewogICAgdWludCBwcml2YXRlIGRhdGE7CgogICAgZnVuY3Rpb24gZih1aW50IGEpIHByaXZhdGUgcHVyZSByZXR1cm5zKHVpbnQgYikgeyByZXR1cm4gYSArIDE7IH0KICAgIGZ1bmN0aW9uIHNldERhdGEodWludCBhKSBwdWJsaWMgeyBkYXRhID0gYTsgfQogICAgZnVuY3Rpb24gZ2V0RGF0YSgpIHB1YmxpYyB2aWV3IHJldHVybnModWludCkgeyByZXR1cm4gZGF0YTsgfQogICAgZnVuY3Rpb24gY29tcHV0ZSh1aW50IGEsIHVpbnQgYikgaW50ZXJuYWwgcHVyZSByZXR1cm5zICh1aW50KSB7IHJldHVybiBhICsgYjsgfQp9CgovLyDov5nlsIbkuI3kvJrnvJbor5EKY29udHJhY3QgRCB7CiAgICBmdW5jdGlvbiByZWFkRGF0YSgpIHB1YmxpYyB7CiAgICAgICAgQyBjID0gbmV3IEMoKTsKICAgICAgICB1aW50IGxvY2FsID0gYy5mKDcpOyAvLyDplJnor6/vvJrmiJDlkZggYGZgIOS4jeWPr+ingQogICAgICAgIGMuc2V0RGF0YSgzKTsKICAgICAgICBsb2NhbCA9IGMuZ2V0RGF0YSgpOwogICAgICAgIGxvY2FsID0gYy5jb21wdXRlKDMsIDUpOyAvLyDplJnor6/vvJrmiJDlkZggYGNvbXB1dGVgIOS4jeWPr+ingQogICAgfQp9Cgpjb250cmFjdCBFIGlzIEMgewogICAgZnVuY3Rpb24gZygpIHB1YmxpYyB7CiAgICAgICAgQyBjID0gbmV3IEMoKTsKICAgICAgICB1aW50IHZhbCA9IGNvbXB1dGUoMywgNSk7IC8vIOiuv+mXruWGhemDqOaIkOWRmO+8iOS7jue7p+aJv+WQiOe6puiuv+mXrueItuWQiOe6puaIkOWRmO+8iQogICAgfQp9"><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.4.16</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span><span class="w"></span>

<span class="k">contract</span><span class="w"> </span><span class="ni">C</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">uint</span><span class="w"> </span><span class="k">private </span><span class="nv">data</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">f</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">a</span><span class="p">)</span><span class="w"> </span><span class="kt">private</span><span class="w"> </span>pure<span class="w"> </span><span class="kt">returns</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="kt">return</span><span class="w"> </span>a<span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="m m-Decimal">1</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">setData</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">a</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>data<span class="w"> </span><span class="o">=</span><span class="w"> </span>a<span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">getData</span><span class="p">()</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>view<span class="w"> </span><span class="kt">returns</span><span class="p">(</span><span class="kt">uint</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="kt">return</span><span class="w"> </span>data<span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">compute</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">a</span><span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="nv">b</span><span class="p">)</span><span class="w"> </span><span class="kt">internal</span><span class="w"> </span>pure<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="kt">return</span><span class="w"> </span>a<span class="w"> </span><span class="o">+</span><span class="w"> </span>b<span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// 这将不会编译</span>
<span class="k">contract</span><span class="w"> </span><span class="ni">D</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">readData</span><span class="p">()</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span>C<span class="w"> </span>c<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">new</span><span class="w"> </span>C<span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="kt">uint</span><span class="w"> </span><span class="nv">local</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>c<span class="p">.</span>f<span class="p">(</span><span class="m m-Decimal">7</span><span class="p">);</span><span class="w"> </span><span class="c1">// 错误：成员 `f` 不可见</span>
<span class="w">        </span>c<span class="p">.</span>setData<span class="p">(</span><span class="m m-Decimal">3</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span>local<span class="w"> </span><span class="o">=</span><span class="w"> </span>c<span class="p">.</span>getData<span class="p">();</span><span class="w"></span>
<span class="w">        </span>local<span class="w"> </span><span class="o">=</span><span class="w"> </span>c<span class="p">.</span>compute<span class="p">(</span><span class="m m-Decimal">3</span><span class="p">,</span><span class="w"> </span><span class="m m-Decimal">5</span><span class="p">);</span><span class="w"> </span><span class="c1">// 错误：成员 `compute` 不可见</span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">contract</span><span class="w"> </span><span class="ni">E</span><span class="w"> </span><span class="kt">is</span><span class="w"> </span>C<span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">g</span><span class="p">()</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span>C<span class="w"> </span>c<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">new</span><span class="w"> </span>C<span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="kt">uint</span><span class="w"> </span><span class="nv">val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>compute<span class="p">(</span><span class="m m-Decimal">3</span><span class="p">,</span><span class="w"> </span><span class="m m-Decimal">5</span><span class="p">);</span><span class="w"> </span><span class="c1">// 访问内部成员（从继承合约访问父合约成员）</span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="getter-functions">
<span id="index-4"></span><span id="id5"></span><h3>Getter 函数<a class="headerlink" href="#getter-functions" title="Permalink to this heading"></a></h3>
<p>编译器会自动为所有 <strong>公开</strong> 状态变量创建getter函数。
对于下面给出的合约，编译器将生成一个名为 <code class="docutils literal notranslate"><span class="pre">data</span></code> 的函数，
它没有任何输入参数，并返回一个 <code class="docutils literal notranslate"><span class="pre">uint</span></code>，
即状态变量 <code class="docutils literal notranslate"><span class="pre">data</span></code> 的值。状态变量在声明时可以被初始化。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.13&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCmNvbnRyYWN0IEMgewogICAgdWludCBwdWJsaWMgZGF0YSA9IDQyOwp9Cgpjb250cmFjdCBDYWxsZXIgewogICAgQyBjID0gbmV3IEMoKTsKICAgIGZ1bmN0aW9uIGYoKSBwdWJsaWMgdmlldyByZXR1cm5zICh1aW50KSB7CiAgICAgICAgcmV0dXJuIGMuZGF0YSgpOwogICAgfQp9"><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.4.16</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span><span class="w"></span>

<span class="k">contract</span><span class="w"> </span><span class="ni">C</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">uint</span><span class="w"> </span><span class="k">public </span><span class="nv">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m m-Decimal">42</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">contract</span><span class="w"> </span><span class="ni">Caller</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span>C<span class="w"> </span>c<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">new</span><span class="w"> </span>C<span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">f</span><span class="p">()</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>view<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">return</span><span class="w"> </span>c<span class="p">.</span>data<span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>getter函数具有外部可见性。
如果该符号被内部访问（即没有 <code class="docutils literal notranslate"><span class="pre">this.</span></code>），它被评估为一个状态变量。
如果它被外部访问（即有 <code class="docutils literal notranslate"><span class="pre">this.</span></code>），它将被评价为一个函数。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.13&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjAgPDAuOS4wOwoKY29udHJhY3QgQyB7CiAgICB1aW50IHB1YmxpYyBkYXRhOwogICAgZnVuY3Rpb24geCgpIHB1YmxpYyByZXR1cm5zICh1aW50KSB7CiAgICAgICAgZGF0YSA9IDM7IC8vIOWGhemDqOiuv+mXrgogICAgICAgIHJldHVybiB0aGlzLmRhdGEoKTsgLy8g5aSW6YOo6K6/6ZeuCiAgICB9Cn0="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.4.0</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span><span class="w"></span>

<span class="k">contract</span><span class="w"> </span><span class="ni">C</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">uint</span><span class="w"> </span><span class="k">public </span><span class="nv">data</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">x</span><span class="p">()</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span>data<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m m-Decimal">3</span><span class="p">;</span><span class="w"> </span><span class="c1">// 内部访问</span>
<span class="w">        </span><span class="kt">return</span><span class="w"> </span><span class="kt">this</span><span class="p">.</span>data<span class="p">();</span><span class="w"> </span><span class="c1">// 外部访问</span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>如果您有一个数组类型的 <code class="docutils literal notranslate"><span class="pre">public</span></code> 状态变量，
那么您只能通过生成的getter函数检索数组的单个元素。
这种机制的存在是为了避免在返回整个数组时产生高额的气体成本。
您可以使用参数来指定要返回的单个元素，例如 <code class="docutils literal notranslate"><span class="pre">myArray(0)</span></code>。
如果您想在一次调用中返回整个数组，那么您需要写一个函数，例如：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.13&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCmNvbnRyYWN0IGFycmF5RXhhbXBsZSB7CiAgICAvLyDlhazlvIDnirbmgIHlj5jph48KICAgIHVpbnRbXSBwdWJsaWMgbXlBcnJheTsKCiAgICAvLyDnvJbor5HlmajnlJ/miJDnmoRnZXR0ZXLlh73mlbAKICAgIC8qCiAgICBmdW5jdGlvbiBteUFycmF5KHVpbnQgaSkgcHVibGljIHZpZXcgcmV0dXJucyAodWludCkgewogICAgICAgIHJldHVybiBteUFycmF5W2ldOwogICAgfQogICAgKi8KCiAgICAvLyDov5Tlm57mlbTkuKrmlbDnu4TnmoTlh73mlbAKICAgIGZ1bmN0aW9uIGdldEFycmF5KCkgcHVibGljIHZpZXcgcmV0dXJucyAodWludFtdIG1lbW9yeSkgewogICAgICAgIHJldHVybiBteUFycmF5OwogICAgfQp9"><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.4.16</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span><span class="w"></span>

<span class="k">contract</span><span class="w"> </span><span class="ni">arrayExample</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// 公开状态变量</span>
<span class="w">    </span><span class="kt">uint</span><span class="p">[]</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>myArray<span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="c1">// 编译器生成的getter函数</span>
<span class="w">    </span><span class="cm">/*</span>
<span class="cm">    function myArray(uint i) public view returns (uint) {</span>
<span class="cm">        return myArray[i];</span>
<span class="cm">    }</span>
<span class="cm">    */</span><span class="w"></span>

<span class="w">    </span><span class="c1">// 返回整个数组的函数</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">getArray</span><span class="p">()</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>view<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="p">[]</span><span class="w"> </span><span class="kt">memory</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">return</span><span class="w"> </span>myArray<span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>现在您可以使用 <code class="docutils literal notranslate"><span class="pre">getArray()</span></code> 来检索整个数组，
而不是使用 <code class="docutils literal notranslate"><span class="pre">myArray(i)</span></code>，它每次调用只返回一个元素。</p>
<p>下一个例子稍微复杂一些：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.13&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjAgPDAuOS4wOwoKY29udHJhY3QgQ29tcGxleCB7CiAgICBzdHJ1Y3QgRGF0YSB7CiAgICAgICAgdWludCBhOwogICAgICAgIGJ5dGVzMyBiOwogICAgICAgIG1hcHBpbmcgKHVpbnQgPT4gdWludCkgbWFwOwogICAgICAgIHVpbnRbM10gYzsKICAgICAgICB1aW50W10gZDsKICAgICAgICBieXRlcyBlOwogICAgfQogICAgbWFwcGluZyAodWludCA9PiBtYXBwaW5nKGJvb2wgPT4gRGF0YVtdKSkgcHVibGljIGRhdGE7Cn0="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.4.0</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span><span class="w"></span>

<span class="k">contract</span><span class="w"> </span><span class="ni">Complex</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">struct</span><span class="w"> </span><span class="nv">Data</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">uint</span><span class="w"> </span><span class="nv">a</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span>bytes3<span class="w"> </span>b<span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="kt">mapping</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="kt">uint</span><span class="p">)</span><span class="w"> </span>map<span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="kt">uint</span><span class="p">[</span><span class="m m-Decimal">3</span><span class="p">]</span><span class="w"> </span>c<span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="kt">uint</span><span class="p">[]</span><span class="w"> </span>d<span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="kt">bytes</span><span class="w"> </span><span class="nv">e</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="kt">mapping</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="kt">mapping</span><span class="p">(</span><span class="kt">bool</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span>Data<span class="p">[]))</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>data<span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>它生成了一个如下形式的函数。结构中的映射和数组（字节数组除外）被省略了，
因为没有好的方法来选择单个结构成员或为映射提供一个键：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.13&amp;code=ZnVuY3Rpb24gZGF0YSh1aW50IGFyZzEsIGJvb2wgYXJnMiwgdWludCBhcmczKQogICAgcHVibGljCiAgICByZXR1cm5zICh1aW50IGEsIGJ5dGVzMyBiLCBieXRlcyBtZW1vcnkgZSkKewogICAgYSA9IGRhdGFbYXJnMV1bYXJnMl1bYXJnM10uYTsKICAgIGIgPSBkYXRhW2FyZzFdW2FyZzJdW2FyZzNdLmI7CiAgICBlID0gZGF0YVthcmcxXVthcmcyXVthcmczXS5lOwp9"><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="kt">function</span><span class="w"> </span><span class="nv">data</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">arg1</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="nv">arg2</span><span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="nv">arg3</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="kt">public</span><span class="w"></span>
<span class="w">    </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">a</span><span class="p">,</span><span class="w"> </span>bytes3<span class="w"> </span>b<span class="p">,</span><span class="w"> </span><span class="kt">bytes</span><span class="w"> </span><span class="nv">memory</span><span class="w"> </span>e<span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span>a<span class="w"> </span><span class="o">=</span><span class="w"> </span>data<span class="p">[</span>arg1<span class="p">][</span>arg2<span class="p">][</span>arg3<span class="p">].</span>a<span class="p">;</span><span class="w"></span>
<span class="w">    </span>b<span class="w"> </span><span class="o">=</span><span class="w"> </span>data<span class="p">[</span>arg1<span class="p">][</span>arg2<span class="p">][</span>arg3<span class="p">].</span>b<span class="p">;</span><span class="w"></span>
<span class="w">    </span>e<span class="w"> </span><span class="o">=</span><span class="w"> </span>data<span class="p">[</span>arg1<span class="p">][</span>arg2<span class="p">][</span>arg3<span class="p">].</span>e<span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
</section>
<section id="modifiers">
<span id="index-5"></span><span id="id6"></span><h2>函数修饰器<a class="headerlink" href="#modifiers" title="Permalink to this heading"></a></h2>
<p>函数修饰器可以用来以声明的方式改变函数的行为。
例如，您可以使用修饰器在执行函数之前自动检查一个条件。</p>
<p>修饰器是合约的可继承属性，可以被派生合约重载，
但只有当它们被标记为 <code class="docutils literal notranslate"><span class="pre">virtual</span></code> 时，才能被重载。
详情请见 <a class="reference internal" href="#modifier-overriding"><span class="std std-ref">修饰器重载</span></a>。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.13&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjEgPDAuOS4wOwoKY29udHJhY3Qgb3duZWQgewogICAgY29uc3RydWN0b3IoKSB7IG93bmVyID0gcGF5YWJsZShtc2cuc2VuZGVyKTsgfQogICAgYWRkcmVzcyBwYXlhYmxlIG93bmVyOwoKICAgIC8vIOi/meS4quWQiOe6puWPquWumuS5ieS6huS4gOS4quS/rumlsOWZqO+8jOS9huayoeacieS9v+eUqOWug++8mgogICAgLy8g5a6D5bCG5Zyo5rS+55Sf5ZCI57qm5Lit5L2/55So44CCCiAgICAvLyDkv67ppbDlmajmiYDkv67ppbDnmoTlh73mlbDkvZPkvJrooqvmj5LlhaXliLDnibnmrornrKblj7cgYF87YCDnmoTkvY3nva7jgIIKICAgIC8vIOi/meaEj+WRs+edgO+8jOWmguaenOaJgOacieiAheiwg+eUqOi/meS4quWHveaVsO+8jOi/meS4quWHveaVsOWwseS8muiiq+aJp+ihjO+8jAogICAgLy8g5ZCm5YiZ5bCx5Lya5oqb5Ye65LiA5Liq5byC5bi444CCCiAgICBtb2RpZmllciBvbmx5T3duZXIgewogICAgICAgIHJlcXVpcmUoCiAgICAgICAgICAgIG1zZy5zZW5kZXIgPT0gb3duZXIsCiAgICAgICAgICAgICJPbmx5IG93bmVyIGNhbiBjYWxsIHRoaXMgZnVuY3Rpb24uIgogICAgICAgICk7CiAgICAgICAgXzsKICAgIH0KfQoKY29udHJhY3QgZGVzdHJ1Y3RpYmxlIGlzIG93bmVkIHsKICAgIC8vIOi/meS4quWQiOe6puS7jiBgb3duZWRgIOWQiOe6pue7p+aJv+S6hiBgb25seU93bmVyYCDkv67ppbDlmajvvIwKICAgIC8vIOW5tuWwhuWFtuW6lOeUqOS6jiBgZGVzdHJveWAg5Ye95pWw77yMCiAgICAvLyDlj6rmnInlnKjlkIjnuqbph4zkv53lrZjnmoQgb3duZXIg6LCD55SoIGBkZXN0cm95YCDlh73mlbDvvIzmiY3kvJrnlJ/mlYjjgIIKICAgIGZ1bmN0aW9uIGRlc3Ryb3koKSBwdWJsaWMgb25seU93bmVyIHsKICAgICAgICBzZWxmZGVzdHJ1Y3Qob3duZXIpOwogICAgfQp9Cgpjb250cmFjdCBwcmljZWQgewogICAgLy8g5L+u6aWw5Zmo5Y+v5Lul5o6l5Y+X5Y+C5pWw77yaCiAgICBtb2RpZmllciBjb3N0cyh1aW50IHByaWNlKSB7CiAgICAgICAgaWYgKG1zZy52YWx1ZSA+PSBwcmljZSkgewogICAgICAgICAgICBfOwogICAgICAgIH0KICAgIH0KfQoKY29udHJhY3QgUmVnaXN0ZXIgaXMgcHJpY2VkLCBkZXN0cnVjdGlibGUgewogICAgbWFwcGluZyAoYWRkcmVzcyA9PiBib29sKSByZWdpc3RlcmVkQWRkcmVzc2VzOwogICAgdWludCBwcmljZTsKCiAgICBjb25zdHJ1Y3Rvcih1aW50IGluaXRpYWxQcmljZSkgeyBwcmljZSA9IGluaXRpYWxQcmljZTsgfQoKICAgIC8vIOWcqOi/memHjOS5n+S9v+eUqOWFs+mUruWtlyBgcGF5YWJsZWAg6Z2e5bi46YeN6KaB77yMCiAgICAvLyDlkKbliJnlh73mlbDkvJroh6rliqjmi5Lnu53miYDmnInlj5HpgIHnu5nlroPnmoTku6XlpKrluIHjgIIKICAgIGZ1bmN0aW9uIHJlZ2lzdGVyKCkgcHVibGljIHBheWFibGUgY29zdHMocHJpY2UpIHsKICAgICAgICByZWdpc3RlcmVkQWRkcmVzc2VzW21zZy5zZW5kZXJdID0gdHJ1ZTsKICAgIH0KCiAgICBmdW5jdGlvbiBjaGFuZ2VQcmljZSh1aW50IF9wcmljZSkgcHVibGljIG9ubHlPd25lciB7CiAgICAgICAgcHJpY2UgPSBfcHJpY2U7CiAgICB9Cn0KCmNvbnRyYWN0IE11dGV4IHsKICAgIGJvb2wgbG9ja2VkOwogICAgbW9kaWZpZXIgbm9SZWVudHJhbmN5KCkgewogICAgICAgIHJlcXVpcmUoCiAgICAgICAgICAgICFsb2NrZWQsCiAgICAgICAgICAgICJSZWVudHJhbnQgY2FsbC4iCiAgICAgICAgKTsKICAgICAgICBsb2NrZWQgPSB0cnVlOwogICAgICAgIF87CiAgICAgICAgbG9ja2VkID0gZmFsc2U7CiAgICB9CgogICAgLy8vIOi/meS4quWHveaVsOWPl+S6kuaWpemHj+S/neaKpO+8jOi/meaEj+WRs+edgCBgbXNnLnNlbmRlci5jYWxsYCDkuK3nmoTph43lhaXosIPnlKjkuI3og73lho3mrKHosIPnlKggIGBmYOOAggogICAgLy8vIGByZXR1cm4gN2Ag6K+t5Y+l5oyH5a6a6L+U5Zue5YC85Li6IDfvvIzkvYbkv67ppbDlmajkuK3nmoTor63lj6UgYGxvY2tlZCA9IGZhbHNlYCDku43kvJrmiafooYzjgIIKICAgIGZ1bmN0aW9uIGYoKSBwdWJsaWMgbm9SZWVudHJhbmN5IHJldHVybnMgKHVpbnQpIHsKICAgICAgICAoYm9vbCBzdWNjZXNzLCkgPSBtc2cuc2VuZGVyLmNhbGwoIiIpOwogICAgICAgIHJlcXVpcmUoc3VjY2Vzcyk7CiAgICAgICAgcmV0dXJuIDc7CiAgICB9Cn0="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.7.1</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span><span class="w"></span>

<span class="k">contract</span><span class="w"> </span><span class="ni">owned</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">constructor</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>owner<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">payable</span><span class="p">(</span><span class="k">msg.sender</span><span class="p">);</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="kt">address</span><span class="w"> </span><span class="nv">payable</span><span class="w"> </span>owner<span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="c1">// 这个合约只定义了一个修饰器，但没有使用它：</span>
<span class="w">    </span><span class="c1">// 它将在派生合约中使用。</span>
<span class="w">    </span><span class="c1">// 修饰器所修饰的函数体会被插入到特殊符号 `_;` 的位置。</span>
<span class="w">    </span><span class="c1">// 这意味着，如果所有者调用这个函数，这个函数就会被执行，</span>
<span class="w">    </span><span class="c1">// 否则就会抛出一个异常。</span>
<span class="w">    </span><span class="kt">modifier</span><span class="w"> </span>onlyOwner<span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">require</span><span class="p">(</span><span class="w"></span>
<span class="w">            </span><span class="k">msg.sender</span><span class="w"> </span><span class="o">==</span><span class="w"> </span>owner<span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="s2">&quot;Only owner can call this function.&quot;</span><span class="w"></span>
<span class="w">        </span><span class="p">);</span><span class="w"></span>
<span class="w">        </span>_<span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">contract</span><span class="w"> </span><span class="ni">destructible</span><span class="w"> </span><span class="kt">is</span><span class="w"> </span>owned<span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// 这个合约从 `owned` 合约继承了 `onlyOwner` 修饰器，</span>
<span class="w">    </span><span class="c1">// 并将其应用于 `destroy` 函数，</span>
<span class="w">    </span><span class="c1">// 只有在合约里保存的 owner 调用 `destroy` 函数，才会生效。</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">destroy</span><span class="p">()</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>onlyOwner<span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span>selfdestruct<span class="p">(</span>owner<span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">contract</span><span class="w"> </span><span class="ni">priced</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// 修饰器可以接受参数：</span>
<span class="w">    </span><span class="kt">modifier</span><span class="w"> </span>costs<span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">price</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">if</span><span class="w"> </span><span class="p">(</span><span class="k">msg.value</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span>price<span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span>_<span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">contract</span><span class="w"> </span><span class="ni">Register</span><span class="w"> </span><span class="kt">is</span><span class="w"> </span>priced<span class="p">,</span><span class="w"> </span>destructible<span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">mapping</span><span class="w"> </span><span class="p">(</span><span class="kt">address</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="kt">bool</span><span class="p">)</span><span class="w"> </span>registeredAddresses<span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">uint</span><span class="w"> </span><span class="nv">price</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="kt">constructor</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">initialPrice</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>price<span class="w"> </span><span class="o">=</span><span class="w"> </span>initialPrice<span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="c1">// 在这里也使用关键字 `payable` 非常重要，</span>
<span class="w">    </span><span class="c1">// 否则函数会自动拒绝所有发送给它的以太币。</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">register</span><span class="p">()</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="kt">payable</span><span class="w"> </span>costs<span class="p">(</span>price<span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span>registeredAddresses<span class="p">[</span><span class="k">msg.sender</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">true</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">changePrice</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">_price</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>onlyOwner<span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span>price<span class="w"> </span><span class="o">=</span><span class="w"> </span>_price<span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">contract</span><span class="w"> </span><span class="ni">Mutex</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nv">locked</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">modifier</span><span class="w"> </span>noReentrancy<span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">require</span><span class="p">(</span><span class="w"></span>
<span class="w">            </span><span class="o">!</span>locked<span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="s2">&quot;Reentrant call.&quot;</span><span class="w"></span>
<span class="w">        </span><span class="p">);</span><span class="w"></span>
<span class="w">        </span>locked<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">true</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span>_<span class="p">;</span><span class="w"></span>
<span class="w">        </span>locked<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">false</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="c1">/// 这个函数受互斥量保护，这意味着 `msg.sender.call` 中的重入调用不能再次调用  `f`。</span>
<span class="w">    </span><span class="c1">/// `return 7` 语句指定返回值为 7，但修饰器中的语句 `locked = false` 仍会执行。</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">f</span><span class="p">()</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>noReentrancy<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="p">(</span><span class="kt">bool</span><span class="w"> </span><span class="nv">success</span><span class="p">,)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">msg.sender</span><span class="p">.</span>call<span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kt">require</span><span class="p">(</span>success<span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kt">return</span><span class="w"> </span><span class="m m-Decimal">7</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>如果您想访问定义在合约 <code class="docutils literal notranslate"><span class="pre">C</span></code> 中的修饰器 <code class="docutils literal notranslate"><span class="pre">m</span></code>，
您可以使用 <code class="docutils literal notranslate"><span class="pre">C.m</span></code> 来引用它而不需要虚拟查询。
只能使用定义在当前合约或其基础合约中的修饰器。
修饰器也可以定义在库合约中，但其使用仅限于同一库合约的函数。</p>
<p>如果同一个函数有多个修饰器，它们之间以空格隔开，并按照所呈现的顺序进行评估运算。</p>
<p>修饰器不能隐式地访问或改变它们所修改的函数的参数和返回值。
它们的值只能在调用的时候明确地传递给它们。</p>
<p>修饰器或函数体的显式返回只离开当前修饰器或函数体。
返回变量会被赋值，但整个执行逻辑会从前一个修饰器中定义的 <code class="docutils literal notranslate"><span class="pre">_</span></code> 之后继续执行。</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>在Solidity的早期版本中，具有修饰器的函数中的 <code class="docutils literal notranslate"><span class="pre">return</span></code> 语句会表现的不同。</p>
</div>
<p>用 <code class="docutils literal notranslate"><span class="pre">return;</span></code> 从修饰器显式返回并不影响函数返回的值。
然而，修饰器可以选择完全不执行函数主体，在这种情况下，
返回变量被设置为 <a class="reference internal" href="control-structures.html#default-value"><span class="std std-ref">默认值</span></a>，就像函数有一个空主体一样。</p>
<p><code class="docutils literal notranslate"><span class="pre">_</span></code> 符号可以在修饰器中多次出现。每次出现都会被替换成函数体。</p>
<p>允许修饰器参数使用任意表达式，在这种情况下，所有从函数中可见的符号在修饰器中都是可见的。
修饰器中引入的符号在函数中是不可见的（因为它们可能因重载而改变）。</p>
</section>
<section id="constant-immutable">
<span id="constants"></span><span id="index-6"></span><h2>Constant 和 Immutable 状态变量<a class="headerlink" href="#constant-immutable" title="Permalink to this heading"></a></h2>
<p>状态变量可以被声明为 <code class="docutils literal notranslate"><span class="pre">constant</span></code> 或 <code class="docutils literal notranslate"><span class="pre">immutable</span></code>。
在这两种情况下，变量在合约构建完成后不能被修改。
对于 <code class="docutils literal notranslate"><span class="pre">constant</span></code> 变量，其值必须在编译时固定，
而对于 <code class="docutils literal notranslate"><span class="pre">immutable</span></code> 变量，仍然可以在构造时分配。</p>
<p>也可以在文件级别定义 <code class="docutils literal notranslate"><span class="pre">constant</span></code> 变量。</p>
<p>编译器并没有为这些变量预留存储，它们的每次出现都会被替换为相应的常量表达式。</p>
<p>与普通的状态变量相比，常量变量（constant）和不可改变的变量（immutable）的气体成本要低得多。
对于常量变量，分配给它的表达式被复制到所有访问它的地方，并且每次都要重新评估，
这使得局部优化成为可能。不可变的变量在构造时被评估一次，其值被复制到代码中所有被访问的地方。
对于这些值，要保留32个字节，即使它们可以装入更少的字节。由于这个原因，常量值有时会比不可变的值更便宜。</p>
<p>目前，并非所有的常量和不可变量的类型都已实现。
唯一支持的类型是 <a class="reference internal" href="types.html#strings"><span class="std std-ref">字符串类型</span></a> （仅用于常量）和 <a class="reference internal" href="types.html#value-types"><span class="std std-ref">值类型</span></a>。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.13&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjQ7Cgp1aW50IGNvbnN0YW50IFggPSAzMioqMjIgKyA4OwoKY29udHJhY3QgQyB7CiAgICBzdHJpbmcgY29uc3RhbnQgVEVYVCA9ICJhYmMiOwogICAgYnl0ZXMzMiBjb25zdGFudCBNWV9IQVNIID0ga2VjY2FrMjU2KCJhYmMiKTsKICAgIHVpbnQgaW1tdXRhYmxlIGRlY2ltYWxzOwogICAgdWludCBpbW11dGFibGUgbWF4QmFsYW5jZTsKICAgIGFkZHJlc3MgaW1tdXRhYmxlIG93bmVyID0gbXNnLnNlbmRlcjsKCiAgICBjb25zdHJ1Y3Rvcih1aW50IF9kZWNpbWFscywgYWRkcmVzcyBfcmVmZXJlbmNlKSB7CiAgICAgICAgZGVjaW1hbHMgPSBfZGVjaW1hbHM7CiAgICAgICAgLy8g5a+55LiN5Y+v5Y+Y6YeP55qE6LWL5YC855Sa6Iez5Y+v5Lul6K6/6Zeu5LiA5Lqb5YWo5bGA5bGe5oCn44CCCiAgICAgICAgbWF4QmFsYW5jZSA9IF9yZWZlcmVuY2UuYmFsYW5jZTsKICAgIH0KCiAgICBmdW5jdGlvbiBpc0JhbGFuY2VUb29IaWdoKGFkZHJlc3MgX290aGVyKSBwdWJsaWMgdmlldyByZXR1cm5zIChib29sKSB7CiAgICAgICAgcmV0dXJuIF9vdGhlci5iYWxhbmNlID4gbWF4QmFsYW5jZTsKICAgIH0KfQ=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.7.4</span><span class="p">;</span><span class="w"></span>

<span class="kt">uint</span><span class="w"> </span><span class="nv">constant</span><span class="w"> </span>X<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m m-Decimal">32</span><span class="o">**</span><span class="m m-Decimal">22</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="m m-Decimal">8</span><span class="p">;</span><span class="w"></span>

<span class="k">contract</span><span class="w"> </span><span class="ni">C</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">string</span><span class="w"> </span><span class="nv">constant</span><span class="w"> </span>TEXT<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">&quot;abc&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">bytes32</span><span class="w"> </span><span class="nv">constant</span><span class="w"> </span>MY_HASH<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">keccak256</span><span class="p">(</span><span class="s2">&quot;abc&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="kt">uint</span><span class="w"> </span><span class="nv">immutable</span><span class="w"> </span>decimals<span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">uint</span><span class="w"> </span><span class="nv">immutable</span><span class="w"> </span>maxBalance<span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">address</span><span class="w"> </span><span class="nv">immutable</span><span class="w"> </span>owner<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">msg.sender</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="kt">constructor</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">_decimals</span><span class="p">,</span><span class="w"> </span><span class="kt">address</span><span class="w"> </span><span class="nv">_reference</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span>decimals<span class="w"> </span><span class="o">=</span><span class="w"> </span>_decimals<span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="c1">// 对不可变量的赋值甚至可以访问一些全局属性。</span>
<span class="w">        </span>maxBalance<span class="w"> </span><span class="o">=</span><span class="w"> </span>_reference<span class="p">.</span>balance<span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">isBalanceTooHigh</span><span class="p">(</span><span class="kt">address</span><span class="w"> </span><span class="nv">_other</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>view<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">bool</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">return</span><span class="w"> </span>_other<span class="p">.</span>balance<span class="w"> </span><span class="o">&gt;</span><span class="w"> </span>maxBalance<span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<section id="constant">
<h3>Constant<a class="headerlink" href="#constant" title="Permalink to this heading"></a></h3>
<p>对于 <code class="docutils literal notranslate"><span class="pre">constant</span></code> 变量，其值在编译时必须是一个常量，并且必须在变量声明的地方分配。
任何访问存储、区块链数据（例如： <code class="docutils literal notranslate"><span class="pre">block.timestamp</span></code>, <code class="docutils literal notranslate"><span class="pre">address(this).balance</span></code> 或 <code class="docutils literal notranslate"><span class="pre">block.number</span></code>）
或执行数据（ <code class="docutils literal notranslate"><span class="pre">msg.value</span></code> 或 <code class="docutils literal notranslate"><span class="pre">gasleft()</span></code>）或者调用外部合约的表达式都是不允许的。
但可能对内存分配产生副作用的表达式是允许的，但那些可能对其他内存对象产生副作用的表达式是不允许的。
内置函数 <code class="docutils literal notranslate"><span class="pre">keccak256</span></code>， <code class="docutils literal notranslate"><span class="pre">sha256</span></code>， <code class="docutils literal notranslate"><span class="pre">ripemd160</span></code>， <code class="docutils literal notranslate"><span class="pre">ecrecover</span></code>， <code class="docutils literal notranslate"><span class="pre">addmod</span></code> 和 <code class="docutils literal notranslate"><span class="pre">mulmod</span></code>
是允许的（尽管除了 <code class="docutils literal notranslate"><span class="pre">keccak256</span></code>，它们确实调用了外部合约）。</p>
<p>允许在内存分配器上产生副作用的原因是，
它应该可以构建复杂的对象，比如说查找表。
这个功能现在还不能完全使用。</p>
</section>
<section id="immutable">
<h3>Immutable<a class="headerlink" href="#immutable" title="Permalink to this heading"></a></h3>
<p>声明为 <code class="docutils literal notranslate"><span class="pre">immutable</span></code> 的变量比声明为 <code class="docutils literal notranslate"><span class="pre">constant</span></code> 的变量受到的限制要少一些。
不可变的变量可以在合约的构造函数中或在声明时被分配一个任意的值。
它们只能被分配一次，并且从那时起，即使在构造时间内也可以被读取。</p>
<p>编译器生成的合约创建代码将在其返回之前修改合约的运行时代码，
用分配给它们的值替换所有对不可变量的引用。
当您将编译器生成的运行时代码与实际存储在区块链中的代码进行比较，这一点很重要。</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>在声明时被分配的不可变量只有在合约的构造函数执行时才会被视为初始化。
这意味着您不能在内联中用一个依赖于另一个不可变量的值来初始化不可变量。
然而，您可以在合约的构造函数中这样做。</p>
<p>这是对状态变量初始化和构造函数执行顺序的不同解释的一种保障，特别是在继承方面。</p>
</div>
</section>
</section>
<section id="functions">
<span id="index-7"></span><span id="id7"></span><h2>函数<a class="headerlink" href="#functions" title="Permalink to this heading"></a></h2>
<p>可以在合约内部和外部定义函数。</p>
<p>合约之外的函数，也称为 “自由函数”，总是隐含着 <code class="docutils literal notranslate"><span class="pre">internal</span></code> 的 <a class="reference internal" href="#visibility-and-getters"><span class="std std-ref">可见性</span></a>。
它们的代码包含在所有调用它们的合约中，类似于内部库函数。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.13&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjEgPDAuOS4wOwoKZnVuY3Rpb24gc3VtKHVpbnRbXSBtZW1vcnkgX2FycikgcHVyZSByZXR1cm5zICh1aW50IHMpIHsKICAgIGZvciAodWludCBpID0gMDsgaSA8IF9hcnIubGVuZ3RoOyBpKyspCiAgICAgICAgcyArPSBfYXJyW2ldOwp9Cgpjb250cmFjdCBBcnJheUV4YW1wbGUgewogICAgYm9vbCBmb3VuZDsKICAgIGZ1bmN0aW9uIGYodWludFtdIG1lbW9yeSBfYXJyKSBwdWJsaWMgewogICAgICAgIC8vIOi/meWcqOWGhemDqOiwg+eUqOiHqueUseWHveaVsOOAggogICAgICAgIC8vIOe8luivkeWZqOS8muWwhuWFtuS7o+eggea3u+WKoOWIsOWQiOe6puS4reOAggogICAgICAgIHVpbnQgcyA9IHN1bShfYXJyKTsKICAgICAgICByZXF1aXJlKHMgPj0gMTApOwogICAgICAgIGZvdW5kID0gdHJ1ZTsKICAgIH0KfQ=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.7.1</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span><span class="w"></span>

<span class="kt">function</span><span class="w"> </span><span class="nv">sum</span><span class="p">(</span><span class="kt">uint</span><span class="p">[]</span><span class="w"> </span><span class="kt">memory</span><span class="w"> </span>_arr<span class="p">)</span><span class="w"> </span>pure<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">s</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">for</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m m-Decimal">0</span><span class="p">;</span><span class="w"> </span>i<span class="w"> </span><span class="o">&lt;</span><span class="w"> </span>_arr<span class="p">.</span>length<span class="p">;</span><span class="w"> </span>i<span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span>s<span class="w"> </span><span class="o">+=</span><span class="w"> </span>_arr<span class="p">[</span>i<span class="p">];</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">contract</span><span class="w"> </span><span class="ni">ArrayExample</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nv">found</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">f</span><span class="p">(</span><span class="kt">uint</span><span class="p">[]</span><span class="w"> </span><span class="kt">memory</span><span class="w"> </span>_arr<span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// 这在内部调用自由函数。</span>
<span class="w">        </span><span class="c1">// 编译器会将其代码添加到合约中。</span>
<span class="w">        </span><span class="kt">uint</span><span class="w"> </span><span class="nv">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>sum<span class="p">(</span>_arr<span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kt">require</span><span class="p">(</span>s<span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="m m-Decimal">10</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span>found<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">true</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>在合约之外定义的函数，仍然总是在合约的背景下执行。它们仍然可以访问变量 <code class="docutils literal notranslate"><span class="pre">this</span></code>，
可以调用其他合约，向它们发送以太，并销毁调用它们的合约，以及其他事项。
与合约内定义的函数的主要区别是，自由函数不能直接访问不在其范围内的存储变量和函数。</p>
</div>
<section id="function-parameters-return-variables">
<span id="id8"></span><h3>函数参数和返回变量<a class="headerlink" href="#function-parameters-return-variables" title="Permalink to this heading"></a></h3>
<p>与许多其他语言不同, 函数接受类型化的参数作为输入，
也可以返回任意数量的值作为输出。</p>
<section id="id9">
<h4>函数参数<a class="headerlink" href="#id9" title="Permalink to this heading"></a></h4>
<p>函数参数的声明方式与变量相同，未使用的参数名称可以省略。</p>
<p>例如，如果您想让您的合约接受一种带有两个整数的外部调用，您可以使用类似以下的方式：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.13&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCmNvbnRyYWN0IFNpbXBsZSB7CiAgICB1aW50IHN1bTsKICAgIGZ1bmN0aW9uIHRha2VyKHVpbnQgX2EsIHVpbnQgX2IpIHB1YmxpYyB7CiAgICAgICAgc3VtID0gX2EgKyBfYjsKICAgIH0KfQ=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.4.16</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span><span class="w"></span>

<span class="k">contract</span><span class="w"> </span><span class="ni">Simple</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">uint</span><span class="w"> </span><span class="nv">sum</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">taker</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">_a</span><span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="nv">_b</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span>sum<span class="w"> </span><span class="o">=</span><span class="w"> </span>_a<span class="w"> </span><span class="o">+</span><span class="w"> </span>_b<span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>函数参数可以像任何其他局部变量一样使用，它们也可以被赋值。</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>一个 <a class="reference internal" href="control-structures.html#external-function-calls"><span class="std std-ref">外部函数</span></a> 不能接受一个多维数组作为输入参数。
如果您通过在源文件中添加 <code class="docutils literal notranslate"><span class="pre">pragma</span> <span class="pre">abicoder</span> <span class="pre">v2;</span></code> 来启用ABI编码器v2，就可以实现这个功能。</p>
<p>一个 <a class="reference internal" href="control-structures.html#external-function-calls"><span class="std std-ref">内部函数</span></a> 可以不启用该功能而接受一个多维数组。</p>
</div>
</section>
<section id="index-8">
<span id="id10"></span><h4>返回的变量<a class="headerlink" href="#index-8" title="Permalink to this heading"></a></h4>
<p>函数的返回变量在 <code class="docutils literal notranslate"><span class="pre">returns</span></code> 关键字之后用同样的语法声明。</p>
<p>例如，假设您想返回两个结果：作为函数参数传递的两个整数的总和和乘积，那么您就使用类似的方法：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.13&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCmNvbnRyYWN0IFNpbXBsZSB7CiAgICBmdW5jdGlvbiBhcml0aG1ldGljKHVpbnQgX2EsIHVpbnQgX2IpCiAgICAgICAgcHVibGljCiAgICAgICAgcHVyZQogICAgICAgIHJldHVybnMgKHVpbnQgc3VtLCB1aW50IHByb2R1Y3QpCiAgICB7CiAgICAgICAgc3VtID0gX2EgKyBfYjsKICAgICAgICBwcm9kdWN0ID0gX2EgKiBfYjsKICAgIH0KfQ=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.4.16</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span><span class="w"></span>

<span class="k">contract</span><span class="w"> </span><span class="ni">Simple</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">arithmetic</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">_a</span><span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="nv">_b</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="kt">public</span><span class="w"></span>
<span class="w">        </span>pure<span class="w"></span>
<span class="w">        </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">sum</span><span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="nv">product</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span>sum<span class="w"> </span><span class="o">=</span><span class="w"> </span>_a<span class="w"> </span><span class="o">+</span><span class="w"> </span>_b<span class="p">;</span><span class="w"></span>
<span class="w">        </span>product<span class="w"> </span><span class="o">=</span><span class="w"> </span>_a<span class="w"> </span><span class="o">*</span><span class="w"> </span>_b<span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>返回变量的名字可以被省略。返回变量可以像其他本地变量一样使用，
它们被初始化为相应的 <a class="reference internal" href="control-structures.html#default-value"><span class="std std-ref">默认值</span></a>，
并且在它们被（重新）赋值之前拥有这个值。</p>
<p>您可以明确地赋值给返回变量，然后像上面那样结束函数，
或者您可以用 <code class="docutils literal notranslate"><span class="pre">return</span></code> 语句直接提供返回值（单个或 <a class="reference internal" href="#multi-return"><span class="std std-ref">多个返回值</span></a>）。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.13&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCmNvbnRyYWN0IFNpbXBsZSB7CiAgICBmdW5jdGlvbiBhcml0aG1ldGljKHVpbnQgX2EsIHVpbnQgX2IpCiAgICAgICAgcHVibGljCiAgICAgICAgcHVyZQogICAgICAgIHJldHVybnMgKHVpbnQgc3VtLCB1aW50IHByb2R1Y3QpCiAgICB7CiAgICAgICAgcmV0dXJuIChfYSArIF9iLCBfYSAqIF9iKTsKICAgIH0KfQ=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.4.16</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span><span class="w"></span>

<span class="k">contract</span><span class="w"> </span><span class="ni">Simple</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">arithmetic</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">_a</span><span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="nv">_b</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="kt">public</span><span class="w"></span>
<span class="w">        </span>pure<span class="w"></span>
<span class="w">        </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">sum</span><span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="nv">product</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">return</span><span class="w"> </span><span class="p">(</span>_a<span class="w"> </span><span class="o">+</span><span class="w"> </span>_b<span class="p">,</span><span class="w"> </span>_a<span class="w"> </span><span class="o">*</span><span class="w"> </span>_b<span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>如果您过早使用 <code class="docutils literal notranslate"><span class="pre">return</span></code> 来结束一个有返回变量的函数，您必须在返回语句中同时提供返回值。</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>您不能从非内部函数返回某些类型，特别是多维动态数组和结构。
如果您通过在源文件中添加 <code class="docutils literal notranslate"><span class="pre">pragma</span> <span class="pre">abicoder</span> <span class="pre">v2;</span></code> 来启用ABI编码器v2，
那么就会有更多的类型可用，但 <code class="docutils literal notranslate"><span class="pre">映射（mapping）</span></code> 类型仍然被限制在单个合约内，您不能转移它们。</p>
</div>
</section>
<section id="multi-return">
<span id="id11"></span><h4>返回多个值<a class="headerlink" href="#multi-return" title="Permalink to this heading"></a></h4>
<p>当一个函数有多个返回类型时，语句 <code class="docutils literal notranslate"><span class="pre">return</span> <span class="pre">(v0,</span> <span class="pre">v1,</span> <span class="pre">...,</span> <span class="pre">vn)</span></code> 可以用来返回多个值。
声明的数量必须与返回变量的数量相同，并且它们的类型必须匹配，
有可能是经过 <a class="reference internal" href="types.html#types-conversion-elementary-types"><span class="std std-ref">隐式转换</span></a>。</p>
</section>
</section>
<section id="state-mutability">
<span id="id12"></span><h3>状态可变性<a class="headerlink" href="#state-mutability" title="Permalink to this heading"></a></h3>
<section id="view">
<span id="view-functions"></span><span id="index-9"></span><h4>View 函数<a class="headerlink" href="#view" title="Permalink to this heading"></a></h4>
<p>函数可以被声明为 <code class="docutils literal notranslate"><span class="pre">view</span></code>，在这种情况下，它们承诺不修改状态。</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>如果编译器的EVM版本是Byzantium或更新的（默认），
当调用 <code class="docutils literal notranslate"><span class="pre">view</span></code> 函数时，会使用操作码 <code class="docutils literal notranslate"><span class="pre">STATICCALL</span></code>，这使得状态作为EVM执行的一部分保持不被修改。
对于库合约的 <code class="docutils literal notranslate"><span class="pre">view</span></code> 函数，会使用 <code class="docutils literal notranslate"><span class="pre">DELEGATECALL</span></code>，
因为没有组合的 <code class="docutils literal notranslate"><span class="pre">DELEGATECALL</span></code> 和 <code class="docutils literal notranslate"><span class="pre">STATICCALL</span></code>。
这意味着库合约中的 <code class="docutils literal notranslate"><span class="pre">view</span></code> 函数没有防止状态修改的运行时的检查。
这应该不会对安全产生负面影响，因为库合约的代码通常在编译时就知道了，
而且静态检查器也会进行编译时检查。</p>
</div>
<p>以下声明被认为是修改状态：</p>
<ol class="arabic simple">
<li><p>修改状态变量。</p></li>
<li><p><a class="reference internal" href="#events"><span class="std std-ref">产生事件</span></a>。</p></li>
<li><p><a class="reference internal" href="control-structures.html#creating-contracts"><span class="std std-ref">创建其它合约</span></a>。</p></li>
<li><p>使用 <code class="docutils literal notranslate"><span class="pre">selfdestruct</span></code>。</p></li>
<li><p>通过调用发送以太币。</p></li>
<li><p>调用任何没有标记为 <code class="docutils literal notranslate"><span class="pre">view</span></code> 或者 <code class="docutils literal notranslate"><span class="pre">pure</span></code> 的函数。</p></li>
<li><p>使用低级调用。</p></li>
<li><p>使用包含特定操作码的内联汇编。</p></li>
</ol>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.13&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC41LjAgPDAuOS4wOwoKY29udHJhY3QgQyB7CiAgICBmdW5jdGlvbiBmKHVpbnQgYSwgdWludCBiKSBwdWJsaWMgdmlldyByZXR1cm5zICh1aW50KSB7CiAgICAgICAgcmV0dXJuIGEgKiAoYiArIDQyKSArIGJsb2NrLnRpbWVzdGFtcDsKICAgIH0KfQ=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.5.0</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span><span class="w"></span>

<span class="k">contract</span><span class="w"> </span><span class="ni">C</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">f</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">a</span><span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="nv">b</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>view<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">return</span><span class="w"> </span>a<span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span>b<span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="m m-Decimal">42</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="k">block.timestamp</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>函数上的 <code class="docutils literal notranslate"><span class="pre">constant</span></code> 曾经是 <code class="docutils literal notranslate"><span class="pre">view</span></code> 的别名，但在0.5.0版本中被取消。</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Getter方法被自动标记为 <code class="docutils literal notranslate"><span class="pre">view</span></code>。</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>在0.5.0版本之前，编译器没有为 <code class="docutils literal notranslate"><span class="pre">view</span></code> 函数使用 <code class="docutils literal notranslate"><span class="pre">STATICCALL</span></code> 操作码。
这使得 <code class="docutils literal notranslate"><span class="pre">view</span></code> 函数通过使用无效的显式类型转换进行状态修改。
通过对 <code class="docutils literal notranslate"><span class="pre">view</span></code> 函数使用 <code class="docutils literal notranslate"><span class="pre">STATICCALL</span></code>，在EVM层面上防止了对状态的修改。</p>
</div>
</section>
<section id="pure">
<span id="pure-functions"></span><span id="index-10"></span><h4>Pure 函数<a class="headerlink" href="#pure" title="Permalink to this heading"></a></h4>
<p>函数可以被声明为 <code class="docutils literal notranslate"><span class="pre">pure</span></code>，在这种情况下，它们承诺不读取或修改状态。
特别是，应该可以在编译时评估一个 <code class="docutils literal notranslate"><span class="pre">pure</span></code> 函数，只给它的输入和 <code class="docutils literal notranslate"><span class="pre">msg.data</span></code>，
但不知道当前区块链状态。这意味着读取 <code class="docutils literal notranslate"><span class="pre">immutable</span></code> 的变量可以是一个非标准pure的操作。</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>如果编译器的EVM版本是Byzantium或更新的（默认），则使用操作码 <code class="docutils literal notranslate"><span class="pre">STATICCALL</span></code>，
这并不能保证不读取状态，但至少不能修改。</p>
</div>
<p>除了上面解释的状态修改语句列表外，以下内容被认为是从状态中读取的：</p>
<ol class="arabic simple">
<li><p>读取状态变量。</p></li>
<li><p>访问 <code class="docutils literal notranslate"><span class="pre">address(this).balance</span></code> 或者 <code class="docutils literal notranslate"><span class="pre">&lt;address&gt;.balance</span></code>。</p></li>
<li><p>访问 <code class="docutils literal notranslate"><span class="pre">block</span></code>， <code class="docutils literal notranslate"><span class="pre">tx</span></code>， <code class="docutils literal notranslate"><span class="pre">msg</span></code> 中任意成员 （除 <code class="docutils literal notranslate"><span class="pre">msg.sig</span></code> 和 <code class="docutils literal notranslate"><span class="pre">msg.data</span></code> 之外）。</p></li>
<li><p>调用任何未标记为 <code class="docutils literal notranslate"><span class="pre">pure</span></code> 的函数。</p></li>
<li><p>使用包含某些操作码的内联汇编。</p></li>
</ol>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.13&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC41LjAgPDAuOS4wOwoKY29udHJhY3QgQyB7CiAgICBmdW5jdGlvbiBmKHVpbnQgYSwgdWludCBiKSBwdWJsaWMgcHVyZSByZXR1cm5zICh1aW50KSB7CiAgICAgICAgcmV0dXJuIGEgKiAoYiArIDQyKTsKICAgIH0KfQ=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.5.0</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span><span class="w"></span>

<span class="k">contract</span><span class="w"> </span><span class="ni">C</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">f</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">a</span><span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="nv">b</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>pure<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">return</span><span class="w"> </span>a<span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span>b<span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="m m-Decimal">42</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>当一个 <a class="reference internal" href="control-structures.html#assert-and-require"><span class="std std-ref">错误发生</span></a> 时，
Pure 函数能够使用 <code class="docutils literal notranslate"><span class="pre">revert()</span></code> 和 <code class="docutils literal notranslate"><span class="pre">require()</span></code> 函数来恢复潜在的状态变化。</p>
<p>恢复一个状态变化不被认为是 “状态修改”，
因为只有之前在没有 <code class="docutils literal notranslate"><span class="pre">view</span></code> 或 <code class="docutils literal notranslate"><span class="pre">pure</span></code> 限制的代码中对状态的改变才会被恢复，
并且该代码可以选择捕捉 <code class="docutils literal notranslate"><span class="pre">revert</span></code> 而不传递给它。</p>
<p>这种行为也与 <code class="docutils literal notranslate"><span class="pre">STATICCALL</span></code> 操作码一致。</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>在EVM层面不可能阻止函数读取状态，只可能阻止它们写入状态
（即只有 <code class="docutils literal notranslate"><span class="pre">view</span></code> 可以在EVM层面执行， <code class="docutils literal notranslate"><span class="pre">pure</span></code> 不可以）。</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>在0.5.0版本之前，编译器没有为 <code class="docutils literal notranslate"><span class="pre">pure</span></code> 函数使用 <code class="docutils literal notranslate"><span class="pre">STATICCALL</span></code> 操作码。
这使得在 <code class="docutils literal notranslate"><span class="pre">pure</span></code> 函数中通过使用无效的显式类型转换进行状态修改。
通过对 <code class="docutils literal notranslate"><span class="pre">pure</span></code> 函数使用 <code class="docutils literal notranslate"><span class="pre">STATICCALL</span></code>，在EVM层面防止了对状态的修改。</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>在0.4.17版本之前，编译器并没有强制要求 <code class="docutils literal notranslate"><span class="pre">pure</span></code> 不读取状态。
这是一个编译时的类型检查，可以规避在合约类型之间做无效的显式转换，
因为编译器可以验证合约的类型不做改变状态的操作，
但它不能检查将在运行时被调用的合约是否真的属于该类型。</p>
</div>
</section>
</section>
<section id="special-functions">
<span id="id13"></span><h3>特殊的函数<a class="headerlink" href="#special-functions" title="Permalink to this heading"></a></h3>
<section id="receive-ether-function">
<span id="index-11"></span><span id="id14"></span><h4>接收以太的函数<a class="headerlink" href="#receive-ether-function" title="Permalink to this heading"></a></h4>
<p>一个合约最多可以有一个 <code class="docutils literal notranslate"><span class="pre">receive</span></code> 函数，
使用 <code class="docutils literal notranslate"><span class="pre">receive()</span> <span class="pre">external</span> <span class="pre">payable</span> <span class="pre">{</span> <span class="pre">...</span> <span class="pre">}</span></code> 来声明。（没有  <code class="docutils literal notranslate"><span class="pre">function</span></code> 关键字）。
这个函数不能有参数，不能返回任何东西，必须具有 <code class="docutils literal notranslate"><span class="pre">external</span></code> 的可见性和 <code class="docutils literal notranslate"><span class="pre">payable</span></code> 的状态可变性。
它可以是虚拟的，可以重载，也可以有修饰器。</p>
<p>receive 函数是在调用合约时执行的，并带有空的 calldata。
这是在纯以太传输（例如通过 <code class="docutils literal notranslate"><span class="pre">.send()</span></code> 或 <code class="docutils literal notranslate"><span class="pre">.transfer()</span></code> ）时执行的函数。
如果不存在这样的函数，但存在一个 payable 类型的 <a class="reference internal" href="#fallback-function"><span class="std std-ref">fallback函数</span></a>，
这个fallback函数将在纯以太传输时被调用。
如果既没有直接接收以太（receive函数），也没有可接收以太的 fallback 函数，
合约就不能通过常规交易接收以太，并抛出一个异常。</p>
<p>在最坏的情况下， <code class="docutils literal notranslate"><span class="pre">receive</span></code> 函数只有2300个气体可用（例如当使用 <code class="docutils literal notranslate"><span class="pre">send</span></code> 或 <code class="docutils literal notranslate"><span class="pre">transfer</span></code> 时），
除了基本的记录外，几乎没有空间来执行其他操作。以下操作的消耗气体将超过2300气体的规定：</p>
<ul class="simple">
<li><p>写入存储</p></li>
<li><p>创建合约</p></li>
<li><p>调用消耗大量 gas 的外部函数</p></li>
<li><p>发送以太币</p></li>
</ul>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>直接接收以太的合约（没有函数调用，即使用 <code class="docutils literal notranslate"><span class="pre">send</span></code> 或 <code class="docutils literal notranslate"><span class="pre">transfer</span></code>），
但没有定义接收以太的函数或 payable 类型的 fallback 函数，会抛出一个异常，
将以太送回（这在Solidity v0.4.0之前是不同的）。因此，如果您想让您的合约接收以太，
您必须实现一个 receive 函数（不建议使用 payable 类型的 fallback 函数来接收以太，
因为它不会因为接口混乱而失败）。</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>没有接收以太币功能的合约可以作为 <em>coinbase交易*（又称 *矿工区块奖励</em>）的接收者
或作为 <code class="docutils literal notranslate"><span class="pre">selfdestruct</span></code> 的目的地接收以太币。</p>
<p>合约不能对这样的以太币转移做出反应，因此也不能拒绝它们。
这是EVM的一个设计选择，Solidity无法绕过它。</p>
<p>这也意味着 <code class="docutils literal notranslate"><span class="pre">address(this).balance</span></code> 可以高于合约中
实现的一些手工记帐的总和（即在接收以太函数中更新的累加器）。</p>
</div>
<p>下面您可以看到一个使用 <code class="docutils literal notranslate"><span class="pre">receive</span></code> 函数的Sink合约的例子。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.13&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjAgPDAuOS4wOwoKLy8g6L+Z5Liq5ZCI57qm5Lya5L+d55WZ5omA5pyJ5Y+R6YCB57uZ5a6D55qE5Lul5aSq5biB77yM5rKh5pyJ5Yqe5rOV6L+U6L+Y44CCCmNvbnRyYWN0IFNpbmsgewogICAgZXZlbnQgUmVjZWl2ZWQoYWRkcmVzcywgdWludCk7CiAgICByZWNlaXZlKCkgZXh0ZXJuYWwgcGF5YWJsZSB7CiAgICAgICAgZW1pdCBSZWNlaXZlZChtc2cuc2VuZGVyLCBtc2cudmFsdWUpOwogICAgfQp9"><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.6.0</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span><span class="w"></span>

<span class="c1">// 这个合约会保留所有发送给它的以太币，没有办法返还。</span>
<span class="k">contract</span><span class="w"> </span><span class="ni">Sink</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">event</span><span class="w"> </span><span class="nv">Received</span><span class="p">(</span><span class="kt">address</span><span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span>receive<span class="p">()</span><span class="w"> </span><span class="kt">external</span><span class="w"> </span><span class="kt">payable</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span>emit<span class="w"> </span>Received<span class="p">(</span><span class="k">msg.sender</span><span class="p">,</span><span class="w"> </span><span class="k">msg.value</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="fallback">
<span id="fallback-function"></span><span id="index-12"></span><h4>Fallback 函数<a class="headerlink" href="#fallback" title="Permalink to this heading"></a></h4>
<p>一个合约最多可以有一个 <code class="docutils literal notranslate"><span class="pre">fallback</span></code> 函数，使用 <code class="docutils literal notranslate"><span class="pre">fallback</span> <span class="pre">()</span> <span class="pre">external</span> <span class="pre">[payable]</span></code>
或 <code class="docutils literal notranslate"><span class="pre">fallback</span> <span class="pre">(bytes</span> <span class="pre">calldata</span> <span class="pre">_input)</span> <span class="pre">external</span> <span class="pre">[payable]</span> <span class="pre">returns</span> <span class="pre">(bytes</span> <span class="pre">memory</span> <span class="pre">_output)</span></code>
来声明（都没有 <code class="docutils literal notranslate"><span class="pre">function</span></code> 关键字）。
这个函数必须具有 <code class="docutils literal notranslate"><span class="pre">external</span></code> 的函数可见性。
一个fallback函数可以是虚拟的，可以重载，也可以有修饰器。</p>
<p>如果其他函数都不符合给定的函数签名，或者根本没有提供数据，
也没有 <a class="reference internal" href="#receive-ether-function"><span class="std std-ref">接收以太的函数</span></a>，那么fallback函数将在调用合约时执行。
fallback函数总是接收数据，但为了同时接收以太，它必须被标记为 <code class="docutils literal notranslate"><span class="pre">payable</span></code>。</p>
<p>如果使用带参数的版本， <code class="docutils literal notranslate"><span class="pre">_input</span></code>  将包含发送给合约的全部数据（等于 <code class="docutils literal notranslate"><span class="pre">msg.data</span></code>），
并可以在 <code class="docutils literal notranslate"><span class="pre">_output</span></code> 中返回数据。返回的数据将不会被ABI编码。
相反，它将在没有修改的情况下返回（甚至没有填充）。</p>
<p>在最坏的情况下，如果一个可接收以太的fallback函数也被用来代替接收功能，
那么它只有2300气体是可用的
（参见 <a class="reference internal" href="#receive-ether-function"><span class="std std-ref">接收以太函数</span></a> 对这一含义的简要描述）。</p>
<p>像任何函数一样，只要有足够的气体传递给它，fallback函数就可以执行复杂的操作。</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>如果没有 <a class="reference internal" href="#receive-ether-function"><span class="std std-ref">receive 函数</span></a> 的存在，
一个标记为 <code class="docutils literal notranslate"><span class="pre">payable</span></code> 的fallback函数也会在普通的以太传输时执行。
如果您已经定义了一个 payable 类型的 fallback 函数，
我们仍建议您也定义一个 receive 函数接收以太，以区分以太传输和接口混淆的情况。</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>如果您想对输入数据进行解码，您可以检查前四个字节的函数选择器，
然后您可以使用 <code class="docutils literal notranslate"><span class="pre">abi.decode</span></code> 与数组切片语法一起对ABI编码的数据进行解码。
<code class="docutils literal notranslate"><span class="pre">(c,</span> <span class="pre">d)</span> <span class="pre">=</span> <span class="pre">abi.decode(_input[4:],</span> <span class="pre">(uint256,</span> <span class="pre">uint256));</span></code>
注意，这只能作为最后的手段，应该使用适当的函数来代替。</p>
</div>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.13&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjIgPDAuOS4wOwoKY29udHJhY3QgVGVzdCB7CiAgICB1aW50IHg7CiAgICAvLyDmiYDmnInlj5HpgIHliLDmraTlkIjnuqbnmoTmtojmga/pg73kvJrosIPnlKjmraTlh73mlbDvvIjmsqHmnInlhbbku5blh73mlbDvvInjgIIKICAgIC8vIOWQkeivpeWQiOe6puWPkemAgeS7peWkquW4geWwhuW8lei1t+W8guW4uO+8jAogICAgLy8g5Zug5Li6ZmFsbGJhY2vlh73mlbDmsqHmnIkgYHBheWFibGVgIOS/rumlsOWZqOOAggogICAgZmFsbGJhY2soKSBleHRlcm5hbCB7IHggPSAxOyB9Cn0KCmNvbnRyYWN0IFRlc3RQYXlhYmxlIHsKICAgIHVpbnQgeDsKICAgIHVpbnQgeTsKICAgIC8vIOaJgOacieWPkemAgeWIsOatpOWQiOe6pueahOa2iOaBr+mDveS8muiwg+eUqOi/meS4quWHveaVsO+8jAogICAgLy8g6Zmk5LqG5pmu6YCa55qE5Lul5aSq5Lyg6L6T77yI6Zmk5LqGcmVjZWl2ZeWHveaVsO+8jOayoeacieWFtuS7luWHveaVsO+8ieOAggogICAgLy8g5Lu75L2V5a+56K+l5ZCI57qm55qE6Z2e56m655qE6LCD55So6YO95bCG5omn6KGMZmFsbGJhY2vlh73mlbDvvIjljbPkvb/ku6XlpKrkuI7osIPnlKjkuIDotbfooqvlj5HpgIHvvInjgIIKICAgIGZhbGxiYWNrKCkgZXh0ZXJuYWwgcGF5YWJsZSB7IHggPSAxOyB5ID0gbXNnLnZhbHVlOyB9CgogICAgLy8g6L+Z5Liq5Ye95pWw5piv5Li657qv5Lul5aSq5Lyg6L6T6ICM6LCD55So55qE77yMCiAgICAvLyDljbPkuLrmr4/kuIDkuKrluKbmnInnqbpjYWxsZGF0YeeahOiwg+eUqOOAggogICAgcmVjZWl2ZSgpIGV4dGVybmFsIHBheWFibGUgeyB4ID0gMjsgeSA9IG1zZy52YWx1ZTsgfQp9Cgpjb250cmFjdCBDYWxsZXIgewogICAgZnVuY3Rpb24gY2FsbFRlc3QoVGVzdCB0ZXN0KSBwdWJsaWMgcmV0dXJucyAoYm9vbCkgewogICAgICAgIChib29sIHN1Y2Nlc3MsKSA9IGFkZHJlc3ModGVzdCkuY2FsbChhYmkuZW5jb2RlV2l0aFNpZ25hdHVyZSgibm9uRXhpc3RpbmdGdW5jdGlvbigpIikpOwogICAgICAgIHJlcXVpcmUoc3VjY2Vzcyk7CiAgICAgICAgLy8g57uT5p6c5pivIHRlc3QueCDnrYnkuo4gMeOAggoKICAgICAgICAvLyBhZGRyZXNzKHRlc3Qp5bCG5LiN5YWB6K6455u05o6l6LCD55SoIGBgc2VuZGBg77yMCiAgICAgICAgLy8g5Zug5Li6IGBgdGVzdGBgIOayoeacieWPr+aOpeaUtuS7peWkqueahGZhbGxiYWNr5Ye95pWw44CCCiAgICAgICAgLy8g5a6D5b+F6aG76KKr6L2s5o2i5Li6IGBgYWRkcmVzcyBwYXlhYmxlYGAg57G75Z6L77yM5omN5YWB6K646LCD55SoIGBgc2VuZGBg44CCCiAgICAgICAgYWRkcmVzcyBwYXlhYmxlIHRlc3RQYXlhYmxlID0gcGF5YWJsZShhZGRyZXNzKHRlc3QpKTsKCiAgICAgICAgLy8g5aaC5p6c5pyJ5Lq65ZCR6K+l5ZCI57qm5Y+R6YCB5Lul5aSq5biB77yM6L2s6LSm5bCG5aSx6LSl77yM5Y2z6L+Z6YeM6L+U5ZueZmFsc2XjgIIKICAgICAgICByZXR1cm4gdGVzdFBheWFibGUuc2VuZCgyIGV0aGVyKTsKICAgIH0KCiAgICBmdW5jdGlvbiBjYWxsVGVzdFBheWFibGUoVGVzdFBheWFibGUgdGVzdCkgcHVibGljIHJldHVybnMgKGJvb2wpIHsKICAgICAgICAoYm9vbCBzdWNjZXNzLCkgPSBhZGRyZXNzKHRlc3QpLmNhbGwoYWJpLmVuY29kZVdpdGhTaWduYXR1cmUoIm5vbkV4aXN0aW5nRnVuY3Rpb24oKSIpKTsKICAgICAgICByZXF1aXJlKHN1Y2Nlc3MpOwogICAgICAgIC8vIOe7k+aenOaYryB0ZXN0Lngg562J5LqOIDHvvIx0ZXN0Lnkg562J5LqOIDDjgIIKICAgICAgICAoc3VjY2VzcywpID0gYWRkcmVzcyh0ZXN0KS5jYWxse3ZhbHVlOiAxfShhYmkuZW5jb2RlV2l0aFNpZ25hdHVyZSgibm9uRXhpc3RpbmdGdW5jdGlvbigpIikpOwogICAgICAgIHJlcXVpcmUoc3VjY2Vzcyk7CiAgICAgICAgLy8g57uT5p6c5pivIHRlc3QueCDnrYnkuo4gMe+8jHRlc3QueSDnrYnkuo4gMeOAggoKICAgICAgICAvLyDlpoLmnpzmnInkurrlkJHor6XlkIjnuqblj5HpgIHku6XlpKrluIHvvIxUZXN0UGF5YWJsZeeahHJlY2VpdmXlh73mlbDlsIbooqvosIPnlKjjgIIKICAgICAgICAvLyDnlLHkuo7or6Xlh73mlbDkvJrlhpnlhaXlrZjlgqjnqbrpl7TvvIzlroPpnIDopoHnmoTmsJTkvZPmr5TnroDljZXnmoQgYGBzZW5kYGAg5oiWIGBgdHJhbnNmZXJgYCDopoHlpJrjgIIKICAgICAgICAvLyDnlLHkuo7ov5nkuKrljp/lm6DvvIzmiJHku6zlv4XpobvopoHkvb/nlKjkuIDkuKrkvY7nuqfliKvnmoTosIPnlKjjgIIKICAgICAgICAoc3VjY2VzcywpID0gYWRkcmVzcyh0ZXN0KS5jYWxse3ZhbHVlOiAyIGV0aGVyfSgiIik7CiAgICAgICAgcmVxdWlyZShzdWNjZXNzKTsKICAgICAgICAvLyDnu5PmnpzmmK8gdGVzdC54IOetieS6jiAx77yMdGVzdC55IOetieS6jiAyIOS4quS7peWkquOAggoKICAgICAgICByZXR1cm4gdHJ1ZTsKICAgIH0KfQ=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.6.2</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span><span class="w"></span>

<span class="k">contract</span><span class="w"> </span><span class="ni">Test</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">uint</span><span class="w"> </span><span class="nv">x</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="c1">// 所有发送到此合约的消息都会调用此函数（没有其他函数）。</span>
<span class="w">    </span><span class="c1">// 向该合约发送以太币将引起异常，</span>
<span class="w">    </span><span class="c1">// 因为fallback函数没有 `payable` 修饰器。</span>
<span class="w">    </span>fallback<span class="p">()</span><span class="w"> </span><span class="kt">external</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>x<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m m-Decimal">1</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">contract</span><span class="w"> </span><span class="ni">TestPayable</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">uint</span><span class="w"> </span><span class="nv">x</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">uint</span><span class="w"> </span><span class="nv">y</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="c1">// 所有发送到此合约的消息都会调用这个函数，</span>
<span class="w">    </span><span class="c1">// 除了普通的以太传输（除了receive函数，没有其他函数）。</span>
<span class="w">    </span><span class="c1">// 任何对该合约的非空的调用都将执行fallback函数（即使以太与调用一起被发送）。</span>
<span class="w">    </span>fallback<span class="p">()</span><span class="w"> </span><span class="kt">external</span><span class="w"> </span><span class="kt">payable</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>x<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m m-Decimal">1</span><span class="p">;</span><span class="w"> </span>y<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">msg.value</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="c1">// 这个函数是为纯以太传输而调用的，</span>
<span class="w">    </span><span class="c1">// 即为每一个带有空calldata的调用。</span>
<span class="w">    </span>receive<span class="p">()</span><span class="w"> </span><span class="kt">external</span><span class="w"> </span><span class="kt">payable</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>x<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m m-Decimal">2</span><span class="p">;</span><span class="w"> </span>y<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">msg.value</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">contract</span><span class="w"> </span><span class="ni">Caller</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">callTest</span><span class="p">(</span>Test<span class="w"> </span>test<span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">bool</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="p">(</span><span class="kt">bool</span><span class="w"> </span><span class="nv">success</span><span class="p">,)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">address</span><span class="p">(</span>test<span class="p">).</span>call<span class="p">(</span>abi<span class="p">.</span>encodeWithSignature<span class="p">(</span><span class="s2">&quot;nonExistingFunction()&quot;</span><span class="p">));</span><span class="w"></span>
<span class="w">        </span><span class="kt">require</span><span class="p">(</span>success<span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="c1">// 结果是 test.x 等于 1。</span>

<span class="w">        </span><span class="c1">// address(test)将不允许直接调用 ``send``，</span>
<span class="w">        </span><span class="c1">// 因为 ``test`` 没有可接收以太的fallback函数。</span>
<span class="w">        </span><span class="c1">// 它必须被转换为 ``address payable`` 类型，才允许调用 ``send``。</span>
<span class="w">        </span><span class="kt">address</span><span class="w"> </span><span class="nv">payable</span><span class="w"> </span>testPayable<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">payable</span><span class="p">(</span><span class="kt">address</span><span class="p">(</span>test<span class="p">));</span><span class="w"></span>

<span class="w">        </span><span class="c1">// 如果有人向该合约发送以太币，转账将失败，即这里返回false。</span>
<span class="w">        </span><span class="kt">return</span><span class="w"> </span>testPayable<span class="p">.</span>send<span class="p">(</span><span class="m m-Decimal">2</span><span class="w"> </span>ether<span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">callTestPayable</span><span class="p">(</span>TestPayable<span class="w"> </span>test<span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">bool</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="p">(</span><span class="kt">bool</span><span class="w"> </span><span class="nv">success</span><span class="p">,)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">address</span><span class="p">(</span>test<span class="p">).</span>call<span class="p">(</span>abi<span class="p">.</span>encodeWithSignature<span class="p">(</span><span class="s2">&quot;nonExistingFunction()&quot;</span><span class="p">));</span><span class="w"></span>
<span class="w">        </span><span class="kt">require</span><span class="p">(</span>success<span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="c1">// 结果是 test.x 等于 1，test.y 等于 0。</span>
<span class="w">        </span><span class="p">(</span>success<span class="p">,)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">address</span><span class="p">(</span>test<span class="p">).</span>call<span class="p">{</span>value<span class="p">:</span><span class="w"> </span><span class="m m-Decimal">1</span><span class="p">}(</span>abi<span class="p">.</span>encodeWithSignature<span class="p">(</span><span class="s2">&quot;nonExistingFunction()&quot;</span><span class="p">));</span><span class="w"></span>
<span class="w">        </span><span class="kt">require</span><span class="p">(</span>success<span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="c1">// 结果是 test.x 等于 1，test.y 等于 1。</span>

<span class="w">        </span><span class="c1">// 如果有人向该合约发送以太币，TestPayable的receive函数将被调用。</span>
<span class="w">        </span><span class="c1">// 由于该函数会写入存储空间，它需要的气体比简单的 ``send`` 或 ``transfer`` 要多。</span>
<span class="w">        </span><span class="c1">// 由于这个原因，我们必须要使用一个低级别的调用。</span>
<span class="w">        </span><span class="p">(</span>success<span class="p">,)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">address</span><span class="p">(</span>test<span class="p">).</span>call<span class="p">{</span>value<span class="p">:</span><span class="w"> </span><span class="m m-Decimal">2</span><span class="w"> </span>ether<span class="p">}(</span><span class="s2">&quot;&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kt">require</span><span class="p">(</span>success<span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="c1">// 结果是 test.x 等于 1，test.y 等于 2 个以太。</span>

<span class="w">        </span><span class="kt">return</span><span class="w"> </span><span class="kt">true</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
</section>
<section id="overload-function">
<span id="index-13"></span><span id="id15"></span><h3>函数重载<a class="headerlink" href="#overload-function" title="Permalink to this heading"></a></h3>
<p>一个合约可以有多个同名的，但参数类型不同的函数。
这个过程被称为 “重载”，也适用于继承的函数。
下面的例子显示了在合约 <code class="docutils literal notranslate"><span class="pre">A</span></code> 范围内对函数 <code class="docutils literal notranslate"><span class="pre">f</span></code> 的重载。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.13&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCmNvbnRyYWN0IEEgewogICAgZnVuY3Rpb24gZih1aW50IF9pbikgcHVibGljIHB1cmUgcmV0dXJucyAodWludCBvdXQpIHsKICAgICAgICBvdXQgPSBfaW47CiAgICB9CgogICAgZnVuY3Rpb24gZih1aW50IF9pbiwgYm9vbCBfcmVhbGx5KSBwdWJsaWMgcHVyZSByZXR1cm5zICh1aW50IG91dCkgewogICAgICAgIGlmIChfcmVhbGx5KQogICAgICAgICAgICBvdXQgPSBfaW47CiAgICB9Cn0="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.4.16</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span><span class="w"></span>

<span class="k">contract</span><span class="w"> </span><span class="ni">A</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">f</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">_in</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>pure<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">out</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span>out<span class="w"> </span><span class="o">=</span><span class="w"> </span>_in<span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">f</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">_in</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="nv">_really</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>pure<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">out</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">if</span><span class="w"> </span><span class="p">(</span>_really<span class="p">)</span><span class="w"></span>
<span class="w">            </span>out<span class="w"> </span><span class="o">=</span><span class="w"> </span>_in<span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>重载函数也存在于外部接口中。如果两个外部可见函数仅区别于 Solidity 内的类型而不是它们的外部类型则会导致错误。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.13&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCi8vIOi/meauteS7o+eggeS4jeS8mue8luivkQpjb250cmFjdCBBIHsKICAgIGZ1bmN0aW9uIGYoQiBfaW4pIHB1YmxpYyBwdXJlIHJldHVybnMgKEIgb3V0KSB7CiAgICAgICAgb3V0ID0gX2luOwogICAgfQoKICAgIGZ1bmN0aW9uIGYoYWRkcmVzcyBfaW4pIHB1YmxpYyBwdXJlIHJldHVybnMgKGFkZHJlc3Mgb3V0KSB7CiAgICAgICAgb3V0ID0gX2luOwogICAgfQp9Cgpjb250cmFjdCBCIHsKfQ=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.4.16</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span><span class="w"></span>

<span class="c1">// 这段代码不会编译</span>
<span class="k">contract</span><span class="w"> </span><span class="ni">A</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">f</span><span class="p">(</span>B<span class="w"> </span>_in<span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>pure<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span>B<span class="w"> </span>out<span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span>out<span class="w"> </span><span class="o">=</span><span class="w"> </span>_in<span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">f</span><span class="p">(</span><span class="kt">address</span><span class="w"> </span><span class="nv">_in</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>pure<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">address</span><span class="w"> </span><span class="nv">out</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span>out<span class="w"> </span><span class="o">=</span><span class="w"> </span>_in<span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">contract</span><span class="w"> </span><span class="ni">B</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>以上两个 <code class="docutils literal notranslate"><span class="pre">f</span></code> 函数重载最终都接受ABI的地址类型，尽管它们在Solidity中被认为是不同的。</p>
<section id="id16">
<h4>重载解析和参数匹配<a class="headerlink" href="#id16" title="Permalink to this heading"></a></h4>
<p>通过将当前范围内的函数声明与函数调用中提供的参数相匹配，可以选择重载函数。
如果所有参数都可以隐式地转换为预期类型，则选择函数作为重载候选项。
如果一个候选都没有，解析失败。</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>返回参数不作为重载解析的依据。</p>
</div>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.13&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjE2IDwwLjkuMDsKCmNvbnRyYWN0IEEgewogICAgZnVuY3Rpb24gZih1aW50OCBfaW4pIHB1YmxpYyBwdXJlIHJldHVybnMgKHVpbnQ4IG91dCkgewogICAgICAgIG91dCA9IF9pbjsKICAgIH0KCiAgICBmdW5jdGlvbiBmKHVpbnQyNTYgX2luKSBwdWJsaWMgcHVyZSByZXR1cm5zICh1aW50MjU2IG91dCkgewogICAgICAgIG91dCA9IF9pbjsKICAgIH0KfQ=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.4.16</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span><span class="w"></span>

<span class="k">contract</span><span class="w"> </span><span class="ni">A</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">f</span><span class="p">(</span><span class="kt">uint8</span><span class="w"> </span><span class="nv">_in</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>pure<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint8</span><span class="w"> </span><span class="nv">out</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span>out<span class="w"> </span><span class="o">=</span><span class="w"> </span>_in<span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">f</span><span class="p">(</span><span class="kt">uint256</span><span class="w"> </span><span class="nv">_in</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>pure<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint256</span><span class="w"> </span><span class="nv">out</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span>out<span class="w"> </span><span class="o">=</span><span class="w"> </span>_in<span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>调用 <code class="docutils literal notranslate"><span class="pre">f(50)</span></code> 会导致类型错误，因为 <code class="docutils literal notranslate"><span class="pre">50</span></code> 既可以被隐式转换为 <code class="docutils literal notranslate"><span class="pre">uint8</span></code>
也可以被隐式转换为 <code class="docutils literal notranslate"><span class="pre">uint256</span></code>。 另一方面，调用 <code class="docutils literal notranslate"><span class="pre">f(256)</span></code> 则会解析为 <code class="docutils literal notranslate"><span class="pre">f(uint256)</span></code> 重载，
因为 <code class="docutils literal notranslate"><span class="pre">256</span></code> 不能隐式转换为 <code class="docutils literal notranslate"><span class="pre">uint8</span></code>。</p>
</section>
</section>
</section>
<section id="events">
<span id="index-14"></span><span id="id17"></span><h2>事件<a class="headerlink" href="#events" title="Permalink to this heading"></a></h2>
<p>Solidity事件在EVM的日志功能之上给出了一个抽象。
应用程序可以通过Ethereum客户端的RPC接口订阅和监听这些事件。</p>
<p>事件是合约的可继承成员。当您调用它们时，
它们会导致参数被存储在交易的日志中–区块链中的一个特殊数据结构。
这些日志与合约的地址相关联，被纳入区块链，
只要有区块可以访问，就会留在那里（目前是永远，但这可能会随着Serenity升级而改变）。
日志及其事件数据不能从合约内部访问（甚至不能从创建它们的合约访问）。</p>
<p>有可能要求为日志提供Merkle证明，
所以如果外部实体向合约提供这样的证明，它可以检查日志是否真的存在于区块链中。
由于合约中仅能访问最近的 256 个区块哈希，所以还需要提供区块头信息。</p>
<p>您可以最多给三个参数添加 <code class="docutils literal notranslate"><span class="pre">indexed</span></code> 属性，将它们添加到一个特殊的数据结构中，
称为 <a class="reference internal" href="abi-spec.html#abi-events"><span class="std std-ref">“topics”</span></a>，而不是日志的数据部分。
一个topic只能容纳一个字（32字节），所以如果您为一个索引参数使用 <a class="reference internal" href="types.html#reference-types"><span class="std std-ref">引用类型</span></a>，
该值的Keccak-256哈希值将被存储为一个topic中。</p>
<p>所有没有 <code class="docutils literal notranslate"><span class="pre">indexed</span></code> 属性的参数都会被 <a class="reference internal" href="abi-spec.html#abi"><span class="std std-ref">ABI 编码</span></a> 到日志的数据部分。</p>
<p>Topics允许您用来搜索事件，例如为特定的事件来过滤一系列的区块。
您用来也可以通过发出事件的合约的地址来过滤事件。</p>
<p>例如，下面的代码使用web3.js <code class="docutils literal notranslate"><span class="pre">subscribe(&quot;logs&quot;)</span></code>
<a class="reference external" href="https://web3js.readthedocs.io/en/1.0/web3-eth-subscribe.html#subscribe-logs">方法</a>
来过滤与某一地址值相匹配的日志：</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span><span class="w"> </span><span class="nx">options</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nx">fromBlock</span><span class="o">:</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="nx">address</span><span class="o">:</span><span class="w"> </span><span class="nx">web3</span><span class="p">.</span><span class="nx">eth</span><span class="p">.</span><span class="nx">defaultAccount</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="nx">topics</span><span class="o">:</span><span class="w"> </span><span class="p">[</span><span class="s2">&quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;</span><span class="p">,</span><span class="w"> </span><span class="kc">null</span><span class="p">,</span><span class="w"> </span><span class="kc">null</span><span class="p">]</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
<span class="nx">web3</span><span class="p">.</span><span class="nx">eth</span><span class="p">.</span><span class="nx">subscribe</span><span class="p">(</span><span class="s1">&#39;logs&#39;</span><span class="p">,</span><span class="w"> </span><span class="nx">options</span><span class="p">,</span><span class="w"> </span><span class="kd">function</span><span class="w"> </span><span class="p">(</span><span class="nx">error</span><span class="p">,</span><span class="w"> </span><span class="nx">result</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="nx">error</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">result</span><span class="p">);</span><span class="w"></span>
<span class="p">})</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s2">&quot;data&quot;</span><span class="p">,</span><span class="w"> </span><span class="kd">function</span><span class="w"> </span><span class="p">(</span><span class="nx">log</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">log</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">})</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s2">&quot;changed&quot;</span><span class="p">,</span><span class="w"> </span><span class="kd">function</span><span class="w"> </span><span class="p">(</span><span class="nx">log</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="p">});</span><span class="w"></span>
</pre></div>
</div>
<p>除非您用 <code class="docutils literal notranslate"><span class="pre">anonymous</span></code> 指定符声明事件，否则事件的签名的哈希值是topic之一。
这意味着不可能通过名字来过滤特定的匿名事件，
您只能通过合约地址来过滤。匿名事件的优点是，它们的部署和调用都比较便宜。
它还允许您声明四个索引参数，而不是三个。</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>由于交易日志只存储事件数据而不存储类型，因此您必须知道事件的类型，
包括哪个参数被索引以及事件是否是匿名的，以便正确解析数据。
特别的是，有可能用一个匿名事件 “伪造“ 另一个事件的签名。</p>
</div>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.13&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjIxIDwwLjkuMDsKCmNvbnRyYWN0IENsaWVudFJlY2VpcHQgewogICAgZXZlbnQgRGVwb3NpdCgKICAgICAgICBhZGRyZXNzIGluZGV4ZWQgX2Zyb20sCiAgICAgICAgYnl0ZXMzMiBpbmRleGVkIF9pZCwKICAgICAgICB1aW50IF92YWx1ZQogICAgKTsKCiAgICBmdW5jdGlvbiBkZXBvc2l0KGJ5dGVzMzIgX2lkKSBwdWJsaWMgcGF5YWJsZSB7CiAgICAgICAgLy8g5LqL5Lu25piv55SoIGBlbWl0YCDlj5Hlh7rnmoTvvIzlkI7pnaLmmK/kuovku7bnmoTlkI3np7Dlkozmi6zlj7fph4znmoTlj4LmlbDvvIjlpoLmnpzmnInvvInjgIIKICAgICAgICAvLyDku7vkvZXov5nmoLfnmoTosIPnlKjvvIjnlJroh7PmmK/mt7HluqbltYzlpZfvvInpg73lj6/ku6XpgJrov4fov4fmu6QgYERlcG9zaXRgCiAgICAgICAgLy8g5LuOSmF2YVNjcmlwdCBBUEnkuK3mo4DmtYvlh7rmnaXjgIIKICAgICAgICBlbWl0IERlcG9zaXQobXNnLnNlbmRlciwgX2lkLCBtc2cudmFsdWUpOwogICAgfQp9"><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.4.21</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span><span class="w"></span>

<span class="k">contract</span><span class="w"> </span><span class="ni">ClientReceipt</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">event</span><span class="w"> </span><span class="nv">Deposit</span><span class="p">(</span><span class="w"></span>
<span class="w">        </span><span class="kt">address</span><span class="w"> </span><span class="nv">indexed</span><span class="w"> </span>_from<span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="kt">bytes32</span><span class="w"> </span><span class="nv">indexed</span><span class="w"> </span>_id<span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="kt">uint</span><span class="w"> </span><span class="nv">_value</span><span class="w"></span>
<span class="w">    </span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">deposit</span><span class="p">(</span><span class="kt">bytes32</span><span class="w"> </span><span class="nv">_id</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="kt">payable</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// 事件是用 `emit` 发出的，后面是事件的名称和括号里的参数（如果有）。</span>
<span class="w">        </span><span class="c1">// 任何这样的调用（甚至是深度嵌套）都可以通过过滤 `Deposit`</span>
<span class="w">        </span><span class="c1">// 从JavaScript API中检测出来。</span>
<span class="w">        </span>emit<span class="w"> </span>Deposit<span class="p">(</span><span class="k">msg.sender</span><span class="p">,</span><span class="w"> </span>_id<span class="p">,</span><span class="w"> </span><span class="k">msg.value</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>在JavaScript API中的使用方式如下：</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span><span class="w"> </span><span class="nx">abi</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="cm">/* 由编译器产生的abi */</span><span class="p">;</span><span class="w"></span>
<span class="kd">var</span><span class="w"> </span><span class="nx">ClientReceipt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">web3</span><span class="p">.</span><span class="nx">eth</span><span class="p">.</span><span class="nx">contract</span><span class="p">(</span><span class="nx">abi</span><span class="p">);</span><span class="w"></span>
<span class="kd">var</span><span class="w"> </span><span class="nx">clientReceipt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">ClientReceipt</span><span class="p">.</span><span class="nx">at</span><span class="p">(</span><span class="s2">&quot;0x1234...ab67&quot;</span><span class="w"> </span><span class="cm">/* 地址 */</span><span class="p">);</span><span class="w"></span>

<span class="kd">var</span><span class="w"> </span><span class="nx">depositEvent</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">clientReceipt</span><span class="p">.</span><span class="nx">Deposit</span><span class="p">();</span><span class="w"></span>

<span class="c1">// 监视变化</span><span class="w"></span>
<span class="nx">depositEvent</span><span class="p">.</span><span class="nx">watch</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">error</span><span class="p">,</span><span class="w"> </span><span class="nx">result</span><span class="p">){</span><span class="w"></span>
<span class="w">    </span><span class="c1">// 结果包含非索引的参数和给 `Deposit` 调用的 topics。</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="nx">error</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">result</span><span class="p">);</span><span class="w"></span>
<span class="p">});</span><span class="w"></span>


<span class="c1">// 或者通过回调立即开始监视</span><span class="w"></span>
<span class="kd">var</span><span class="w"> </span><span class="nx">depositEvent</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">clientReceipt</span><span class="p">.</span><span class="nx">Deposit</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">error</span><span class="p">,</span><span class="w"> </span><span class="nx">result</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="nx">error</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">result</span><span class="p">);</span><span class="w"></span>
<span class="p">});</span><span class="w"></span>
</pre></div>
</div>
<p>上面的输出看起来像下面这样（经过修剪）:</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="nt">&quot;returnValues&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">       </span><span class="nt">&quot;_from&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;0x1111…FFFFCCCC&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">       </span><span class="nt">&quot;_id&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;0x50…sd5adb20&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">       </span><span class="nt">&quot;_value&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;0x420042&quot;</span><span class="w"></span>
<span class="w">   </span><span class="p">},</span><span class="w"></span>
<span class="w">   </span><span class="nt">&quot;raw&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">       </span><span class="nt">&quot;data&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;0x7f…91385&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">       </span><span class="nt">&quot;topics&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">&quot;0xfd4…b4ead7&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;0x7f…1a91385&quot;</span><span class="p">]</span><span class="w"></span>
<span class="w">   </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<section id="id19">
<h3>了解事件的其他资源<a class="headerlink" href="#id19" title="Permalink to this heading"></a></h3>
<ul class="simple">
<li><p><a class="reference external" href="https://github.com/ethereum/web3.js/blob/1.x/docs/web3-eth-contract.rst#events">Javascript 文档</a></p></li>
<li><p><a class="reference external" href="https://github.com/ethchange/smart-exchange/blob/master/lib/contracts/SmartExchange.sol">事件的使用实例</a></p></li>
<li><p><a class="reference external" href="https://github.com/ethchange/smart-exchange/blob/master/lib/exchange_transactions.js">如何在js中访问它们</a></p></li>
</ul>
</section>
</section>
<section id="errors">
<span id="index-15"></span><span id="id21"></span><h2>错误和恢复语句<a class="headerlink" href="#errors" title="Permalink to this heading"></a></h2>
<p>Solidity 中的错误提供了一种方便且省gas的方式来向用户解释为什么一个操作会失败。
它们可以被定义在合约内部和外部（包括接口合约和库合约）。</p>
<p>它们必须与 <a class="reference internal" href="control-structures.html#revert-statement"><span class="std std-ref">恢复语句</span></a> 一起使用，
它导致当前调用中的所有变化被恢复，并将错误数据传回给调用者。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.13&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguNDsKCi8vLyDovazotKbnmoTkvZnpop3kuI3otrPjgILpnIDopoEgYHJlcXVpcmVkYCDmlbDph4/kvYblj6rmnIkgYGF2YWlsYWJsZWAg5pWw6YeP5Y+v55So44CCCi8vLyBAcGFyYW0g5Y+v55So55qE5L2Z6aKd44CCCi8vLyBAcGFyYW0g6ZyA6KaB6KaB5rGC55qE6L2s5biQ6YeR6aKd44CCCmVycm9yIEluc3VmZmljaWVudEJhbGFuY2UodWludDI1NiBhdmFpbGFibGUsIHVpbnQyNTYgcmVxdWlyZWQpOwoKY29udHJhY3QgVGVzdFRva2VuIHsKICAgIG1hcHBpbmcoYWRkcmVzcyA9PiB1aW50KSBiYWxhbmNlOwogICAgZnVuY3Rpb24gdHJhbnNmZXIoYWRkcmVzcyB0bywgdWludDI1NiBhbW91bnQpIHB1YmxpYyB7CiAgICAgICAgaWYgKGFtb3VudCA+IGJhbGFuY2VbbXNnLnNlbmRlcl0pCiAgICAgICAgICAgIHJldmVydCBJbnN1ZmZpY2llbnRCYWxhbmNlKHsKICAgICAgICAgICAgICAgIGF2YWlsYWJsZTogYmFsYW5jZVttc2cuc2VuZGVyXSwKICAgICAgICAgICAgICAgIHJlcXVpcmVkOiBhbW91bnQKICAgICAgICAgICAgfSk7CiAgICAgICAgYmFsYW5jZVttc2cuc2VuZGVyXSAtPSBhbW91bnQ7CiAgICAgICAgYmFsYW5jZVt0b10gKz0gYW1vdW50OwogICAgfQogICAgLy8gLi4uCn0="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">^</span><span class="k">0.8.4</span><span class="p">;</span><span class="w"></span>

<span class="c1">/// 转账的余额不足。需要 `required` 数量但只有 `available` 数量可用。</span>
<span class="c1">/// @param 可用的余额。</span>
<span class="c1">/// @param 需要要求的转帐金额。</span>
error<span class="w"> </span>InsufficientBalance<span class="p">(</span><span class="kt">uint256</span><span class="w"> </span><span class="nv">available</span><span class="p">,</span><span class="w"> </span><span class="kt">uint256</span><span class="w"> </span><span class="nv">required</span><span class="p">);</span><span class="w"></span>

<span class="k">contract</span><span class="w"> </span><span class="ni">TestToken</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">mapping</span><span class="p">(</span><span class="kt">address</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="kt">uint</span><span class="p">)</span><span class="w"> </span>balance<span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">transfer</span><span class="p">(</span><span class="kt">address</span><span class="w"> </span><span class="nv">to</span><span class="p">,</span><span class="w"> </span><span class="kt">uint256</span><span class="w"> </span><span class="nv">amount</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">if</span><span class="w"> </span><span class="p">(</span>amount<span class="w"> </span><span class="o">&gt;</span><span class="w"> </span>balance<span class="p">[</span><span class="k">msg.sender</span><span class="p">])</span><span class="w"></span>
<span class="w">            </span>revert<span class="w"> </span>InsufficientBalance<span class="p">({</span><span class="w"></span>
<span class="w">                </span>available<span class="p">:</span><span class="w"> </span>balance<span class="p">[</span><span class="k">msg.sender</span><span class="p">],</span><span class="w"></span>
<span class="w">                </span>required<span class="p">:</span><span class="w"> </span>amount<span class="w"></span>
<span class="w">            </span><span class="p">});</span><span class="w"></span>
<span class="w">        </span>balance<span class="p">[</span><span class="k">msg.sender</span><span class="p">]</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span>amount<span class="p">;</span><span class="w"></span>
<span class="w">        </span>balance<span class="p">[</span>to<span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span>amount<span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="c1">// ...</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>错误不能被重载或覆盖，但是可以被继承。
只要作用域不同，同一个错误可以在多个地方定义。
错误的实例只能使用 <code class="docutils literal notranslate"><span class="pre">revert</span></code> 语句创建。</p>
<p>错误会创建数据，然后通过还原操作传递给调用者，
使其返回到链下组件或在 <a class="reference internal" href="control-structures.html#try-catch"><span class="std std-ref">try/catch 语句</span></a> 中捕获它。
需要注意的是，一个错误只能在来自外部调用时被捕获，
发生在内部调用或同一函数内的还原不能被捕获。</p>
<p>如果您不提供任何参数，错误只需要四个字节的数据，
您可以像上面一样使用 <a class="reference internal" href="natspec-format.html#natspec"><span class="std std-ref">NatSpec 语法</span></a> 来进一步解释错误背后的原因，
这并不存储在链上。这使得这同时也是一个非常便宜和方便的错误报告功能。</p>
<p>更具体地说，一个错误实例在被ABI编码时，
其方式与对相同名称和类型的函数的调用相同，
然后作为 <code class="docutils literal notranslate"><span class="pre">revert</span></code> 操作码的返回数据。
这意味着数据由一个4字节的选择器和 <a class="reference internal" href="abi-spec.html#abi"><span class="std std-ref">ABI编码</span></a> 数据组成。
选择器由错误类型的签名的keccak256-hash的前四个字节组成。</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>一个合约有可能因为同名的不同错误而恢复，
甚至因为在不同地方定义的错误而使调用者无法区分。
对于外部来说，即ABI，只有错误的名称是相关的，而不是定义它的合约或文件。</p>
</div>
<p>如果您能定义 <code class="docutils literal notranslate"><span class="pre">error</span> <span class="pre">Error(string)</span></code>，
那么语句 <code class="docutils literal notranslate"><span class="pre">require(condition,</span> <span class="pre">&quot;description&quot;);</span></code>
将等同于 <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">(!condition)</span> <span class="pre">revert</span> <span class="pre">Error(&quot;description&quot;)</span></code>。
但是请注意， <code class="docutils literal notranslate"><span class="pre">Error</span></code> 是一个内置类型，不能在用户提供的代码中定义。</p>
<p>同样，一个失败的 <code class="docutils literal notranslate"><span class="pre">assert</span></code> 或类似的条件将以一个内置的 <code class="docutils literal notranslate"><span class="pre">Panic(uint256)</span></code> 类型的错误来恢复。</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>错误数据应该只被用来指示失败，而不是作为控制流的手段。
原因是内部调用的恢复数据默认是通过外部调用链传播回来的。
这意味着内部调用可以 ”伪造” 恢复数据，使它看起来像是来自调用它的合约。</p>
</div>
</section>
<section id="index-16">
<span id="id22"></span><h2>继承<a class="headerlink" href="#index-16" title="Permalink to this heading"></a></h2>
<p>Solidity支持多重继承，包括多态性。</p>
<p>多态性意味着函数调用（内部和外部）总是执行继承层次结构中最新继承的合约中的同名函数（和参数类型）。
但必须使用 <code class="docutils literal notranslate"><span class="pre">virtual</span></code> 和 <code class="docutils literal notranslate"><span class="pre">override</span></code> 关键字在层次结构中的每个函数上明确启用。
参见 <a class="reference internal" href="#function-overriding"><span class="std std-ref">函数重载</span></a> 以了解更多细节。</p>
<p>通过使用 <code class="docutils literal notranslate"><span class="pre">ContractName.functionName()</span></code> 明确指定合约，
可以在内部调用继承层次结构中更高的函数。
或者如果您想在扁平化的继承层次中调用高一级的函数（见下文），
可以使用 <code class="docutils literal notranslate"><span class="pre">super.functionName()</span></code>。</p>
<p>当一个合约继承自其他合约时，在区块链上只创建一个单一的合约，
所有基础合约的代码被编译到创建的合约中。
这意味着对基础合约的所有内部函数的调用也只是使用内部函数调用
（ <code class="docutils literal notranslate"><span class="pre">super.f(..)</span></code> 将使用 JUMP 而不是消息调用）。</p>
<p>状态变量的阴影被认为是一个错误。
一个派生合约只能声明一个状态变量 <code class="docutils literal notranslate"><span class="pre">x</span></code>，
如果在它的任何基类中没有相同名称的可见状态变量。</p>
<p>总的来说，Solidity 的继承系统与 <a class="reference external" href="https://docs.python.org/3/tutorial/classes.html#inheritance">Python的继承系统</a>
非常相似，特别是关于多重继承方面，但也有一些 <a class="reference internal" href="#multi-inheritance"><span class="std std-ref">不同之处</span></a>。</p>
<p>详细情况见下面的例子。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.13&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjAgPDAuOS4wOwoKCmNvbnRyYWN0IE93bmVkIHsKICAgIGNvbnN0cnVjdG9yKCkgeyBvd25lciA9IHBheWFibGUobXNnLnNlbmRlcik7IH0KICAgIGFkZHJlc3MgcGF5YWJsZSBvd25lcjsKfQoKCi8vIOS9v+eUqCBgaXNgIOS7juWPpuS4gOS4quWQiOe6pua0vueUn+OAgua0vueUn+WQiOe6puWPr+S7peiuv+mXruaJgOaciemdnuengeacieaIkOWRmO+8jAovLyDljIXmi6zlhoXpg6jlh73mlbDlkoznirbmgIHlj5jph4/vvIzkvYbml6Dms5XpgJrov4cgYHRoaXNgIOadpeWklumDqOiuv+mXruOAggpjb250cmFjdCBEZXN0cnVjdGlibGUgaXMgT3duZWQgewogICAgLy8g5YWz6ZSu5a2XIGB2aXJ0dWFsYCDmhI/lkbPnnYDor6Xlh73mlbDlj6/ku6XlnKjmtL7nlJ/nsbvkuK3mlLnlj5jlhbbooYzkuLrvvIgi6YeN6L29Iu+8ieOAggogICAgZnVuY3Rpb24gZGVzdHJveSgpIHZpcnR1YWwgcHVibGljIHsKICAgICAgICBpZiAobXNnLnNlbmRlciA9PSBvd25lcikgc2VsZmRlc3RydWN0KG93bmVyKTsKICAgIH0KfQoKCi8vIOi/meS6m+aKveixoeWQiOe6puS7heeUqOS6jue7mee8luivkeWZqOaPkOS+m+aOpeWPo+OAggovLyDms6jmhI/lh73mlbDmsqHmnInlh73mlbDkvZPjgIIKLy8g5aaC5p6c5LiA5Liq5ZCI57qm5rKh5pyJ5a6e546w5omA5pyJ5Ye95pWw77yM5YiZ5Y+q6IO955So5L2c5o6l5Y+j44CCCmFic3RyYWN0IGNvbnRyYWN0IENvbmZpZyB7CiAgICBmdW5jdGlvbiBsb29rdXAodWludCBpZCkgcHVibGljIHZpcnR1YWwgcmV0dXJucyAoYWRkcmVzcyBhZHIpOwp9CgoKYWJzdHJhY3QgY29udHJhY3QgTmFtZVJlZyB7CiAgICBmdW5jdGlvbiByZWdpc3RlcihieXRlczMyIG5hbWUpIHB1YmxpYyB2aXJ0dWFsOwogICAgZnVuY3Rpb24gdW5yZWdpc3RlcigpIHB1YmxpYyB2aXJ0dWFsOwp9CgoKLy8g5Y+v5Lul5aSa6YeN57un5om/44CC6K+35rOo5oSP77yMIGBvd25lZGAg5Lmf5pivIGBEZXN0cnVjdGlibGVgIOeahOWfuuexu++8jAovLyDkvYblj6rmnInkuIDkuKogYG93bmVkYCDlrp7kvovvvIjlsLHlg48gQysrIOS4reeahOiZmuaLn+e7p+aJv++8ieOAggpjb250cmFjdCBOYW1lZCBpcyBPd25lZCwgRGVzdHJ1Y3RpYmxlIHsKICAgIGNvbnN0cnVjdG9yKGJ5dGVzMzIgbmFtZSkgewogICAgICAgIENvbmZpZyBjb25maWcgPSBDb25maWcoMHhENWY5RDhEOTQ4ODZFNzBiMDZFNDc0YzNmQjE0RmQ0M0UyZjIzOTcwKTsKICAgICAgICBOYW1lUmVnKGNvbmZpZy5sb29rdXAoMSkpLnJlZ2lzdGVyKG5hbWUpOwogICAgfQoKICAgIC8vIOWHveaVsOWPr+S7peiiq+WPpuS4gOS4quWFt+acieebuOWQjOWQjeensOWSjOebuOWQjOaVsOmHjy/nsbvlnovovpPlhaXnmoTlh73mlbDph43ovb3jgIIKICAgIC8vIOWmguaenOmHjei9veWHveaVsOacieS4jeWQjOexu+Wei+eahOi+k+WHuuWPguaVsO+8jOS8muWvvOiHtOmUmeivr+OAggogICAgLy8g5pys5Zyw5ZKM5Z+65LqO5raI5oGv55qE5Ye95pWw6LCD55So6YO95Lya6ICD6JmR6L+Z5Lqb6YeN6L2944CCCiAgICAvLyDlpoLmnpzmgqjmg7Pph43ovb3ov5nkuKrlh73mlbDvvIzmgqjpnIDopoHkvb/nlKggYG92ZXJyaWRlYCDlhbPplK7lrZfjgIIKICAgIC8vIOWmguaenOaCqOaDs+iuqei/meS4quWHveaVsOWGjeasoeiiq+mHjei9ve+8jOaCqOmcgOimgeWGjeaMh+WumiBgdmlydHVhbGAg5YWz6ZSu5a2X44CCCiAgICBmdW5jdGlvbiBkZXN0cm95KCkgcHVibGljIHZpcnR1YWwgb3ZlcnJpZGUgewogICAgICAgIGlmIChtc2cuc2VuZGVyID09IG93bmVyKSB7CiAgICAgICAgICAgIENvbmZpZyBjb25maWcgPSBDb25maWcoMHhENWY5RDhEOTQ4ODZFNzBiMDZFNDc0YzNmQjE0RmQ0M0UyZjIzOTcwKTsKICAgICAgICAgICAgTmFtZVJlZyhjb25maWcubG9va3VwKDEpKS51bnJlZ2lzdGVyKCk7CiAgICAgICAgICAgIC8vIOS7jeeEtuWPr+S7peiwg+eUqOeJueWumueahOmHjei9veWHveaVsOOAggogICAgICAgICAgICBEZXN0cnVjdGlibGUuZGVzdHJveSgpOwogICAgICAgIH0KICAgIH0KfQoKCi8vIOWmguaenOaehOmAoOWHveaVsOaOpeWPl+WPguaVsO+8jAovLyDliJnpnIDopoHlnKjlo7DmmI7vvIjlkIjnuqbnmoTmnoTpgKDlh73mlbDvvInml7bmj5DkvpvvvIwKLy8g5oiW5Zyo5rS+55Sf5ZCI57qm55qE5p6E6YCg5Ye95pWw5L2N572u5Lul5L+u6aWw5Zmo6LCD55So6aOO5qC85o+Q5L6b77yI6KeB5LiL5paH77yJ44CCCmNvbnRyYWN0IFByaWNlRmVlZCBpcyBPd25lZCwgRGVzdHJ1Y3RpYmxlLCBOYW1lZCgiR29sZEZlZWQiKSB7CiAgICBmdW5jdGlvbiB1cGRhdGVJbmZvKHVpbnQgbmV3SW5mbykgcHVibGljIHsKICAgICAgICBpZiAobXNnLnNlbmRlciA9PSBvd25lcikgaW5mbyA9IG5ld0luZm87CiAgICB9CgogICAgLy8g5Zyo6L+Z6YeM77yM5oiR5Lus5Y+q5oyH5a6a5LqGIGBvdmVycmlkZWAg6ICM5rKh5pyJIGB2aXJ0dWFsYOOAggogICAgLy8g6L+Z5oSP5ZGz552A5LuOIGBQcmljZUZlZWRgIOa0vueUn+WHuuadpeeahOWQiOe6puS4jeiDveWGjeaUueWPmCBgZGVzdHJveWAg55qE6KGM5Li644CCCiAgICBmdW5jdGlvbiBkZXN0cm95KCkgcHVibGljIG92ZXJyaWRlKERlc3RydWN0aWJsZSwgTmFtZWQpIHsgTmFtZWQuZGVzdHJveSgpOyB9CiAgICBmdW5jdGlvbiBnZXQoKSBwdWJsaWMgdmlldyByZXR1cm5zKHVpbnQgcikgeyByZXR1cm4gaW5mbzsgfQoKICAgIHVpbnQgaW5mbzsKfQ=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.7.0</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span><span class="w"></span>


<span class="k">contract</span><span class="w"> </span><span class="ni">Owned</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">constructor</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>owner<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">payable</span><span class="p">(</span><span class="k">msg.sender</span><span class="p">);</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="kt">address</span><span class="w"> </span><span class="nv">payable</span><span class="w"> </span>owner<span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>


<span class="c1">// 使用 `is` 从另一个合约派生。派生合约可以访问所有非私有成员，</span>
<span class="c1">// 包括内部函数和状态变量，但无法通过 `this` 来外部访问。</span>
<span class="k">contract</span><span class="w"> </span><span class="ni">Destructible</span><span class="w"> </span><span class="kt">is</span><span class="w"> </span>Owned<span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// 关键字 `virtual` 意味着该函数可以在派生类中改变其行为（&quot;重载&quot;）。</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">destroy</span><span class="p">()</span><span class="w"> </span>virtual<span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">if</span><span class="w"> </span><span class="p">(</span><span class="k">msg.sender</span><span class="w"> </span><span class="o">==</span><span class="w"> </span>owner<span class="p">)</span><span class="w"> </span>selfdestruct<span class="p">(</span>owner<span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>


<span class="c1">// 这些抽象合约仅用于给编译器提供接口。</span>
<span class="c1">// 注意函数没有函数体。</span>
<span class="c1">// 如果一个合约没有实现所有函数，则只能用作接口。</span>
abstract<span class="w"> </span><span class="k">contract</span><span class="w"> </span><span class="ni">Config</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">lookup</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">id</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>virtual<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">address</span><span class="w"> </span><span class="nv">adr</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>


abstract<span class="w"> </span><span class="k">contract</span><span class="w"> </span><span class="ni">NameReg</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">register</span><span class="p">(</span><span class="kt">bytes32</span><span class="w"> </span><span class="nv">name</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>virtual<span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">unregister</span><span class="p">()</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>virtual<span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>


<span class="c1">// 可以多重继承。请注意， `owned` 也是 `Destructible` 的基类，</span>
<span class="c1">// 但只有一个 `owned` 实例（就像 C++ 中的虚拟继承）。</span>
<span class="k">contract</span><span class="w"> </span><span class="ni">Named</span><span class="w"> </span><span class="kt">is</span><span class="w"> </span>Owned<span class="p">,</span><span class="w"> </span>Destructible<span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">constructor</span><span class="p">(</span><span class="kt">bytes32</span><span class="w"> </span><span class="nv">name</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span>Config<span class="w"> </span>config<span class="w"> </span><span class="o">=</span><span class="w"> </span>Config<span class="p">(</span><span class="mh">0xD5f9D8D94886E70b06E474c3fB14Fd43E2f23970</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span>NameReg<span class="p">(</span>config<span class="p">.</span>lookup<span class="p">(</span><span class="m m-Decimal">1</span><span class="p">)).</span>register<span class="p">(</span>name<span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="c1">// 函数可以被另一个具有相同名称和相同数量/类型输入的函数重载。</span>
<span class="w">    </span><span class="c1">// 如果重载函数有不同类型的输出参数，会导致错误。</span>
<span class="w">    </span><span class="c1">// 本地和基于消息的函数调用都会考虑这些重载。</span>
<span class="w">    </span><span class="c1">// 如果您想重载这个函数，您需要使用 `override` 关键字。</span>
<span class="w">    </span><span class="c1">// 如果您想让这个函数再次被重载，您需要再指定 `virtual` 关键字。</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">destroy</span><span class="p">()</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>virtual<span class="w"> </span>override<span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">if</span><span class="w"> </span><span class="p">(</span><span class="k">msg.sender</span><span class="w"> </span><span class="o">==</span><span class="w"> </span>owner<span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span>Config<span class="w"> </span>config<span class="w"> </span><span class="o">=</span><span class="w"> </span>Config<span class="p">(</span><span class="mh">0xD5f9D8D94886E70b06E474c3fB14Fd43E2f23970</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span>NameReg<span class="p">(</span>config<span class="p">.</span>lookup<span class="p">(</span><span class="m m-Decimal">1</span><span class="p">)).</span>unregister<span class="p">();</span><span class="w"></span>
<span class="w">            </span><span class="c1">// 仍然可以调用特定的重载函数。</span>
<span class="w">            </span>Destructible<span class="p">.</span>destroy<span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>


<span class="c1">// 如果构造函数接受参数，</span>
<span class="c1">// 则需要在声明（合约的构造函数）时提供，</span>
<span class="c1">// 或在派生合约的构造函数位置以修饰器调用风格提供（见下文）。</span>
<span class="k">contract</span><span class="w"> </span><span class="ni">PriceFeed</span><span class="w"> </span><span class="kt">is</span><span class="w"> </span>Owned<span class="p">,</span><span class="w"> </span>Destructible<span class="p">,</span><span class="w"> </span>Named<span class="p">(</span><span class="s2">&quot;GoldFeed&quot;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">updateInfo</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">newInfo</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">if</span><span class="w"> </span><span class="p">(</span><span class="k">msg.sender</span><span class="w"> </span><span class="o">==</span><span class="w"> </span>owner<span class="p">)</span><span class="w"> </span>info<span class="w"> </span><span class="o">=</span><span class="w"> </span>newInfo<span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="c1">// 在这里，我们只指定了 `override` 而没有 `virtual`。</span>
<span class="w">    </span><span class="c1">// 这意味着从 `PriceFeed` 派生出来的合约不能再改变 `destroy` 的行为。</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">destroy</span><span class="p">()</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>override<span class="p">(</span>Destructible<span class="p">,</span><span class="w"> </span>Named<span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>Named<span class="p">.</span>destroy<span class="p">();</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">get</span><span class="p">()</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>view<span class="w"> </span><span class="kt">returns</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">r</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="kt">return</span><span class="w"> </span>info<span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kt">uint</span><span class="w"> </span><span class="nv">info</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>注意，在上面，我们调用 <code class="docutils literal notranslate"><span class="pre">Destructible.destroy()</span></code> 来 “转发” 销毁请求。
这样做的方式是有问题的，从下面的例子中可以看出：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.13&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjAgPDAuOS4wOwoKY29udHJhY3Qgb3duZWQgewogICAgY29uc3RydWN0b3IoKSB7IG93bmVyID0gcGF5YWJsZShtc2cuc2VuZGVyKTsgfQogICAgYWRkcmVzcyBwYXlhYmxlIG93bmVyOwp9Cgpjb250cmFjdCBEZXN0cnVjdGlibGUgaXMgb3duZWQgewogICAgZnVuY3Rpb24gZGVzdHJveSgpIHB1YmxpYyB2aXJ0dWFsIHsKICAgICAgICBpZiAobXNnLnNlbmRlciA9PSBvd25lcikgc2VsZmRlc3RydWN0KG93bmVyKTsKICAgIH0KfQoKY29udHJhY3QgQmFzZTEgaXMgRGVzdHJ1Y3RpYmxlIHsKICAgIGZ1bmN0aW9uIGRlc3Ryb3koKSBwdWJsaWMgdmlydHVhbCBvdmVycmlkZSB7IC8qIOa4hemZpOaTjeS9nCAxICovIERlc3RydWN0aWJsZS5kZXN0cm95KCk7IH0KfQoKY29udHJhY3QgQmFzZTIgaXMgRGVzdHJ1Y3RpYmxlIHsKICAgIGZ1bmN0aW9uIGRlc3Ryb3koKSBwdWJsaWMgdmlydHVhbCBvdmVycmlkZSB7IC8qIOa4hemZpOaTjeS9nCAyICovIERlc3RydWN0aWJsZS5kZXN0cm95KCk7IH0KfQoKY29udHJhY3QgRmluYWwgaXMgQmFzZTEsIEJhc2UyIHsKICAgIGZ1bmN0aW9uIGRlc3Ryb3koKSBwdWJsaWMgb3ZlcnJpZGUoQmFzZTEsIEJhc2UyKSB7IEJhc2UyLmRlc3Ryb3koKTsgfQp9"><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.7.0</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span><span class="w"></span>

<span class="k">contract</span><span class="w"> </span><span class="ni">owned</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">constructor</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>owner<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">payable</span><span class="p">(</span><span class="k">msg.sender</span><span class="p">);</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="kt">address</span><span class="w"> </span><span class="nv">payable</span><span class="w"> </span>owner<span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">contract</span><span class="w"> </span><span class="ni">Destructible</span><span class="w"> </span><span class="kt">is</span><span class="w"> </span>owned<span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">destroy</span><span class="p">()</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>virtual<span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">if</span><span class="w"> </span><span class="p">(</span><span class="k">msg.sender</span><span class="w"> </span><span class="o">==</span><span class="w"> </span>owner<span class="p">)</span><span class="w"> </span>selfdestruct<span class="p">(</span>owner<span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">contract</span><span class="w"> </span><span class="ni">Base1</span><span class="w"> </span><span class="kt">is</span><span class="w"> </span>Destructible<span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">destroy</span><span class="p">()</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>virtual<span class="w"> </span>override<span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="cm">/* 清除操作 1 */</span><span class="w"> </span>Destructible<span class="p">.</span>destroy<span class="p">();</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">contract</span><span class="w"> </span><span class="ni">Base2</span><span class="w"> </span><span class="kt">is</span><span class="w"> </span>Destructible<span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">destroy</span><span class="p">()</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>virtual<span class="w"> </span>override<span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="cm">/* 清除操作 2 */</span><span class="w"> </span>Destructible<span class="p">.</span>destroy<span class="p">();</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">contract</span><span class="w"> </span><span class="ni">Final</span><span class="w"> </span><span class="kt">is</span><span class="w"> </span>Base1<span class="p">,</span><span class="w"> </span>Base2<span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">destroy</span><span class="p">()</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>override<span class="p">(</span>Base1<span class="p">,</span><span class="w"> </span>Base2<span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>Base2<span class="p">.</span>destroy<span class="p">();</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>调用 <code class="docutils literal notranslate"><span class="pre">Final.destroy()</span></code> 时会调用最后的派生重载函数 <code class="docutils literal notranslate"><span class="pre">Base2.destroy</span></code>，
但是会绕过 <code class="docutils literal notranslate"><span class="pre">Base1.destroy</span></code>， 解决这个问题的方法是使用 <code class="docutils literal notranslate"><span class="pre">super</span></code>：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.13&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjAgPDAuOS4wOwoKY29udHJhY3Qgb3duZWQgewogICAgY29uc3RydWN0b3IoKSB7IG93bmVyID0gcGF5YWJsZShtc2cuc2VuZGVyKTsgfQogICAgYWRkcmVzcyBwYXlhYmxlIG93bmVyOwp9Cgpjb250cmFjdCBEZXN0cnVjdGlibGUgaXMgb3duZWQgewogICAgZnVuY3Rpb24gZGVzdHJveSgpIHZpcnR1YWwgcHVibGljIHsKICAgICAgICBpZiAobXNnLnNlbmRlciA9PSBvd25lcikgc2VsZmRlc3RydWN0KG93bmVyKTsKICAgIH0KfQoKY29udHJhY3QgQmFzZTEgaXMgRGVzdHJ1Y3RpYmxlIHsKICAgIGZ1bmN0aW9uIGRlc3Ryb3koKSBwdWJsaWMgdmlydHVhbCBvdmVycmlkZSB7IC8qIOa4hemZpOaTjeS9nCAxICovIHN1cGVyLmRlc3Ryb3koKTsgfQp9CgoKY29udHJhY3QgQmFzZTIgaXMgRGVzdHJ1Y3RpYmxlIHsKICAgIGZ1bmN0aW9uIGRlc3Ryb3koKSBwdWJsaWMgdmlydHVhbCBvdmVycmlkZSB7IC8qIOa4hemZpOaTjeS9nCAyICovIHN1cGVyLmRlc3Ryb3koKTsgfQp9Cgpjb250cmFjdCBGaW5hbCBpcyBCYXNlMSwgQmFzZTIgewogICAgZnVuY3Rpb24gZGVzdHJveSgpIHB1YmxpYyBvdmVycmlkZShCYXNlMSwgQmFzZTIpIHsgc3VwZXIuZGVzdHJveSgpOyB9Cn0="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.7.0</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span><span class="w"></span>

<span class="k">contract</span><span class="w"> </span><span class="ni">owned</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">constructor</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>owner<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">payable</span><span class="p">(</span><span class="k">msg.sender</span><span class="p">);</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="kt">address</span><span class="w"> </span><span class="nv">payable</span><span class="w"> </span>owner<span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">contract</span><span class="w"> </span><span class="ni">Destructible</span><span class="w"> </span><span class="kt">is</span><span class="w"> </span>owned<span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">destroy</span><span class="p">()</span><span class="w"> </span>virtual<span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">if</span><span class="w"> </span><span class="p">(</span><span class="k">msg.sender</span><span class="w"> </span><span class="o">==</span><span class="w"> </span>owner<span class="p">)</span><span class="w"> </span>selfdestruct<span class="p">(</span>owner<span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">contract</span><span class="w"> </span><span class="ni">Base1</span><span class="w"> </span><span class="kt">is</span><span class="w"> </span>Destructible<span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">destroy</span><span class="p">()</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>virtual<span class="w"> </span>override<span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="cm">/* 清除操作 1 */</span><span class="w"> </span>super<span class="p">.</span>destroy<span class="p">();</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>


<span class="k">contract</span><span class="w"> </span><span class="ni">Base2</span><span class="w"> </span><span class="kt">is</span><span class="w"> </span>Destructible<span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">destroy</span><span class="p">()</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>virtual<span class="w"> </span>override<span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="cm">/* 清除操作 2 */</span><span class="w"> </span>super<span class="p">.</span>destroy<span class="p">();</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">contract</span><span class="w"> </span><span class="ni">Final</span><span class="w"> </span><span class="kt">is</span><span class="w"> </span>Base1<span class="p">,</span><span class="w"> </span>Base2<span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">destroy</span><span class="p">()</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>override<span class="p">(</span>Base1<span class="p">,</span><span class="w"> </span>Base2<span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>super<span class="p">.</span>destroy<span class="p">();</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>如果 <code class="docutils literal notranslate"><span class="pre">Base2</span></code> 调用 <code class="docutils literal notranslate"><span class="pre">super</span></code> 的函数，它不会简单在其基类合约上调用该函数。
相反，它在最终的继承关系图谱的上一个基类合约中调用这个函数，
所以它会调用 <code class="docutils literal notranslate"><span class="pre">Base1.destroy()</span></code>
（注意最终的继承序列是——从最远派生合约开始：Final, Base2, Base1, Destructible, ownerd）。
在类中使用 super 调用的实际函数在当前类的上下文中是未知的，尽管它的类型是已知的。
这与普通的虚拟方法查找类似。</p>
<section id="function-overriding">
<span id="index-17"></span><span id="id23"></span><h3>函数重载<a class="headerlink" href="#function-overriding" title="Permalink to this heading"></a></h3>
<p>如果基函数被标记为 <code class="docutils literal notranslate"><span class="pre">virtual</span></code>，则可以通过继承合约来改变其行为。
被重载的函数必须在函数头中使用 <code class="docutils literal notranslate"><span class="pre">override</span></code> 关键字。
重载函数只能将被重载函数的可见性从 <code class="docutils literal notranslate"><span class="pre">external</span></code> 改为 <code class="docutils literal notranslate"><span class="pre">public</span></code>。
可变性可以按照以下顺序改变为更严格的可变性。
<code class="docutils literal notranslate"><span class="pre">nonpayable</span></code> 可以被 <code class="docutils literal notranslate"><span class="pre">view</span></code> 和 <code class="docutils literal notranslate"><span class="pre">pure</span></code> 重载。
<code class="docutils literal notranslate"><span class="pre">view</span></code> 可以被 <code class="docutils literal notranslate"><span class="pre">pure</span></code> 重写。 <code class="docutils literal notranslate"><span class="pre">payable</span></code> 是一个例外，不能被改变为任何其他可变性。</p>
<p>下面的例子演示了改变函数可变性和可见性：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.13&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjAgPDAuOS4wOwoKY29udHJhY3QgQmFzZQp7CiAgICBmdW5jdGlvbiBmb28oKSB2aXJ0dWFsIGV4dGVybmFsIHZpZXcge30KfQoKY29udHJhY3QgTWlkZGxlIGlzIEJhc2Uge30KCmNvbnRyYWN0IEluaGVyaXRlZCBpcyBNaWRkbGUKewogICAgZnVuY3Rpb24gZm9vKCkgb3ZlcnJpZGUgcHVibGljIHB1cmUge30KfQ=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.7.0</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span><span class="w"></span>

<span class="k">contract</span><span class="w"> </span><span class="ni">Base</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">foo</span><span class="p">()</span><span class="w"> </span>virtual<span class="w"> </span><span class="kt">external</span><span class="w"> </span>view<span class="w"> </span><span class="p">{}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">contract</span><span class="w"> </span><span class="ni">Middle</span><span class="w"> </span><span class="kt">is</span><span class="w"> </span>Base<span class="w"> </span><span class="p">{}</span><span class="w"></span>

<span class="k">contract</span><span class="w"> </span><span class="ni">Inherited</span><span class="w"> </span><span class="kt">is</span><span class="w"> </span>Middle<span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">foo</span><span class="p">()</span><span class="w"> </span>override<span class="w"> </span><span class="kt">public</span><span class="w"> </span>pure<span class="w"> </span><span class="p">{}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>对于多重继承，必须在 <code class="docutils literal notranslate"><span class="pre">override</span></code> 关键字后明确指定定义同一函数的最多派生基类合约。
换句话说，您必须指定所有定义同一函数的基类合约，
并且还没有被另一个基类合约重载（在继承图的某个路径上）。
此外，如果一个合约从多个（不相关的）基类合约上继承了同一个函数，必须明确地重载它。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.13&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjAgPDAuOS4wOwoKY29udHJhY3QgQmFzZTEKewogICAgZnVuY3Rpb24gZm9vKCkgdmlydHVhbCBwdWJsaWMge30KfQoKY29udHJhY3QgQmFzZTIKewogICAgZnVuY3Rpb24gZm9vKCkgdmlydHVhbCBwdWJsaWMge30KfQoKY29udHJhY3QgSW5oZXJpdGVkIGlzIEJhc2UxLCBCYXNlMgp7CiAgICAvLyDmtL7nlJ/oh6rlpJrkuKrlrprkuYkgZm9vKCkg5Ye95pWw55qE5Z+657G75ZCI57qm77yMCiAgICAvLyDmiYDku6XmiJHku6zlv4XpobvmmI7noa7lnLDph43ovb3lroMKICAgIGZ1bmN0aW9uIGZvbygpIHB1YmxpYyBvdmVycmlkZShCYXNlMSwgQmFzZTIpIHt9Cn0="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.6.0</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span><span class="w"></span>

<span class="k">contract</span><span class="w"> </span><span class="ni">Base1</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">foo</span><span class="p">()</span><span class="w"> </span>virtual<span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">contract</span><span class="w"> </span><span class="ni">Base2</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">foo</span><span class="p">()</span><span class="w"> </span>virtual<span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">contract</span><span class="w"> </span><span class="ni">Inherited</span><span class="w"> </span><span class="kt">is</span><span class="w"> </span>Base1<span class="p">,</span><span class="w"> </span>Base2<span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// 派生自多个定义 foo() 函数的基类合约，</span>
<span class="w">    </span><span class="c1">// 所以我们必须明确地重载它</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">foo</span><span class="p">()</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>override<span class="p">(</span>Base1<span class="p">,</span><span class="w"> </span>Base2<span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>如果函数被定义在一个共同的基类合约中，
或者在一个共同的基类合约中有一个独特的函数已经重载了所有其他的函数，
则不需要明确的函数重载指定符。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.13&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjAgPDAuOS4wOwoKY29udHJhY3QgQSB7IGZ1bmN0aW9uIGYoKSBwdWJsaWMgcHVyZXt9IH0KY29udHJhY3QgQiBpcyBBIHt9CmNvbnRyYWN0IEMgaXMgQSB7fQovLyDml6DpnIDmmI7noa7nmoTph43ovb0KY29udHJhY3QgRCBpcyBCLCBDIHt9"><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.6.0</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span><span class="w"></span>

<span class="k">contract</span><span class="w"> </span><span class="ni">A</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="kt">function</span><span class="w"> </span><span class="nv">f</span><span class="p">()</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>pure<span class="p">{}</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="k">contract</span><span class="w"> </span><span class="ni">B</span><span class="w"> </span><span class="kt">is</span><span class="w"> </span>A<span class="w"> </span><span class="p">{}</span><span class="w"></span>
<span class="k">contract</span><span class="w"> </span><span class="ni">C</span><span class="w"> </span><span class="kt">is</span><span class="w"> </span>A<span class="w"> </span><span class="p">{}</span><span class="w"></span>
<span class="c1">// 无需明确的重载</span>
<span class="k">contract</span><span class="w"> </span><span class="ni">D</span><span class="w"> </span><span class="kt">is</span><span class="w"> </span>B<span class="p">,</span><span class="w"> </span>C<span class="w"> </span><span class="p">{}</span><span class="w"></span>
</pre></div>
</div>
<p>更准确地说，如果有一个基类合约是该签名的所有重载路径的一部分，
并且（1）该基类合约实现了该函数，并且从当前合约到该基类合约的任何路径都没有提到具有该签名的函数，
或者（2）该基类合约没有实现该函数，并且从当前合约到该基类合约的所有路径中最多只有一个提到该函数，
那么就不需要重载从多个基类合约继承的函数（直接或间接）。</p>
<p>在这个意义上，一个签名的重载路径是一条继承图的路径，
它从所考虑的合约开始，到提到具有该签名的函数的合约结束，
而该签名没有重载。</p>
<p>如果您不把一个重载的函数标记为 <code class="docutils literal notranslate"><span class="pre">virtual</span></code>，派生合约就不能再改变该函数的行为。</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>具有 <code class="docutils literal notranslate"><span class="pre">private</span></code> 可见性的函数不能是 <code class="docutils literal notranslate"><span class="pre">virtual</span></code>。</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>在接口合约之外，没有实现的函数必须被标记为 <code class="docutils literal notranslate"><span class="pre">virtual</span></code>。
在接口合约中，所有的函数都被自动视为 <code class="docutils literal notranslate"><span class="pre">virtual</span></code>。</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>从Solidity 0.8.8开始，当重载一个接口函数时，
不需要 <code class="docutils literal notranslate"><span class="pre">override</span></code> 关键字，除非该函数被定义在多个基础上。</p>
</div>
<p>如果函数的参数和返回类型与变量的getter函数匹配，公共状态变量可以重载为外部函数。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.13&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjAgPDAuOS4wOwoKY29udHJhY3QgQQp7CiAgICBmdW5jdGlvbiBmKCkgZXh0ZXJuYWwgdmlldyB2aXJ0dWFsIHJldHVybnModWludCkgeyByZXR1cm4gNTsgfQp9Cgpjb250cmFjdCBCIGlzIEEKewogICAgdWludCBwdWJsaWMgb3ZlcnJpZGUgZjsKfQ=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.6.0</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span><span class="w"></span>

<span class="k">contract</span><span class="w"> </span><span class="ni">A</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">f</span><span class="p">()</span><span class="w"> </span><span class="kt">external</span><span class="w"> </span>view<span class="w"> </span>virtual<span class="w"> </span><span class="kt">returns</span><span class="p">(</span><span class="kt">uint</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="kt">return</span><span class="w"> </span><span class="m m-Decimal">5</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">contract</span><span class="w"> </span><span class="ni">B</span><span class="w"> </span><span class="kt">is</span><span class="w"> </span>A<span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">uint</span><span class="w"> </span><span class="k">public </span><span class="nv">override</span><span class="w"> </span>f<span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>虽然公共状态变量可以重载外部函数，但它们本身不能被重载。</p>
</div>
</section>
<section id="modifier-overriding">
<span id="index-18"></span><span id="id24"></span><h3>修饰器重载<a class="headerlink" href="#modifier-overriding" title="Permalink to this heading"></a></h3>
<p>函数修改器可以相互重载。
这与 <a class="reference internal" href="#function-overriding"><span class="std std-ref">函数重载</span></a> 的工作方式相同（除了对修改器没有重载）。
<code class="docutils literal notranslate"><span class="pre">virtual</span></code> 关键字必须用在被重载的修改器上， <code class="docutils literal notranslate"><span class="pre">override</span></code> 关键字必须用在重载的修改器上：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.13&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjAgPDAuOS4wOwoKY29udHJhY3QgQmFzZQp7CiAgICBtb2RpZmllciBmb28oKSB2aXJ0dWFsIHtfO30KfQoKY29udHJhY3QgSW5oZXJpdGVkIGlzIEJhc2UKewogICAgbW9kaWZpZXIgZm9vKCkgb3ZlcnJpZGUge187fQp9"><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.6.0</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span><span class="w"></span>

<span class="k">contract</span><span class="w"> </span><span class="ni">Base</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">modifier</span><span class="w"> </span>foo<span class="p">()</span><span class="w"> </span>virtual<span class="w"> </span><span class="p">{</span>_<span class="p">;}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">contract</span><span class="w"> </span><span class="ni">Inherited</span><span class="w"> </span><span class="kt">is</span><span class="w"> </span>Base<span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">modifier</span><span class="w"> </span>foo<span class="p">()</span><span class="w"> </span>override<span class="w"> </span><span class="p">{</span>_<span class="p">;}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>在多重继承的情况下，必须明确指定所有的直接基类合约。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.13&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjAgPDAuOS4wOwoKY29udHJhY3QgQmFzZTEKewogICAgbW9kaWZpZXIgZm9vKCkgdmlydHVhbCB7Xzt9Cn0KCmNvbnRyYWN0IEJhc2UyCnsKICAgIG1vZGlmaWVyIGZvbygpIHZpcnR1YWwge187fQp9Cgpjb250cmFjdCBJbmhlcml0ZWQgaXMgQmFzZTEsIEJhc2UyCnsKICAgIG1vZGlmaWVyIGZvbygpIG92ZXJyaWRlKEJhc2UxLCBCYXNlMikge187fQp9"><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.6.0</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span><span class="w"></span>

<span class="k">contract</span><span class="w"> </span><span class="ni">Base1</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">modifier</span><span class="w"> </span>foo<span class="p">()</span><span class="w"> </span>virtual<span class="w"> </span><span class="p">{</span>_<span class="p">;}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">contract</span><span class="w"> </span><span class="ni">Base2</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">modifier</span><span class="w"> </span>foo<span class="p">()</span><span class="w"> </span>virtual<span class="w"> </span><span class="p">{</span>_<span class="p">;}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">contract</span><span class="w"> </span><span class="ni">Inherited</span><span class="w"> </span><span class="kt">is</span><span class="w"> </span>Base1<span class="p">,</span><span class="w"> </span>Base2<span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">modifier</span><span class="w"> </span>foo<span class="p">()</span><span class="w"> </span>override<span class="p">(</span>Base1<span class="p">,</span><span class="w"> </span>Base2<span class="p">)</span><span class="w"> </span><span class="p">{</span>_<span class="p">;}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="constructor">
<span id="index-19"></span><span id="id25"></span><h3>构造函数<a class="headerlink" href="#constructor" title="Permalink to this heading"></a></h3>
<p>构造函数是一个用 <code class="docutils literal notranslate"><span class="pre">constructor</span></code> 关键字声明的可选函数，
它在合约创建时被执行，您可以在这里运行合约初始化代码。</p>
<p>在构造函数代码执行之前，如果您用内联编程的方式初始化状态变量，则将其初始化为指定的值；
如果您不用内联编程的方式来初始化，则将其初始化为 <a class="reference internal" href="control-structures.html#default-value"><span class="std std-ref">默认值</span></a>。</p>
<p>构造函数运行后，合约的最终代码被部署到区块链上。
部署代码的gas花费与代码长度成线性关系。
这段代码包括属于公共接口的所有函数，以及所有通过函数调用可以到达的函数。
但不包括构造函数代码或只从构造函数中调用的内部函数。</p>
<p>如果没有构造函数，合约将假定默认的构造函数，
相当于 <code class="docutils literal notranslate"><span class="pre">constructor()</span> <span class="pre">{}</span></code>。比如说：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.13&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjAgPDAuOS4wOwoKYWJzdHJhY3QgY29udHJhY3QgQSB7CiAgICB1aW50IHB1YmxpYyBhOwoKICAgIGNvbnN0cnVjdG9yKHVpbnQgX2EpIHsKICAgICAgICBhID0gX2E7CiAgICB9Cn0KCmNvbnRyYWN0IEIgaXMgQSgxKSB7CiAgICBjb25zdHJ1Y3RvcigpIHt9Cn0="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.7.0</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span><span class="w"></span>

abstract<span class="w"> </span><span class="k">contract</span><span class="w"> </span><span class="ni">A</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">uint</span><span class="w"> </span><span class="k">public </span><span class="nv">a</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="kt">constructor</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">_a</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span>a<span class="w"> </span><span class="o">=</span><span class="w"> </span>_a<span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">contract</span><span class="w"> </span><span class="ni">B</span><span class="w"> </span><span class="kt">is</span><span class="w"> </span>A<span class="p">(</span><span class="m m-Decimal">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">constructor</span><span class="p">()</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>您可以在构造函数中使用内部参数（例如，存储指针）。
在这种情况下，合约必须被标记为 <a class="reference internal" href="#abstract-contract"><span class="std std-ref">abstract</span></a>，
因为这些参数不能从外部分配有效的值，只能通过派生合约的构造函数来赋值。</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>在0.4.22版本之前，构造函数被定义为与合约同名的函数。
这种语法已被废弃，在0.5.0版本中不再允许。</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>在0.7.0版本之前，您必须指定构造函数的可见性为 <code class="docutils literal notranslate"><span class="pre">internal</span></code> 或 <code class="docutils literal notranslate"><span class="pre">public</span></code>。</p>
</div>
</section>
<section id="index-20">
<span id="id26"></span><h3>基本构造函数的参数<a class="headerlink" href="#index-20" title="Permalink to this heading"></a></h3>
<p>所有基类合约的构造函数将按照下面解释的线性化规则被调用。
如果基类合约构造函数有参数，派生合约需要指定所有的参数。
这可以通过两种方式实现：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.13&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjAgPDAuOS4wOwoKY29udHJhY3QgQmFzZSB7CiAgICB1aW50IHg7CiAgICBjb25zdHJ1Y3Rvcih1aW50IF94KSB7IHggPSBfeDsgfQp9CgovLyDopoHkuYjnm7TmjqXlnKjnu6fmib/liJfooajkuK3mjIflrpouLi4KY29udHJhY3QgRGVyaXZlZDEgaXMgQmFzZSg3KSB7CiAgICBjb25zdHJ1Y3RvcigpIHt9Cn0KCi8vIOaIluiAhemAmui/h+a0vueUn+aehOmAoOWHveaVsOeahOS4gOS4qiAi5L+u5pS55ZmoIuOAggpjb250cmFjdCBEZXJpdmVkMiBpcyBCYXNlIHsKICAgIGNvbnN0cnVjdG9yKHVpbnQgX3kpIEJhc2UoX3kgKiBfeSkge30KfQ=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.7.0</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span><span class="w"></span>

<span class="k">contract</span><span class="w"> </span><span class="ni">Base</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">uint</span><span class="w"> </span><span class="nv">x</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">constructor</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">_x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>x<span class="w"> </span><span class="o">=</span><span class="w"> </span>_x<span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// 要么直接在继承列表中指定...</span>
<span class="k">contract</span><span class="w"> </span><span class="ni">Derived1</span><span class="w"> </span><span class="kt">is</span><span class="w"> </span>Base<span class="p">(</span><span class="m m-Decimal">7</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">constructor</span><span class="p">()</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// 或者通过派生构造函数的一个 &quot;修改器&quot;。</span>
<span class="k">contract</span><span class="w"> </span><span class="ni">Derived2</span><span class="w"> </span><span class="kt">is</span><span class="w"> </span>Base<span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">constructor</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">_y</span><span class="p">)</span><span class="w"> </span>Base<span class="p">(</span>_y<span class="w"> </span><span class="o">*</span><span class="w"> </span>_y<span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>一种方式是直接在继承列表中给出（ <code class="docutils literal notranslate"><span class="pre">is</span> <span class="pre">Base(7)</span></code> ）。
另一种是通过修改器作为派生构造函数的一部分被调用的方式（ <code class="docutils literal notranslate"><span class="pre">Base(_y</span> <span class="pre">*</span> <span class="pre">_y)</span></code> ）。
如果构造函数参数是一个常量，并且定义了合约的行为或描述了它，那么第一种方式更方便。
如果基类合约的构造函数参数依赖于派生合约的参数，则必须使用第二种方式。
参数必须在继承列表中或在派生构造函数中以修饰器的形式给出。
在两个地方都指定参数是一个错误。</p>
<p>如果一个派生合约没有指定其所有基类合约的构造函数的参数，它将是抽象的合约。</p>
</section>
<section id="multi-inheritance">
<span id="index-21"></span><span id="id27"></span><h3>多重继承与线性化<a class="headerlink" href="#multi-inheritance" title="Permalink to this heading"></a></h3>
<p>编程语言实现多重继承需要解决几个问题。
一个问题是 <a class="reference external" href="https://en.wikipedia.org/wiki/Multiple_inheritance#The_diamond_problem">钻石问题</a> 。
Solidity 借鉴了 Python 的方式并且使用 “<a class="reference external" href="https://en.wikipedia.org/wiki/C3_linearization">C3 线性化</a>”
强制一个由基类构成的 DAG（有向无环图）保持一个特定的顺序。
这最终实现我们所希望的唯一化的结果，但也使某些继承方式变为无效。
尤其是，基类在 <code class="docutils literal notranslate"><span class="pre">is</span></code> 后面的顺序很重要。 在下面的代码中，
您必须按照从 “最接近的基类”（most base-like）到 “最远的继承”（most derived）的顺序来指定所有的基类。
注意，这个顺序与Python中使用的顺序相反。</p>
<p>另一种简化的解释方式是，当一个函数被调用时，
它在不同的合约中被多次定义，给定的基类以深度优先的方式从右到左（Python中从左到右）进行搜索，
在第一个匹配处停止。如果一个基类合约已经被搜索过了，它就被跳过。</p>
<p>在下面的代码中，Solidity 会给出 “Linearization of inheritance graph impossible” 这样的错误。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.13&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC40LjAgPDAuOS4wOwoKY29udHJhY3QgWCB7fQpjb250cmFjdCBBIGlzIFgge30KLy8g6L+Z5q615Luj56CB5LiN5Lya57yW6K+RCmNvbnRyYWN0IEMgaXMgQSwgWCB7fQ=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.4.0</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span><span class="w"></span>

<span class="k">contract</span><span class="w"> </span><span class="ni">X</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>
<span class="k">contract</span><span class="w"> </span><span class="ni">A</span><span class="w"> </span><span class="kt">is</span><span class="w"> </span>X<span class="w"> </span><span class="p">{}</span><span class="w"></span>
<span class="c1">// 这段代码不会编译</span>
<span class="k">contract</span><span class="w"> </span><span class="ni">C</span><span class="w"> </span><span class="kt">is</span><span class="w"> </span>A<span class="p">,</span><span class="w"> </span>X<span class="w"> </span><span class="p">{}</span><span class="w"></span>
</pre></div>
</div>
<p>代码编译出错的原因是 <code class="docutils literal notranslate"><span class="pre">C</span></code> 要求 <code class="docutils literal notranslate"><span class="pre">X</span></code> 重写 <code class="docutils literal notranslate"><span class="pre">A</span></code>
（因为定义的顺序是 <code class="docutils literal notranslate"><span class="pre">A,</span> <span class="pre">X</span></code> ）， 但是 <code class="docutils literal notranslate"><span class="pre">A</span></code> 本身要求重写 <code class="docutils literal notranslate"><span class="pre">X</span></code>，
这是一种无法解决的冲突。</p>
<p>由于您必须明确地重载一个从多个基类合约继承的函数，
而没有唯一的重载，C3线性化在实践中不是太重要。</p>
<p>继承的线性化特别重要的一个领域是，当继承层次中存在多个构造函数时，也许不那么清楚。
构造函数将总是按照线性化的顺序执行，而不管它们的参数在继承合约的构造函数中是以何种顺序提供的。 比如说：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.13&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC43LjAgPDAuOS4wOwoKY29udHJhY3QgQmFzZTEgewogICAgY29uc3RydWN0b3IoKSB7fQp9Cgpjb250cmFjdCBCYXNlMiB7CiAgICBjb25zdHJ1Y3RvcigpIHt9Cn0KCi8vIOaehOmAoOWHveaVsOaMieS7peS4i+mhuuW6j+aJp+ihjO+8mgovLyAgMSAtIEJhc2UxCi8vICAyIC0gQmFzZTIKLy8gIDMgLSBEZXJpdmVkMQpjb250cmFjdCBEZXJpdmVkMSBpcyBCYXNlMSwgQmFzZTIgewogICAgY29uc3RydWN0b3IoKSBCYXNlMSgpIEJhc2UyKCkge30KfQoKLy8g5p6E6YCg5Ye95pWw5oyJ5Lul5LiL6aG65bqP5omn6KGM77yaCi8vICAxIC0gQmFzZTIKLy8gIDIgLSBCYXNlMQovLyAgMyAtIERlcml2ZWQyCmNvbnRyYWN0IERlcml2ZWQyIGlzIEJhc2UyLCBCYXNlMSB7CiAgICBjb25zdHJ1Y3RvcigpIEJhc2UyKCkgQmFzZTEoKSB7fQp9CgovLyDmnoTpgKDlh73mlbDku43mjInku6XkuIvpobrluo/miafooYzvvJoKLy8gIDEgLSBCYXNlMgovLyAgMiAtIEJhc2UxCi8vICAzIC0gRGVyaXZlZDMKY29udHJhY3QgRGVyaXZlZDMgaXMgQmFzZTIsIEJhc2UxIHsKICAgIGNvbnN0cnVjdG9yKCkgQmFzZTEoKSBCYXNlMigpIHt9Cn0="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.7.0</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span><span class="w"></span>

<span class="k">contract</span><span class="w"> </span><span class="ni">Base1</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">constructor</span><span class="p">()</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">contract</span><span class="w"> </span><span class="ni">Base2</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">constructor</span><span class="p">()</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// 构造函数按以下顺序执行：</span>
<span class="c1">//  1 - Base1</span>
<span class="c1">//  2 - Base2</span>
<span class="c1">//  3 - Derived1</span>
<span class="k">contract</span><span class="w"> </span><span class="ni">Derived1</span><span class="w"> </span><span class="kt">is</span><span class="w"> </span>Base1<span class="p">,</span><span class="w"> </span>Base2<span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">constructor</span><span class="p">()</span><span class="w"> </span>Base1<span class="p">()</span><span class="w"> </span>Base2<span class="p">()</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// 构造函数按以下顺序执行：</span>
<span class="c1">//  1 - Base2</span>
<span class="c1">//  2 - Base1</span>
<span class="c1">//  3 - Derived2</span>
<span class="k">contract</span><span class="w"> </span><span class="ni">Derived2</span><span class="w"> </span><span class="kt">is</span><span class="w"> </span>Base2<span class="p">,</span><span class="w"> </span>Base1<span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">constructor</span><span class="p">()</span><span class="w"> </span>Base2<span class="p">()</span><span class="w"> </span>Base1<span class="p">()</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// 构造函数仍按以下顺序执行：</span>
<span class="c1">//  1 - Base2</span>
<span class="c1">//  2 - Base1</span>
<span class="c1">//  3 - Derived3</span>
<span class="k">contract</span><span class="w"> </span><span class="ni">Derived3</span><span class="w"> </span><span class="kt">is</span><span class="w"> </span>Base2<span class="p">,</span><span class="w"> </span>Base1<span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">constructor</span><span class="p">()</span><span class="w"> </span>Base1<span class="p">()</span><span class="w"> </span>Base2<span class="p">()</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="id29">
<h3>继承有相同名字的不同类型成员<a class="headerlink" href="#id29" title="Permalink to this heading"></a></h3>
<dl class="simple">
<dt>由于继承的原因，当合约有以下任何一对具有相同的名称时，这是一个错误：</dt><dd><ul class="simple">
<li><p>函数和修饰器</p></li>
<li><p>函数和事件</p></li>
<li><p>事件和修饰器</p></li>
</ul>
</dd>
</dl>
<p>有一种例外情况，状态变量的 getter 可以重载一个外部函数。</p>
</section>
</section>
<section id="abstract-contract">
<span id="index-22"></span><span id="id30"></span><h2>抽象合约<a class="headerlink" href="#abstract-contract" title="Permalink to this heading"></a></h2>
<p>当合约中至少有一个功能没有被实现时，需要将其标记为抽象的。
即使所有的功能都实现了，合约也可以被标记为抽象的。</p>
<p>这可以通过使用 <code class="docutils literal notranslate"><span class="pre">abstract</span></code> 关键字来实现，如下例所示。
注意，这个合约需要被定义为抽象的，因为定义了函数 <code class="docutils literal notranslate"><span class="pre">utterance()</span></code>，
但没有提供实现（没有给出实现体 <code class="docutils literal notranslate"><span class="pre">{</span> <span class="pre">}</span></code>）。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.13&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjAgPDAuOS4wOwoKYWJzdHJhY3QgY29udHJhY3QgRmVsaW5lIHsKICAgIGZ1bmN0aW9uIHV0dGVyYW5jZSgpIHB1YmxpYyB2aXJ0dWFsIHJldHVybnMgKGJ5dGVzMzIpOwp9"><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.6.0</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span><span class="w"></span>

abstract<span class="w"> </span><span class="k">contract</span><span class="w"> </span><span class="ni">Feline</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">utterance</span><span class="p">()</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>virtual<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">bytes32</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>这样的抽象合约不能被直接实例化。如果一个抽象合约本身实现了所有定义的功能，这也是可以的。
抽象合约作为基类的用法在下面的例子中显示：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.13&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjAgPDAuOS4wOwoKYWJzdHJhY3QgY29udHJhY3QgRmVsaW5lIHsKICAgIGZ1bmN0aW9uIHV0dGVyYW5jZSgpIHB1YmxpYyBwdXJlIHZpcnR1YWwgcmV0dXJucyAoYnl0ZXMzMik7Cn0KCmNvbnRyYWN0IENhdCBpcyBGZWxpbmUgewogICAgZnVuY3Rpb24gdXR0ZXJhbmNlKCkgcHVibGljIHB1cmUgb3ZlcnJpZGUgcmV0dXJucyAoYnl0ZXMzMikgeyByZXR1cm4gIm1pYW93IjsgfQp9"><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.6.0</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span><span class="w"></span>

abstract<span class="w"> </span><span class="k">contract</span><span class="w"> </span><span class="ni">Feline</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">utterance</span><span class="p">()</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>pure<span class="w"> </span>virtual<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">bytes32</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">contract</span><span class="w"> </span><span class="ni">Cat</span><span class="w"> </span><span class="kt">is</span><span class="w"> </span>Feline<span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">utterance</span><span class="p">()</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>pure<span class="w"> </span>override<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">bytes32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="kt">return</span><span class="w"> </span><span class="s2">&quot;miaow&quot;</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>如果一个合约继承自一个抽象合约，并且没有通过重写实现所有未实现的函数，那么它也需要被标记为抽象的。</p>
<p>注意，没有实现的函数与 <a class="reference internal" href="types.html#function-types"><span class="std std-ref">函数类型</span></a> 不同，尽管它们的语法看起来非常相似。</p>
<p>没有实现内容的函数的例子（一个函数声明）：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.13&amp;code=ZnVuY3Rpb24gZm9vKGFkZHJlc3MpIGV4dGVybmFsIHJldHVybnMgKGFkZHJlc3MpOw=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="kt">function</span><span class="w"> </span><span class="nv">foo</span><span class="p">(</span><span class="kt">address</span><span class="p">)</span><span class="w"> </span><span class="kt">external</span><span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">address</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>类型为函数类型的变量的声明实例：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.13&amp;code=ZnVuY3Rpb24oYWRkcmVzcykgZXh0ZXJuYWwgcmV0dXJucyAoYWRkcmVzcykgZm9vOw=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="kt">function</span><span class="p">(</span><span class="kt">address</span><span class="p">)</span><span class="w"> </span><span class="kt">external</span><span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">address</span><span class="p">)</span><span class="w"> </span>foo<span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>抽象合约将合约的定义与它的实现解耦，提供了更好的可扩展性和自我记录，
促进了像 <a class="reference external" href="https://en.wikipedia.org/wiki/Template_method_pattern">模板方法</a> 这样的模式，
并消除了代码的重复。抽象合约的作用与在接口中定义方法的作用相同。
它是抽象合约的设计者说 “我的任何孩子都必须实现这个方法” 的一种方式。</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>抽象合约不能用一个未实现的virtual函数来重载一个已实现的virtual函数。</p>
</div>
</section>
<section id="interfaces">
<span id="index-23"></span><span id="id32"></span><h2>接口<a class="headerlink" href="#interfaces" title="Permalink to this heading"></a></h2>
<p>接口类似于抽象合约，但是它们不能实现任何函数。还有进一步的限制：</p>
<ul class="simple">
<li><p>它们不能继承其他合约，但它们可以继承其他接口。</p></li>
<li><p>所有声明的函数必须是外部的。</p></li>
<li><p>它们不能定义构造函数。</p></li>
<li><p>它们不能定义变量。</p></li>
<li><p>它们不能定义修饰器。</p></li>
</ul>
<p>将来可能会解除这些里的某些限制。</p>
<p>接口基本上仅限于合约 ABI 可以表示的内容，
并且 ABI 和接口之间的转换应该不会丢失任何信息。</p>
<p>接口由它们自己的关键字表示：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.13&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjIgPDAuOS4wOwoKaW50ZXJmYWNlIFRva2VuIHsKICAgIGVudW0gVG9rZW5UeXBlIHsgRnVuZ2libGUsIE5vbkZ1bmdpYmxlIH0KICAgIHN0cnVjdCBDb2luIHsgc3RyaW5nIG9idmVyc2U7IHN0cmluZyByZXZlcnNlOyB9CiAgICBmdW5jdGlvbiB0cmFuc2ZlcihhZGRyZXNzIHJlY2lwaWVudCwgdWludCBhbW91bnQpIGV4dGVybmFsOwp9"><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.6.2</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span><span class="w"></span>

interface<span class="w"> </span>Token<span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">enum</span><span class="w"> </span><span class="nv">TokenType</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>Fungible<span class="p">,</span><span class="w"> </span>NonFungible<span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="kt">struct</span><span class="w"> </span><span class="nv">Coin</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="kt">string</span><span class="w"> </span><span class="nv">obverse</span><span class="p">;</span><span class="w"> </span><span class="kt">string</span><span class="w"> </span><span class="nv">reverse</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">transfer</span><span class="p">(</span><span class="kt">address</span><span class="w"> </span><span class="nv">recipient</span><span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="nv">amount</span><span class="p">)</span><span class="w"> </span><span class="kt">external</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>就像继承其他合约一样，合约可以继承接口。</p>
<p>所有在接口中声明的函数都是隐式的 <code class="docutils literal notranslate"><span class="pre">virtual</span></code> 的类型，
任何重载它们的函数都不需要 <code class="docutils literal notranslate"><span class="pre">override</span></code> 关键字。
这并不自动意味着一个重载的函数可以被再次重载–这只有在重载的函数被标记为 <code class="docutils literal notranslate"><span class="pre">virtual</span></code> 时才可能。</p>
<p>接口可以从其他接口继承。这与普通的继承有着相同的规则。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.13&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjIgPDAuOS4wOwoKaW50ZXJmYWNlIFBhcmVudEEgewogICAgZnVuY3Rpb24gdGVzdCgpIGV4dGVybmFsIHJldHVybnMgKHVpbnQyNTYpOwp9CgppbnRlcmZhY2UgUGFyZW50QiB7CiAgICBmdW5jdGlvbiB0ZXN0KCkgZXh0ZXJuYWwgcmV0dXJucyAodWludDI1Nik7Cn0KCmludGVyZmFjZSBTdWJJbnRlcmZhY2UgaXMgUGFyZW50QSwgUGFyZW50QiB7CiAgICAvLyDlv4Xpobvph43mlrDlrprkuYl0ZXN077yM5Lul5L6/5pat6KiA54i257G755qE5ZCr5LmJ5piv5YW85a6555qE44CCCiAgICBmdW5jdGlvbiB0ZXN0KCkgZXh0ZXJuYWwgb3ZlcnJpZGUoUGFyZW50QSwgUGFyZW50QikgcmV0dXJucyAodWludDI1Nik7Cn0="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.6.2</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span><span class="w"></span>

interface<span class="w"> </span>ParentA<span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">test</span><span class="p">()</span><span class="w"> </span><span class="kt">external</span><span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint256</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

interface<span class="w"> </span>ParentB<span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">test</span><span class="p">()</span><span class="w"> </span><span class="kt">external</span><span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint256</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

interface<span class="w"> </span>SubInterface<span class="w"> </span><span class="kt">is</span><span class="w"> </span>ParentA<span class="p">,</span><span class="w"> </span>ParentB<span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// 必须重新定义test，以便断言父类的含义是兼容的。</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">test</span><span class="p">()</span><span class="w"> </span><span class="kt">external</span><span class="w"> </span>override<span class="p">(</span>ParentA<span class="p">,</span><span class="w"> </span>ParentB<span class="p">)</span><span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint256</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>在接口和其他类似合约的结构中定义的类型可以从其他合约中访问： <code class="docutils literal notranslate"><span class="pre">Token.TokenType</span></code> 或 <code class="docutils literal notranslate"><span class="pre">Token.Coin</span></code>。</p>
</section>
<section id="libraries">
<span id="index-24"></span><span id="id33"></span><h2>库合约<a class="headerlink" href="#libraries" title="Permalink to this heading"></a></h2>
<p>库合约与普通合约类似，但是它们只需要在特定的地址部署一次，
并且它们的代码可以通过 EVM 的 <code class="docutils literal notranslate"><span class="pre">DELEGATECALL</span></code> (Homestead 之前使用 <code class="docutils literal notranslate"><span class="pre">CALLCODE</span></code> 关键字)特性进行重用。
这意味着如果库函数被调用，它的代码在调用合约的上下文中执行，
即 <code class="docutils literal notranslate"><span class="pre">this</span></code> 指向调用合约，特别是可以访问调用合约的存储。
因为每个库合约都是一段独立的代码，所以它仅能访问调用合约明确提供的状态变量（否则它就无法通过名字访问这些变量）。
如果库函数不修改状态（也就是说，如果它们是 <code class="docutils literal notranslate"><span class="pre">view</span></code> 或者 <code class="docutils literal notranslate"><span class="pre">pure</span></code> 函数），
它们可以通过直接调用来使用（即不使用 <code class="docutils literal notranslate"><span class="pre">DELEGATECALL</span></code> 关键字），
这是因为我们假定库合约是无状态的。
特别的是，销毁一个库合约是不可能的。</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>在0.4.20版本之前，有可能通过规避Solidity的类型系统来破坏库合约。
从该版本开始，库合约包含一个 <a class="reference internal" href="#call-protection"><span class="std std-ref">保护机制</span></a>，
不允许直接调用修改状态的函数（即没有 <code class="docutils literal notranslate"><span class="pre">DELEGATECALL</span></code> ）。</p>
</div>
<p>库合约可以看作是使用他们的合约的隐式的基类合约。
虽然它们在继承关系中不会显式可见，但调用库函数与调用显式的基类合约十分类似
（如果 <code class="docutils literal notranslate"><span class="pre">L</span></code> 是库合约的话，可以使用 <code class="docutils literal notranslate"><span class="pre">L.f()</span></code> 调用库函数）。
当然，需要使用内部调用约定来调用内部函数，这意味着所有的内部类型都可以被传递，
类型 <a class="reference internal" href="types.html#data-location"><span class="std std-ref">存储在内存</span></a> 将被引用传递而不是复制。
为了在EVM中实现这一点，从合约中调用的内部库函数的代码和其中调用的所有函数将在编译时包含在调用合约中，
并使用常规的 <code class="docutils literal notranslate"><span class="pre">JUMP</span></code> 调用，而不是 <code class="docutils literal notranslate"><span class="pre">DELEGATECALL</span></code>。</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>当涉及到公共函数时，继承的类比就失效了。
用 <code class="docutils literal notranslate"><span class="pre">L.f()</span></code> 调用公共库函数的结果是一个外部调用（准确地说，是 <code class="docutils literal notranslate"><span class="pre">DELEGATECALL</span></code> ）。
相反，当 <code class="docutils literal notranslate"><span class="pre">A.f()</span></code> 是当前合约的基类合约时， <code class="docutils literal notranslate"><span class="pre">A.f()</span></code> 是一个内部调用。</p>
</div>
<p id="index-25">下面的示例说明如何使用库（但也请务必看看 <a class="reference internal" href="#using-for"><span class="std std-ref">using for</span></a> 有一个实现 set 更好的例子）。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.13&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjAgPDAuOS4wOwoKCi8vIOaIkeS7rOWumuS5ieS6huS4gOS4quaWsOeahOe7k+aehOS9k+aVsOaNruexu+Wei++8jOeUqOS6juWcqOiwg+eUqOWQiOe6puS4reS/neWtmOaVsOaNruOAggpzdHJ1Y3QgRGF0YSB7CiAgICBtYXBwaW5nKHVpbnQgPT4gYm9vbCkgZmxhZ3M7Cn0KCmxpYnJhcnkgU2V0IHsKICAgIC8vIOazqOaEj+esrOS4gOS4quWPguaVsOaYryDigJxzdG9yYWdlIHJlZmVyZW5jZeKAneexu+Wei++8jAogICAgLy8g5Zug5q2k5Zyo6LCD55So5Lit5Y+C5pWw5Lyg6YCS55qE5Y+q5piv5a6D55qE5a2Y5YKo5Zyw5Z2A6ICM5LiN5piv5YaF5a6544CCCiAgICAvLyDov5nmmK/lupPlh73mlbDnmoTkuIDkuKrnibnmgKfjgILlpoLmnpzor6Xlh73mlbDlj6/ku6Xooqvop4bkuLrlr7nosaHnmoTmlrnms5XvvIwKICAgIC8vIOWImeS5oOaDr+ensOesrOS4gOS4quWPguaVsOS4uiBgc2VsZmAg44CCCiAgICBmdW5jdGlvbiBpbnNlcnQoRGF0YSBzdG9yYWdlIHNlbGYsIHVpbnQgdmFsdWUpCiAgICAgICAgcHVibGljCiAgICAgICAgcmV0dXJucyAoYm9vbCkKICAgIHsKICAgICAgICBpZiAoc2VsZi5mbGFnc1t2YWx1ZV0pCiAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8g5bey57uP5a2Y5ZyoCiAgICAgICAgc2VsZi5mbGFnc1t2YWx1ZV0gPSB0cnVlOwogICAgICAgIHJldHVybiB0cnVlOwogICAgfQoKICAgIGZ1bmN0aW9uIHJlbW92ZShEYXRhIHN0b3JhZ2Ugc2VsZiwgdWludCB2YWx1ZSkKICAgICAgICBwdWJsaWMKICAgICAgICByZXR1cm5zIChib29sKQogICAgewogICAgICAgIGlmICghc2VsZi5mbGFnc1t2YWx1ZV0pCiAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8g5LiN5a2Y5ZyoCiAgICAgICAgc2VsZi5mbGFnc1t2YWx1ZV0gPSBmYWxzZTsKICAgICAgICByZXR1cm4gdHJ1ZTsKICAgIH0KCiAgICBmdW5jdGlvbiBjb250YWlucyhEYXRhIHN0b3JhZ2Ugc2VsZiwgdWludCB2YWx1ZSkKICAgICAgICBwdWJsaWMKICAgICAgICB2aWV3CiAgICAgICAgcmV0dXJucyAoYm9vbCkKICAgIHsKICAgICAgICByZXR1cm4gc2VsZi5mbGFnc1t2YWx1ZV07CiAgICB9Cn0KCgpjb250cmFjdCBDIHsKICAgIERhdGEga25vd25WYWx1ZXM7CgogICAgZnVuY3Rpb24gcmVnaXN0ZXIodWludCB2YWx1ZSkgcHVibGljIHsKICAgICAgICAvLyDkuI3pnIDopoHlupPnmoTnibnlrprlrp7kvovlsLHlj6/ku6XosIPnlKjlupPlh73mlbDvvIwKICAgICAgICAvLyDlm6DkuLrlvZPliY3lkIjnuqblsLHmmK8g4oCcaW5zdGFuY2XigJ3jgIIKICAgICAgICByZXF1aXJlKFNldC5pbnNlcnQoa25vd25WYWx1ZXMsIHZhbHVlKSk7CiAgICB9CiAgICAvLyDlpoLmnpzmiJHku6zmhL/mhI/vvIzmiJHku6zkuZ/lj6/ku6XlnKjov5nkuKrlkIjnuqbkuK3nm7TmjqXorr/pl64ga25vd25WYWx1ZXMuZmxhZ3PjgIIKfQ=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.6.0</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span><span class="w"></span>


<span class="c1">// 我们定义了一个新的结构体数据类型，用于在调用合约中保存数据。</span>
<span class="kt">struct</span><span class="w"> </span><span class="nv">Data</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">mapping</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="kt">bool</span><span class="p">)</span><span class="w"> </span>flags<span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">library</span><span class="w"> </span>Set<span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// 注意第一个参数是 “storage reference”类型，</span>
<span class="w">    </span><span class="c1">// 因此在调用中参数传递的只是它的存储地址而不是内容。</span>
<span class="w">    </span><span class="c1">// 这是库函数的一个特性。如果该函数可以被视为对象的方法，</span>
<span class="w">    </span><span class="c1">// 则习惯称第一个参数为 `self` 。</span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">insert</span><span class="p">(</span>Data<span class="w"> </span>storage<span class="w"> </span>self<span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="nv">value</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="kt">public</span><span class="w"></span>
<span class="w">        </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">bool</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">if</span><span class="w"> </span><span class="p">(</span>self<span class="p">.</span>flags<span class="p">[</span>value<span class="p">])</span><span class="w"></span>
<span class="w">            </span><span class="kt">return</span><span class="w"> </span><span class="kt">false</span><span class="p">;</span><span class="w"> </span><span class="c1">// 已经存在</span>
<span class="w">        </span>self<span class="p">.</span>flags<span class="p">[</span>value<span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">true</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="kt">return</span><span class="w"> </span><span class="kt">true</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">remove</span><span class="p">(</span>Data<span class="w"> </span>storage<span class="w"> </span>self<span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="nv">value</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="kt">public</span><span class="w"></span>
<span class="w">        </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">bool</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span>self<span class="p">.</span>flags<span class="p">[</span>value<span class="p">])</span><span class="w"></span>
<span class="w">            </span><span class="kt">return</span><span class="w"> </span><span class="kt">false</span><span class="p">;</span><span class="w"> </span><span class="c1">// 不存在</span>
<span class="w">        </span>self<span class="p">.</span>flags<span class="p">[</span>value<span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">false</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="kt">return</span><span class="w"> </span><span class="kt">true</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">contains</span><span class="p">(</span>Data<span class="w"> </span>storage<span class="w"> </span>self<span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="nv">value</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="kt">public</span><span class="w"></span>
<span class="w">        </span>view<span class="w"></span>
<span class="w">        </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">bool</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">return</span><span class="w"> </span>self<span class="p">.</span>flags<span class="p">[</span>value<span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>


<span class="k">contract</span><span class="w"> </span><span class="ni">C</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span>Data<span class="w"> </span>knownValues<span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">register</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">value</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// 不需要库的特定实例就可以调用库函数，</span>
<span class="w">        </span><span class="c1">// 因为当前合约就是 “instance”。</span>
<span class="w">        </span><span class="kt">require</span><span class="p">(</span>Set<span class="p">.</span>insert<span class="p">(</span>knownValues<span class="p">,</span><span class="w"> </span>value<span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="c1">// 如果我们愿意，我们也可以在这个合约中直接访问 knownValues.flags。</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>当然，您不必按照这种方式去使用库：它们也可以在不定义结构数据类型的情况下使用。
函数也不需要任何存储引用参数，库可以出现在任何位置并且可以有多个存储引用参数。</p>
<p>调用 <code class="docutils literal notranslate"><span class="pre">Set.contains</span></code>， <code class="docutils literal notranslate"><span class="pre">Set.insert</span></code> 和 <code class="docutils literal notranslate"><span class="pre">Set.remove</span></code> 都被编译为对外部合约/库的调用（ <code class="docutils literal notranslate"><span class="pre">DELEGATECALL</span></code> ）。
如果使用库，请注意实际执行的是外部函数调用。
<code class="docutils literal notranslate"><span class="pre">msg.sender</span></code>， <code class="docutils literal notranslate"><span class="pre">msg.value</span></code> 和 <code class="docutils literal notranslate"><span class="pre">this</span></code> 在调用中将保留它们的值，
（在 Homestead 之前，因为使用了 <code class="docutils literal notranslate"><span class="pre">CALLCODE</span></code> ，改变了 <code class="docutils literal notranslate"><span class="pre">msg.sender</span></code> 和 <code class="docutils literal notranslate"><span class="pre">msg.value</span></code>)。</p>
<p>下面的例子显示了如何使用 <a class="reference internal" href="types.html#data-location"><span class="std std-ref">存储在内存中的类型</span></a> 和库合约中的内部函数，
以实现自定义类型，而没有外部函数调用的开销：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.13&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5IF4wLjguMDsKCnN0cnVjdCBiaWdpbnQgewogICAgdWludFtdIGxpbWJzOwp9CgpsaWJyYXJ5IEJpZ0ludCB7CiAgICBmdW5jdGlvbiBmcm9tVWludCh1aW50IHgpIGludGVybmFsIHB1cmUgcmV0dXJucyAoYmlnaW50IG1lbW9yeSByKSB7CiAgICAgICAgci5saW1icyA9IG5ldyB1aW50W10oMSk7CiAgICAgICAgci5saW1ic1swXSA9IHg7CiAgICB9CgogICAgZnVuY3Rpb24gYWRkKGJpZ2ludCBtZW1vcnkgX2EsIGJpZ2ludCBtZW1vcnkgX2IpIGludGVybmFsIHB1cmUgcmV0dXJucyAoYmlnaW50IG1lbW9yeSByKSB7CiAgICAgICAgci5saW1icyA9IG5ldyB1aW50W10obWF4KF9hLmxpbWJzLmxlbmd0aCwgX2IubGltYnMubGVuZ3RoKSk7CiAgICAgICAgdWludCBjYXJyeSA9IDA7CiAgICAgICAgZm9yICh1aW50IGkgPSAwOyBpIDwgci5saW1icy5sZW5ndGg7ICsraSkgewogICAgICAgICAgICB1aW50IGEgPSBsaW1iKF9hLCBpKTsKICAgICAgICAgICAgdWludCBiID0gbGltYihfYiwgaSk7CiAgICAgICAgICAgIHVuY2hlY2tlZCB7CiAgICAgICAgICAgICAgICByLmxpbWJzW2ldID0gYSArIGIgKyBjYXJyeTsKCiAgICAgICAgICAgICAgICBpZiAoYSArIGIgPCBhIHx8IChhICsgYiA9PSB0eXBlKHVpbnQpLm1heCAmJiBjYXJyeSA+IDApKQogICAgICAgICAgICAgICAgICAgIGNhcnJ5ID0gMTsKICAgICAgICAgICAgICAgIGVsc2UKICAgICAgICAgICAgICAgICAgICBjYXJyeSA9IDA7CiAgICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgaWYgKGNhcnJ5ID4gMCkgewogICAgICAgICAgICAvLyDlpKrlt67kuobvvIzmiJHku6zpnIDopoHlop7liqDkuIDkuKogbGltYgogICAgICAgICAgICB1aW50W10gbWVtb3J5IG5ld0xpbWJzID0gbmV3IHVpbnRbXShyLmxpbWJzLmxlbmd0aCArIDEpOwogICAgICAgICAgICB1aW50IGk7CiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCByLmxpbWJzLmxlbmd0aDsgKytpKQogICAgICAgICAgICAgICAgbmV3TGltYnNbaV0gPSByLmxpbWJzW2ldOwogICAgICAgICAgICBuZXdMaW1ic1tpXSA9IGNhcnJ5OwogICAgICAgICAgICByLmxpbWJzID0gbmV3TGltYnM7CiAgICAgICAgfQogICAgfQoKICAgIGZ1bmN0aW9uIGxpbWIoYmlnaW50IG1lbW9yeSBfYSwgdWludCBfbGltYikgaW50ZXJuYWwgcHVyZSByZXR1cm5zICh1aW50KSB7CiAgICAgICAgcmV0dXJuIF9saW1iIDwgX2EubGltYnMubGVuZ3RoID8gX2EubGltYnNbX2xpbWJdIDogMDsKICAgIH0KCiAgICBmdW5jdGlvbiBtYXgodWludCBhLCB1aW50IGIpIHByaXZhdGUgcHVyZSByZXR1cm5zICh1aW50KSB7CiAgICAgICAgcmV0dXJuIGEgPiBiID8gYSA6IGI7CiAgICB9Cn0KCmNvbnRyYWN0IEMgewogICAgdXNpbmcgQmlnSW50IGZvciBiaWdpbnQ7CgogICAgZnVuY3Rpb24gZigpIHB1YmxpYyBwdXJlIHsKICAgICAgICBiaWdpbnQgbWVtb3J5IHggPSBCaWdJbnQuZnJvbVVpbnQoNyk7CiAgICAgICAgYmlnaW50IG1lbW9yeSB5ID0gQmlnSW50LmZyb21VaW50KHR5cGUodWludCkubWF4KTsKICAgICAgICBiaWdpbnQgbWVtb3J5IHogPSB4LmFkZCh5KTsKICAgICAgICBhc3NlcnQoei5saW1iKDEpID4gMCk7CiAgICB9Cn0="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">^</span><span class="k">0.8.0</span><span class="p">;</span><span class="w"></span>

<span class="kt">struct</span><span class="w"> </span><span class="nv">bigint</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">uint</span><span class="p">[]</span><span class="w"> </span>limbs<span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">library</span><span class="w"> </span>BigInt<span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">fromUint</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">x</span><span class="p">)</span><span class="w"> </span><span class="kt">internal</span><span class="w"> </span>pure<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span>bigint<span class="w"> </span><span class="kt">memory</span><span class="w"> </span>r<span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span>r<span class="p">.</span>limbs<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">new</span><span class="w"> </span><span class="kt">uint</span><span class="p">[](</span><span class="m m-Decimal">1</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span>r<span class="p">.</span>limbs<span class="p">[</span><span class="m m-Decimal">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>x<span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">add</span><span class="p">(</span>bigint<span class="w"> </span><span class="kt">memory</span><span class="w"> </span>_a<span class="p">,</span><span class="w"> </span>bigint<span class="w"> </span><span class="kt">memory</span><span class="w"> </span>_b<span class="p">)</span><span class="w"> </span><span class="kt">internal</span><span class="w"> </span>pure<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span>bigint<span class="w"> </span><span class="kt">memory</span><span class="w"> </span>r<span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span>r<span class="p">.</span>limbs<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">new</span><span class="w"> </span><span class="kt">uint</span><span class="p">[](</span>max<span class="p">(</span>_a<span class="p">.</span>limbs<span class="p">.</span>length<span class="p">,</span><span class="w"> </span>_b<span class="p">.</span>limbs<span class="p">.</span>length<span class="p">));</span><span class="w"></span>
<span class="w">        </span><span class="kt">uint</span><span class="w"> </span><span class="nv">carry</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m m-Decimal">0</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="kt">for</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m m-Decimal">0</span><span class="p">;</span><span class="w"> </span>i<span class="w"> </span><span class="o">&lt;</span><span class="w"> </span>r<span class="p">.</span>limbs<span class="p">.</span>length<span class="p">;</span><span class="w"> </span><span class="o">++</span>i<span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="kt">uint</span><span class="w"> </span><span class="nv">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>limb<span class="p">(</span>_a<span class="p">,</span><span class="w"> </span>i<span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="kt">uint</span><span class="w"> </span><span class="nv">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>limb<span class="p">(</span>_b<span class="p">,</span><span class="w"> </span>i<span class="p">);</span><span class="w"></span>
<span class="w">            </span>unchecked<span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span>r<span class="p">.</span>limbs<span class="p">[</span>i<span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>a<span class="w"> </span><span class="o">+</span><span class="w"> </span>b<span class="w"> </span><span class="o">+</span><span class="w"> </span>carry<span class="p">;</span><span class="w"></span>

<span class="w">                </span><span class="kt">if</span><span class="w"> </span><span class="p">(</span>a<span class="w"> </span><span class="o">+</span><span class="w"> </span>b<span class="w"> </span><span class="o">&lt;</span><span class="w"> </span>a<span class="w"> </span><span class="err">||</span><span class="w"> </span><span class="p">(</span>a<span class="w"> </span><span class="o">+</span><span class="w"> </span>b<span class="w"> </span><span class="o">==</span><span class="w"> </span>type<span class="p">(</span><span class="kt">uint</span><span class="p">).</span>max<span class="w"> </span><span class="err">&amp;&amp;</span><span class="w"> </span>carry<span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="m m-Decimal">0</span><span class="p">))</span><span class="w"></span>
<span class="w">                    </span>carry<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m m-Decimal">1</span><span class="p">;</span><span class="w"></span>
<span class="w">                </span><span class="kt">else</span><span class="w"></span>
<span class="w">                    </span>carry<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m m-Decimal">0</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="kt">if</span><span class="w"> </span><span class="p">(</span>carry<span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="m m-Decimal">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="c1">// 太差了，我们需要增加一个 limb</span>
<span class="w">            </span><span class="kt">uint</span><span class="p">[]</span><span class="w"> </span><span class="kt">memory</span><span class="w"> </span>newLimbs<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">new</span><span class="w"> </span><span class="kt">uint</span><span class="p">[](</span>r<span class="p">.</span>limbs<span class="p">.</span>length<span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="m m-Decimal">1</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="kt">uint</span><span class="w"> </span><span class="nv">i</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="kt">for</span><span class="w"> </span><span class="p">(</span>i<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m m-Decimal">0</span><span class="p">;</span><span class="w"> </span>i<span class="w"> </span><span class="o">&lt;</span><span class="w"> </span>r<span class="p">.</span>limbs<span class="p">.</span>length<span class="p">;</span><span class="w"> </span><span class="o">++</span>i<span class="p">)</span><span class="w"></span>
<span class="w">                </span>newLimbs<span class="p">[</span>i<span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>r<span class="p">.</span>limbs<span class="p">[</span>i<span class="p">];</span><span class="w"></span>
<span class="w">            </span>newLimbs<span class="p">[</span>i<span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>carry<span class="p">;</span><span class="w"></span>
<span class="w">            </span>r<span class="p">.</span>limbs<span class="w"> </span><span class="o">=</span><span class="w"> </span>newLimbs<span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">limb</span><span class="p">(</span>bigint<span class="w"> </span><span class="kt">memory</span><span class="w"> </span>_a<span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="nv">_limb</span><span class="p">)</span><span class="w"> </span><span class="kt">internal</span><span class="w"> </span>pure<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">return</span><span class="w"> </span>_limb<span class="w"> </span><span class="o">&lt;</span><span class="w"> </span>_a<span class="p">.</span>limbs<span class="p">.</span>length<span class="w"> </span><span class="err">?</span><span class="w"> </span>_a<span class="p">.</span>limbs<span class="p">[</span>_limb<span class="p">]</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="m m-Decimal">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">max</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">a</span><span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="nv">b</span><span class="p">)</span><span class="w"> </span><span class="kt">private</span><span class="w"> </span>pure<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">return</span><span class="w"> </span>a<span class="w"> </span><span class="o">&gt;</span><span class="w"> </span>b<span class="w"> </span><span class="err">?</span><span class="w"> </span>a<span class="w"> </span><span class="p">:</span><span class="w"> </span>b<span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">contract</span><span class="w"> </span><span class="ni">C</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span>using<span class="w"> </span>BigInt<span class="w"> </span><span class="kt">for</span><span class="w"> </span>bigint<span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">f</span><span class="p">()</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>pure<span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span>bigint<span class="w"> </span><span class="kt">memory</span><span class="w"> </span>x<span class="w"> </span><span class="o">=</span><span class="w"> </span>BigInt<span class="p">.</span>fromUint<span class="p">(</span><span class="m m-Decimal">7</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span>bigint<span class="w"> </span><span class="kt">memory</span><span class="w"> </span>y<span class="w"> </span><span class="o">=</span><span class="w"> </span>BigInt<span class="p">.</span>fromUint<span class="p">(</span>type<span class="p">(</span><span class="kt">uint</span><span class="p">).</span>max<span class="p">);</span><span class="w"></span>
<span class="w">        </span>bigint<span class="w"> </span><span class="kt">memory</span><span class="w"> </span>z<span class="w"> </span><span class="o">=</span><span class="w"> </span>x<span class="p">.</span>add<span class="p">(</span>y<span class="p">);</span><span class="w"></span>
<span class="w">        </span>assert<span class="p">(</span>z<span class="p">.</span>limb<span class="p">(</span><span class="m m-Decimal">1</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="m m-Decimal">0</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>通过将库合约的类型转换为 <code class="docutils literal notranslate"><span class="pre">address</span></code> 类型，即使用 <code class="docutils literal notranslate"><span class="pre">address(LibraryName)</span></code>，可以获得一个库的地址。</p>
<p>由于编译器不知道库合约的部署地址，
编译后的十六进制代码将包含 <code class="docutils literal notranslate"><span class="pre">__$30bbc0abd4d6364515865950d3e0d10953$__</span></code> 形式的占位符。
占位符是完全等同于库合约名的keccak256哈希值的34个字符的前缀，例如 <code class="docutils literal notranslate"><span class="pre">libraries/bigint.sol:BigInt</span></code>，
如果该库存储在 <code class="docutils literal notranslate"><span class="pre">libraries/</span></code> 目录下一个名为 <code class="docutils literal notranslate"><span class="pre">bigint.sol</span></code> 的文件中。
这样的字节码是不完整的，不应该被部署。占位符需要被替换成实际地址。
您可以在编译库的时候把它们传递给编译器，或者用链接器来更新已经编译好的二进制文件。
参见 <a class="reference internal" href="using-the-compiler.html#library-linking"><span class="std std-ref">库链接</span></a>，了解如何使用命令行编译器进行链接。</p>
<p>与合约相比，库在以下方面受到限制：</p>
<ul class="simple">
<li><p>它们不能有状态变量</p></li>
<li><p>它们不能继承，也不能被继承</p></li>
<li><p>它们不能接收以太</p></li>
<li><p>它们不能被销毁</p></li>
</ul>
<p>(这些可能会在以后的时间里被解除)。</p>
<span class="target" id="library-selectors"></span><section id="index-26">
<span id="id34"></span><h3>库合约中的函数签名和选择器<a class="headerlink" href="#index-26" title="Permalink to this heading"></a></h3>
<p>虽然对公共或外部库函数的外部调用是可能的，但这种调用的调用惯例被认为是 Solidity 内部的，
与常规 <a class="reference internal" href="abi-spec.html#abi"><span class="std std-ref">合约 ABI</span></a> 所指定的不一样。
外部库函数比外部合约函数支持更多的参数类型，例如递归结构和存储指针。
由于这个原因，用于计算4字节选择器的函数签名是按照内部命名模式计算的，
合约ABI中不支持的类型的参数使用内部编码。</p>
<p>签名中的类型使用了以下标识符：</p>
<ul class="simple">
<li><p>值类型、非存储的 <code class="docutils literal notranslate"><span class="pre">string</span></code> 和非存储的 <code class="docutils literal notranslate"><span class="pre">bytes</span></code> 使用与合约ABI中相同的标识符。</p></li>
<li><p>非存储数组类型遵循与合约ABI中相同的惯例，即 <code class="docutils literal notranslate"><span class="pre">&lt;type&gt;[]</span></code> 用于动态数组，
<code class="docutils literal notranslate"><span class="pre">&lt;type&gt;[M]</span></code> 用于 <code class="docutils literal notranslate"><span class="pre">M</span></code> 元素的固定大小数组。</p></li>
<li><p>非存储结构体用其完全等同于的名称来指代，即 <code class="docutils literal notranslate"><span class="pre">C.S</span></code> 代表 <code class="docutils literal notranslate"><span class="pre">contract</span> <span class="pre">C</span> <span class="pre">{</span> <span class="pre">struct</span> <span class="pre">S</span> <span class="pre">{</span> <span class="pre">...</span> <span class="pre">}</span> <span class="pre">}</span></code>。</p></li>
<li><p>存储指针映射使用 <code class="docutils literal notranslate"><span class="pre">mapping(&lt;keyType&gt;</span> <span class="pre">=&gt;</span> <span class="pre">&lt;valueType&gt;)</span> <span class="pre">storage</span></code>，
其中 <code class="docutils literal notranslate"><span class="pre">&lt;keyType&gt;</span></code> 和 <code class="docutils literal notranslate"><span class="pre">&lt;valueType&gt;</span></code> 分别是映射的键和值类型的标识。</p></li>
<li><p>其他存储指针类型使用其对应的非存储类型的类型标识符，但在其后面附加一个空格，即 <code class="docutils literal notranslate"><span class="pre">storage</span></code>。</p></li>
</ul>
<p>参数的编码与普通合约ABI相同，除了存储指针，
它被编码为一个 <code class="docutils literal notranslate"><span class="pre">uint256</span></code> 值，指的是它们所指向的存储槽。</p>
<p>与合约ABI类似，选择器由签名的Keccak256-hash的前四个字节组成。
它的值可以通过使用 <code class="docutils literal notranslate"><span class="pre">.selector</span></code> 成员从 Solidity 获得，如下：</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.13&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC41LjE0IDwwLjkuMDsKCmxpYnJhcnkgTCB7CiAgICBmdW5jdGlvbiBmKHVpbnQyNTYpIGV4dGVybmFsIHt9Cn0KCmNvbnRyYWN0IEMgewogICAgZnVuY3Rpb24gZygpIHB1YmxpYyBwdXJlIHJldHVybnMgKGJ5dGVzNCkgewogICAgICAgIHJldHVybiBMLmYuc2VsZWN0b3I7CiAgICB9Cn0="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.5.14</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span><span class="w"></span>

<span class="kt">library</span><span class="w"> </span>L<span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">f</span><span class="p">(</span><span class="kt">uint256</span><span class="p">)</span><span class="w"> </span><span class="kt">external</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">contract</span><span class="w"> </span><span class="ni">C</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">g</span><span class="p">()</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>pure<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span>bytes4<span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">return</span><span class="w"> </span>L<span class="p">.</span>f<span class="p">.</span>selector<span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="call-protection">
<span id="id35"></span><h3>库的调用保护<a class="headerlink" href="#call-protection" title="Permalink to this heading"></a></h3>
<p>正如介绍中提到的那样，如果库的代码是通过 <code class="docutils literal notranslate"><span class="pre">CALL</span></code> 来执行，
而不是 <code class="docutils literal notranslate"><span class="pre">DELEGATECALL</span></code> 或者 <code class="docutils literal notranslate"><span class="pre">CALLCODE</span></code>，
那么执行的结果会被恢复， 除非是对 <code class="docutils literal notranslate"><span class="pre">view</span></code> 或者 <code class="docutils literal notranslate"><span class="pre">pure</span></code> 函数的调用。</p>
<p>EVM没有提供一个直接的方法让合约检测它是否被使用 <code class="docutils literal notranslate"><span class="pre">CALL</span></code> 调用，
但是合约可以使用 <code class="docutils literal notranslate"><span class="pre">ADDRESS</span></code> 操作码来找出它当前运行的 “位置”。
生成的代码将这个地址与构造时使用的地址进行比较，以确定调用的模式。</p>
<p>更具体地说，一个库合约的运行时代码总是以 push 指令开始，
在编译时它是一个20字节的零。
当部署代码运行时，这个常数在内存中被当前地址所取代，这个修改后的代码被存储在合约中。
在运行时，这导致部署时的地址成为第一个被推入堆栈的常数，
对于任何 非-view 和 非-pure 函数，调度器代码会将当前地址与这个常数进行比较。</p>
<p>这意味着一个存储在链上的库合约的实际代码，与编译器报告的 <code class="docutils literal notranslate"><span class="pre">deployedBytecode</span></code> 的代码不同。</p>
</section>
</section>
<section id="using-for">
<span id="index-27"></span><span id="id36"></span><h2>Using For<a class="headerlink" href="#using-for" title="Permalink to this heading"></a></h2>
<p>指令 <code class="docutils literal notranslate"><span class="pre">use</span> <span class="pre">A</span> <span class="pre">for</span> <span class="pre">B;</span></code> 可以用来将库函数（来自库 <code class="docutils literal notranslate"><span class="pre">A</span></code>）附加到合约背景下的任何类型（ <code class="docutils literal notranslate"><span class="pre">B</span></code>）。
这些函数将接收它们被调用的对象作为其第一个参数（就像Python中的 <code class="docutils literal notranslate"><span class="pre">self</span></code> 变量）。</p>
<p><code class="docutils literal notranslate"><span class="pre">using</span> <span class="pre">A</span> <span class="pre">for</span> <span class="pre">*;</span></code> 的效果是，库合约 <code class="docutils literal notranslate"><span class="pre">A</span></code> 中的函数被附加在 <em>任意</em> 的类型上。</p>
<p>在这两种情况下， <em>所有</em> 函数都会被附加一个参数，
即使它们的第一个参数类型与对象的类型不匹配。 函数调用和重载解析时才会做类型检查。</p>
<p><code class="docutils literal notranslate"><span class="pre">using</span> <span class="pre">A</span> <span class="pre">for</span> <span class="pre">B;</span></code> 指令只在当前的合约内有效，包括其所有的功能，在使用该指令的合约之外没有效果。
该指令只能在合约内使用，不能在其任何函数内使用。</p>
<p>让我们用这种方式将 <a class="reference internal" href="#libraries"><span class="std std-ref">库合约</span></a> 中的 set 例子重写:</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.13&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjAgPDAuOS4wOwoKCi8vIOi/meaYr+WSjOS5i+WJjeS4gOagt+eahOS7o+egge+8jOWPquaYr+ayoeacieazqOmHiuOAggpzdHJ1Y3QgRGF0YSB7IG1hcHBpbmcodWludCA9PiBib29sKSBmbGFnczsgfQoKbGlicmFyeSBTZXQgewogICAgZnVuY3Rpb24gaW5zZXJ0KERhdGEgc3RvcmFnZSBzZWxmLCB1aW50IHZhbHVlKQogICAgICAgIHB1YmxpYwogICAgICAgIHJldHVybnMgKGJvb2wpCiAgICB7CiAgICAgICAgaWYgKHNlbGYuZmxhZ3NbdmFsdWVdKQogICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIOW3sue7j+WtmOWcqAogICAgICAgIHNlbGYuZmxhZ3NbdmFsdWVdID0gdHJ1ZTsKICAgICAgICByZXR1cm4gdHJ1ZTsKICAgIH0KCiAgICBmdW5jdGlvbiByZW1vdmUoRGF0YSBzdG9yYWdlIHNlbGYsIHVpbnQgdmFsdWUpCiAgICAgICAgcHVibGljCiAgICAgICAgcmV0dXJucyAoYm9vbCkKICAgIHsKICAgICAgICBpZiAoIXNlbGYuZmxhZ3NbdmFsdWVdKQogICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIOS4jeWtmOWcqAogICAgICAgIHNlbGYuZmxhZ3NbdmFsdWVdID0gZmFsc2U7CiAgICAgICAgcmV0dXJuIHRydWU7CiAgICB9CgogICAgZnVuY3Rpb24gY29udGFpbnMoRGF0YSBzdG9yYWdlIHNlbGYsIHVpbnQgdmFsdWUpCiAgICAgICAgcHVibGljCiAgICAgICAgdmlldwogICAgICAgIHJldHVybnMgKGJvb2wpCiAgICB7CiAgICAgICAgcmV0dXJuIHNlbGYuZmxhZ3NbdmFsdWVdOwogICAgfQp9CgoKY29udHJhY3QgQyB7CiAgICB1c2luZyBTZXQgZm9yIERhdGE7IC8vIOi/memHjOaYr+WFs+mUrueahOS/ruaUuQogICAgRGF0YSBrbm93blZhbHVlczsKCiAgICBmdW5jdGlvbiByZWdpc3Rlcih1aW50IHZhbHVlKSBwdWJsaWMgewogICAgICAgIC8vIOi/memHjO+8jCBEYXRhIOexu+Wei+eahOaJgOacieWPmOmHj+mDveacieS4juS5i+ebuOWvueW6lOeahOaIkOWRmOWHveaVsOOAggogICAgICAgIC8vIOS4i+mdoueahOWHveaVsOiwg+eUqOWSjCBgU2V0Lmluc2VydChrbm93blZhbHVlcywgdmFsdWUpYCDnmoTmlYjmnpzlrozlhajnm7jlkIzjgIIKICAgICAgICByZXF1aXJlKGtub3duVmFsdWVzLmluc2VydCh2YWx1ZSkpOwogICAgfQp9"><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.6.0</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span><span class="w"></span>


<span class="c1">// 这是和之前一样的代码，只是没有注释。</span>
<span class="kt">struct</span><span class="w"> </span><span class="nv">Data</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="kt">mapping</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="kt">bool</span><span class="p">)</span><span class="w"> </span>flags<span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>

<span class="kt">library</span><span class="w"> </span>Set<span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">insert</span><span class="p">(</span>Data<span class="w"> </span>storage<span class="w"> </span>self<span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="nv">value</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="kt">public</span><span class="w"></span>
<span class="w">        </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">bool</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">if</span><span class="w"> </span><span class="p">(</span>self<span class="p">.</span>flags<span class="p">[</span>value<span class="p">])</span><span class="w"></span>
<span class="w">            </span><span class="kt">return</span><span class="w"> </span><span class="kt">false</span><span class="p">;</span><span class="w"> </span><span class="c1">// 已经存在</span>
<span class="w">        </span>self<span class="p">.</span>flags<span class="p">[</span>value<span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">true</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="kt">return</span><span class="w"> </span><span class="kt">true</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">remove</span><span class="p">(</span>Data<span class="w"> </span>storage<span class="w"> </span>self<span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="nv">value</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="kt">public</span><span class="w"></span>
<span class="w">        </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">bool</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span>self<span class="p">.</span>flags<span class="p">[</span>value<span class="p">])</span><span class="w"></span>
<span class="w">            </span><span class="kt">return</span><span class="w"> </span><span class="kt">false</span><span class="p">;</span><span class="w"> </span><span class="c1">// 不存在</span>
<span class="w">        </span>self<span class="p">.</span>flags<span class="p">[</span>value<span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">false</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="kt">return</span><span class="w"> </span><span class="kt">true</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">contains</span><span class="p">(</span>Data<span class="w"> </span>storage<span class="w"> </span>self<span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="nv">value</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="kt">public</span><span class="w"></span>
<span class="w">        </span>view<span class="w"></span>
<span class="w">        </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">bool</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">return</span><span class="w"> </span>self<span class="p">.</span>flags<span class="p">[</span>value<span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>


<span class="k">contract</span><span class="w"> </span><span class="ni">C</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span>using<span class="w"> </span>Set<span class="w"> </span><span class="kt">for</span><span class="w"> </span>Data<span class="p">;</span><span class="w"> </span><span class="c1">// 这里是关键的修改</span>
<span class="w">    </span>Data<span class="w"> </span>knownValues<span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">register</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">value</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// 这里， Data 类型的所有变量都有与之相对应的成员函数。</span>
<span class="w">        </span><span class="c1">// 下面的函数调用和 `Set.insert(knownValues, value)` 的效果完全相同。</span>
<span class="w">        </span><span class="kt">require</span><span class="p">(</span>knownValues<span class="p">.</span>insert<span class="p">(</span>value<span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>也可以像这样扩展基本类型:</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.13&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC42LjggPDAuOS4wOwoKbGlicmFyeSBTZWFyY2ggewogICAgZnVuY3Rpb24gaW5kZXhPZih1aW50W10gc3RvcmFnZSBzZWxmLCB1aW50IHZhbHVlKQogICAgICAgIHB1YmxpYwogICAgICAgIHZpZXcKICAgICAgICByZXR1cm5zICh1aW50KQogICAgewogICAgICAgIGZvciAodWludCBpID0gMDsgaSA8IHNlbGYubGVuZ3RoOyBpKyspCiAgICAgICAgICAgIGlmIChzZWxmW2ldID09IHZhbHVlKSByZXR1cm4gaTsKICAgICAgICByZXR1cm4gdHlwZSh1aW50KS5tYXg7CiAgICB9Cn0KCmNvbnRyYWN0IEMgewogICAgdXNpbmcgU2VhcmNoIGZvciB1aW50W107CiAgICB1aW50W10gZGF0YTsKCiAgICBmdW5jdGlvbiBhcHBlbmQodWludCB2YWx1ZSkgcHVibGljIHsKICAgICAgICBkYXRhLnB1c2godmFsdWUpOwogICAgfQoKICAgIGZ1bmN0aW9uIHJlcGxhY2UodWludCBfb2xkLCB1aW50IF9uZXcpIHB1YmxpYyB7CiAgICAgICAgLy8g5omn6KGM5bqT5Ye95pWw6LCD55SoCiAgICAgICAgdWludCBpbmRleCA9IGRhdGEuaW5kZXhPZihfb2xkKTsKICAgICAgICBpZiAoaW5kZXggPT0gdHlwZSh1aW50KS5tYXgpCiAgICAgICAgICAgIGRhdGEucHVzaChfbmV3KTsKICAgICAgICBlbHNlCiAgICAgICAgICAgIGRhdGFbaW5kZXhdID0gX25ldzsKICAgIH0KfQ=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.6.8</span><span class="w"> </span><span class="o">&lt;</span><span class="k">0.9.0</span><span class="p">;</span><span class="w"></span>

<span class="kt">library</span><span class="w"> </span>Search<span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">indexOf</span><span class="p">(</span><span class="kt">uint</span><span class="p">[]</span><span class="w"> </span>storage<span class="w"> </span>self<span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="nv">value</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="kt">public</span><span class="w"></span>
<span class="w">        </span>view<span class="w"></span>
<span class="w">        </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">for</span><span class="w"> </span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m m-Decimal">0</span><span class="p">;</span><span class="w"> </span>i<span class="w"> </span><span class="o">&lt;</span><span class="w"> </span>self<span class="p">.</span>length<span class="p">;</span><span class="w"> </span>i<span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="kt">if</span><span class="w"> </span><span class="p">(</span>self<span class="p">[</span>i<span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span>value<span class="p">)</span><span class="w"> </span><span class="kt">return</span><span class="w"> </span>i<span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="kt">return</span><span class="w"> </span>type<span class="p">(</span><span class="kt">uint</span><span class="p">).</span>max<span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">contract</span><span class="w"> </span><span class="ni">C</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span>using<span class="w"> </span>Search<span class="w"> </span><span class="kt">for</span><span class="w"> </span><span class="kt">uint</span><span class="p">[];</span><span class="w"></span>
<span class="w">    </span><span class="kt">uint</span><span class="p">[]</span><span class="w"> </span>data<span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">append</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">value</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span>data<span class="p">.</span>push<span class="p">(</span>value<span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">replace</span><span class="p">(</span><span class="kt">uint</span><span class="w"> </span><span class="nv">_old</span><span class="p">,</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="nv">_new</span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// 执行库函数调用</span>
<span class="w">        </span><span class="kt">uint</span><span class="w"> </span><span class="nv">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>data<span class="p">.</span>indexOf<span class="p">(</span>_old<span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kt">if</span><span class="w"> </span><span class="p">(</span>index<span class="w"> </span><span class="o">==</span><span class="w"> </span>type<span class="p">(</span><span class="kt">uint</span><span class="p">).</span>max<span class="p">)</span><span class="w"></span>
<span class="w">            </span>data<span class="p">.</span>push<span class="p">(</span>_new<span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kt">else</span><span class="w"></span>
<span class="w">            </span>data<span class="p">[</span>index<span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>_new<span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>注意，所有的外部库调用实际都是EVM函数调用。
这意味着，如果你传递内存或值类型，将进行拷贝，即使是在 <code class="docutils literal notranslate"><span class="pre">self</span></code> 变量的情况下。
唯一不进行拷贝的情况是当使用存储引用变量或调用内部库函数时。</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="control-structures.html" class="btn btn-neutral float-left" title="表达式和控制结构" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="assembly.html" class="btn btn-neutral float-right" title="内联汇编" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2016-2021, Ethereum.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
  
    <p>
        <a href="credits-and-attribution.html">Credits and attribution</a>.
    </p>


</footer>
        </div>
      </div>
    </section>
  </div>
  
<div class="rst-versions" data-toggle="rst-versions" role="note" aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
    <span class="fa fa-book fa-element"> RTD </span>

    <span class="fa fa-element">
    <input class="container_toggle" type="checkbox" id="switch" name="mode">
    <label for="switch"></label>
    </span>

    <span class="fa fa-v fa-element"> v:  <span class="fa fa-caret-down"></span></span>

    </span>
    <div class="rst-other-versions">
        <dl>
            <dt>Downloads</dt> 
        </dl>
        <dl>
            <dt>Versions</dt> 
        </dl>
        <dl>
            
            <dt>On Read the Docs</dt>
            <dd>
                <a href="///projects//?fromdocs=">Project Home</a>
            </dd>
            <dd>
                <a href="///builds//?fromdocs=">Builds</a>
            </dd>
        </dl>
    </div>
</div><script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>