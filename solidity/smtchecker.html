<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>SMT检查器和形式化验证 &mdash; Solidity 0.8.13 documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="_static/a4_railroad_diagram.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/custom.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/toggle.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/sphinx_highlight.js"></script>
        <script src="_static/js/toggle.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="资源" href="resources.html" />
    <link rel="prev" title="安全考虑" href="security-considerations.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #65afff" >
            <a href="index.html">
            <img src="_static/logo.svg" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                0.8.13
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
    
              <p class="caption" role="heading"><span class="caption-text">Basics</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="introduction-to-smart-contracts.html">智能合约概述</a></li>
<li class="toctree-l1"><a class="reference internal" href="installing-solidity.html">安装 Solidity 编译器</a></li>
<li class="toctree-l1"><a class="reference internal" href="solidity-by-example.html">Solidity 合约示例</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Language Description</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="layout-of-source-files.html">Solidity 源文件结构</a></li>
<li class="toctree-l1"><a class="reference internal" href="structure-of-a-contract.html">合约结构</a></li>
<li class="toctree-l1"><a class="reference internal" href="types.html">类型</a></li>
<li class="toctree-l1"><a class="reference internal" href="units-and-global-variables.html">单位和全局变量</a></li>
<li class="toctree-l1"><a class="reference internal" href="control-structures.html">表达式和控制结构</a></li>
<li class="toctree-l1"><a class="reference internal" href="contracts.html">合约</a></li>
<li class="toctree-l1"><a class="reference internal" href="assembly.html">内联汇编</a></li>
<li class="toctree-l1"><a class="reference internal" href="cheatsheet.html">速查表</a></li>
<li class="toctree-l1"><a class="reference internal" href="grammar.html">语法</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Compiler</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="using-the-compiler.html">使用编译器</a></li>
<li class="toctree-l1"><a class="reference internal" href="analysing-compilation-output.html">分析编译器的输出结果</a></li>
<li class="toctree-l1"><a class="reference internal" href="ir-breaking-changes.html">基于Solidity中间表征的Codegen变化</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Internals</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="internals/layout_in_storage.html">存储中的状态变量储存结构</a></li>
<li class="toctree-l1"><a class="reference internal" href="internals/layout_in_memory.html">内存中的存储结构</a></li>
<li class="toctree-l1"><a class="reference internal" href="internals/layout_in_calldata.html">调用数据的存储结构</a></li>
<li class="toctree-l1"><a class="reference internal" href="internals/variable_cleanup.html">清理变量</a></li>
<li class="toctree-l1"><a class="reference internal" href="internals/source_mappings.html">源代码映射</a></li>
<li class="toctree-l1"><a class="reference internal" href="internals/optimizer.html">优化器</a></li>
<li class="toctree-l1"><a class="reference internal" href="metadata.html">合约的元数据</a></li>
<li class="toctree-l1"><a class="reference internal" href="abi-spec.html">合约ABI规范</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Additional Material</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="050-breaking-changes.html">Solidity v0.5.0 突破性变化</a></li>
<li class="toctree-l1"><a class="reference internal" href="060-breaking-changes.html">Solidity 0.6.0 版本突破性变化</a></li>
<li class="toctree-l1"><a class="reference internal" href="070-breaking-changes.html">Solidity v0.7.0 突破性变化</a></li>
<li class="toctree-l1"><a class="reference internal" href="080-breaking-changes.html">Solidity v0.8.0 突破性变化</a></li>
<li class="toctree-l1"><a class="reference internal" href="natspec-format.html">风格指南</a></li>
<li class="toctree-l1"><a class="reference internal" href="security-considerations.html">安全考虑</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">SMT检查器和形式化验证</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id1">教程</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id2">溢出</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id3">断言</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id4">状态属性</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id5">外部调用和重入</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#smtchecker-options">SMT检查器选项和调试</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id7">超时</a></li>
<li class="toctree-l3"><a class="reference internal" href="#smtchecker-targets">验证目标</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id9">未验证的目标</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id10">已验证过的合约</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id11">报告推断的归纳变量</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id12">有松弛变量的除法和模数运算</a></li>
<li class="toctree-l3"><a class="reference internal" href="#natspec">Natspec标签函数抽象化</a></li>
<li class="toctree-l3"><a class="reference internal" href="#smtchecker-engines">模型检查引擎</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#bmc">有界模型检查器 （BMC）</a></li>
<li class="toctree-l4"><a class="reference internal" href="#constrained-horn-clauses-chc">受约束的角条款（Constrained Horn Clauses， CHC）</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#smthorn">SMT和Horn求解器</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id15">抽象和假阳性结果</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id16">SMT的编码和类型</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id17">函数调用</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id18">引用类型和别名</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id19">合约余额</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id20">现实世界的假设</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="resources.html">资源</a></li>
<li class="toctree-l1"><a class="reference internal" href="path-resolution.html">Import Path Resolution</a></li>
<li class="toctree-l1"><a class="reference internal" href="yul.html">Yul</a></li>
<li class="toctree-l1"><a class="reference internal" href="style-guide.html">风格指南</a></li>
<li class="toctree-l1"><a class="reference internal" href="common-patterns.html">通用模式</a></li>
<li class="toctree-l1"><a class="reference internal" href="bugs.html">已知bug列表</a></li>
<li class="toctree-l1"><a class="reference internal" href="contributing.html">贡献方式</a></li>
<li class="toctree-l1"><a class="reference internal" href="brand-guide.html">Solidity 品牌指南</a></li>
<li class="toctree-l1"><a class="reference internal" href="language-influences.html">Language Influences</a></li>
</ul>

    <ul>
        <li>
            <a href="genindex.html">Keyword Index</a>
        </li>
    </ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: #65afff" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Solidity</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
      <li>SMT检查器和形式化验证</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/smtchecker.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="smt">
<span id="formal-verification"></span><h1>SMT检查器和形式化验证<a class="headerlink" href="#smt" title="Permalink to this heading"></a></h1>
<p>使用形式化验证，有可能进行自动数学证明，
证明您的源代码符合某种形式化规范。
该规范仍然是正式的（就像源代码一样），但通常要简单得多。</p>
<p>请注意，形式化验证本身只能帮助您理解您所做的（规范）和您如何做的（实际实现）之间的区别。
您仍然需要检查规范是否是您想要的，以及您没有遗漏任何意想不到的效果。</p>
<p>Solidity 实现了基于 <a class="reference external" href="https://en.wikipedia.org/wiki/Satisfiability_modulo_theoris">SMT（可满足性模型理论（Satisfiability Modulo Theories）</a>
和 <a class="reference external" href="https://en.wikipedia.org/wiki/Horn-satisfiability">Horn</a> 解决的形式验证方法。
SMT检查器模块自动尝试证明代码满足由 <code class="docutils literal notranslate"><span class="pre">require</span></code> 和 <code class="docutils literal notranslate"><span class="pre">assert</span></code> 语句给出的规范。
也就是说，它把 <code class="docutils literal notranslate"><span class="pre">require</span></code> 语句视为假设，并试图证明 <code class="docutils literal notranslate"><span class="pre">assert</span></code> 语句中的条件总是真的。
如果发现断言失败，则可以向用户提供一个反例，说明断言是如何被违反的。
如果 SMT 检查器对某一属性没有给出警告，这意味着该属性是安全的。</p>
<p>SMT 检查器在编译时检查的其他验证目标有：</p>
<ul class="simple">
<li><p>算术上的下溢和溢出。</p></li>
<li><p>除以0的除法。</p></li>
<li><p>无用的条件和无法访问的代码。</p></li>
<li><p>弹出一个空数组。</p></li>
<li><p>超出界限的索引访问。</p></li>
<li><p>转账资金不足。</p></li>
</ul>
<p>如果所有检查引擎都被启用，上述所有目标都被默认为自动检查，
除了 Solidity &gt;=0.8.7 的下溢和溢出。</p>
<p>SMT 检查器所报告的潜在警告是：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">&lt;失败的属性&gt;</span> <span class="pre">发生在这里</span></code>。这意味着 SMT 检查器证明了某一属性失败。可能会给出一个反例，但是在复杂的情况下，也可能不会显示反例。在某些情况下，当 SMT 编码为 Solidity 代码添加了难以表达或无法表达的抽象时，这个结果也可能是一个假阳性。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&lt;失败的属性&gt;</span> <span class="pre">可能发生在这里</span></code>。这意味着求解器无法在给定的超时时间内证明两种情况。由于结果是未知的，SMT 检查器会报告潜在的健全性失败。这可以通过增加查询超时时间来解决，但问题也可能只是对引擎来说太难解决。</p></li>
</ul>
<p>要启用SMT检查器，您必须选择 <a class="reference internal" href="#smtchecker-engines"><span class="std std-ref">应该运行哪一个引擎</span></a>，
其中默认的是没有引擎。选择引擎可以在所有文件上启用SMT检查器。</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>在 Solidity 0.8.4 之前，启用SMT检查器的默认方式是通过 <code class="docutils literal notranslate"><span class="pre">pragma</span> <span class="pre">experimental</span> <span class="pre">SMTChecker;</span></code>
并且只有包含 pragma 的合约才会被分析。该 pragma 已被弃用，
尽管它仍能使SMT检查器向后兼容，但它将在 Solidity 0.9.0 中被移除。
还要注意的是，现在即使在一个文件中使用 pragma，也会对所有文件启用SMT检查器。</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>假设SMT检查器和底层求解器中没有错误，
那么验证目标没有警告就代表了一个无可争议的正确性数学证明。
请记住，这些问题在一般情况下是 <em>很难</em> 的，有时是 <em>不可能</em> 自动解决的。
因此，有几个属性可能无法解决，或者可能导致大型合约的假阳性。
每一个被证明的属性都应该被看作是一个重要的成就。
对于高级用户，请参阅 <a class="reference internal" href="#smtchecker-options"><span class="std std-ref">SMT检查器 调优</span></a>
来了解一些可能有助于证明更复杂属性的选项。</p>
</div>
<section id="id1">
<h2>教程<a class="headerlink" href="#id1" title="Permalink to this heading"></a></h2>
<section id="id2">
<h3>溢出<a class="headerlink" href="#id2" title="Permalink to this heading"></a></h3>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.13&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC44LjA7Cgpjb250cmFjdCBPdmVyZmxvdyB7CiAgICB1aW50IGltbXV0YWJsZSB4OwogICAgdWludCBpbW11dGFibGUgeTsKCiAgICBmdW5jdGlvbiBhZGQodWludCBfeCwgdWludCBfeSkgaW50ZXJuYWwgcHVyZSByZXR1cm5zICh1aW50KSB7CiAgICAgICAgcmV0dXJuIF94ICsgX3k7CiAgICB9CgogICAgY29uc3RydWN0b3IodWludCBfeCwgdWludCBfeSkgewogICAgICAgICh4LCB5KSA9IChfeCwgX3kpOwogICAgfQoKICAgIGZ1bmN0aW9uIHN0YXRlQWRkKCkgcHVibGljIHZpZXcgcmV0dXJucyAodWludCkgewogICAgICAgIHJldHVybiBhZGQoeCwgeSk7CiAgICB9Cn0="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-Solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// </span><span class="cs">SPDX-License-Identifier:</span><span class="c1"> GPL-3.0</span>
<span class="k">pragma solidity</span> <span class="o">&gt;=</span><span class="mf">0.8</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

<span class="kd">contract</span> <span class="n">Overflow</span> <span class="p">{</span>
    <span class="kt">uint</span> <span class="kr">immutable</span> <span class="n">x</span><span class="p">;</span>
    <span class="kt">uint</span> <span class="kr">immutable</span> <span class="n">y</span><span class="p">;</span>

    <span class="kd">function</span> <span class="n">add</span><span class="p">(</span><span class="kt">uint</span> <span class="n">_x</span><span class="p">,</span> <span class="kt">uint</span> <span class="n">_y</span><span class="p">)</span> <span class="k">internal</span> <span class="k">pure</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">_x</span> <span class="o">+</span> <span class="n">_y</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kd">constructor</span><span class="p">(</span><span class="kt">uint</span> <span class="n">_x</span><span class="p">,</span> <span class="kt">uint</span> <span class="n">_y</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">_x</span><span class="p">,</span> <span class="n">_y</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="n">stateAdd</span><span class="p">()</span> <span class="k">public</span> <span class="k">view</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">add</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上面的合约显示了一个溢出检查的例子。
对于 Solidity &gt;=0.8.7，SMT检查器默认不检查下溢和溢出，
所以我们需要使用命令行选项 <code class="docutils literal notranslate"><span class="pre">--model-checker-targets</span> <span class="pre">&quot;underflow,overflow&quot;</span></code>
或者JSON选项 <code class="docutils literal notranslate"><span class="pre">settings.modelChecker.targets</span> <span class="pre">=</span> <span class="pre">[&quot;underflow&quot;,</span> <span class="pre">&quot;overflow&quot;]</span></code>。
参见 <a class="reference internal" href="#smtchecker-targets"><span class="std std-ref">本节的目标配置</span></a>。此处，它报告如下：</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Warning: CHC: Overflow (resulting value larger than 2**256 - 1) happens here.
Counterexample:
x = 1, y = 115792089237316195423570985008687907853269984665640564039457584007913129639935
 = 0

Transaction trace:
Overflow.constructor(1, 115792089237316195423570985008687907853269984665640564039457584007913129639935)
State: x = 1, y = 115792089237316195423570985008687907853269984665640564039457584007913129639935
Overflow.stateAdd()
    Overflow.add(1, 115792089237316195423570985008687907853269984665640564039457584007913129639935) -- internal call
 --&gt; o.sol:9:20:
  |
9 |             return _x + _y;
  |                    ^^^^^^^
</pre></div>
</div>
<p>如果我们添加了过滤掉溢出情况的 <code class="docutils literal notranslate"><span class="pre">require</span></code> 语句，
SMT检查器就会证明没有溢出是可以达到的（会通过不报告警告表现出来）。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.13&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC44LjA7Cgpjb250cmFjdCBPdmVyZmxvdyB7CiAgICB1aW50IGltbXV0YWJsZSB4OwogICAgdWludCBpbW11dGFibGUgeTsKCiAgICBmdW5jdGlvbiBhZGQodWludCBfeCwgdWludCBfeSkgaW50ZXJuYWwgcHVyZSByZXR1cm5zICh1aW50KSB7CiAgICAgICAgcmV0dXJuIF94ICsgX3k7CiAgICB9CgogICAgY29uc3RydWN0b3IodWludCBfeCwgdWludCBfeSkgewogICAgICAgICh4LCB5KSA9IChfeCwgX3kpOwogICAgfQoKICAgIGZ1bmN0aW9uIHN0YXRlQWRkKCkgcHVibGljIHZpZXcgcmV0dXJucyAodWludCkgewogICAgICAgIHJlcXVpcmUoeCA8IHR5cGUodWludDEyOCkubWF4KTsKICAgICAgICByZXF1aXJlKHkgPCB0eXBlKHVpbnQxMjgpLm1heCk7CiAgICAgICAgcmV0dXJuIGFkZCh4LCB5KTsKICAgIH0KfQ=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-Solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// </span><span class="cs">SPDX-License-Identifier:</span><span class="c1"> GPL-3.0</span>
<span class="k">pragma solidity</span> <span class="o">&gt;=</span><span class="mf">0.8</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

<span class="kd">contract</span> <span class="n">Overflow</span> <span class="p">{</span>
    <span class="kt">uint</span> <span class="kr">immutable</span> <span class="n">x</span><span class="p">;</span>
    <span class="kt">uint</span> <span class="kr">immutable</span> <span class="n">y</span><span class="p">;</span>

    <span class="kd">function</span> <span class="n">add</span><span class="p">(</span><span class="kt">uint</span> <span class="n">_x</span><span class="p">,</span> <span class="kt">uint</span> <span class="n">_y</span><span class="p">)</span> <span class="k">internal</span> <span class="k">pure</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">_x</span> <span class="o">+</span> <span class="n">_y</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kd">constructor</span><span class="p">(</span><span class="kt">uint</span> <span class="n">_x</span><span class="p">,</span> <span class="kt">uint</span> <span class="n">_y</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">_x</span><span class="p">,</span> <span class="n">_y</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="n">stateAdd</span><span class="p">()</span> <span class="k">public</span> <span class="k">view</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">require</span><span class="p">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="k">type(uint128).max);</span>
<span class="k">        require(y &lt; type(uint128).max</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">add</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="id3">
<h3>断言<a class="headerlink" href="#id3" title="Permalink to this heading"></a></h3>
<p>断言表示代码中的一个不变量： <em>对于所有的事务，包括所有的输入和存储值</em>，
一个属性必须为真，否则就会出现错误。</p>
<p>下面的代码定义了一个保证没有溢出的函数 <code class="docutils literal notranslate"><span class="pre">f</span></code>。
函数 <code class="docutils literal notranslate"><span class="pre">inv</span></code> 定义了 <code class="docutils literal notranslate"><span class="pre">f</span></code> 是单调递增的规范：
对于每个可能的数值对 <code class="docutils literal notranslate"><span class="pre">(_a,</span> <span class="pre">_b)</span></code>，如果 <code class="docutils literal notranslate"><span class="pre">_b</span> <span class="pre">&gt;</span> <span class="pre">_a</span></code>，那么 <code class="docutils literal notranslate"><span class="pre">f(_b)</span> <span class="pre">&gt;</span> <span class="pre">f(_a)</span></code>。
由于 <code class="docutils literal notranslate"><span class="pre">f</span></code> 确实是单调增长的，SMT检查器证明了我们的属性是正确的。
我们鼓励您试试这个属性和函数定义，看看会有什么样的结果!</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.13&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC44LjA7Cgpjb250cmFjdCBNb25vdG9uaWMgewogICAgZnVuY3Rpb24gZih1aW50IF94KSBpbnRlcm5hbCBwdXJlIHJldHVybnMgKHVpbnQpIHsKICAgICAgICByZXF1aXJlKF94IDwgdHlwZSh1aW50MTI4KS5tYXgpOwogICAgICAgIHJldHVybiBfeCAqIDQyOwogICAgfQoKICAgIGZ1bmN0aW9uIGludih1aW50IF9hLCB1aW50IF9iKSBwdWJsaWMgcHVyZSB7CiAgICAgICAgcmVxdWlyZShfYiA+IF9hKTsKICAgICAgICBhc3NlcnQoZihfYikgPiBmKF9hKSk7CiAgICB9Cn0="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-Solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// </span><span class="cs">SPDX-License-Identifier:</span><span class="c1"> GPL-3.0</span>
<span class="k">pragma solidity</span> <span class="o">&gt;=</span><span class="mf">0.8</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

<span class="kd">contract</span> <span class="n">Monotonic</span> <span class="p">{</span>
    <span class="kd">function</span> <span class="n">f</span><span class="p">(</span><span class="kt">uint</span> <span class="n">_x</span><span class="p">)</span> <span class="k">internal</span> <span class="k">pure</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">require</span><span class="p">(</span><span class="n">_x</span> <span class="o">&lt;</span> <span class="k">type(uint128).max</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">_x</span> <span class="o">*</span> <span class="mi">42</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="n">inv</span><span class="p">(</span><span class="kt">uint</span> <span class="n">_a</span><span class="p">,</span> <span class="kt">uint</span> <span class="n">_b</span><span class="p">)</span> <span class="k">public</span> <span class="k">pure</span> <span class="p">{</span>
        <span class="nf">require</span><span class="p">(</span><span class="n">_b</span> <span class="o">&gt;</span> <span class="n">_a</span><span class="p">);</span>
        <span class="nf">assert</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">_b</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">f</span><span class="p">(</span><span class="n">_a</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>我们还可以在循环中添加断言，以验证更多的复杂的属性。
下面的代码搜索一个不受限制的数字数组的最大元素，
并断言找到的元素必须大于或等于数组中的每个元素的属性。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.13&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC44LjA7Cgpjb250cmFjdCBNYXggewogICAgZnVuY3Rpb24gbWF4KHVpbnRbXSBtZW1vcnkgX2EpIHB1YmxpYyBwdXJlIHJldHVybnMgKHVpbnQpIHsKICAgICAgICB1aW50IG0gPSAwOwogICAgICAgIGZvciAodWludCBpID0gMDsgaSA8IF9hLmxlbmd0aDsgKytpKQogICAgICAgICAgICBpZiAoX2FbaV0gPiBtKQogICAgICAgICAgICAgICAgbSA9IF9hW2ldOwoKICAgICAgICBmb3IgKHVpbnQgaSA9IDA7IGkgPCBfYS5sZW5ndGg7ICsraSkKICAgICAgICAgICAgYXNzZXJ0KG0gPj0gX2FbaV0pOwoKICAgICAgICByZXR1cm4gbTsKICAgIH0KfQ=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-Solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// </span><span class="cs">SPDX-License-Identifier:</span><span class="c1"> GPL-3.0</span>
<span class="k">pragma solidity</span> <span class="o">&gt;=</span><span class="mf">0.8</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

<span class="kd">contract</span> <span class="n">Max</span> <span class="p">{</span>
    <span class="kd">function</span> <span class="n">max</span><span class="p">(</span><span class="kt">uint</span><span class="p">[]</span> <span class="k">memory</span> <span class="n">_a</span><span class="p">)</span> <span class="k">public</span> <span class="k">pure</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">uint</span> <span class="n">m</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">uint</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">_a</span><span class="p">.</span><span class="n">length</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">_a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">m</span><span class="p">)</span>
                <span class="n">m</span> <span class="o">=</span> <span class="n">_a</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

        <span class="k">for</span> <span class="p">(</span><span class="kt">uint</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">_a</span><span class="p">.</span><span class="n">length</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
            <span class="nf">assert</span><span class="p">(</span><span class="n">m</span> <span class="o">&gt;=</span> <span class="n">_a</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

        <span class="k">return</span> <span class="n">m</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>注意，在这个例子中，SMT检查器将自动尝试证明三个属性：</p>
<ol class="arabic simple">
<li><p>第一个循环中的 <code class="docutils literal notranslate"><span class="pre">++i</span></code> 不会溢出。</p></li>
<li><p>第二个循环中的 <code class="docutils literal notranslate"><span class="pre">++i</span></code> 不会溢出。</p></li>
<li><p>该断言始终是正确的。</p></li>
</ol>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>这些属性涉及到循环，这使得它比前面的例子 <em>更加</em> 难了，所以要当心循环的问题！</p>
</div>
<p>所有的属性都被正确证明是安全的。
可以随意改变属性和/或在数组上添加限制，以看到不同的结果。例如，将代码改为</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.13&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC44LjA7Cgpjb250cmFjdCBNYXggewogICAgZnVuY3Rpb24gbWF4KHVpbnRbXSBtZW1vcnkgX2EpIHB1YmxpYyBwdXJlIHJldHVybnMgKHVpbnQpIHsKICAgICAgICByZXF1aXJlKF9hLmxlbmd0aCA+PSA1KTsKICAgICAgICB1aW50IG0gPSAwOwogICAgICAgIGZvciAodWludCBpID0gMDsgaSA8IF9hLmxlbmd0aDsgKytpKQogICAgICAgICAgICBpZiAoX2FbaV0gPiBtKQogICAgICAgICAgICAgICAgbSA9IF9hW2ldOwoKICAgICAgICBmb3IgKHVpbnQgaSA9IDA7IGkgPCBfYS5sZW5ndGg7ICsraSkKICAgICAgICAgICAgYXNzZXJ0KG0gPiBfYVtpXSk7CgogICAgICAgIHJldHVybiBtOwogICAgfQp9"><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-Solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// </span><span class="cs">SPDX-License-Identifier:</span><span class="c1"> GPL-3.0</span>
<span class="k">pragma solidity</span> <span class="o">&gt;=</span><span class="mf">0.8</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

<span class="kd">contract</span> <span class="n">Max</span> <span class="p">{</span>
    <span class="kd">function</span> <span class="n">max</span><span class="p">(</span><span class="kt">uint</span><span class="p">[]</span> <span class="k">memory</span> <span class="n">_a</span><span class="p">)</span> <span class="k">public</span> <span class="k">pure</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">require</span><span class="p">(</span><span class="n">_a</span><span class="p">.</span><span class="n">length</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">);</span>
        <span class="kt">uint</span> <span class="n">m</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">uint</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">_a</span><span class="p">.</span><span class="n">length</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">_a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">m</span><span class="p">)</span>
                <span class="n">m</span> <span class="o">=</span> <span class="n">_a</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

        <span class="k">for</span> <span class="p">(</span><span class="kt">uint</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">_a</span><span class="p">.</span><span class="n">length</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
            <span class="nf">assert</span><span class="p">(</span><span class="n">m</span> <span class="o">&gt;</span> <span class="n">_a</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

        <span class="k">return</span> <span class="n">m</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>我们得到的结果：</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Warning: CHC: Assertion violation happens here.
Counterexample:

_a = [0, 0, 0, 0, 0]
 = 0

Transaction trace:
Test.constructor()
Test.max([0, 0, 0, 0, 0])
  --&gt; max.sol:14:4:
   |
14 |            assert(m &gt; _a[i]);
</pre></div>
</div>
</section>
<section id="id4">
<h3>状态属性<a class="headerlink" href="#id4" title="Permalink to this heading"></a></h3>
<p>到目前为止，这些例子只展示了SMT检查器在纯代码上的使用，
证明了关于特定操作或算法的属性。
智能合约中常见的属性类型是涉及合约状态的属性。
对于这样的属性，可能需要多个交易来使断言失效。</p>
<p>举一个例子，考虑一个二维网格，其中两个轴的坐标都在（-2^128, 2^128 - 1）范围内。
让我们在位置（0，0）放置一个机器人。该机器人只能在对角线上移动，一次只能走一步，
不能在网格外移动。机器人的状态机可以用下面的智能合约来表示。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.13&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC44LjA7Cgpjb250cmFjdCBSb2JvdCB7CiAgICBpbnQgeCA9IDA7CiAgICBpbnQgeSA9IDA7CgogICAgbW9kaWZpZXIgd2FsbCB7CiAgICAgICAgcmVxdWlyZSh4ID4gdHlwZShpbnQxMjgpLm1pbiAmJiB4IDwgdHlwZShpbnQxMjgpLm1heCk7CiAgICAgICAgcmVxdWlyZSh5ID4gdHlwZShpbnQxMjgpLm1pbiAmJiB5IDwgdHlwZShpbnQxMjgpLm1heCk7CiAgICAgICAgXzsKICAgIH0KCiAgICBmdW5jdGlvbiBtb3ZlTGVmdFVwKCkgd2FsbCBwdWJsaWMgewogICAgICAgIC0teDsKICAgICAgICArK3k7CiAgICB9CgogICAgZnVuY3Rpb24gbW92ZUxlZnREb3duKCkgd2FsbCBwdWJsaWMgewogICAgICAgIC0teDsKICAgICAgICAtLXk7CiAgICB9CgogICAgZnVuY3Rpb24gbW92ZVJpZ2h0VXAoKSB3YWxsIHB1YmxpYyB7CiAgICAgICAgKyt4OwogICAgICAgICsreTsKICAgIH0KCiAgICBmdW5jdGlvbiBtb3ZlUmlnaHREb3duKCkgd2FsbCBwdWJsaWMgewogICAgICAgICsreDsKICAgICAgICAtLXk7CiAgICB9CgogICAgZnVuY3Rpb24gaW52KCkgcHVibGljIHZpZXcgewogICAgICAgIGFzc2VydCgoeCArIHkpICUgMiA9PSAwKTsKICAgIH0KfQ=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-Solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// </span><span class="cs">SPDX-License-Identifier:</span><span class="c1"> GPL-3.0</span>
<span class="k">pragma solidity</span> <span class="o">&gt;=</span><span class="mf">0.8</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

<span class="kd">contract</span> <span class="n">Robot</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="kd">modifier</span> <span class="n">wall</span> <span class="p">{</span>
        <span class="nf">require</span><span class="p">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="k">type(int128).min &amp;&amp; x &lt; type(int128).max);</span>
<span class="k">        require(y &gt; type(int128).min &amp;&amp; y &lt; type(int128).max</span><span class="p">);</span>
        <span class="k">_</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="n">moveLeftUp</span><span class="p">()</span> <span class="n">wall</span> <span class="k">public</span> <span class="p">{</span>
        <span class="o">--</span><span class="n">x</span><span class="p">;</span>
        <span class="o">++</span><span class="n">y</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="n">moveLeftDown</span><span class="p">()</span> <span class="n">wall</span> <span class="k">public</span> <span class="p">{</span>
        <span class="o">--</span><span class="n">x</span><span class="p">;</span>
        <span class="o">--</span><span class="n">y</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="n">moveRightUp</span><span class="p">()</span> <span class="n">wall</span> <span class="k">public</span> <span class="p">{</span>
        <span class="o">++</span><span class="n">x</span><span class="p">;</span>
        <span class="o">++</span><span class="n">y</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="n">moveRightDown</span><span class="p">()</span> <span class="n">wall</span> <span class="k">public</span> <span class="p">{</span>
        <span class="o">++</span><span class="n">x</span><span class="p">;</span>
        <span class="o">--</span><span class="n">y</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="n">inv</span><span class="p">()</span> <span class="k">public</span> <span class="k">view</span> <span class="p">{</span>
        <span class="nf">assert</span><span class="p">((</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>函数 <code class="docutils literal notranslate"><span class="pre">inv</span></code> 代表状态机的一个不变量，即 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">+</span> <span class="pre">y</span></code> 必须是偶数。
SMT检查器设法证明，无论我们给机器人多少条命令，
即使是无限多的命令，这个不变量都 <em>不会</em> 失败。
有兴趣的读者可能也想手动证明这个事实。 提示：这个不变量是归纳性的。</p>
<p>我们也可以欺骗SMT检查器，让它给我们提供一条通往某个我们认为可能是可访问的位置的路径。
我们可以通过添加以下函数，来增加(2, 4)是 <em>不</em> 可访问的属性。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.13&amp;code=ZnVuY3Rpb24gcmVhY2hfMl80KCkgcHVibGljIHZpZXcgewogICAgYXNzZXJ0KCEoeCA9PSAyICYmIHkgPT0gNCkpOwp9"><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-Solidity notranslate"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="n">reach_2_4</span><span class="p">()</span> <span class="k">public</span> <span class="k">view</span> <span class="p">{</span>
    <span class="nf">assert</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">&amp;&amp;</span> <span class="n">y</span> <span class="o">==</span> <span class="mi">4</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
<p>这个属性是假的，在证明这个属性是假的同时，
SMT检查器准确地告诉我们 <em>如何</em> 访问到(2, 4)。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Warning: CHC: Assertion violation happens here.
Counterexample:
x = 2, y = 4

Transaction trace:
Robot.constructor()
State: x = 0, y = 0
Robot.moveLeftUp()
State: x = (- 1), y = 1
Robot.moveRightUp()
State: x = 0, y = 2
Robot.moveRightUp()
State: x = 1, y = 3
Robot.moveRightUp()
State: x = 2, y = 4
Robot.reach_2_4()
  --&gt; r.sol:35:4:
   |
35 |            assert(!(x == 2 &amp;&amp; y == 4));
   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^
</pre></div>
</div>
<p>请注意，上面的路径不一定是确定的，
因为还有其他路径可以访问（2，4）。
选择哪条路径可能会根据所使用的解算器，其使用版本，或者只是随机地改变。</p>
</section>
<section id="id5">
<h3>外部调用和重入<a class="headerlink" href="#id5" title="Permalink to this heading"></a></h3>
<p>每个外部调用都被SMT检查器视为对未知代码的调用。
这背后的原因是，即使被调用合约的代码在编译时是可用的，
也不能保证部署的合约确实与编译时接口所在的合约相同。</p>
<p>在某些情况下，有可能在状态变量上自动推断出属性，
即使外部调用的代码可以做任何事情，包括重新进入调用者合约，
这些属性仍然是真的。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.13&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC44LjA7CgppbnRlcmZhY2UgVW5rbm93biB7CiAgICBmdW5jdGlvbiBydW4oKSBleHRlcm5hbDsKfQoKY29udHJhY3QgTXV0ZXggewogICAgdWludCB4OwogICAgYm9vbCBsb2NrOwoKICAgIFVua25vd24gaW1tdXRhYmxlIHVua25vd247CgogICAgY29uc3RydWN0b3IoVW5rbm93biBfdSkgewogICAgICAgIHJlcXVpcmUoYWRkcmVzcyhfdSkgIT0gYWRkcmVzcygwKSk7CiAgICAgICAgdW5rbm93biA9IF91OwogICAgfQoKICAgIG1vZGlmaWVyIG11dGV4IHsKICAgICAgICByZXF1aXJlKCFsb2NrKTsKICAgICAgICBsb2NrID0gdHJ1ZTsKICAgICAgICBfOwogICAgICAgIGxvY2sgPSBmYWxzZTsKICAgIH0KCiAgICBmdW5jdGlvbiBzZXQodWludCBfeCkgbXV0ZXggcHVibGljIHsKICAgICAgICB4ID0gX3g7CiAgICB9CgogICAgZnVuY3Rpb24gcnVuKCkgbXV0ZXggcHVibGljIHsKICAgICAgICB1aW50IHhQcmUgPSB4OwogICAgICAgIHVua25vd24ucnVuKCk7CiAgICAgICAgYXNzZXJ0KHhQcmUgPT0geCk7CiAgICB9Cn0="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-Solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// </span><span class="cs">SPDX-License-Identifier:</span><span class="c1"> GPL-3.0</span>
<span class="k">pragma solidity</span> <span class="o">&gt;=</span><span class="mf">0.8</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

<span class="kd">interface</span> <span class="n">Unknown</span> <span class="p">{</span>
    <span class="kd">function</span> <span class="n">run</span><span class="p">()</span> <span class="k">external</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">contract</span> <span class="n">Mutex</span> <span class="p">{</span>
    <span class="kt">uint</span> <span class="n">x</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">lock</span><span class="p">;</span>

    <span class="n">Unknown</span> <span class="kr">immutable</span> <span class="n">unknown</span><span class="p">;</span>

    <span class="kd">constructor</span><span class="p">(</span><span class="n">Unknown</span> <span class="n">_u</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">require</span><span class="p">(</span><span class="kt">address</span><span class="p">(</span><span class="n">_u</span><span class="p">)</span> <span class="o">!=</span> <span class="kt">address</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
        <span class="n">unknown</span> <span class="o">=</span> <span class="n">_u</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kd">modifier</span> <span class="n">mutex</span> <span class="p">{</span>
        <span class="nf">require</span><span class="p">(</span><span class="o">!</span><span class="n">lock</span><span class="p">);</span>
        <span class="n">lock</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
        <span class="k">_</span><span class="p">;</span>
        <span class="n">lock</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="n">set</span><span class="p">(</span><span class="kt">uint</span> <span class="n">_x</span><span class="p">)</span> <span class="n">mutex</span> <span class="k">public</span> <span class="p">{</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">_x</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="n">run</span><span class="p">()</span> <span class="n">mutex</span> <span class="k">public</span> <span class="p">{</span>
        <span class="kt">uint</span> <span class="n">xPre</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
        <span class="n">unknown</span><span class="p">.</span><span class="n">run</span><span class="p">();</span>
        <span class="nf">assert</span><span class="p">(</span><span class="n">xPre</span> <span class="o">==</span> <span class="n">x</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上面的例子显示了一个使用互斥标志来禁止重入的合约。
解算器能够推断出，当 <code class="docutils literal notranslate"><span class="pre">unknown.run()</span></code> 被调用时，合约已经被 “锁定”，
所以无论未知的调用代码做什么，都不可能改变 <code class="docutils literal notranslate"><span class="pre">x</span></code> 的值。</p>
<p>如果我们 “忘记” 在函数 <code class="docutils literal notranslate"><span class="pre">set</span></code> 上使用 <code class="docutils literal notranslate"><span class="pre">mutex</span></code> 修饰符，
SMT检查器就能合成外部调用代码的行为，从而使断言失败。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Warning: CHC: Assertion violation happens here.
Counterexample:
x = 1, lock = true, unknown = 1

Transaction trace:
Mutex.constructor(1)
State: x = 0, lock = false, unknown = 1
Mutex.run()
    unknown.run() -- untrusted external call, synthesized as:
        Mutex.set(1) -- reentrant call
  --&gt; m.sol:32:3:
   |
32 |                assert(xPre == x);
   |                ^^^^^^^^^^^^^^^^^
</pre></div>
</div>
</section>
</section>
<section id="smtchecker-options">
<span id="id6"></span><h2>SMT检查器选项和调试<a class="headerlink" href="#smtchecker-options" title="Permalink to this heading"></a></h2>
<section id="id7">
<h3>超时<a class="headerlink" href="#id7" title="Permalink to this heading"></a></h3>
<p>SMT检查器使用了一个硬编码的资源限制（ <code class="docutils literal notranslate"><span class="pre">rlimit</span></code> ），
这个限制是根据每个求解器选择的，与时间没有确切的关系。
我们选择 <code class="docutils literal notranslate"><span class="pre">rlimit</span></code> 选项作为默认值，因为它比求解器内部的时间提供了更多的确定性保证。</p>
<p>这个选项大致转化为每个查询 “几秒钟超时”。
当然，许多属性非常复杂，需要大量的时间来解决，而决定并不重要。
如果SMT检查器不能用默认的 <code class="docutils literal notranslate"><span class="pre">rlimit</span></code> 选项处理合约属性，
则可以通过CLI选项 <code class="docutils literal notranslate"><span class="pre">--model-checker-timeout</span> <span class="pre">&lt;time&gt;</span></code> 或
JSON选项 <code class="docutils literal notranslate"><span class="pre">settings.modelChecker.timeout=&lt;time&gt;</span></code> 给出以毫秒为单位的超时。
其中0表示不超时。</p>
</section>
<section id="smtchecker-targets">
<span id="id8"></span><h3>验证目标<a class="headerlink" href="#smtchecker-targets" title="Permalink to this heading"></a></h3>
<p>SMT检查器创建的验证目标的类型也可以通过CLI选项 <code class="docutils literal notranslate"><span class="pre">--model-checker-target</span> <span class="pre">&lt;targets&gt;</span></code>
或JSON选项 <code class="docutils literal notranslate"><span class="pre">settings.modelChecker.targets=&lt;targets&gt;</span></code> 来定制。
在CLI情况下， <code class="docutils literal notranslate"><span class="pre">&lt;targets&gt;</span></code> 是一个没有空格的逗号分隔的一个或多个验证目标的列表，
在JSON输入中是一个或多个作为字符串的目标数组。
代表目标的关键词是：</p>
<ul class="simple">
<li><p>断言： <code class="docutils literal notranslate"><span class="pre">assert</span></code>。</p></li>
<li><p>算术下溢： <code class="docutils literal notranslate"><span class="pre">underflow</span></code>。</p></li>
<li><p>算术溢出： <code class="docutils literal notranslate"><span class="pre">overflow</span></code>。</p></li>
<li><p>除以零： <code class="docutils literal notranslate"><span class="pre">divByZero</span></code>。</p></li>
<li><p>无用的条件和无法访问的代码： <code class="docutils literal notranslate"><span class="pre">constantCondition</span></code>。</p></li>
<li><p>弹出一个空数组： <code class="docutils literal notranslate"><span class="pre">popEmptyArray</span></code>。</p></li>
<li><p>越界的数组/固定字节索引访问： <code class="docutils literal notranslate"><span class="pre">outOfBounds</span></code>。</p></li>
<li><p>转账资金不足： <code class="docutils literal notranslate"><span class="pre">balance</span></code>。</p></li>
<li><p>以上都是： <code class="docutils literal notranslate"><span class="pre">default</span></code> （仅适用CLI）。</p></li>
</ul>
<p>一个常见的目标子集可能是，例如： <code class="docutils literal notranslate"><span class="pre">--model-checker-targets</span> <span class="pre">assert,overflow</span></code>。</p>
<p>所有目标都被默认检查，除了Solidity &gt;=0.8.7的下溢和溢出。</p>
<p>关于如何以及何时分割验证目标，没有精确的指导方法。
但在处理大型合约时，它可能是有用的。</p>
</section>
<section id="id9">
<h3>未验证的目标<a class="headerlink" href="#id9" title="Permalink to this heading"></a></h3>
<p>如果有任何未验证的目标，SMT检查器会发出一个警告，
说明有多少个未验证的目标。如果用户希望看到所有具体的未验证的目标，
可以使用CLI选项 <code class="docutils literal notranslate"><span class="pre">--model-checker-show-unproved</span></code>
和JSON选项 <code class="docutils literal notranslate"><span class="pre">settings.modelChecker.showUnproved</span> <span class="pre">=</span> <span class="pre">true</span></code>。</p>
</section>
<section id="id10">
<h3>已验证过的合约<a class="headerlink" href="#id10" title="Permalink to this heading"></a></h3>
<p>默认情况下，给定来源中的所有可部署合约都会被单独分析，正如将被部署的那一个合约一样。
这意味着，如果一个合约有许多直接和间接的继承父类，所有这些都将被单独分析，
尽管只有最终派生的合约可以在区块链上被直接访问。
这给SMT检查器和求解器造成了不必要的负担。
为了帮助缓解这样的情况，用户可以指定哪些合约应该作为部署的合约进行分析。
当然，基类合约仍然被分析，但只是在分析最终派生的合约的情况下才进行，
这可以减少编码和生成查询的复杂性。
请注意，抽象合约在默认情况下不会被SMT检查器分析为最终派生的合约。</p>
<p>选择的合约可以通过CLI，用 &lt;source&gt;:&lt;contract&gt; 形式的键值对，以逗号分隔的列表（不允许有空格）给出：
<code class="docutils literal notranslate"><span class="pre">--model-checker-contracts</span> <span class="pre">&quot;&lt;source1.sol:contract1&gt;,&lt;source2.sol:contract2&gt;,&lt;source2.sol:contract3&gt;&quot;</span></code>，
以及通过 <a class="reference internal" href="using-the-compiler.html#compiler-api"><span class="std std-ref">JSON 输入</span></a> 中的对象 <code class="docutils literal notranslate"><span class="pre">settings.modelChecker.contracts</span></code>，它有如下格式：</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="nt">&quot;contracts&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nt">&quot;source1.sol&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">&quot;contract1&quot;</span><span class="p">],</span><span class="w"></span>
<span class="w">    </span><span class="nt">&quot;source2.sol&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">&quot;contract2&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;contract3&quot;</span><span class="p">]</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="id11">
<h3>报告推断的归纳变量<a class="headerlink" href="#id11" title="Permalink to this heading"></a></h3>
<p>于那些被CHC引擎证明为安全的属性，
SMT检查器可以检索由Horn求解器推断出的归纳不变性，作为证明的一部分。
目前有两种类型的不变量可以报告给用户：</p>
<ul class="simple">
<li><p>合约不变量：这些是合约的状态变量的属性，在合约可能运行的每一个可能的事务之前和之后都是真的。
例如， <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&gt;=</span> <span class="pre">y</span></code>，其中 <code class="docutils literal notranslate"><span class="pre">x</span></code> 和 <code class="docutils literal notranslate"><span class="pre">y</span></code> 是一个合约的状态变量。</p></li>
<li><p>可重入性属性：它们代表了合约在存在对未知代码的外部调用时的行为。
这些属性可以表达外部调用前后状态变量的值之间的关系，
其中外部调用可以自由地做任何事情，包括对分析的合约进行可重入调用。
导数变量代表所述外部调用后的状态变量的值。例如： <code class="docutils literal notranslate"><span class="pre">lock</span> <span class="pre">-&gt;</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">x'</span></code>。</p></li>
</ul>
<p>用户可以使用CLI选项 <code class="docutils literal notranslate"><span class="pre">--model-checker-invariants</span> <span class="pre">&quot;contract,reentrancy&quot;</span></code> 来选择要报告的不变量类型，
或者在 <a class="reference internal" href="using-the-compiler.html#compiler-api"><span class="std std-ref">JSON 输入</span></a> 中的字段 <code class="docutils literal notranslate"><span class="pre">settings.modelChecker.invariants</span></code> 中作为数组。
默认情况下，SMT检查器不报告不变量。</p>
</section>
<section id="id12">
<h3>有松弛变量的除法和模数运算<a class="headerlink" href="#id12" title="Permalink to this heading"></a></h3>
<p>Spacer是SMT检查器使用的默认Horn求解器，它通常不喜欢Horn规则中的除法和模数操作。
正因为如此，默认情况下，Solidity的除法和模运算是用约束条件 <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">b</span> <span class="pre">*</span> <span class="pre">d</span> <span class="pre">+</span> <span class="pre">m</span></code> 来编码的，
其中 <code class="docutils literal notranslate"><span class="pre">d</span> <span class="pre">=</span> <span class="pre">a</span> <span class="pre">/</span> <span class="pre">b</span></code> 和 <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">=</span> <span class="pre">a</span> <span class="pre">%</span> <span class="pre">b</span></code>。
然而，对于其他求解器，如Eldarica，更喜欢语法上的精确操作。
命令行标志 <code class="docutils literal notranslate"><span class="pre">--model-checker-div-mod-no-slacks</span></code> 和
JSON选项 <code class="docutils literal notranslate"><span class="pre">settings.modelChecker.divModNoSlacks</span></code> 可以用来切换编码，
这取决于所用求解器的偏好。</p>
</section>
<section id="natspec">
<h3>Natspec标签函数抽象化<a class="headerlink" href="#natspec" title="Permalink to this heading"></a></h3>
<p>某些函数包括常见的数学方法，如 <code class="docutils literal notranslate"><span class="pre">pow</span></code> 和 <code class="docutils literal notranslate"><span class="pre">sqrt</span></code>，
可能它们过于复杂，无法用完全自动化的方式进行分析。
这些函数可以用Natspec标签进行注释，向SMT检查器表明这些函数应该被抽象化。
这意味着在调用此函数时，不会使用函数的主体，函数将：</p>
<ul class="simple">
<li><p>返回一个非决定性的值，如果抽象函数是 view/pure 类型的，则保持状态变量不变，
否则会将状态变量设置为非决定性的值。
可以通过注解 <code class="docutils literal notranslate"><span class="pre">//&#64;custom:smtchecker</span> <span class="pre">abstract-function-nondet</span></code> 来使用。</p></li>
<li><p>作为一个未被解释的函数。这意味着函数的语义（由主体给出）会被忽略，
这个函数的唯一属性是，给定相同的输入，它保证有相同的输出。
这一点目前正在开发中，并将通过注解 <code class="docutils literal notranslate"><span class="pre">//&#64;custom:smtchecker</span> <span class="pre">abstract-function-uf</span></code> 来使用。</p></li>
</ul>
</section>
<section id="smtchecker-engines">
<span id="id13"></span><h3>模型检查引擎<a class="headerlink" href="#smtchecker-engines" title="Permalink to this heading"></a></h3>
<p>SMT检查器模块实现了两个不同的推理引擎，一个是有界模型检查器（Bounded Model Checker， BMC），
一个是约束角条款（Constrained Horn Clauses， CHC）系统。
这两个引擎目前都在开发中，并且有不同的特点。
这两个引擎是独立的，每一个属性警告都说明它来自哪个引擎。
请注意，上面所有带有反例的例子都是由CHC这个更强大的引擎报告的。</p>
<p>默认情况下，两个引擎都会被使用，其中首先运行CHC，
每一个没有被证明的属性都被传递给BMC。
您可以通过CLI选项 <code class="docutils literal notranslate"><span class="pre">--model-checker-engine</span> <span class="pre">{all,bmc,chc,none}</span></code> 或
JSON选项 <code class="docutils literal notranslate"><span class="pre">settings.modelChecker.engine</span> <span class="pre">{all,bmc,chc,none}</span></code> 来选择一个特定的引擎。</p>
<section id="bmc">
<h4>有界模型检查器 （BMC）<a class="headerlink" href="#bmc" title="Permalink to this heading"></a></h4>
<p>BMC引擎单独地分析函数，也就是说，它在分析每个函数时不会考虑合约在多个交易中的整体行为。
目前在这个引擎中循环也会被忽略了。
只要不是直接或间接的递归，内部函数调用是内联的。
如果可能的话，外部函数调用是内联的。
有可能受重入影响的理论在此被忽略。</p>
<p>上述特点使BMC容易报告假阳性，
但它也是轻量级的，应该能够快速找到小的局部bug。</p>
</section>
<section id="constrained-horn-clauses-chc">
<h4>受约束的角条款（Constrained Horn Clauses， CHC）<a class="headerlink" href="#constrained-horn-clauses-chc" title="Permalink to this heading"></a></h4>
<p>合约的控制流程图（CFG）被建模为一个Horn条款系统，
其中合约的生命周期由一个可以非确定性地访问每个公共/外部函数的循环表示。
这样，在分析任何函数时都会考虑到整个合约在无限制数量的事务中的行为。
这个引擎完全支持循环。
支持内部函数调用，而外部函数调用假定被调用的代码是未知的，可以做任何事情。</p>
<p>在能够证明的内容方面，CHC引擎要比BMC强大得多，但可能需要更多的计算资源。</p>
</section>
</section>
<section id="smthorn">
<h3>SMT和Horn求解器<a class="headerlink" href="#smthorn" title="Permalink to this heading"></a></h3>
<p>上面详述的两个引擎使用自动定理证明器作为其逻辑后端。
BMC使用一个SMT求解器，而CHC使用一个Horn求解器。
通常同一个工具可以同时充当这两种工具，如 <a class="reference external" href="https://github.com/Z3Prover/z3">z3</a>，
它主要是一个SMT求解器，并将 <a class="reference external" href="https://spacer.bitbucket.io/">Spacer</a>
作为一个Horn求解器使用，而 <a class="reference external" href="https://github.com/uuverifiers/eldarica">Eldarica</a>
则同时做这两种工作。</p>
<p>如果求解器可用的话，用户可以通过CLI选项 <code class="docutils literal notranslate"><span class="pre">--model-checker-solvers</span> <span class="pre">{all,cvc4,smtlib2,z3}</span></code>
或JSON选项 <code class="docutils literal notranslate"><span class="pre">settings.modelChecker.solvers=[smtlib2,z3]</span></code> 来选择应该使用哪个求解器，
其中：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">cvc4</span></code> 仅在使用 <code class="docutils literal notranslate"><span class="pre">solc</span></code> 编译二进制文件时可用。并且只有BMC使用 <code class="docutils literal notranslate"><span class="pre">cvc4</span></code>。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">smtlib2</span></code> 以 <a class="reference external" href="http://smtlib.cs.uiowa.edu/">smtlib2</a> 格式输出 SMT/Horn 查询。
这些可以和编译器的 <a class="reference external" href="https://github.com/ethereum/solc-js">回调机制</a> 一起使用，
这样就可以采用系统中的任何求解器二进制来同步返回查询的结果给编译器。
例如，这是目前使用Eldarica的唯一方法，因为它没有C++ API。
根据调用哪个求解器，BMC和CHC都可以使用此方法。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">z3</span></code> 是可用的</p>
<ul>
<li><p>如果 <code class="docutils literal notranslate"><span class="pre">solc</span></code> 与它一起被编译的话。</p></li>
<li><p>如果Linux系统中安装了4.8.x版本的动态 <code class="docutils literal notranslate"><span class="pre">z3</span></code> 库（从Solidity 0.7.6开始）。</p></li>
<li><p>在 <code class="docutils literal notranslate"><span class="pre">soljson.js</span></code> （从Solidity 0.6.9开始）中静态的，也就是编译器的Javascript二进制。</p></li>
</ul>
</li>
</ul>
<p>由于BMC和CHC都使用 <code class="docutils literal notranslate"><span class="pre">z3</span></code>，而且 <code class="docutils literal notranslate"><span class="pre">z3</span></code> 可以在更多的环境中使用，包括在浏览器中，
大多数用户几乎不需要关心这个选项。更高级的用户可能会应用这个选项，在更复杂的问题上尝试其他求解器。</p>
<p>请注意，所选择的引擎和求解器的某些组合将导致SMT检查器不做任何事情，例如选择CHC和 <code class="docutils literal notranslate"><span class="pre">cvc4</span></code>。</p>
</section>
</section>
<section id="id15">
<h2>抽象和假阳性结果<a class="headerlink" href="#id15" title="Permalink to this heading"></a></h2>
<p>SMT检查器以一种不完整但健全的方式实现了抽象：
如果报告了一个bug，它可能是由抽象引入的假阳性（由于删除了知识或使用了非精确类型）。
如果它确定一个验证目标是安全的，那么它确实是安全的，也就是说，
不存在假阴性（除非SMT检查器中存在一个bug）。</p>
<p>如果一个目标不能被证明，您可以尝试通过使用上一节中的调整选项来帮助求解器。
如果您确定是假阳性，在代码中加入有更多信息的 <code class="docutils literal notranslate"><span class="pre">require</span></code> 语句也可能给求解器带来一些更多的帮助。</p>
<section id="id16">
<h3>SMT的编码和类型<a class="headerlink" href="#id16" title="Permalink to this heading"></a></h3>
<p>SMT检查器编码试图尽可能精确，
将Solidity类型和表达式映射到它们最接近的 <a class="reference external" href="http://smtlib.cs.uiowa.edu/">SMT-LIB</a> 表示法上，
正如下表所示。</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 29%" />
<col style="width: 41%" />
<col style="width: 29%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Solidity 类型</p></th>
<th class="head"><p>SMT 类别</p></th>
<th class="head"><p>理论值</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Boolean</p></td>
<td><p>Bool</p></td>
<td><p>Bool</p></td>
</tr>
<tr class="row-odd"><td><p>intN, uintN, address,
bytesN, enum, contract</p></td>
<td><p>Integer</p></td>
<td><p>LIA, NIA</p></td>
</tr>
<tr class="row-even"><td><p>array, mapping, bytes,
string</p></td>
<td><p>Tuple
(Array elements, Integer length)</p></td>
<td><p>Datatypes, Arrays, LIA</p></td>
</tr>
<tr class="row-odd"><td><p>struct</p></td>
<td><p>Tuple</p></td>
<td><p>Datatypes</p></td>
</tr>
<tr class="row-even"><td><p>其他类型</p></td>
<td><p>Integer</p></td>
<td><p>LIA</p></td>
</tr>
</tbody>
</table>
<p>尚不支持的类型由一个256位无符号整数抽象出来，其不支持的操作被忽略。</p>
<p>关于SMT编码的内部工作方式的更多细节，请参见论文
<a class="reference external" href="https://github.com/leonardoalt/text/blob/master/solidity_isola_2018/main.pdf">基于SMT的Solidity智能合约验证</a>。</p>
</section>
<section id="id17">
<h3>函数调用<a class="headerlink" href="#id17" title="Permalink to this heading"></a></h3>
<p>在BMC引擎中，当可能时，即当它们的实现可用时，对相同合约（或基础合约）的函数调用被内联。
对其他合约中的函数的调用不被内联，即使它们的代码是可用的，因为我们不能保证实际部署的代码是相同的。</p>
<p>CHC引擎创建了非线性的Horn选项，使用被调用函数的摘要来支持内部函数调用。
外部函数调用被视为对未知代码的调用，包括潜在的可重入调用。</p>
<p>复杂的纯函数是由参数上的未转译函数（UF）抽象出来的。</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 46%" />
<col style="width: 54%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>方法</p></th>
<th class="head"><p>BMC/CHC 运行方式</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">assert</span></code></p></td>
<td><p>验证目标。</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">require</span></code></p></td>
<td><p>假设。</p></td>
</tr>
<tr class="row-even"><td><p>内部调用</p></td>
<td><p>BMC: 内联函数调用。
CHC：函数摘要。</p></td>
</tr>
<tr class="row-odd"><td><p>对已知代码的外部调用</p></td>
<td><p>BMC: 内联函数调用或
抹去关于状态变量的记忆
和本地存储引用。
CHC: 假设被调用的代码是未知的。
试图推断出在调用返回后仍然成立的不变性。</p></td>
</tr>
<tr class="row-even"><td><p>存储数组的压栈和出栈</p></td>
<td><p>精确地支持
检查是否从一个空数组弹出。</p></td>
</tr>
<tr class="row-odd"><td><p>ABI 函数</p></td>
<td><p>用UF函数进行抽象</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">addmod</span></code>, <code class="docutils literal notranslate"><span class="pre">mulmod</span></code></p></td>
<td><p>精确地支持</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">gasleft</span></code>, <code class="docutils literal notranslate"><span class="pre">blockhash</span></code>,
<code class="docutils literal notranslate"><span class="pre">keccak256</span></code>, <code class="docutils literal notranslate"><span class="pre">ecrecover</span></code>
<code class="docutils literal notranslate"><span class="pre">ripemd160</span></code></p></td>
<td><p>用UF函数进行抽象</p></td>
</tr>
<tr class="row-even"><td><p>无执行动作的纯函数（外部或复杂）。</p></td>
<td><p>用UF函数进行抽象</p></td>
</tr>
<tr class="row-odd"><td><p>无执行动作的外部函数</p></td>
<td><p>BMC：擦除状态记忆并假定结果是不确定的。
CHC：不确定的摘要。
试图推断出在调用返回后仍然成立的不变性。</p></td>
</tr>
<tr class="row-even"><td><p>transfer</p></td>
<td><p>BMC：检查合约的余额是否足够。
CHC：还不执行检查。</p></td>
</tr>
<tr class="row-odd"><td><p>其他调用</p></td>
<td><p>目前不支持</p></td>
</tr>
</tbody>
</table>
<p>使用抽象意味着失去精确的知识，但在许多情况下，这并不意味着失去证明力。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.13&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC44LjA7Cgpjb250cmFjdCBSZWNvdmVyCnsKICAgIGZ1bmN0aW9uIGYoCiAgICAgICAgYnl0ZXMzMiBoYXNoLAogICAgICAgIHVpbnQ4IF92MSwgdWludDggX3YyLAogICAgICAgIGJ5dGVzMzIgX3IxLCBieXRlczMyIF9yMiwKICAgICAgICBieXRlczMyIF9zMSwgYnl0ZXMzMiBfczIKICAgICkgcHVibGljIHB1cmUgcmV0dXJucyAoYWRkcmVzcykgewogICAgICAgIGFkZHJlc3MgYTEgPSBlY3JlY292ZXIoaGFzaCwgX3YxLCBfcjEsIF9zMSk7CiAgICAgICAgcmVxdWlyZShfdjEgPT0gX3YyKTsKICAgICAgICByZXF1aXJlKF9yMSA9PSBfcjIpOwogICAgICAgIHJlcXVpcmUoX3MxID09IF9zMik7CiAgICAgICAgYWRkcmVzcyBhMiA9IGVjcmVjb3ZlcihoYXNoLCBfdjIsIF9yMiwgX3MyKTsKICAgICAgICBhc3NlcnQoYTEgPT0gYTIpOwogICAgICAgIHJldHVybiBhMTsKICAgIH0KfQ=="><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.8.0</span><span class="p">;</span><span class="w"></span>

<span class="k">contract</span><span class="w"> </span><span class="ni">Recover</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">f</span><span class="p">(</span><span class="w"></span>
<span class="w">        </span><span class="kt">bytes32</span><span class="w"> </span><span class="nv">hash</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="kt">uint8</span><span class="w"> </span><span class="nv">_v1</span><span class="p">,</span><span class="w"> </span><span class="kt">uint8</span><span class="w"> </span><span class="nv">_v2</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="kt">bytes32</span><span class="w"> </span><span class="nv">_r1</span><span class="p">,</span><span class="w"> </span><span class="kt">bytes32</span><span class="w"> </span><span class="nv">_r2</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="kt">bytes32</span><span class="w"> </span><span class="nv">_s1</span><span class="p">,</span><span class="w"> </span><span class="kt">bytes32</span><span class="w"> </span><span class="nv">_s2</span><span class="w"></span>
<span class="w">    </span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span>pure<span class="w"> </span><span class="kt">returns</span><span class="w"> </span><span class="p">(</span><span class="kt">address</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">address</span><span class="w"> </span><span class="nv">a1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>ecrecover<span class="p">(</span><span class="kt">hash</span><span class="p">,</span><span class="w"> </span>_v1<span class="p">,</span><span class="w"> </span>_r1<span class="p">,</span><span class="w"> </span>_s1<span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kt">require</span><span class="p">(</span>_v1<span class="w"> </span><span class="o">==</span><span class="w"> </span>_v2<span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kt">require</span><span class="p">(</span>_r1<span class="w"> </span><span class="o">==</span><span class="w"> </span>_r2<span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kt">require</span><span class="p">(</span>_s1<span class="w"> </span><span class="o">==</span><span class="w"> </span>_s2<span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kt">address</span><span class="w"> </span><span class="nv">a2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>ecrecover<span class="p">(</span><span class="kt">hash</span><span class="p">,</span><span class="w"> </span>_v2<span class="p">,</span><span class="w"> </span>_r2<span class="p">,</span><span class="w"> </span>_s2<span class="p">);</span><span class="w"></span>
<span class="w">        </span>assert<span class="p">(</span>a1<span class="w"> </span><span class="o">==</span><span class="w"> </span>a2<span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kt">return</span><span class="w"> </span>a1<span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>在上面的例子中，SMT检查器的表达能力不足以实际计算 <code class="docutils literal notranslate"><span class="pre">ecrecover</span></code>，
但通过将函数调用建模为未转译的函数，我们知道在同等参数上调用时返回值是相同的。
这就足以证明上面的断言总是正确的。</p>
<p>对于已知是确定性的函数，可以用UF来抽象一个函数调用，
对于纯函数也很容易做到。
然而，对于一般的外部函数来说，这是很难做到的，
因为它们可能依赖于状态变量。</p>
</section>
<section id="id18">
<h3>引用类型和别名<a class="headerlink" href="#id18" title="Permalink to this heading"></a></h3>
<p>Solidity 为具有相同 <a class="reference internal" href="types.html#data-location"><span class="std std-ref">数据位置</span></a> 的引用类型实现了别名。
这意味着可以通过对同一数据区域的引用来修改一个变量。
SMT检查器并不跟踪哪些引用是指向相同的数据。
这意味着每当分配一个局部引用或引用类型的状态变量时，
所有关于相同类型和数据位置的变量的知识都会被抹去。
如果类型是嵌套的，知识删除也包括所有的前缀基础类型。</p>
<p class="remix-link-container"><a class="remix-link reference external" href="https://remix.ethereum.org/?language=solidity&amp;version=0.8.13&amp;code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAKcHJhZ21hIHNvbGlkaXR5ID49MC44LjA7Cgpjb250cmFjdCBBbGlhc2luZwp7CiAgICB1aW50W10gYXJyYXkxOwogICAgdWludFtdW10gYXJyYXkyOwogICAgZnVuY3Rpb24gZigKICAgICAgICB1aW50W10gbWVtb3J5IGEsCiAgICAgICAgdWludFtdIG1lbW9yeSBiLAogICAgICAgIHVpbnRbXVtdIG1lbW9yeSBjLAogICAgICAgIHVpbnRbXSBzdG9yYWdlIGQKICAgICkgaW50ZXJuYWwgewogICAgICAgIGFycmF5MVswXSA9IDQyOwogICAgICAgIGFbMF0gPSAyOwogICAgICAgIGNbMF1bMF0gPSAyOwogICAgICAgIGJbMF0gPSAxOwogICAgICAgIC8vIOWIoOmZpOWFs+S6juWGheWtmOW8leeUqOeahOiusOW/huS4jeW6lOivpeWIoOmZpOWFs+S6jueKtuaAgeWPmOmHj+eahOiusOW/huOAggogICAgICAgIGFzc2VydChhcnJheTFbMF0gPT0gNDIpOwogICAgICAgIC8vIOS9huaYr++8jOWvueWtmOWCqOW8leeUqOeahOi1i+WAvOWwhuebuOW6lOWcsOWIoOmZpOWtmOWCqOiusOW/huOAggogICAgICAgIGRbMF0gPSAyOwogICAgICAgIC8vIOeUseS6juS4iumdoueahOWIhumFje+8jOWksei0peS4uuWBh+mYs+aAp+OAggogICAgICAgIGFzc2VydChhcnJheTFbMF0gPT0gNDIpOwogICAgICAgIC8vIOWksei0pe+8jOWboOS4uiBgYSA9PSBiYCDmmK/lj6/og73nmoTjgIIKICAgICAgICBhc3NlcnQoYVswXSA9PSAyKTsKICAgICAgICAvLyDlpLHotKXvvIzlm6DkuLogYGNbaV0gPT0gYmAg5piv5Y+v6IO955qE44CCCiAgICAgICAgYXNzZXJ0KGNbMF1bMF0gPT0gMik7CiAgICAgICAgYXNzZXJ0KGRbMF0gPT0gMik7CiAgICAgICAgYXNzZXJ0KGJbMF0gPT0gMSk7CiAgICB9CiAgICBmdW5jdGlvbiBnKAogICAgICAgIHVpbnRbXSBtZW1vcnkgYSwKICAgICAgICB1aW50W10gbWVtb3J5IGIsCiAgICAgICAgdWludFtdW10gbWVtb3J5IGMsCiAgICAgICAgdWludCB4CiAgICApIHB1YmxpYyB7CiAgICAgICAgZihhLCBiLCBjLCBhcnJheTJbeF0pOwogICAgfQp9"><span class="link-icon"></span><span class="link-text">open in Remix</span></a></p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="c1">// SPDX-License-Identifier: GPL-3.0</span>
<span class="k">pragma solidity</span><span class="w"> </span><span class="o">&gt;=</span><span class="k">0.8.0</span><span class="p">;</span><span class="w"></span>

<span class="k">contract</span><span class="w"> </span><span class="ni">Aliasing</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">uint</span><span class="p">[]</span><span class="w"> </span>array1<span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">uint</span><span class="p">[][]</span><span class="w"> </span>array2<span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">f</span><span class="p">(</span><span class="w"></span>
<span class="w">        </span><span class="kt">uint</span><span class="p">[]</span><span class="w"> </span><span class="kt">memory</span><span class="w"> </span>a<span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="kt">uint</span><span class="p">[]</span><span class="w"> </span><span class="kt">memory</span><span class="w"> </span>b<span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="kt">uint</span><span class="p">[][]</span><span class="w"> </span><span class="kt">memory</span><span class="w"> </span>c<span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="kt">uint</span><span class="p">[]</span><span class="w"> </span>storage<span class="w"> </span>d<span class="w"></span>
<span class="w">    </span><span class="p">)</span><span class="w"> </span><span class="kt">internal</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span>array1<span class="p">[</span><span class="m m-Decimal">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m m-Decimal">42</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span>a<span class="p">[</span><span class="m m-Decimal">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m m-Decimal">2</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span>c<span class="p">[</span><span class="m m-Decimal">0</span><span class="p">][</span><span class="m m-Decimal">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m m-Decimal">2</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span>b<span class="p">[</span><span class="m m-Decimal">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m m-Decimal">1</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="c1">// 删除关于内存引用的记忆不应该删除关于状态变量的记忆。</span>
<span class="w">        </span>assert<span class="p">(</span>array1<span class="p">[</span><span class="m m-Decimal">0</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="m m-Decimal">42</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="c1">// 但是，对存储引用的赋值将相应地删除存储记忆。</span>
<span class="w">        </span>d<span class="p">[</span><span class="m m-Decimal">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m m-Decimal">2</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="c1">// 由于上面的分配，失败为假阳性。</span>
<span class="w">        </span>assert<span class="p">(</span>array1<span class="p">[</span><span class="m m-Decimal">0</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="m m-Decimal">42</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="c1">// 失败，因为 `a == b` 是可能的。</span>
<span class="w">        </span>assert<span class="p">(</span>a<span class="p">[</span><span class="m m-Decimal">0</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="m m-Decimal">2</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="c1">// 失败，因为 `c[i] == b` 是可能的。</span>
<span class="w">        </span>assert<span class="p">(</span>c<span class="p">[</span><span class="m m-Decimal">0</span><span class="p">][</span><span class="m m-Decimal">0</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="m m-Decimal">2</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span>assert<span class="p">(</span>d<span class="p">[</span><span class="m m-Decimal">0</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="m m-Decimal">2</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span>assert<span class="p">(</span>b<span class="p">[</span><span class="m m-Decimal">0</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="m m-Decimal">1</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="kt">function</span><span class="w"> </span><span class="nv">g</span><span class="p">(</span><span class="w"></span>
<span class="w">        </span><span class="kt">uint</span><span class="p">[]</span><span class="w"> </span><span class="kt">memory</span><span class="w"> </span>a<span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="kt">uint</span><span class="p">[]</span><span class="w"> </span><span class="kt">memory</span><span class="w"> </span>b<span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="kt">uint</span><span class="p">[][]</span><span class="w"> </span><span class="kt">memory</span><span class="w"> </span>c<span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="kt">uint</span><span class="w"> </span><span class="nv">x</span><span class="w"></span>
<span class="w">    </span><span class="p">)</span><span class="w"> </span><span class="kt">public</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span>f<span class="p">(</span>a<span class="p">,</span><span class="w"> </span>b<span class="p">,</span><span class="w"> </span>c<span class="p">,</span><span class="w"> </span>array2<span class="p">[</span>x<span class="p">]);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>在对 <code class="docutils literal notranslate"><span class="pre">b[0]</span></code> 进行赋值后，我们需要清除关于 <code class="docutils literal notranslate"><span class="pre">a</span></code> 的知识，
因为它有相同的类型（ <code class="docutils literal notranslate"><span class="pre">uint[]</span></code> ）和数据位置（内存）。
我们还需要清除关于 <code class="docutils literal notranslate"><span class="pre">c</span></code> 的知识，因为它的基本类型也是一个位于内存中的 <code class="docutils literal notranslate"><span class="pre">uint[]</span></code>。
这意味着一些 <code class="docutils literal notranslate"><span class="pre">c[i]</span></code> 可能与 <code class="docutils literal notranslate"><span class="pre">b</span></code> 或 <code class="docutils literal notranslate"><span class="pre">a</span></code> 指的是同一个数据。</p>
<p>注意，我们没有清除关于 <code class="docutils literal notranslate"><span class="pre">array</span></code> 和 <code class="docutils literal notranslate"><span class="pre">d</span></code> 的知识，
因为它们位于存储区，尽管它们也有 <code class="docutils literal notranslate"><span class="pre">uint[]</span></code> 类型。
然而，如果 <code class="docutils literal notranslate"><span class="pre">d</span></code> 被分配，我们就需要清除关于 <code class="docutils literal notranslate"><span class="pre">array</span></code> 的知识，反之亦然。</p>
</section>
<section id="id19">
<h3>合约余额<a class="headerlink" href="#id19" title="Permalink to this heading"></a></h3>
<p>如果在部署交易中 <code class="docutils literal notranslate"><span class="pre">msg.value</span></code> &gt; 0，则合约可能在部署时被发送资金。
然而，合约的地址在部署前可能已经有了资金，
这些资金由合约保存。
因此，SMT检查器在构造函数中假定 <code class="docutils literal notranslate"><span class="pre">address(this).balance</span> <span class="pre">&gt;=</span> <span class="pre">msg.value</span></code>，
以便与EVM规则一致。合约的余额也可能在不触发任何对合约的调用的情况下增加，如果</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">selfdestruct</span></code> 是由另一个合约执行的，被分析的合约是剩余资金的接收目标。</p></li>
<li><p>该合约是某个区块的coinbase（即 <code class="docutils literal notranslate"><span class="pre">block.coinbase</span></code>）。</p></li>
</ul>
<p>为了正确建模，SMT检查器假设在每一笔新的交易中，合约的余额可能至少增长 <code class="docutils literal notranslate"><span class="pre">msg.value</span></code> 的值。</p>
</section>
</section>
<section id="id20">
<h2>现实世界的假设<a class="headerlink" href="#id20" title="Permalink to this heading"></a></h2>
<p>有些情况可以在Solidity和EVM中可以表达出，但可能在实践中不会发生。
其中一种情况是动态存储数组的长度在压栈过程中溢出：
如果 <code class="docutils literal notranslate"><span class="pre">push</span></code> 操作被应用于一个长度为 2^256 - 1的数组，它的长度会悄悄溢出。
然而，这在实践中不太可能发生，因为将数组增长到这一点所需的操作需要数十亿年的时间来执行。
SMT检查器采取的另一个类似的假设是，一个地址的余额永远不会溢出。</p>
<p>类似的想法在 <a class="reference external" href="https://eips.ethereum.org/EIPS/eip-1985">EIP-1985</a> 中提出过。</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="security-considerations.html" class="btn btn-neutral float-left" title="安全考虑" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="resources.html" class="btn btn-neutral float-right" title="资源" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2016-2021, Ethereum.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
  
    <p>
        <a href="credits-and-attribution.html">Credits and attribution</a>.
    </p>


</footer>
        </div>
      </div>
    </section>
  </div>
  
<div class="rst-versions" data-toggle="rst-versions" role="note" aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
    <span class="fa fa-book fa-element"> RTD </span>

    <span class="fa fa-element">
    <input class="container_toggle" type="checkbox" id="switch" name="mode">
    <label for="switch"></label>
    </span>

    <span class="fa fa-v fa-element"> v:  <span class="fa fa-caret-down"></span></span>

    </span>
    <div class="rst-other-versions">
        <dl>
            <dt>Downloads</dt> 
        </dl>
        <dl>
            <dt>Versions</dt> 
        </dl>
        <dl>
            
            <dt>On Read the Docs</dt>
            <dd>
                <a href="///projects//?fromdocs=">Project Home</a>
            </dd>
            <dd>
                <a href="///builds//?fromdocs=">Builds</a>
            </dd>
        </dl>
    </div>
</div><script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>